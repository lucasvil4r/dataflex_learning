Compiling Program: C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\AppSrc\GlobalBuffers.src
Memory Available: 3809013760
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 20.0\Pkg\windows.x64.pkd)
8041>Use cHtmlHelp.pkg
Including file: cHtmlHelp.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cHtmlHelp.pkg)
8041>>>Use windows.pkg
8041>>>Use LanguageText.pkg
8041>>>Use cHtmlHelp.inc // API Functions and Constants, etc.
Including file: cHtmlHelp.inc    (C:\Program Files\DataFlex 20.0\Pkg\cHtmlHelp.inc)
8041>>>>>Use Unicode.Pkg
8041>>>>>
8041>>>>>// Do not call directly, use the wrapper function instead
8041>>>>>External_Function HtmlHelp "HtmlHelpW" HHCTRL.OCX ;    Handle  hwndCaller ;    WString sFile ;    Integer uCommand ;    Longptr dwData ;      // The Windows Kits source defines this as a DWORD_PTR, while the MSDN documentation says it is DWORD !!    Returns Handle
8042>>>>>
8042>>>>>// Declarations. Note HH_DISPLAY_TOPIC and HH_HELP_FINDER perform the same function for backward compatibility
8042>>>>>Define HH_DISPLAY_TOPIC         for |CI$0000
8042>>>>>Define HH_HELP_FINDER           for |CI$0000
8042>>>>>Define HH_DISPLAY_TOC           for |CI$0001
8042>>>>>Define HH_DISPLAY_INDEX         for |CI$0002
8042>>>>>Define HH_DISPLAY_SEARCH        for |CI$0003
8042>>>>>Define HH_SET_WIN_TYPE          for |CI$0004
8042>>>>>Define HH_GET_WIN_TYPE          for |CI$0005
8042>>>>>Define HH_GET_WIN_HANDLE        for |CI$0006
8042>>>>>Define HH_ENUM_INFO_TYPE        for |CI$0007
8042>>>>>Define HH_SET_INFO_TYPE         for |CI$0008
8042>>>>>Define HH_SYNC                  for |CI$0009
8042>>>>>Define HH_KEYWORD_LOOKUP        for |CI$000D
8042>>>>>Define HH_DISPLAY_TEXT_POPUP    for |CI$000E
8042>>>>>Define HH_HELP_CONTEXT          for |CI$000F
8042>>>>>Define HH_TP_HELP_CONTEXTMENU   for |CI$0010
8042>>>>>Define HH_TP_HELP_WM_HELP       for |CI$0011
8042>>>>>Define HH_CLOSE_ALL             for |CI$0012
8042>>>>>Define HH_ALINK_LOOKUP          for |CI$0013
8042>>>>>Define HH_GET_LAST_ERROR        for |CI$0014
8042>>>>>Define HH_ENUM_CATEGORY         for |CI$0015
8042>>>>>Define HH_ENUM_CATEGORY_IT      for |CI$0016
8042>>>>>Define HH_RESET_IT_FILTER       for |CI$0017
8042>>>>>Define HH_SET_INCLUSIVE_FILTER  for |CI$0018
8042>>>>>Define HH_SET_EXCLUSIVE_FILTER  for |CI$0019
8042>>>>>Define HH_INITIALIZE            for |CI$001C
8042>>>>>Define HH_UNINITIALIZE          for |CI$001D
8042>>>>>Define HH_PRETRANSLATEMESSAGE   for |CI$00FD
8042>>>>>Define HH_SET_GLOBAL_PROPERTY   for |CI$00FC
8042>>>>>
8042>>>>>
8042>>>Use GlobalFunctionsProcedures.pkg
8042>>>Use HelpSystemConstants.pkg
8042>>>
8042>>>Register_Function phoMainPanel Returns Integer
8042>>>
8042>>>
8042>>>Class cHtmlHelp is a cObject
8043>>>    Procedure Construct_Object
8045>>>        Forward Send Construct_Object
8047>>>        
8047>>>        
8047>>>        Move Self to ghoHtmlHelp // registers the object-handle globally
8048>>>        
8048>>>        Property String  psHelpFile ""
8049>>>        Property Handle  phoOwner           // object that is the owner of the HTML help window
8050>>>        Property Boolean pbAlwaysOnTop True // if true, help is always on top.
8051>>>        
8051>>>        Property Integer private_piCookie
8052>>>        
8052>>>        Send DoInitialize
8053>>>        
8053>>>    End_Procedure
8054>>>    
8054>>>    Procedure Destroy_Object
8056>>>        Send DoDeInitialize
8057>>>        Forward Send Destroy_Object
8059>>>    End_Procedure
8060>>>    
8060>>>    // get owner's window handle. if phoOwner not defined use
8060>>>    // handle of application objects phoMainPanel. If no owner return 0
8060>>>    Function GetOwnerWindowHandle Returns Handle
8062>>>        Handle hoOwner
8062>>>        // if not always on top we want to use the windows desktop window handle. When the desktop is the owner
8062>>>        // you don't get on-top behavior and the help windows does not minimize when you minimize
8062>>>        // main program. When the Main panel has the focus, you get the on-top behavior.
8062>>>        If (pbAlwaysOnTop(Self)) Begin
8064>>>            Get phoOwner to hoOwner
8065>>>            If (hoOwner=0 and ghoApplication) ;                Get phoMainPanel of ghoApplication to hoOwner
8068>>>            If hoOwner ;                Get window_handle of hoOwner to hoOwner // the DF objects window handle
8071>>>        End
8071>>>>
8071>>>        // owner will be 0, if we could not find a main active handle or, the more likely
8071>>>        // case, pbAlwaysOnTop is set false. Using the windows destkop stops help on top.
8071>>>        If (hoOwner=0) Begin
8073>>>            Move (GetDesktopWindow()) to hoOwner
8074>>>        End
8074>>>>
8074>>>        Function_Return hoOwner
8075>>>    End_Function
8076>>>    
8076>>>    Function GetHelpFile Returns String
8078>>>        String sHelpFile
8078>>>        Get psHelpFile to sHelpFile
8079>>>        // if name is not directly set object, see if we can get it from the application object
8079>>>        If (sHelpFile="" and ghoApplication and peHelpType(ghoApplication)=htHtmlHelp);            Get psHelpFile of ghoApplication to sHelpFile
8082>>>        If (sHelpFile<>"") ;            Get_File_Path sHelpFile to sHelpFile
8085>>>        Function_Return sHelpFile
8086>>>    End_Function
8087>>>    
8087>>>    // It appears that using hh_initialize/hh_uninitialze causes keyboard problems with
8087>>>    // embedded help which causing ctrl+c to not work. According to messages found on a Newsgroup this
8087>>>    // is a known issue and that not using these is the solution. The general advice was to stay
8087>>>    // away from these messages - and it does seem to solve the problem (jjt)
8087>>>    
8087>>>    Procedure DoInitialize
8089>>>//        //Must be sent before any HTML commands can be used
8089>>>//        Handle hRetVal
8089>>>//        Integer dwCookie
8089>>>//        String sBuffer
8089>>>//        Pointer pBuffer
8089>>>        
8089>>>//        Zerotype tDWORD TO sBuffer
8089>>>//        GetAddress OF sBuffer TO pBuffer
8089>>>        
8089>>>//        Move (HtmlHelp(0, "", HH_INITIALIZE, pBuffer)) TO hRetVal
8089>>>//        GetBuff From sBuffer AT tDWORD.DWord TO dwCookie
8089>>>//        Set private_piCookie TO dwCookie
8089>>>    End_Procedure
8090>>>    
8090>>>    Procedure DoDeInitialize
8092>>>//        //Must be sent to free resources
8092>>>//        Dword dwCookie
8092>>>//        Handle hRetVal
8092>>>//        String sHelpFile
8092>>>//        Get private_piCookie TO dwCookie
8092>>>        
8092>>>//        Move (HtmlHelp(0, "", HH_UNINITIALIZE, dwCookie))TO hRetVal
8092>>>    End_Procedure
8093>>>    
8093>>>    Procedure DoDisplayTopic WString wTopic
8095>>>        //Most-used command. Pops up the tri-pane Help Viewer.
8095>>>        Handle hRetVal
8095>>>        String sHelpFile
8095>>>        Get GetHelpFile to sHelpFile
8096>>>        If (sHelpFile<>"") Begin
8098>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOPIC, AddressOf(wTopic))) to hRetVal
8099>>>        End
8099>>>>
8099>>>    End_Procedure
8100>>>    
8100>>>    Procedure DoDisplayIndex
8102>>>        //Another commonly-used command. Pops up the topic for the current index entry.
8102>>>        Handle hRetVal
8102>>>        String sHelpFile
8102>>>        Get GetHelpFile to sHelpFile
8103>>>        If (sHelpFile<>"") Begin
8105>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, 0)) to hRetVal
8106>>>        End
8106>>>>
8106>>>    End_Procedure
8107>>>    
8107>>>    Procedure DoDisplayIndexString WString wIndex
8109>>>        //Another commonly-used command. Shows the Index, and highlights the sIndex entry
8109>>>        Handle hRetVal
8109>>>        String sHelpFile
8109>>>        Get GetHelpFile to sHelpFile
8110>>>        If (sHelpFile<>"") Begin
8112>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, AddressOf(wIndex))) to hRetVal
8113>>>        End
8113>>>>
8113>>>    End_Procedure
8114>>>    
8114>>>    Procedure DoShowMapId Longptr iMapID
8116>>>        //Passed an integer of the MapID allocated to the topic
8116>>>        Handle hRetVal
8116>>>        String sHelpFile
8116>>>        Get GetHelpFile to sHelpFile
8117>>>        
8117>>>        If (sHelpFile<>"") Begin
8119>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_HELP_CONTEXT, iMapID)) to hRetVal
8120>>>            Send DoDisplayTOC
8121>>>            //Send DoSyncToc
8121>>>        End
8121>>>>
8121>>>    End_Procedure
8122>>>    
8122>>>    Procedure DoDisplayKeyword WString wKeyword
8124>>>        Handle hRetVal
8124>>>        String sHelpFile sErrorText
8124>>>        tWinHH_AKLink AKLink
8124>>>        tWinHH_AKLink AKLink
8124>>>        Get GetHelpFile to sHelpFile
8125>>>        If (sHelpFile<>"") Begin
8127>>>            
8127>>>            Move (SFormat(C_$SorryIsNotInTheIndex, wKeyword)) to sErrorText
8128>>>            
8128>>>            Move (SizeOfType(tWinHH_AKLink)) to AkLink.cbStruct
8129>>>            Move 0            to AkLink.fReserved
8130>>>            Move (AddressOf(wKeyword))   to AkLink.pszKeywords
8131>>>            Move 0            to AkLink.pszUrl
8132>>>            //Move (Addressof(sErrorText)) to AkLink.pszMsgText
8132>>>            Move 0  to AkLink.pszMsgText
8133>>>            Move 0  to AkLink.pszMsgTitle
8134>>>            Move 0  to AkLink.pszWindow
8135>>>            Move 0  to AkLink.fIndexOnFail
8136>>>            
8136>>>            Send DoDisplayIndexString wKeyword
8137>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_KEYWORD_LOOKUP, AddressOf(AkLink))) to hRetVal
8138>>>        End
8138>>>>
8138>>>    End_Procedure
8139>>>    
8139>>>    Procedure DoDisplayTOC
8141>>>        Handle hRetVal
8141>>>        String sHelpFile
8141>>>        Get GetHelpFile to sHelpFile
8142>>>        If (sHelpFile<>"") Begin
8144>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOC, 0)) to hRetVal
8145>>>        End
8145>>>>
8145>>>    End_Procedure
8146>>>    
8146>>>    Procedure DoSyncToc
8148>>>        Handle hRetVal
8148>>>        String sHelpFile
8148>>>        Get GetHelpFile to sHelpFile
8149>>>        If (sHelpFile<>"") Begin
8151>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_SYNC, 0)) to hRetVal
8152>>>        End
8152>>>>
8152>>>    End_Procedure
8153>>>    
8153>>>    Procedure DO_HH_DISPLAY_SEARCH WString wTopic
8155>>>        Handle hRetVal
8155>>>        String sHelpFile
8155>>>        Get GetHelpFile to sHelpFile
8156>>>        If (sHelpFile<>"") Begin
8158>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_SEARCH, AddressOf(wTopic))) to hRetVal
8159>>>        End
8159>>>>
8159>>>    End_Procedure
8160>>>    
8160>>>End_Class
8161>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cApplication.pkg)
8161>>>Use Windows.pkg
8161>>>
8161>>>Use LanguageText.pkg
8161>>>Use WinUser.pkg
8161>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files\DataFlex 20.0\Pkg\WinShell.pkg)
8161>>>>>Use DLL.pkg
8161>>>>>
8161>>>>>Define S_OK                                     for |CI$00000000 // Operation successful
8161>>>>>Define E_ABORT                                  for |CI$80004004 // Operation aborted
8161>>>>>Define E_ACCESSDENIED                               for |CI$80070005 // General access denied error 
8161>>>>>Define E_FAIL                                   for |CI$80004005 // Unspecified failure
8161>>>>>Define E_HANDLE                                 for |CI$80070006 // Handle that is not valid
8161>>>>>Define E_INVALIDARG                             for |CI$80070057 // One or more arguments are not valid
8161>>>>>Define E_NOINTERFACE                            for |CI$80004002 // No such interface supported
8161>>>>>Define E_NOTIMPL                                for |CI$80004001 // not implemented
8161>>>>>Define E_OUTOFMEMORY                            for |CI$8007000E // Failed to allocate necessary memory
8161>>>>>Define E_POINTER                                for |CI$80004003 // Pointer that is not valid
8161>>>>>Define E_UNEXPECTED                             for |CI$8000FFFF // Unexpected failure
8161>>>>>
8161>>>>>External_Function PathFileExists "PathFileExistsW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8162>>>>>
8162>>>>>External_Function PathIsRelative "PathIsRelativeW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8163>>>>>
8163>>>>>// When called directly, be sure to use WString types.
8163>>>>>External_Function PathRemoveExtensionW "PathRemoveExtensionW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer // void
8164>>>>>
8164>>>>>// Compatibility Wrapper Function PathRemoveExtension
8164>>>>>Function PathRemoveExtension Global ;    Pointer lpPath ;    Returns Integer // Boolean
8166>>>>>    
8166>>>>>    Integer iResult
8166>>>>>    UWide   uwPath
8166>>>>>    UWide   uwPath
8166>>>>>
8166>>>>>    Send StringToWide lpPath (&uwPath)
8167>>>>>                    
8167>>>>>    Move (PathRemoveExtensionW (uwPath.lpUText)) to iResult 
8168>>>>>    
8168>>>>>    Send WideToString (&uwPath) lpPath
8169>>>>>        
8169>>>>>    Function_Return iResult
8170>>>>>End_Function
8171>>>>>
8171>>>>>// When called directly, be sure to use WString types.
8171>>>>>External_Function PathRemoveFileSpecW "PathRemoveFileSpecW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer
8172>>>>>    
8172>>>>>// Compatibility Wrapper Function PathRemoveFileSpec
8172>>>>>Function PathRemoveFileSpec Global ;    Pointer lpPath ;    Returns Integer // Boolean
8174>>>>>    
8174>>>>>    Integer iResult
8174>>>>>    UWide   uwPath
8174>>>>>    UWide   uwPath
8174>>>>>
8174>>>>>    Send StringToWide lpPath (&uwPath)
8175>>>>>                    
8175>>>>>    Move (PathRemoveFileSpecW (uwPath.lpUText)) to iResult 
8176>>>>>
8176>>>>>    Send WideToString (&uwPath) lpPath
8177>>>>>        
8177>>>>>    Function_Return iResult
8178>>>>>End_Function 
8179>>>>>
8179>>>>>Define URL_UNESCAPE_INPLACE                     for |CI$00100000
8179>>>>>Define URL_UNESCAPE_AS_UTF8                     for |CI$00040000
8179>>>>>Define URL_ESCAPE_SEGMENT_ONLY                  for |CI$00002000
8179>>>>>
8179>>>>>// When called directly, be sure to use WString types.
8179>>>>>External_Function UrlUnescapeW "UrlUnescapeW" shlwapi.dll;    Pointer pszwURL;    Pointer pszwUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8180>>>>>
8180>>>>>// Compatibility Wrapper Function UrlUnescape
8180>>>>>Function UrlUnescape Global ;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8182>>>>>    
8182>>>>>    Integer iResult
8182>>>>>    UWide   uwUrl uwUnescaped
8182>>>>>    UWide   uwUrl uwUnescaped
8182>>>>>
8182>>>>>    Send StringToWide pszURL (&uwUrl)
8183>>>>>
8183>>>>>    Send WideSetBuffer pszUnescaped pcchUnescaped (&uwUnescaped)
8184>>>>>                        
8184>>>>>    Move (UrlUnescapeW (uwUrl.lpUText, uwUnescaped.lpUText, uwUnescaped.lpSize, dwFlags)) to iResult
8185>>>>>    
8185>>>>>    If (dwFlags = URL_UNESCAPE_INPLACE) Begin
8187>>>>>        Send WideToString (&uwUrl) pszUrl 
8188>>>>>    End
8188>>>>>>
8188>>>>>    Else Begin
8189>>>>>        Send WideToString (&uwUnescaped) pszUnescaped  
8190>>>>>    End    
8190>>>>>>
8190>>>>>    
8190>>>>>    Function_Return iResult
8191>>>>>End_Function  
8192>>>>>
8192>>>>>// When called directly, be sure to use WString types.
8192>>>>>External_Function UrlEscapeW "UrlEscapeW" shlwapi.dll;    Pointer pszwUrl;    Pointer pszwEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8193>>>>>    
8193>>>>>// Compatibility Wrapper Function UrlEscape
8193>>>>>Function UrlEscape Global ;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8195>>>>>    
8195>>>>>    Integer iResult
8195>>>>>    UWide   uwUrl uwEscaped
8195>>>>>    UWide   uwUrl uwEscaped
8195>>>>>
8195>>>>>    Send StringToWide pszURL (&uwUrl)
8196>>>>>
8196>>>>>    Send WideSetBuffer pszEscaped pcchEscaped (&uwEscaped)
8197>>>>>                        
8197>>>>>    Move (UrlEscapeW (uwUrl.lpUText, uwEscaped.lpUText, pcchEscaped, dwFlags)) to iResult
8198>>>>>
8198>>>>>    Send WideToString (&uwEscaped) pszEscaped      
8199>>>>>    
8199>>>>>    Function_Return iResult
8200>>>>>End_Function 
8201>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cWorkspace.pkg)
8201>>>>>Use VdfBase.pkg
8201>>>>>Use tWinStructs.pkg
8201>>>>>Use LanguageText.pkg
8201>>>>>Use WinShell.pkg // Shell API functions
8201>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 20.0\Pkg\seq_chnl.pkg)
8201>>>>>>>Use LanguageText.pkg
8201>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 20.0\Pkg\errornum.inc)
8201>>>>>>>>
8201>>>>>>>>//
8201>>>>>>>>// these will get defined in fmac
8201>>>>>>>>//
8201>>>>>>>>// already defined
8201>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
8201>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
8201>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
8201>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
8201>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
8201>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
8201>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
8201>>>>>>>>// new compiler errors used by fmac
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
8201>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
8201>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
8201>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
8201>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
8201>>>>>>>>
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_STRING_CMD       |CI4531 // pertaining to string commands
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TYPE_CMD         |CI4532 // pertaining to type/end_type commands
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CMD              |CI4533 // pertaining to a more generic obsolete command 
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_GLOBAL_FUNCTION  |CI4534 // Global function is obsolete
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TECHNIQUE        |CI4535 // Using some older technique
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_PACKAGE          |CI4536 // Package is obsolete, remove it if you can
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CLASS            |CI4537 // Class is obsolete, remove it if you can
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_INDICATOR_USE    |CI4538 // Using indicators anywhere
8201>>>>>>>>//    
8201>>>>>>>>//    #Replace DFERR_COMP_ILLEGAL_CONVERSION                            |CI4539 // Datatype conversion is illegal, would cause runtime-error
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_OBJECT_FUNCTION  |CI4540 // Global function is obsolete
8201>>>>>>>>//    #Replace DFERR_INVALID_LOCALE_CODE                    |CI4541 // Error thown by Set_Attribute DF_LOCALE_CODE on invalid value
8201>>>>>>>>//    #Replace DFERR_STRING_COMPARISON_ERROR                |CI4542 // Error during string comparison (ICU returned an error)
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_REDEFINING_RETURN_TYPE    |CI4543 // Warning when redefining a function with a different return type
8201>>>>>>>>//    #Replace DFERR_COMP_AMBIGUOUS_FUNCTION_EXPRESSION     |CI4544 // Error when using ambiguous function in expression
8201>>>>>>>>    
8201>>>>>>>>
8201>>>>>>>>
8201>>>>>>>
8201>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8201>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8201>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8201>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8201>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8201>>>>>>>// so that programs that use direct_input/output
8201>>>>>>>// w/o specifying a channel will work.
8201>>>>>>>Enum_List
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8201>>>>>>>End_Enum_List
8201>>>>>>>
8201>>>>>>>Enum_List
8201>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8201>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8201>>>>>>>End_Enum_List
8201>>>>>>>
8201>>>>>>>Integer Seq$Channel$Error$Mode
8201>>>>>>>
8201>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
8203>>>>>>>    Move Mode to Seq$Channel$Error$Mode
8204>>>>>>>End_Procedure
8205>>>>>>>
8205>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8207>>>>>>>    Function_Return Seq$Channel$Error$Mode
8208>>>>>>>End_Function
8209>>>>>>>
8209>>>>>>>Object Seq_Channel_List is an Array
8211>>>>>>>    Procedure Initialize
8214>>>>>>>        Integer Itm
8214>>>>>>>        
8214>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
8215>>>>>>>        
8215>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
8219>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
8220>>>>>>>            Increment Itm
8221>>>>>>>        Loop
8222>>>>>>>>
8222>>>>>>>    End_Procedure
8223>>>>>>>    
8223>>>>>>>    Send Initialize
8224>>>>>>>End_Object
8225>>>>>>>
8225>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8226>>>>>>>
8226>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
8228>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
8229>>>>>>>End_Function
8230>>>>>>>
8230>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
8232>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
8233>>>>>>>End_Procedure
8234>>>>>>>
8234>>>>>>>Function Seq_New_Channel Global Returns Integer
8236>>>>>>>    Integer Obj Chnl
8236>>>>>>>    
8236>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
8237>>>>>>>    
8237>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
8241>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8243>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8244>>>>>>>            Function_Return Chnl
8245>>>>>>>        End
8245>>>>>>>>
8245>>>>>>>        
8245>>>>>>>        Increment Chnl
8246>>>>>>>    Loop
8247>>>>>>>>
8247>>>>>>>    
8247>>>>>>>    // wrap back to beginning
8247>>>>>>>    Move 0 to Chnl
8248>>>>>>>    
8248>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
8252>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8254>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8255>>>>>>>            Function_Return Chnl
8256>>>>>>>        End
8256>>>>>>>>
8256>>>>>>>        
8256>>>>>>>        Increment Chnl
8257>>>>>>>    Loop
8258>>>>>>>>
8258>>>>>>>    
8258>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8259>>>>>>>End_Function
8260>>>>>>>
8260>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
8262>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
8265>>>>>>>End_Procedure
8266>>>>>>>
8266>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
8268>>>>>>>    Integer Chnl
8268>>>>>>>    
8268>>>>>>>    Move (Seq_New_Channel()) to Chnl
8269>>>>>>>    
8269>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8271>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
8274>>>>>>>        Function_Return Chnl
8275>>>>>>>    End
8275>>>>>>>>
8275>>>>>>>    
8275>>>>>>>    Move False to Err
8276>>>>>>>    Direct_Input channel Chnl Dvc
8278>>>>>>>    
8278>>>>>>>    If (Err) Begin
8280>>>>>>>        Send Seq_Release_Channel Chnl
8281>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8282>>>>>>>    End
8282>>>>>>>>
8282>>>>>>>    
8282>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
8283>>>>>>>    
8283>>>>>>>    Function_Return Chnl
8284>>>>>>>End_Function
8285>>>>>>>
8285>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
8287>>>>>>>    Integer Chnl
8287>>>>>>>    
8287>>>>>>>    Move (Seq_New_Channel()) to Chnl
8288>>>>>>>    
8288>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8290>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8292>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8293>>>>>>>>
8293>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8294>>>>>>>        End
8294>>>>>>>>
8294>>>>>>>        
8294>>>>>>>        Function_Return Chnl
8295>>>>>>>    End
8295>>>>>>>>
8295>>>>>>>    
8295>>>>>>>    Move False to Err
8296>>>>>>>    Direct_Output channel Chnl Dvc
8298>>>>>>>    
8298>>>>>>>    If (Err) Begin
8300>>>>>>>        Send Seq_Release_Channel Chnl
8301>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8302>>>>>>>    End
8302>>>>>>>>
8302>>>>>>>    
8302>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8303>>>>>>>    
8303>>>>>>>    Function_Return Chnl
8304>>>>>>>End_Function
8305>>>>>>>
8305>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
8307>>>>>>>    Integer Chnl
8307>>>>>>>    
8307>>>>>>>    Move (Seq_New_Channel()) to Chnl
8308>>>>>>>    
8308>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8310>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8312>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8313>>>>>>>>
8313>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8314>>>>>>>        End
8314>>>>>>>>
8314>>>>>>>        
8314>>>>>>>        Function_Return Chnl
8315>>>>>>>    End
8315>>>>>>>>
8315>>>>>>>    
8315>>>>>>>    Move False to Err
8316>>>>>>>    Append_Output channel Chnl Dvc
8318>>>>>>>    
8318>>>>>>>    If (Err) Begin
8320>>>>>>>        Send Seq_Release_Channel Chnl
8321>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8322>>>>>>>    End
8322>>>>>>>>
8322>>>>>>>    
8322>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8323>>>>>>>    
8323>>>>>>>    Function_Return Chnl
8324>>>>>>>End_Function
8325>>>>>>>
8325>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
8327>>>>>>>    Integer Mode
8327>>>>>>>    
8327>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
8329>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
8330>>>>>>>        
8330>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
8334>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
8339>>>>>>>        // If channel not open, release it! No (fatal) Error.
8339>>>>>>>        Send Seq_Release_Channel Chnl
8340>>>>>>>    End
8340>>>>>>>>
8340>>>>>>>End_Procedure
8341>>>>>>>
8341>>>>>Use GlobalFunctionsProcedures.pkg
8341>>>>>
8341>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8341>>>>>Register_Function VdfSystemDfPath   Returns String
8341>>>>>Register_Function VdfSystemMakePath Returns String
8341>>>>>
8341>>>>>Enum_List
8341>>>>>    Define wsWorkspaceOpened       // WS opened ok
8341>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8341>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8341>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8341>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8341>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8341>>>>>End_Enum_List
8341>>>>>
8341>>>>>
8341>>>>>Define INVALID_HANDLE_VALUE for -1
8341>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8341>>>>>
8341>>>>>
8341>>>>>// Wide version
8341>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8342>>>>>
8342>>>>>// Wrapper Function winFindNextFile
8342>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8344>>>>>    
8344>>>>>    Handle  hResult
8344>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8344>>>>>    Integer iSizeOfStructWithoutStrings
8344>>>>>    String  sFileName sAlternateFileName
8344>>>>>    WString wFileName wAlternateFileName
8344>>>>>    Pointer pWFD
8344>>>>>    tWin32FindDataW tWFD
8344>>>>>    tWin32FindDataW tWFD
8344>>>>>    
8344>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8344>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8344>>>>>
8344>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8345>>>>>    Move (AddressOf(tWFD)) to pWFD
8346>>>>>    
8346>>>>>    // Call the function
8346>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8347>>>>>
8347>>>>>    // Copy the struct contents back to the incoming one.
8347>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8348>>>>>    
8348>>>>>    // But do the strings separately and convert them to UTF8
8348>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8349>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8350>>>>>    
8350>>>>>    // Extend string with 0 to the maximum number of characters
8350>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8353>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8356>>>>>        
8356>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8357>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8358>>>>>    
8358>>>>>    Function_Return hResult
8359>>>>>End_Function
8360>>>>>
8360>>>>>// When used directly, be sure to use WString types (UTF16).
8360>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8361>>>>>
8361>>>>>// Wrapper Function winFindNextFile
8361>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8363>>>>>    
8363>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8363>>>>>    Integer iSizeOfStructWithoutStrings
8363>>>>>    String  sFileName sAlternateFileName
8363>>>>>    WString wFileName wAlternateFileName
8363>>>>>    Pointer pWFD
8363>>>>>    tWin32FindDataW tWFD
8363>>>>>    tWin32FindDataW tWFD
8363>>>>>
8363>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8363>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8363>>>>>
8363>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8363>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8364>>>>>    Move (AddressOf(tWFD)) to pWFD
8365>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8366>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8366>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8367>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8368>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8369>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8370>>>>>    
8370>>>>>    // Call the function
8370>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8371>>>>>
8371>>>>>    // Copy the struct contents back to the incoming one.
8371>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8372>>>>>    
8372>>>>>    // But do the strings separately and convert them to UTF8
8372>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8373>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8374>>>>>    
8374>>>>>    // Extend string with 0 to the maximum number of characters
8374>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8377>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8380>>>>>        
8380>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8381>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8382>>>>>    
8382>>>>>    Function_Return iResult
8383>>>>>End_Function
8384>>>>>
8384>>>>>
8384>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8385>>>>>
8385>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8387>>>>>    tWin32FindDataW Win32FindData
8387>>>>>    tWin32FindDataW Win32FindData
8387>>>>>    String sMask
8387>>>>>    Integer iVoid
8387>>>>>    Handle hFileFind
8387>>>>>    
8387>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8388>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8390>>>>>        Move (winFindClose(hFileFind)) to iVoid
8391>>>>>    End
8391>>>>>>
8391>>>>>    
8391>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8392>>>>>End_Function
8393>>>>>
8393>>>>>
8393>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cIniFile.pkg)
8393>>>>>>>Use Dll.pkg
8393>>>>>>>Use errornum.inc
8393>>>>>>>Use LanguageText.pkg
8393>>>>>>>Use GlobalFunctionsProcedures.pkg
8393>>>>>>>Use seq_chnl.pkg
8393>>>>>>>Use CharTranslate.pkg
8393>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCharTranslate.pkg)
8393>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Variant.pkg)
8393>>>>>>>>>>>Use ui
8393>>>>>>>>>>>Use errornum.inc
8393>>>>>>>>>>>
8393>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8393>>>>>>>>>>>
8393>>>>>>>>>>>
8393>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8394>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8395>>>>>>>>>>>
8395>>>>>>>>>>>// Returns the character length of the variant string. 
8395>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8397>>>>>>>>>>>    Pointer pVariant
8397>>>>>>>>>>>    Integer iLen iType
8397>>>>>>>>>>>
8397>>>>>>>>>>>    Move (AddressOf(bStr)) to pVariant
8398>>>>>>>>>>>    Move (DeRefW(pVariant,0)) to iType
8399>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8401>>>>>>>>>>>        Function_Return 0
8402>>>>>>>>>>>    End
8402>>>>>>>>>>>>
8402>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8404>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8405>>>>>>>>>>>>
8405>>>>>>>>>>>        Function_Return 0
8406>>>>>>>>>>>    End
8406>>>>>>>>>>>>
8406>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(pVariant,8))) to iLen
8407>>>>>>>>>>>    Function_Return iLen
8408>>>>>>>>>>>End_Function
8409>>>>>>>>>>>
8409>>>>>>>>>>>
8409>>>>>>>>>>>// returns true if char string in the buffer can fit into a string
8409>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8411>>>>>>>>>>>    Integer iMax
8411>>>>>>>>>>>    Get_Argument_Size to iMax
8412>>>>>>>>>>>    Function_Return (CStringSize(pData)<=iMax)
8413>>>>>>>>>>>End_Function
8414>>>>>>>>>>>    
8414>>>>>>>>>Use CharTranslate.pkg
8414>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8414>>>>>>>>>
8414>>>>>>>>>// special for UTF16, which is really not a code page at all
8414>>>>>>>>>Define CP_UTF16 for -1
8414>>>>>>>>>
8414>>>>>>>>>Class cCharTranslate is a cObject
8415>>>>>>>>>    
8415>>>>>>>>>    
8415>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8415>>>>>>>>>    
8415>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8415>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8415>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8417>>>>>>>>>        Pointer pWideBuf
8417>>>>>>>>>        Integer iWideBufLen iStrLen
8417>>>>>>>>>        Move 0 to pWideBuf
8418>>>>>>>>>        Move 0 to iLen
8419>>>>>>>>>        If (pMultiCharBuffer) Begin
8421>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8422>>>>>>>>>            If (iStrLen) Begin
8424>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8425>>>>>>>>>                If (iLen=0) Begin
8427>>>>>>>>>                    Function_Return 0
8428>>>>>>>>>                End
8428>>>>>>>>>>
8428>>>>>>>>>            End
8428>>>>>>>>>>
8428>>>>>>>>>        End
8428>>>>>>>>>>
8428>>>>>>>>>        Function_Return pWideBuf
8429>>>>>>>>>    End_Function
8430>>>>>>>>>    
8430>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8432>>>>>>>>>        Pointer pValue
8432>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8433>>>>>>>>>        Function_Return pValue
8434>>>>>>>>>    End_Function
8435>>>>>>>>>    
8435>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8435>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8435>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8437>>>>>>>>>        Pointer pRetBuf
8437>>>>>>>>>        Integer iRetBufLen
8437>>>>>>>>>        Move 0 to pRetBuf
8438>>>>>>>>>        If (pWideBuf and iLen) Begin
8440>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8441>>>>>>>>>            If (iRetBufLen=0) Begin
8443>>>>>>>>>                Function_Return 0
8444>>>>>>>>>            End
8444>>>>>>>>>>
8444>>>>>>>>>        End
8444>>>>>>>>>>
8444>>>>>>>>>        Function_Return pRetBuf
8445>>>>>>>>>    End_Function
8446>>>>>>>>>    
8446>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8448>>>>>>>>>        String sValue
8448>>>>>>>>>        Pointer pValue
8448>>>>>>>>>        Boolean bOk
8448>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8449>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8451>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8452>>>>>>>>>>
8452>>>>>>>>>        End
8452>>>>>>>>>>
8452>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8453>>>>>>>>>        Move (Free(pValue)) to bOk
8454>>>>>>>>>        Function_Return sValue
8455>>>>>>>>>    End_Function
8456>>>>>>>>>    
8456>>>>>>>>>    
8456>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8456>>>>>>>>>    
8456>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8458>>>>>>>>>        Pointer pWideBuf
8458>>>>>>>>>        Pointer pUtf8Buf
8458>>>>>>>>>        Integer iLen iMultiBufLen
8458>>>>>>>>>        Boolean bOk
8458>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8459>>>>>>>>>        If (iLen=0) Begin
8461>>>>>>>>>            Function_Return 0
8462>>>>>>>>>        End
8462>>>>>>>>>>
8462>>>>>>>>>        Move 0 to pUtf8Buf
8463>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8464>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8465>>>>>>>>>        Function_Return pUtf8Buf
8466>>>>>>>>>    End_Function
8467>>>>>>>>>    
8467>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8469>>>>>>>>>        Pointer pValue
8469>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8470>>>>>>>>>        Function_Return pValue
8471>>>>>>>>>    End_Function
8472>>>>>>>>>    
8472>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8474>>>>>>>>>        Pointer pRetBuf pWideBuf
8474>>>>>>>>>        Integer iWideBufLen
8474>>>>>>>>>        Integer iRetBufLen
8474>>>>>>>>>        Boolean bOk
8474>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8475>>>>>>>>>        If (iWideBufLen=0) Begin
8477>>>>>>>>>            Function_Return 0
8478>>>>>>>>>        End
8478>>>>>>>>>>
8478>>>>>>>>>        Move 0 to pRetBuf
8479>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8480>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8481>>>>>>>>>        Function_Return pRetBuf
8482>>>>>>>>>    End_Function
8483>>>>>>>>>    
8483>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8485>>>>>>>>>        String sValue
8485>>>>>>>>>        Pointer pValue
8485>>>>>>>>>        Boolean bOk
8485>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8486>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8488>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8489>>>>>>>>>>
8489>>>>>>>>>        End
8489>>>>>>>>>>
8489>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8490>>>>>>>>>        Move (Free(pValue)) to bOk
8491>>>>>>>>>        Function_Return sValue
8492>>>>>>>>>    End_Function
8493>>>>>>>>>    
8493>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8493>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8493>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8493>>>>>>>>>    
8493>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8493>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8495>>>>>>>>>        Pointer pBSTR pRetStr
8495>>>>>>>>>        Integer iLen iBufLen
8495>>>>>>>>>        Boolean bOk
8495>>>>>>>>>        Move 0 to pRetStr
8496>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8497>>>>>>>>>        If (iLen) Begin
8499>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8500>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8501>>>>>>>>>        End
8501>>>>>>>>>>
8501>>>>>>>>>        Function_Return pRetStr
8502>>>>>>>>>    End_Function
8503>>>>>>>>>    
8503>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8503>>>>>>>>>    
8503>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8505>>>>>>>>>        String sValue
8505>>>>>>>>>        Pointer pValue
8505>>>>>>>>>        Boolean bOk
8505>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8506>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8508>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8509>>>>>>>>>>
8509>>>>>>>>>        End
8509>>>>>>>>>>
8509>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8510>>>>>>>>>        Move (Free(pValue)) to bOk
8511>>>>>>>>>        Function_Return sValue
8512>>>>>>>>>    End_Function
8513>>>>>>>>>    
8513>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8513>>>>>>>>>    
8513>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8515>>>>>>>>>        Variant vValue
8515>>>>>>>>>        Pointer pvValue
8515>>>>>>>>>        Boolean bOk
8515>>>>>>>>>        Pointer pWStr
8515>>>>>>>>>        Move "" to vValue
8516>>>>>>>>>        If (pSource) Begin
8518>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8518>>>>>>>>>            Move 0 to pWStr
8519>>>>>>>>>            //Convert the Ansi string to Unicode
8519>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8520>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8520>>>>>>>>>            Move 0 to vValue
8521>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8522>>>>>>>>>            //Change the Variant type to VT_BSTR
8522>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8523>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8523>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8524>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8524>>>>>>>>>            Move (Free(pWStr)) to bOk
8525>>>>>>>>>        End
8525>>>>>>>>>>
8525>>>>>>>>>        Function_Return vValue
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8527>>>>>>>>>    
8527>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8529>>>>>>>>>        Variant vValue
8529>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8530>>>>>>>>>        Function_Return vValue
8531>>>>>>>>>    End_Function
8532>>>>>>>>>    
8532>>>>>>>>>    // Create buffer of utf16 data from variant.
8532>>>>>>>>>    // Returns newly created memory address and length (by reference)
8532>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8534>>>>>>>>>        Pointer pBSTR pRetStr
8534>>>>>>>>>        Boolean bOk
8534>>>>>>>>>        Move 0 to pRetStr
8535>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8536>>>>>>>>>        If (iLen) Begin
8538>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8539>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8540>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8541>>>>>>>>>        End
8541>>>>>>>>>>
8541>>>>>>>>>        Function_Return pRetStr
8542>>>>>>>>>    End_Function
8543>>>>>>>>>    
8543>>>>>>>>>    // Create variant from buffer of utf16 data
8543>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8545>>>>>>>>>        Variant vValue
8545>>>>>>>>>        Pointer pvValue
8545>>>>>>>>>        Boolean bOk
8545>>>>>>>>>        Move "" to vValue
8546>>>>>>>>>        If (pSource) Begin
8548>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8548>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8548>>>>>>>>>            Move 0 to vValue
8549>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8550>>>>>>>>>            //Change the Variant type to VT_BSTR
8550>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8551>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8551>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8552>>>>>>>>>        End
8552>>>>>>>>>>
8552>>>>>>>>>        Function_Return vValue
8553>>>>>>>>>    End_Function
8554>>>>>>>>>    
8554>>>>>>>>>    // Create Uchar array from variant string.
8554>>>>>>>>>    // Data buffer is encoded by eCharType
8554>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8556>>>>>>>>>        Pointer pBSTR pRetStr
8556>>>>>>>>>        Integer iLen iBufLen
8556>>>>>>>>>        Boolean bOk
8556>>>>>>>>>        UChar[] UC1
8557>>>>>>>>>        Move 0 to pRetStr
8558>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8559>>>>>>>>>        If (iLen) Begin
8561>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8562>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8564>>>>>>>>>                Move (iLen*2) to iBufLen
8565>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8566>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8567>>>>>>>>>            End
8567>>>>>>>>>>
8567>>>>>>>>>            Else Begin
8568>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8569>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8570>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8571>>>>>>>>>                Move (Free(pRetStr)) to bOk
8572>>>>>>>>>            End
8572>>>>>>>>>>
8572>>>>>>>>>        End
8572>>>>>>>>>>
8572>>>>>>>>>        Function_Return UC1
8573>>>>>>>>>    End_Function
8574>>>>>>>>>    
8574>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8574>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8576>>>>>>>>>        Variant vValue
8576>>>>>>>>>        Pointer pvValue
8576>>>>>>>>>        Boolean bOk
8576>>>>>>>>>        Pointer pWStr
8576>>>>>>>>>        Move "" to vValue
8577>>>>>>>>>        
8577>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8577>>>>>>>>>        Move 0 to pWStr
8578>>>>>>>>>        //Convert the Ansi string to Unicode
8578>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8580>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8581>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8582>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8583>>>>>>>>>        End
8583>>>>>>>>>>
8583>>>>>>>>>        Else Begin
8584>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8585>>>>>>>>>        End
8585>>>>>>>>>>
8585>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8585>>>>>>>>>        Move 0 to vValue
8586>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8587>>>>>>>>>        //Change the Variant type to VT_BSTR
8587>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8588>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8588>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8589>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8589>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8591>>>>>>>>>            Move (Free(pWStr)) to bOk
8592>>>>>>>>>        End
8592>>>>>>>>>>
8592>>>>>>>>>        Function_Return vValue
8593>>>>>>>>>    End_Function
8594>>>>>>>>>    
8594>>>>>>>>>    
8594>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8594>>>>>>>>>    // a new UChar array with to-encoding
8594>>>>>>>>>    
8594>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8596>>>>>>>>>        Pointer pFromBuf pToBuf
8596>>>>>>>>>        Integer iBytes iChars
8596>>>>>>>>>        Boolean bOk
8596>>>>>>>>>        
8596>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8597>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8599>>>>>>>>>            Function_Return UCharData
8600>>>>>>>>>        End
8600>>>>>>>>>>
8600>>>>>>>>>        
8600>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8602>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8603>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8604>>>>>>>>>        End
8604>>>>>>>>>>
8604>>>>>>>>>        Else Begin
8605>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8606>>>>>>>>>        End
8606>>>>>>>>>>
8606>>>>>>>>>        
8606>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8608>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8610>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8611>>>>>>>>>            End
8611>>>>>>>>>>
8611>>>>>>>>>            Else Begin
8612>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8613>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8614>>>>>>>>>            End
8614>>>>>>>>>>
8614>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8615>>>>>>>>>        End
8615>>>>>>>>>>
8615>>>>>>>>>        Else Begin
8616>>>>>>>>>            Move (iChars*2) to iBytes
8617>>>>>>>>>            Move pFromBuf to pToBuf
8618>>>>>>>>>        End
8618>>>>>>>>>>
8618>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8619>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8620>>>>>>>>>        Move (Free(pToBuf)) to bOk
8621>>>>>>>>>        Function_Return UCharData
8622>>>>>>>>>    End_Function
8623>>>>>>>>>    
8623>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8623>>>>>>>>>    // Variant strings. Binary data is always buffer
8623>>>>>>>>>    
8623>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8625>>>>>>>>>        Pointer pBase64
8625>>>>>>>>>        String sResult
8625>>>>>>>>>        Integer iVoid iMax
8625>>>>>>>>>        Get_Argument_Size to iMax
8626>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8627>>>>>>>>>        If (iMax<CStringSize(pBase64)) Begin
8629>>>>>>>>>            Error DFERR_PROGRAM "Base64 encoded string exceeds max string size"
8630>>>>>>>>>>
8630>>>>>>>>>        End
8630>>>>>>>>>>
8630>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8631>>>>>>>>>        Move (Free(pBase64)) to iVoid
8632>>>>>>>>>        Function_Return sResult
8633>>>>>>>>>    End_Function
8634>>>>>>>>>    
8634>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8636>>>>>>>>>        Pointer pBinaryData
8636>>>>>>>>>        String sBinary
8636>>>>>>>>>        Integer iVoid
8636>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8637>>>>>>>>>        Function_Return pBinaryData
8638>>>>>>>>>    End_Function
8639>>>>>>>>>    
8639>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8641>>>>>>>>>        Pointer pBase64
8641>>>>>>>>>        Variant vVar
8641>>>>>>>>>        Integer iBase64Len iVoid
8641>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8643>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8644>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8645>>>>>>>>>            Move (Free(pBase64)) to iVoid
8646>>>>>>>>>        End
8646>>>>>>>>>>
8646>>>>>>>>>        Function_Return vVar
8647>>>>>>>>>    End_Function
8648>>>>>>>>>    
8648>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8650>>>>>>>>>        Pointer pBase64 pBinaryData
8650>>>>>>>>>        Integer iVoid
8650>>>>>>>>>        Move 0 to iBinaryLen
8651>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8652>>>>>>>>>        If (pBase64) Begin
8654>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8655>>>>>>>>>            Move (Free(pBase64)) to iVoid
8656>>>>>>>>>        End
8656>>>>>>>>>>
8656>>>>>>>>>        Function_Return pBinaryData
8657>>>>>>>>>    End_Function
8658>>>>>>>>>    
8658>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8658>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8660>>>>>>>>>        Pointer pBase64
8660>>>>>>>>>        Integer iLen
8660>>>>>>>>>        Boolean bOk
8660>>>>>>>>>        
8660>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8661>>>>>>>>>        If (iLen) Begin
8663>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8664>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8665>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8666>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8667>>>>>>>>>            Move (Free(pBase64)) to bOk
8668>>>>>>>>>        End
8668>>>>>>>>>>
8668>>>>>>>>>        Function_Return UCharData
8669>>>>>>>>>    End_Function
8670>>>>>>>>>    
8670>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8670>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8672>>>>>>>>>        Pointer pData
8672>>>>>>>>>        Integer iLen
8672>>>>>>>>>        Boolean bOk
8672>>>>>>>>>        
8672>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8673>>>>>>>>>        If (iLen) Begin
8675>>>>>>>>>            Move 0 to UCharData[iLen]
8676>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8677>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8678>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8679>>>>>>>>>            Move (Free(pData)) to bOk
8680>>>>>>>>>        End
8680>>>>>>>>>>
8680>>>>>>>>>        Function_Return UCharData
8681>>>>>>>>>    End_Function
8682>>>>>>>>>    
8682>>>>>>>>>End_Class
8683>>>>>>>>>
8683>>>>>>>>>
8683>>>>>>>
8683>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8683>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8683>>>>>>>
8683>>>>>>>
8683>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8684>>>>>>>
8684>>>>>>>
8684>>>>>>>// When called directly, be sure to use WString types.
8684>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8685>>>>>>>
8685>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8686>>>>>>>    
8686>>>>>>>// When called directly, be sure to use String types.
8686>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8687>>>>>>>    
8687>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8687>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8687>>>>>>>    
8687>>>>>>>
8687>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8687>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8689>>>>>>>    
8689>>>>>>>    Integer iResult
8689>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8689>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8689>>>>>>>
8689>>>>>>>    Send StringToWide pSection (&uwSection)
8690>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8691>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8692>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8693>>>>>>>                           
8693>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8694>>>>>>>       
8694>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8695>>>>>>>        
8695>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8696>>>>>>>    
8696>>>>>>>    Function_Return iResult
8697>>>>>>>End_Function
8698>>>>>>> 
8698>>>>>>>
8698>>>>>>>Class cIniFile is a cObject
8699>>>>>>>    Procedure Construct_Object
8701>>>>>>>        Forward Send Construct_Object
8703>>>>>>>        
8703>>>>>>>        
8703>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8703>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8703>>>>>>>        Property Boolean pbWideAPI True
8704>>>>>>>        
8704>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8704>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8704>>>>>>>        // converted on first write (WriteString).
8704>>>>>>>        Property Boolean pbStoreAsUTF16 False
8705>>>>>>>        
8705>>>>>>>        Property String psPrivate_FileName ""
8706>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8707>>>>>>>    End_Procedure
8708>>>>>>>    
8708>>>>>>>    Procedure Set psFileName String sVal
8710>>>>>>>        Set pbPrivate_FirstWrite to True
8711>>>>>>>        Set psPrivate_FileName to sVal
8712>>>>>>>    End_Procedure
8713>>>>>>>    
8713>>>>>>>    Function psFileName Returns String
8715>>>>>>>        Function_Return (psPrivate_FileName(Self))
8716>>>>>>>    End_Function
8717>>>>>>>    
8717>>>>>>>    Procedure InitFile
8719>>>>>>>        Boolean bExists bHasBom
8719>>>>>>>        Integer iChnl
8719>>>>>>>        UChar[] ucData
8720>>>>>>>        Handle hoTranslate
8720>>>>>>>        
8720>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8722>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8723>>>>>>>            If (not(bExists)) Begin
8725>>>>>>>                //  Create the file with a UTF-16 BOM so
8725>>>>>>>                Move (Seq_New_Channel()) to iChnl
8726>>>>>>>                Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8728>>>>>>>                Write channel iChnl C_BOM_UTF16LE
8730>>>>>>>                Close_Output channel iChnl
8732>>>>>>>                Send Seq_Release_Channel iChnl
8733>>>>>>>            End
8733>>>>>>>>
8733>>>>>>>            Else Begin
8734>>>>>>>                //  Check for BOM
8734>>>>>>>                Move (Seq_New_Channel()) to iChnl
8735>>>>>>>                Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8737>>>>>>>                Read_Block channel iChnl ucData 2
8739>>>>>>>                
8739>>>>>>>                Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8740>>>>>>>                
8740>>>>>>>                //  If no BOM we'll have to read the entire file to convert it
8740>>>>>>>                If (not(bHasBom)) Begin
8742>>>>>>>                    Set_Channel_Position iChnl to 0
8743>>>>>>>>
8743>>>>>>>                    Read_Block ucData -1
8744>>>>>>>                End
8744>>>>>>>>
8744>>>>>>>
8744>>>>>>>                Close_Input channel iChnl
8746>>>>>>>                
8746>>>>>>>                If (not(bHasBom)) Begin
8748>>>>>>>                    //  Convert thedata
8748>>>>>>>                    Get Create (RefClass(cCharTranslate)) to hoTranslate
8749>>>>>>>                    Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8750>>>>>>>                    
8750>>>>>>>                    //  Write out the UTF 16 file with BOM
8750>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8752>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8754>>>>>>>                    
8754>>>>>>>                    Write channel iChnl ucData
8756>>>>>>>                    
8756>>>>>>>                    Close_Output channel iChnl
8758>>>>>>>                    
8758>>>>>>>                    Send Destroy of hoTranslate
8759>>>>>>>                End
8759>>>>>>>>
8759>>>>>>>                
8759>>>>>>>                Send Seq_Release_Channel iChnl
8760>>>>>>>            End
8760>>>>>>>>
8760>>>>>>>            
8760>>>>>>>            Set pbPrivate_FirstWrite to False
8761>>>>>>>        End
8761>>>>>>>>
8761>>>>>>>    End_Procedure
8762>>>>>>>    
8762>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8764>>>>>>>        Boolean bSuccess
8764>>>>>>>        String sFileName
8764>>>>>>>        
8764>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8766>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8767>>>>>>>>
8767>>>>>>>            Procedure_Return
8768>>>>>>>        End
8768>>>>>>>>
8768>>>>>>>        
8768>>>>>>>        Send InitFile
8769>>>>>>>        
8769>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8769>>>>>>>        If (pbWideAPI(Self)) Begin
8771>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8772>>>>>>>        End
8772>>>>>>>>
8772>>>>>>>        Else Begin
8773>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8774>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8775>>>>>>>        End
8775>>>>>>>>
8775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8778>>>>>>>    End_Procedure
8779>>>>>>>    
8779>>>>>>>    
8779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8781>>>>>>>        Integer iNumChars iSizeValue
8781>>>>>>>        WString wValue wFileName wSection wKey wDefault
8781>>>>>>>        String sFileName sValue
8781>>>>>>>        
8781>>>>>>>        Move 2047 to iSizeValue
8782>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8783>>>>>>>        
8783>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8785>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8786>>>>>>>>
8786>>>>>>>            Function_Return ''
8787>>>>>>>        End
8787>>>>>>>>
8787>>>>>>>        
8787>>>>>>>        If (pbWideAPI(Self)) Begin
8789>>>>>>>            Move sSection to wSection
8790>>>>>>>            Move sKey to wKey
8791>>>>>>>            Move sDefault to wDefault
8792>>>>>>>            Move sValue to wValue
8793>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8794>>>>>>>            Move wValue to sValue
8795>>>>>>>        End
8795>>>>>>>>
8795>>>>>>>        Else Begin
8796>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8797>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8798>>>>>>>        End
8798>>>>>>>>
8798>>>>>>>        
8798>>>>>>>        Function_Return  (CString(sValue))
8799>>>>>>>    End_Function
8800>>>>>>>    
8800>>>>>>>    Function SectionExists String sSection Returns Boolean
8802>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8802>>>>>>>        Handle hoKeys
8802>>>>>>>        Integer icKey iKey
8802>>>>>>>        
8802>>>>>>>        Get Create U_ARRAY to hoKeys
8803>>>>>>>        Send ReadSection sSection hoKeys
8804>>>>>>>        Get Item_Count of hoKeys to icKey
8805>>>>>>>        Send Destroy of hoKeys
8806>>>>>>>        
8806>>>>>>>        Function_Return (icKey >0)
8807>>>>>>>    End_Function
8808>>>>>>>    
8808>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8810>>>>>>>        Integer iNumChars iSizeValue iPos
8810>>>>>>>        Pointer lpsKeys
8810>>>>>>>        WString wKeys wKey
8810>>>>>>>        
8810>>>>>>>        Move 16384 to iSizeValue
8811>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wKeys
8812>>>>>>>        
8812>>>>>>>        Move (AddressOf(wKeys)) to lpsKeys
8813>>>>>>>        
8813>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8815>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8816>>>>>>>>
8816>>>>>>>            Procedure_Return
8817>>>>>>>        End
8817>>>>>>>>
8817>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8817>>>>>>>        Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8818>>>>>>>        If (iNumChars >0) Begin
8820>>>>>>>            Repeat
8820>>>>>>>>
8820>>>>>>>                Move (Pos(Character(0),wKeys)) to iPos
8821>>>>>>>                If (iPos >1) Begin
8823>>>>>>>                    Move (Left(wKeys,iPos -1))  to wKey
8824>>>>>>>                    Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8825>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to wKey
8826>>>>>>>                End
8826>>>>>>>>
8826>>>>>>>            Until (iPos <=1)
8828>>>>>>>        End
8828>>>>>>>>
8828>>>>>>>    End_Procedure
8829>>>>>>>    
8829>>>>>>>    Procedure ReadSections Handle hoArray
8831>>>>>>>        Integer iNumChars iSizeValue iPos
8831>>>>>>>        Pointer lpwSections
8831>>>>>>>        WString wSections
8831>>>>>>>        String sSection
8831>>>>>>>        
8831>>>>>>>        Move 16384 to iSizeValue
8832>>>>>>>        
8832>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8833>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8834>>>>>>>        
8834>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8836>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8837>>>>>>>>
8837>>>>>>>            Procedure_Return
8838>>>>>>>        End
8838>>>>>>>>
8838>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8838>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8839>>>>>>>        If (iNumChars >0) Begin
8841>>>>>>>            Repeat
8841>>>>>>>>
8841>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8842>>>>>>>                If (iPos >1) Begin
8844>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8845>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8846>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8847>>>>>>>                End
8847>>>>>>>>
8847>>>>>>>            Until (iPos <=1)
8849>>>>>>>        End
8849>>>>>>>>
8849>>>>>>>        
8849>>>>>>>    End_Procedure
8850>>>>>>>    
8850>>>>>>>    Procedure DeleteSection String sSection
8852>>>>>>>        
8852>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8854>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8855>>>>>>>>
8855>>>>>>>            Procedure_Return
8856>>>>>>>        End
8856>>>>>>>>
8856>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8859>>>>>>>    End_Procedure
8860>>>>>>>    
8860>>>>>>>    Procedure DeleteKey String sSection String sKey
8862>>>>>>>        Integer iVoid
8862>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8864>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8865>>>>>>>>
8865>>>>>>>            Procedure_Return
8866>>>>>>>        End
8866>>>>>>>>
8866>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8867>>>>>>>    End_Procedure
8868>>>>>>>    
8868>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
8870>>>>>>>        Handle hoKeys
8870>>>>>>>        Integer iKey
8870>>>>>>>        Boolean bExists
8870>>>>>>>        
8870>>>>>>>        Move (False) to bExists
8871>>>>>>>        
8871>>>>>>>        Move (Uppercase(sKey)) to sKey
8872>>>>>>>        
8872>>>>>>>        Get Create U_ARRAY to hoKeys
8873>>>>>>>        
8873>>>>>>>        Send ReadSection sSection hoKeys
8874>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
8880>>>>>>>>
8880>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
8882>>>>>>>                Move (True) to bExists
8883>>>>>>>            End
8883>>>>>>>>
8883>>>>>>>        Loop
8884>>>>>>>>
8884>>>>>>>        
8884>>>>>>>        Send Destroy of hoKeys
8885>>>>>>>        
8885>>>>>>>        Function_Return bExists
8886>>>>>>>    End_Function
8887>>>>>>>    
8887>>>>>>>End_Class
8888>>>>>
8888>>>>>Class cWorkspace is a cObject
8889>>>>>    
8889>>>>>    Procedure Construct_Object
8891>>>>>        Forward Send Construct_Object
8893>>>>>        
8893>>>>>        
8893>>>>>        Property String psAppSrcPath
8894>>>>>        Property String psBitmapPath
8895>>>>>        Property String psDataPath
8896>>>>>        Property String psDdSrcPath
8897>>>>>        Property String psDescription
8898>>>>>        Property String psFileList
8899>>>>>        Property String psHelpPath
8900>>>>>        Property String psHome
8901>>>>>        Property String psIdeSrcPath
8902>>>>>        Property String psProgramPath
8903>>>>>        Property String psAppHtmlPath
8904>>>>>        Property String psWorkspaceName
8905>>>>>        Property String psWorkspaceWSFile
8906>>>>>        Property String psConnectionIni
8907>>>>>        
8907>>>>>        Property String psSystemDfPath // took from the Registry!
8908>>>>>        Property String psSystemMakePath // took from the Registry!
8909>>>>>        Property String psDfPath        // Calculated
8910>>>>>        
8910>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
8911>>>>>        
8911>>>>>    End_Procedure
8912>>>>>    
8912>>>>>    Function FullPathNames String sShortPathNames Returns String
8914>>>>>        String sFileName
8914>>>>>        String sFullPathNames 
8914>>>>>        WString sFullPathName sShortPathName
8914>>>>>        Pointer lpsFilePart
8914>>>>>        Integer icChar // the number of characters returned
8914>>>>>        Integer iPos
8914>>>>>        
8914>>>>>        Move (Pos(";", sShortPathNames)) to iPos
8915>>>>>        While (length(sShortPathNames) >0)
8919>>>>>            If (iPos =0) Begin
8921>>>>>                Move sShortPathNames to sShortPathName
8922>>>>>                Move "" to sShortPathNames
8923>>>>>            End
8923>>>>>>
8923>>>>>            Else Begin // multiple paths
8924>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
8925>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
8926>>>>>            End
8926>>>>>>
8926>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
8927>>>>>            Move -1 to lpsFilePart
8928>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
8929>>>>>            Append sFullPathNames (CString(sFullPathName))
8930>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
8933>>>>>            Move (Pos(";", sShortPathNames)) to iPos
8934>>>>>        Loop
8935>>>>>>
8935>>>>>        
8935>>>>>        Function_Return sFullPathNames
8936>>>>>    End_Function
8937>>>>>    
8937>>>>>    Function GetApplicationPath Returns String
8939>>>>>        // Returns the path of the Application (no trailing "\")
8939>>>>>        WString wApplicationFileName 
8939>>>>>        Boolean bRemoved
8939>>>>>        Integer iNumChars
8939>>>>>        String sFilename sPath
8939>>>>>        
8939>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
8940>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
8941>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
8942>>>>>        
8942>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
8943>>>>>        Move (CString(wApplicationFileName)) to sPath
8944>>>>>        
8944>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8947>>>>>        Function_Return sPath
8948>>>>>    End_Function
8949>>>>>    
8949>>>>>    Procedure DoClearPaths
8951>>>>>        // Call this prior to changing from one WorkspAce to another
8951>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
8951>>>>>        Set psHome           to ""
8952>>>>>        Set psAppSrcPath     to ""
8953>>>>>        Set psBitmapPath     to ""
8954>>>>>        Set psDataPath       to ""
8955>>>>>        Set psDdSrcPath      to ""
8956>>>>>        Set psDescription    to ""
8957>>>>>        Set psFileList       to ""
8958>>>>>        Set psHelpPath       to ""
8959>>>>>        Set psIdeSrcPath     to ""
8960>>>>>        Set psAppHtmlPath    to ""
8961>>>>>        Set psProgramPath    to ""
8962>>>>>        Set psWorkspaceName  to ""
8963>>>>>        Set psSystemDfPath   to ""
8964>>>>>        Set psSystemMakePath to ""
8965>>>>>        Set psWorkspaceWSFile to ""
8966>>>>>        Set psConnectionIni to ""
8967>>>>>    End_Procedure
8968>>>>>    
8968>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
8970>>>>>        WString wApplicationStartPath
8970>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
8970>>>>>        Boolean bRemoved
8970>>>>>        Handle hoIniFile
8970>>>>>        Boolean bSuccess // call succeeded?
8970>>>>>        String sOldDirectory
8970>>>>>        String sSystemDfPath sSystemMakePath
8970>>>>>        Boolean bExist // does the WS file exist?
8970>>>>>        Boolean bChangingWorkspace
8970>>>>>        
8970>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
8970>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
8970>>>>>        
8970>>>>>        Set psWorkspaceWSFile to ""
8971>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
8974>>>>>        
8974>>>>>        // Append extension if not supplied...
8974>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
8976>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
8977>>>>>        End
8977>>>>>>
8977>>>>>        
8977>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
8978>>>>>        
8978>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
8980>>>>>            // Set the properties to the paths of the Workspace
8980>>>>>            // Find the WS file (with program)...
8980>>>>>            Get GetApplicationPath to wApplicationStartPath
8981>>>>>            
8981>>>>>            Move sWorkspaceFile to sWsName
8982>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
8983>>>>>        End
8983>>>>>>
8983>>>>>        Else Begin
8984>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
8985>>>>>            
8985>>>>>            Move sWorkspaceFile to wApplicationStartPath
8986>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
8987>>>>>        End
8987>>>>>>
8987>>>>>        
8987>>>>>        // Ensure that the file can be found...
8987>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
8987>>>>>        // [JVH] Turn off support for
8987>>>>>        // Ansi extended characters in workspace until we can
8987>>>>>        // resolve all open issues
8987>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
8988>>>>>        File_Exist sWorkspaceFile bExist
8989>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
8992>>>>>        
8992>>>>>        Get psHome           to sHome
8993>>>>>        Get psAppSrcPath     to sAppSrcPath
8994>>>>>        Get psAppHtmlPath    to sAppHtmlPath
8995>>>>>        Get psBitmapPath     to sBitmapPath
8996>>>>>        Get psDataPath       to sDataPath
8997>>>>>        Get psDdSrcPath      to sDdSrcPath
8998>>>>>        Get psDescription    to sDescription
8999>>>>>        Get psFileList       to sFileList
9000>>>>>        Get psHelpPath       to sHelpPath
9001>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9002>>>>>        Get psProgramPath    to sProgramPath
9003>>>>>        Get psSystemDfPath   to sSystemDfPath
9004>>>>>        Get psSystemMakePath to sSystemMakePath
9005>>>>>        Get psWorkspaceName  to sWorkspaceName
9006>>>>>        Get psConnectionIni to sConnectionIni
9007>>>>>        
9007>>>>>        Get_Current_Directory to sOldDirectory
9008>>>>>        // Note- this conversion is temporarily rolled back
9008>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9008>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9009>>>>>        
9009>>>>>        Get Create U_cIniFile to hoIniFile
9010>>>>>        Set pbWideAPI of hoIniFile to False
9011>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9012>>>>>        
9012>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9015>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9018>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9021>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9024>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9027>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9030>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9033>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9036>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9039>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9042>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9045>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9048>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9051>>>>>        
9051>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9054>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9057>>>>>        
9057>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9058>>>>>        
9058>>>>>        // Set CWD to Home...
9058>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9059>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9060>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9061>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9062>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9063>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9064>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9065>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9066>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9067>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9068>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9069>>>>>        
9069>>>>>        Set psWorkspaceName to sWorkspaceName
9070>>>>>        Set psDescription   to sDescription
9071>>>>>        
9071>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9072>>>>>        
9072>>>>>        // Restore CWD...
9072>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9073>>>>>        
9073>>>>>        // Check for error conditions:
9073>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9073>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9076>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9079>>>>>        
9079>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9080>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9083>>>>>        
9083>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9086>>>>>        
9086>>>>>        Send DoAssignPaths // set psDfPath
9087>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9088>>>>>        Set pbWorkspaceOpened to True
9089>>>>>        
9089>>>>>        Function_Return wsWorkspaceOpened
9090>>>>>    End_Function
9091>>>>>    
9091>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9093>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9093>>>>>        
9093>>>>>        Handle hoSections hoIniFile
9093>>>>>        Integer iWorkspace eOpened
9093>>>>>        String sWorkspaceName sPath
9093>>>>>        String sVdfRootDir
9093>>>>>        
9093>>>>>        Get Create U_Array    to hoSections
9094>>>>>        Get Create U_cIniFile to hoIniFile
9095>>>>>        
9095>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9098>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9101>>>>>        
9101>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9102>>>>>        
9102>>>>>        Send ReadSections of hoIniFile hoSections
9103>>>>>        
9103>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9109>>>>>>
9109>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9110>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9112>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9113>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9116>>>>>                
9116>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9117>>>>>                Send Destroy of hoSections
9118>>>>>                Send Destroy of hoIniFile
9119>>>>>                Function_Return eOpened
9120>>>>>            End
9120>>>>>>
9120>>>>>        Loop
9121>>>>>>
9121>>>>>        
9121>>>>>        Send Destroy of hoSections
9122>>>>>        Send Destroy of hoIniFile
9123>>>>>        Function_Return wsWorkspaceNotFound
9124>>>>>    End_Function
9125>>>>>    
9125>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9127>>>>>        Boolean bRegistered
9127>>>>>        Handle hoIniFile
9127>>>>>        String sVdfRootDir
9127>>>>>        
9127>>>>>        Get Create U_cIniFile to hoIniFile
9128>>>>>        
9128>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9131>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9134>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9135>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9136>>>>>        
9136>>>>>        Send Destroy of hoIniFile
9137>>>>>        
9137>>>>>        Function_Return bRegistered
9138>>>>>    End_Function
9139>>>>>    
9139>>>>>    Function VdfSystemDfPath Returns String
9141>>>>>        String sSystemDfPath
9141>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9144>>>>>        
9144>>>>>        Function_Return sSystemDfPath
9145>>>>>    End_Function
9146>>>>>    
9146>>>>>    Function VdfSystemMakePath Returns String
9148>>>>>        String sSystemMakePath
9148>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9151>>>>>        
9151>>>>>        Function_Return sSystemMakePath
9152>>>>>    End_Function
9153>>>>>    
9153>>>>>    Procedure DoAssignPaths
9155>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9155>>>>>        
9155>>>>>        Get psDataPath     to sDataPath
9156>>>>>        Get psBitmapPath   to sBitmapPath
9157>>>>>        Get psHelpPath     to sHelpPath
9158>>>>>        Get psProgramPath  to sProgramPath
9159>>>>>        Get psSystemDfPath to sSystemDfPath
9160>>>>>        
9160>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9161>>>>>        
9161>>>>>    End_Procedure
9162>>>>>    
9162>>>>>    Procedure DoSetPaths
9164>>>>>        // [JVH] must convert paths to Ansi before setting these values
9164>>>>>        // Note- this conversion is temporarily rolled back
9164>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9164>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9164>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9167>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9170>>>>>    End_Procedure
9171>>>>>    
9171>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9173>>>>>        String sPath
9173>>>>>        
9173>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9176>>>>>        Else Begin
9177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9179>>>>>            Send hmGeneric to hoCallBack ""
9180>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9181>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9182>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9183>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9184>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9185>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9186>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9187>>>>>        End
9187>>>>>>
9187>>>>>    End_Procedure
9188>>>>>    
9188>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9190>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9190>>>>>        // returns a corresponding message string.
9190>>>>>        String sError
9190>>>>>        
9190>>>>>        Case Begin
9190>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9192>>>>>                Move C_$NoErrors to sError
9193>>>>>                Case Break
9194>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9197>>>>>                Move C_$NoWsName to sError
9198>>>>>                Case Break
9199>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9202>>>>>                Move C_$NoWsFileFound to sError
9203>>>>>                Case Break
9204>>>>>            Case (eErrorCode = wsDataPathEmpty)
9207>>>>>                Move C_$NoWsDataPath to sError
9208>>>>>                Case Break
9209>>>>>            Case (eErrorCode = wsFileListEmpty)
9212>>>>>                Move C_$NoWsFileList to sError
9213>>>>>                Case Break
9214>>>>>            Case (eErrorCode = wsFileListNotExist)
9217>>>>>                Move C_$NoFileListCfg to sError
9218>>>>>                Case Break
9219>>>>>            Case Else
9219>>>>>                Move C_$UnknownError to sError
9220>>>>>                Case Break
9221>>>>>        Case End
9221>>>>>        
9221>>>>>        Function_Return (sError-".")
9222>>>>>    End_Function
9223>>>>>    
9223>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9225>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9225>>>>>        String sVdfRootDir
9225>>>>>        Handle hoIniFile
9225>>>>>        String sPath
9225>>>>>        String sFileName
9225>>>>>        String sWorkspacePath
9225>>>>>        
9225>>>>>        Move "" to sFileName
9226>>>>>        
9226>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9229>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9232>>>>>        
9232>>>>>        Get Create U_cIniFile to hoIniFile
9233>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9234>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9235>>>>>        If (sWorkspacePath <>"") Begin
9237>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9240>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9241>>>>>        End
9241>>>>>>
9241>>>>>        Send Destroy of hoIniFile
9242>>>>>        
9242>>>>>        Function_Return sFileName
9243>>>>>    End_Function
9244>>>>>    
9244>>>>>    Function CountOfPaths String sPaths Returns Integer
9246>>>>>        // Returns the number of paths defined in a string of paths
9246>>>>>        Integer iChar icChar icPath
9246>>>>>        
9246>>>>>        If (sPaths ="") ;            Function_Return 0
9249>>>>>        
9249>>>>>        Move (Length(sPaths) -1) to icChar
9250>>>>>        For iChar from 1 to icChar
9256>>>>>>
9256>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9259>>>>>        Loop
9260>>>>>>
9260>>>>>        
9260>>>>>        Function_Return (icPath +1)
9261>>>>>    End_Function
9262>>>>>    
9262>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9264>>>>>        // Returns the path at the 1-based index of passed paths.
9264>>>>>        // If the path contains a trailing "\", it will be removed
9264>>>>>        Integer iChar icPath iPath iPos
9264>>>>>        String sPath
9264>>>>>        
9264>>>>>        Move (sPaths +";") to sPaths
9265>>>>>        For iPath from 1 to iIndex
9271>>>>>>
9271>>>>>            Move (Pos(";", sPaths)) to iPos
9272>>>>>            If iPos Begin
9274>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9275>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9278>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9279>>>>>            End
9279>>>>>>
9279>>>>>            Else ;                Function_Return "" // index past number of paths
9281>>>>>        Loop
9282>>>>>>
9282>>>>>        
9282>>>>>        Function_Return sPath
9283>>>>>    End_Function
9284>>>>>    
9284>>>>>End_Class
9285>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCommandLine.pkg)
9285>>>>>Use VDFBase.pkg
9285>>>>>
9285>>>>>Class cCommandLine is a cObject
9286>>>>>    
9286>>>>>    Procedure Construct_Object
9288>>>>>        Forward Send Construct_Object
9290>>>>>        
9290>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9291>>>>>    End_Procedure
9292>>>>>    
9292>>>>>    Procedure Private_DoCreateArgsArray
9294>>>>>        // creates the array for holding the arguments. Created upon demand only!
9294>>>>>        Integer icArg
9294>>>>>        String sArg
9294>>>>>        
9294>>>>>        Object oArgs is an Array
9296>>>>>            Delegate Set phoArgs to Self
9298>>>>>            Repeat
9298>>>>>>
9298>>>>>                CmdLine sArg
9299>>>>>>
9299>>>>>                If (sArg <> "") Begin
9301>>>>>                    Increment icArg
9302>>>>>                    Set Value  (icArg -1) to sArg
9303>>>>>                End
9303>>>>>>
9303>>>>>            Until (sArg = "")
9305>>>>>        End_Object
9306>>>>>    End_Procedure
9307>>>>>    
9307>>>>>    Function CountOfArgs Returns Integer
9309>>>>>        //Returns the number of arguments passed
9309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9312>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9313>>>>>    End_Function
9314>>>>>    
9314>>>>>    Function Argument Integer iIndex Returns String
9316>>>>>        //Returns the one-based argument string
9316>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9319>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9320>>>>>    End_Function
9321>>>>>    
9321>>>>>End_Class
9322>>>>>
9322>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cRegistry.pkg)
9322>>>>>Use Dll.pkg
9322>>>>>Use RegistryAPI.pkg
9322>>>>>
9322>>>>>Enum_List // Registry Data types
9322>>>>>    Define rdString
9322>>>>>    Define rdDword
9322>>>>>    Define rdBinary
9322>>>>>    Define rdUnknown
9322>>>>>End_Enum_List
9322>>>>>
9322>>>>>
9322>>>>>Class cRegistry is a cObject
9323>>>>>    Procedure Construct_Object
9325>>>>>        Forward Send Construct_Object
9327>>>>>        
9327>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9328>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9329>>>>>        Property Handle phCurrentKey
9330>>>>>        Property Boolean pbLazyWrite True
9331>>>>>    End_Procedure
9332>>>>>    
9332>>>>>    Function CountOfSubkeys Returns Integer
9334>>>>>        Integer dwCountOfSubkeys
9334>>>>>        Integer iError
9334>>>>>        String sError
9334>>>>>        
9334>>>>>        Move 0 to dwCountOfSubkeys
9335>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9336>>>>>        If iError Begin
9338>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9339>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9340>>>>>>
9340>>>>>        End
9340>>>>>>
9340>>>>>        Function_Return dwCountOfSubkeys
9341>>>>>    End_Function
9342>>>>>    
9342>>>>>    Function CountOfValues Returns Integer
9344>>>>>        Integer dwCountOfValues
9344>>>>>        Integer iError
9344>>>>>        String sError
9344>>>>>        
9344>>>>>        Move 0 to dwCountOfValues
9345>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9346>>>>>        If iError Begin
9348>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9349>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9350>>>>>>
9350>>>>>        End
9350>>>>>>
9350>>>>>        
9350>>>>>        Function_Return dwCountOfValues
9351>>>>>    End_Function
9352>>>>>    
9352>>>>>    Function LongestSubkeyLength Returns Integer
9354>>>>>        Integer dwLongestSubkeyLength
9354>>>>>        Integer iError
9354>>>>>        String sError
9354>>>>>        
9354>>>>>        Move 0 to dwLongestSubkeyLength
9355>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9356>>>>>        If iError Begin
9358>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9359>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9360>>>>>>
9360>>>>>        End
9360>>>>>>
9360>>>>>        
9360>>>>>        Function_Return dwLongestSubkeyLength
9361>>>>>    End_Function
9362>>>>>    
9362>>>>>    Function LongestValueLength Returns Integer
9364>>>>>        Integer dwLongestValueLength
9364>>>>>        Integer iError
9364>>>>>        String sError
9364>>>>>        
9364>>>>>        Move 0 to dwLongestValueLength
9365>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9366>>>>>        If iError Begin
9368>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9369>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9370>>>>>>
9370>>>>>        End
9370>>>>>>
9370>>>>>        
9370>>>>>        Function_Return dwLongestValueLength
9371>>>>>    End_Function
9372>>>>>    
9372>>>>>    Function LongestDataLength Returns Integer
9374>>>>>        Integer dwLongestDataLength
9374>>>>>        Integer iError
9374>>>>>        String sError
9374>>>>>        
9374>>>>>        Move 0 to dwLongestDataLength
9375>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9376>>>>>        If iError Begin
9378>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9379>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9380>>>>>>
9380>>>>>        End
9380>>>>>>
9380>>>>>        
9380>>>>>        Function_Return dwLongestDataLength
9381>>>>>    End_Function
9382>>>>>    
9382>>>>>    Function ValueType String sValueName Returns Integer
9384>>>>>        Integer dwType
9384>>>>>        Integer iError eType
9384>>>>>        String sError
9384>>>>>        
9384>>>>>        Move 0 to dwType
9385>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9386>>>>>        If iError Begin
9388>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9389>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9390>>>>>>
9390>>>>>        End
9390>>>>>>
9390>>>>>        
9390>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9393>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9397>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9401>>>>>        Else ;            Move rdUnknown to eType
9403>>>>>        
9403>>>>>        Function_Return eType
9404>>>>>    End_Function
9405>>>>>    
9405>>>>>    Function ValueLength String sValueName Returns Integer
9407>>>>>        Integer dwSize
9407>>>>>        Integer iError
9407>>>>>        String sError
9407>>>>>        
9407>>>>>        Move 0 to dwSize
9408>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9409>>>>>        If iError Begin
9411>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9412>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9413>>>>>>
9413>>>>>        End
9413>>>>>>
9413>>>>>        
9413>>>>>        Function_Return dwSize
9414>>>>>    End_Function
9415>>>>>    
9415>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9417>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9417>>>>>        Handle hKey hKeyOpened
9417>>>>>        Integer iError
9417>>>>>        String sError
9417>>>>>        
9417>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9418>>>>>        
9418>>>>>        Get phRootKey to hKey
9419>>>>>        
9419>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9420>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9423>>>>>        Else Begin
9424>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9425>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9426>>>>>>
9426>>>>>        End
9426>>>>>>
9426>>>>>        Function_Return iError
9427>>>>>    End_Function
9428>>>>>    
9428>>>>>    Procedure CloseKey
9430>>>>>        Integer iError
9430>>>>>        Handle hKey
9430>>>>>        
9430>>>>>        Get phCurrentKey to hKey
9431>>>>>        
9431>>>>>        If (hKey <>0) Begin
9433>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9436>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9438>>>>>            
9438>>>>>            Set phCurrentKey to 0
9439>>>>>        End
9439>>>>>>
9439>>>>>    End_Procedure
9440>>>>>    
9440>>>>>    Function OpenKey String sKeyName Returns Boolean
9442>>>>>        Handle hKey hKeyOpened
9442>>>>>        Integer iError
9442>>>>>        
9442>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9443>>>>>        
9443>>>>>        Get phRootKey to hKey
9444>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9445>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9448>>>>>        
9448>>>>>        Function_Return (iError=0)
9449>>>>>    End_Function
9450>>>>>    
9450>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9452>>>>>        Handle hKey
9452>>>>>        Integer iError
9452>>>>>        Integer iData
9452>>>>>        String sError
9452>>>>>        
9452>>>>>        Move iValueData to iData
9453>>>>>        Get phCurrentKey to hKey
9454>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9455>>>>>        If iError Begin
9457>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9458>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9459>>>>>>
9459>>>>>        End
9459>>>>>>
9459>>>>>    End_Procedure
9460>>>>>    
9460>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9460>>>>>    Procedure WriteDword String sValue Integer iValueData
9462>>>>>        Send WriteInteger of Self sValue iValueData
9463>>>>>    End_Procedure
9464>>>>>    
9464>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9466>>>>>        Handle hKey
9466>>>>>        Integer iError
9466>>>>>        UInteger uData
9466>>>>>        String sError
9466>>>>>        
9466>>>>>        Move uValueData to uData
9467>>>>>        Get phCurrentKey to hKey
9468>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9469>>>>>        If iError Begin
9471>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9472>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9473>>>>>>
9473>>>>>        End
9473>>>>>>
9473>>>>>    End_Procedure
9474>>>>>
9474>>>>>    Procedure WriteString WString sValue WString wValueData
9476>>>>>        Handle hKey
9476>>>>>        Integer iError cbData
9476>>>>>        String sError
9476>>>>>        
9476>>>>>        If (wValueData = "") Begin
9478>>>>>            Move (Character(0)) to wValueData
9479>>>>>            Move 1 to cbData
9480>>>>>        End
9480>>>>>>
9480>>>>>        Else Begin
9481>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9482>>>>>        End
9482>>>>>>
9482>>>>>        Get phCurrentKey to hKey
9483>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9484>>>>>        If iError Begin
9486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9488>>>>>>
9488>>>>>        End
9488>>>>>>
9488>>>>>    End_Procedure
9489>>>>>    
9489>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9491>>>>>        Handle hKey
9491>>>>>        Integer iError
9491>>>>>        String sError
9491>>>>>        
9491>>>>>        Get phCurrentKey to hKey
9492>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9493>>>>>        If iError Begin
9495>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9496>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9497>>>>>>
9497>>>>>        End
9497>>>>>>
9497>>>>>    End_Procedure
9498>>>>>    
9498>>>>>    Function ReadInteger WString sValueName Returns Integer
9500>>>>>        Handle hKey
9500>>>>>        Integer iError
9500>>>>>        Integer iValueData iValueDataLength
9500>>>>>        String sError
9500>>>>>        
9500>>>>>        Move 0           to iValueData
9501>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9502>>>>>        
9502>>>>>        Get phCurrentKey to hKey
9503>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9504>>>>>        If iError Begin
9506>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9507>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9508>>>>>>
9508>>>>>        End
9508>>>>>>
9508>>>>>        
9508>>>>>        Function_Return iValueData
9509>>>>>    End_Function
9510>>>>>    
9510>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9510>>>>>    Function ReadDword String sValueName Returns Integer
9512>>>>>        Function_Return (ReadInteger(Self, sValueName))
9513>>>>>    End_Function
9514>>>>>
9514>>>>>    Function ReadUInt WString sValueName Returns UInteger
9516>>>>>        Handle hKey
9516>>>>>        Integer iError
9516>>>>>        UInteger uValueData uValueDataLength
9516>>>>>        String sError
9516>>>>>        
9516>>>>>        Move 0           to uValueData
9517>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9518>>>>>        
9518>>>>>        Get phCurrentKey to hKey
9519>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9520>>>>>        If iError Begin
9522>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9523>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9524>>>>>>
9524>>>>>        End
9524>>>>>>
9524>>>>>        
9524>>>>>        Function_Return uValueData
9525>>>>>    End_Function
9526>>>>>    
9526>>>>>    Function ReadString String sValueName Returns String
9528>>>>>        Handle hKey
9528>>>>>        Integer iError
9528>>>>>        WString wValueData
9528>>>>>        DWord dwValueDataLength dwType
9528>>>>>        Pointer lpsValueData
9528>>>>>        String sError
9528>>>>>        
9528>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9529>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9530>>>>>        
9530>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9531>>>>>        
9531>>>>>        Move REG_SZ to dwType
9532>>>>>        
9532>>>>>        Get phCurrentKey to hKey
9533>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9534>>>>>        If iError Begin
9536>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9537>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9538>>>>>>
9538>>>>>        End
9538>>>>>>
9538>>>>>        
9538>>>>>        Function_Return (CString(wValueData))
9539>>>>>    End_Function
9540>>>>>    
9540>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9542>>>>>        Handle hKey
9542>>>>>        Integer iError
9542>>>>>        String sError
9542>>>>>        
9542>>>>>        Get phCurrentKey to hKey
9543>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9544>>>>>        If iError Begin
9546>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9547>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9548>>>>>>
9548>>>>>        End
9548>>>>>>
9548>>>>>        
9548>>>>>        Function_Return (iDataLength >0)
9549>>>>>    End_Function
9550>>>>>    
9550>>>>>    
9550>>>>>    // Private....
9550>>>>>    Function GetBaseKey Returns Handle
9552>>>>>        Handle hBaseKey
9552>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9555>>>>>        Else ;            Get phCurrentKey to hBaseKey
9557>>>>>        
9557>>>>>        Function_Return hBaseKey
9558>>>>>    End_Function
9559>>>>>    
9559>>>>>    Function GetKey String sKeyName Returns Handle
9561>>>>>        Handle hKeyOpened
9561>>>>>        Integer iError
9561>>>>>        
9561>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9562>>>>>        
9562>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9563>>>>>        
9563>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9566>>>>>        Else ;            Function_Return 0
9568>>>>>    End_Function
9569>>>>>    
9569>>>>>    // Public
9569>>>>>    Function KeyExists String sKeyName Returns Boolean
9571>>>>>        Handle hKey
9571>>>>>        Integer iVoid
9571>>>>>        
9571>>>>>        Get GetKey sKeyName to hKey
9572>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9575>>>>>        Function_Return (hKey <>0)
9576>>>>>    End_Function
9577>>>>>    
9577>>>>>    Function ValueExists String sValueName Returns Boolean
9579>>>>>        // Determines whether a Value exists for the currently-opened Key.
9579>>>>>        Integer iError
9579>>>>>        DWord dwDataType
9579>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9580>>>>>        
9580>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9581>>>>>        
9581>>>>>        Function_Return (iError=0)
9582>>>>>    End_Function
9583>>>>>    
9583>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9585>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9586>>>>>    End_Function
9587>>>>>    
9587>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9589>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9590>>>>>    End_Function
9591>>>>>    
9591>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9593>>>>>        Integer iError
9593>>>>>        Integer icValue iLongestSubkey
9593>>>>>        Handle hKey
9593>>>>>        DWord dwSubkeyNameLength
9593>>>>>        WString wSubkeyName
9593>>>>>        tWinFileTime FileTime
9593>>>>>        tWinFileTime FileTime
9593>>>>>        
9593>>>>>        Get LongestSubkeyLength to iLongestSubkey
9594>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9595>>>>>        
9595>>>>>        Get phCurrentKey to hKey
9596>>>>>        Repeat
9596>>>>>>
9596>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9597>>>>>            
9597>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9598>>>>>            If (iError =0) Begin
9600>>>>>                Increment icValue
9601>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9602>>>>>            End
9602>>>>>>
9602>>>>>        Until (iError)
9604>>>>>        Function_Return icValue
9605>>>>>        
9605>>>>>    End_Function
9606>>>>>    
9606>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9608>>>>>        Integer iError
9608>>>>>        Integer icValue iLongestValue
9608>>>>>        Handle hKey
9608>>>>>        DWord dwValueNameLength
9608>>>>>        WString wValueName 
9608>>>>>        String sValueNameSize
9608>>>>>        Pointer lpsValueName
9608>>>>>        
9608>>>>>        Get LongestValueLength to iLongestValue
9609>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9610>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9611>>>>>        
9611>>>>>        Get phCurrentKey to hKey
9612>>>>>        Repeat
9612>>>>>>
9612>>>>>            Move (iLongestValue +1) to dwValueNameLength
9613>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9614>>>>>            If (iError =0) Begin
9616>>>>>                Increment icValue
9617>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9618>>>>>            End
9618>>>>>>
9618>>>>>        Until (iError)
9620>>>>>        Function_Return icValue
9621>>>>>        
9621>>>>>    End_Function
9622>>>>>    
9622>>>>>End_Class
9623>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cVersionInfo.pkg)
9623>>>>>Use VdfBase.pkg
9623>>>>>Use DLL.pkg
9623>>>>>Use tWinStructs.pkg
9623>>>>>Use WinKern.pkg
9623>>>>>
9623>>>>>Define VS_FF_DEBUG         for |CI$00000001
9623>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9623>>>>>Define VS_FF_PATCHED       for |CI$00000004
9623>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9623>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9623>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9623>>>>>
9623>>>>>// Note: String pointer lpFilename must refer to WString type.
9623>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9624>>>>>    
9624>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9624>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9626>>>>>    
9626>>>>>    DWord  dwResult
9626>>>>>    UWide  uwFileName
9626>>>>>    UWide  uwFileName
9626>>>>>
9626>>>>>    Send StringToWide aFilename (&uwFileName)
9627>>>>>    
9627>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9628>>>>>    Function_Return dwResult
9629>>>>>End_Function
9630>>>>>
9630>>>>>// Note: String pointers should be referring to WString items.
9630>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9631>>>>>    
9631>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9631>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9633>>>>>    
9633>>>>>    Integer iResult
9633>>>>>    UWide   uwFileName
9633>>>>>    UWide   uwFileName
9633>>>>>
9633>>>>>    Send StringToWide aFilename (&uwFileName)
9634>>>>>    
9634>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9635>>>>>    Function_Return iResult
9636>>>>>End_Function    
9637>>>>>
9637>>>>>// Note: String pointers should be referring to WString items.
9637>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9638>>>>>
9638>>>>>// Wrapper Function VerQueryValue (when using strings)
9638>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9640>>>>>    
9640>>>>>    Integer iResult
9640>>>>>    UWide   uwSubBlock
9640>>>>>    UWide   uwSubBlock
9640>>>>>    
9640>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9641>>>>>    
9641>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9642>>>>>    
9642>>>>>    Function_Return iResult
9643>>>>>End_Function
9644>>>>>
9644>>>>>
9644>>>>>Class cVersionInfo is a cObject
9645>>>>>    Procedure Construct_Object
9647>>>>>        Forward Send Construct_Object
9649>>>>>        
9649>>>>>        
9649>>>>>        Property Integer piVersionMajor
9650>>>>>        Property Integer piVersionMinor
9651>>>>>        Property Integer piVersionRelease
9652>>>>>        Property Integer piVersionBuild
9653>>>>>        
9653>>>>>        Property Boolean pbIncluded
9654>>>>>        Property Boolean pbSpecialBuild
9655>>>>>        Property Boolean pbPrivateBuild
9656>>>>>        
9656>>>>>    End_Procedure
9657>>>>>    
9657>>>>>    Procedure DoCreate WString sFileName
9659>>>>>        DWord dwHandle
9659>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9659>>>>>        WString sData
9659>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9659>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9659>>>>>        WString sSubBlock
9659>>>>>        Pointer pVsFixedFileInfo
9659>>>>>        
9659>>>>>        Move 0 to pVsFixedFileInfo
9660>>>>>        Move 0 to dwHandle
9661>>>>>        Move 0 to iVerSize
9662>>>>>        
9662>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9663>>>>>        Set pbIncluded to (iInfoSize <>0)
9664>>>>>        
9664>>>>>        If (pbIncluded(Self)) Begin
9666>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9667>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9668>>>>>            
9668>>>>>            If (iSuccess <>0) Begin
9670>>>>>                Move "\" to sSubBlock
9671>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9673>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9674>>>>>                    
9674>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9675>>>>>                    Set piVersionMajor to (Hi(iVersion))
9676>>>>>                    Set piVersionMinor to (Low(iVersion))
9677>>>>>                    
9677>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9678>>>>>                    Set piVersionRelease to (Hi(iVersion))
9679>>>>>                    Set piVersionBuild   to (Low(iVersion))
9680>>>>>                    
9680>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9681>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9682>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9683>>>>>                End
9683>>>>>>
9683>>>>>            End
9683>>>>>>
9683>>>>>            
9683>>>>>        End
9683>>>>>>
9683>>>>>    End_Procedure
9684>>>>>    
9684>>>>>End_Class
9685>>>Use GlobalFunctionsProcedures.pkg
9685>>>Use tWinStructs.pkg
9685>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9685>>>
9685>>>Register_Function phoWorkspace Returns Handle
9685>>>Register_Function phoCommandLine Returns Handle
9685>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9685>>>Register_Function GetApplicationName Returns String
9685>>>Register_Function GetApplicationFileName Returns String
9685>>>
9685>>>Register_Function Statusbar_State Returns Integer
9685>>>Register_Function Toolbar_State Returns Integer
9685>>>Register_Procedure Set Statusbar_State
9685>>>Register_Procedure Set Toolbar_State
9685>>>
9685>>>
9685>>>Class cApplication is a cObject
9686>>>    Procedure Construct_Object
9688>>>        Forward Send Construct_Object
9690>>>        
9690>>>        Move Self to ghoApplication
9691>>>        
9691>>>        Property Handle phoVersionInfo
9692>>>        Property Handle phoWorkspace
9693>>>        Property Handle phoCommandLine
9694>>>        Property Handle phoMainPanel       // main panel will set this for us.
9695>>>        Property String psHelpFile         // type of file is determined by peHelpType
9696>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9697>>>        
9697>>>        Property String psCompany "Data Access Worldwide"
9698>>>        Property String psProduct "DataFlex Applications"
9699>>>        Property String psVersion C_DFVersion
9700>>>        Property String psProgram (Module_Name(desktop))
9701>>>        
9701>>>        // set to '' to stop the auto open workspace behavior
9701>>>        Property String psAutoOpenWorkspace 'Config.ws'
9702>>>        
9702>>>        
9702>>>        Property Boolean pbPreserveEnvironment True
9703>>>        
9703>>>        Object oCommandLine is a cCommandLine
9705>>>            Delegate Set phoCommandLine to Self
9707>>>        End_Object
9708>>>        
9708>>>        Object oWorkspace is a cWorkspace
9710>>>            Delegate Set phoWorkspace to Self
9712>>>        End_Object
9713>>>        
9713>>>        Object oVersionInfo is a cVersionInfo
9715>>>            Delegate Set phoVersionInfo to Self
9717>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9718>>>        End_Object
9719>>>        
9719>>>        Set pbUseWindowsFont to True
9720>>>        
9720>>>    End_Procedure
9721>>>    
9721>>>    Procedure Destroy_Object
9723>>>        If (ghoApplication=Self) Begin
9725>>>            Move 0 to ghoApplication
9726>>>        End
9726>>>>
9726>>>        Forward Send Destroy_Object
9728>>>    End_Procedure
9729>>>    
9729>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9729>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9729>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9731>>>        Move bNext to gbKEnterNext
9732>>>    End_Procedure
9733>>>    
9733>>>    Function pbEnterKeyAsTabKey Returns Boolean
9735>>>        Function_Return gbKEnterNext
9736>>>    End_Function
9737>>>    
9737>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9739>>>// not used with webapp
9739>>>        Handle hoRegistry hoCommandBars
9739>>>        Handle hMonitor
9739>>>        Integer iError cxy
9739>>>        tWinWindowPlacement WindowPlacement
9739>>>        tWinWindowPlacement WindowPlacement
9739>>>        String sKey
9739>>>        Boolean bSuccess
9739>>>        String sObjectName
9739>>>        
9739>>>        If (pbPreserveEnvironment(Self)) Begin
9741>>>            Get Create U_cRegistry to hoRegistry
9742>>>            Set pfAccessRights of hoRegistry to KEY_READ
9743>>>            
9743>>>            Get RegistryKeyString to sKey
9744>>>            
9744>>>            If (bProgram = False) Begin
9746>>>                Move (sKey +"\WINDOWS") to sKey
9747>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9748>>>                Move (sKey +"\" +sObjectName) to sKey
9749>>>            End
9749>>>>
9749>>>            Else ;                Move (sKey + "\Preferences") to sKey
9751>>>            
9751>>>            Get OpenKey of hoRegistry sKey to bSuccess
9752>>>            
9752>>>            If bSuccess Begin
9754>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9756>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9757>>>                    If bSuccess Begin
9759>>>                        // Do not restore size if the window is not resizable
9759>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9761>>>                            // restore always works with outer size
9761>>>                            Get GuiWindowSize     of hoContainer to cxy
9762>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9763>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9764>>>                        End
9764>>>>
9764>>>                        
9764>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9764>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9764>>>                        If (bProgram) Begin
9766>>>                            // Test the top left point
9766>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9767>>>                            
9767>>>                            If (hMonitor = 0) Begin
9769>>>                                // test the bottom right point
9769>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9770>>>                            End
9770>>>>
9770>>>                            
9770>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9770>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9770>>>                            If (hMonitor = 0) Begin
9772>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9773>>>                            End
9773>>>>
9773>>>                        End
9773>>>>
9773>>>                        
9773>>>                        // Set the placement
9773>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9774>>>                    End
9774>>>>
9774>>>                End
9774>>>>
9774>>>                If bProgram Begin
9776>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9777>>>                    If not hoCommandBars Begin
9779>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9782>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9785>>>                    End
9785>>>>
9785>>>                End
9785>>>>
9785>>>                
9785>>>                Send CloseKey of hoRegistry
9786>>>            End
9786>>>>
9786>>>            
9786>>>            Send Destroy of hoRegistry
9787>>>        End
9787>>>>
9787>>>    End_Procedure
9788>>>    
9788>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9790>>>// not used with webapp
9790>>>        Handle hoRegistry
9790>>>        Integer iError
9790>>>        tWinWindowPlacement WindowPlacement
9790>>>        tWinWindowPlacement WindowPlacement
9790>>>        String sKey
9790>>>        Boolean bSuccess
9790>>>        Integer eShowCmd
9790>>>        String sObjectName
9790>>>        
9790>>>        If (pbPreserveEnvironment(Self)) Begin
9792>>>            Get Create U_cRegistry to hoRegistry
9793>>>            Get RegistryKeyString to sKey
9794>>>            
9794>>>            If (bProgram = False) Begin
9796>>>                Move (sKey +"\WINDOWS") to sKey
9797>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9798>>>                Move (sKey +"\" +sObjectName) to sKey
9799>>>            End
9799>>>>
9799>>>            Else ;                Move (sKey +"\Preferences") to sKey
9801>>>            
9801>>>            Get CreateKey of hoRegistry sKey to iError
9802>>>            If (iError = 0) Begin
9804>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9805>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9806>>>                If bSuccess Begin
9808>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9808>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9810>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9811>>>                    End
9811>>>>
9811>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9812>>>                End
9812>>>>
9812>>>                
9812>>>                If bProgram Begin
9814>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9815>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9816>>>                End
9816>>>>
9816>>>                
9816>>>                
9816>>>                Send CloseKey of hoRegistry
9817>>>            End
9817>>>>
9817>>>            
9817>>>            Send Destroy of hoRegistry
9818>>>        End
9818>>>>
9818>>>    End_Procedure
9819>>>    
9819>>>    
9819>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9821>>>        Integer ixySize ixSize iySize
9821>>>        Integer ixOffset iyOffset
9821>>>        
9821>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9821>>>        Move (0 - WindowPos.left) to ixOffset
9822>>>        Move (0 - WindowPos.top) to iyOffset
9823>>>        
9823>>>        Move 0 to WindowPos.left
9824>>>        Move 0 to WindowPos.top
9825>>>        
9825>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9826>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9827>>>        
9827>>>        // also make sure that the size of the window is <= the size of the main monitor
9827>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9828>>>        Move (low(ixySize))      to ixSize
9829>>>        Move (hi(ixySize))       to iySize
9830>>>        
9830>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9831>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9832>>>    End_Procedure
9833>>>    
9833>>>    
9833>>>    Function RegistryKeyString Returns String
9835>>>        String sCompany sProduct sVersion sProgram
9835>>>        
9835>>>        Get psCompany to sCompany
9836>>>        Get psProduct to sProduct
9837>>>        Get psVersion to sVersion
9838>>>        Get psProgram to sProgram
9839>>>        
9839>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9842>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9845>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
9848>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
9851>>>        
9851>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
9852>>>    End_Function
9853>>>    
9853>>>    Procedure WriteString String sSubKey String sValueName String sValueData
9855>>>        String sKey
9855>>>        Handle hoRegistry
9855>>>        Integer iError
9855>>>        
9855>>>        Get Create U_cRegistry to hoRegistry
9856>>>        Get RegistryKeyString to sKey
9857>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9860>>>        Get CreateKey of hoRegistry sKey to iError
9861>>>        If (iError = 0) Begin
9863>>>            Send WriteString of hoRegistry sValueName sValueData
9864>>>            Send CloseKey of hoRegistry
9865>>>        End
9865>>>>
9865>>>        
9865>>>        Send Destroy of hoRegistry
9866>>>    End_Procedure
9867>>>    
9867>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
9869>>>        String sKey
9869>>>        Handle hoRegistry
9869>>>        Integer iError
9869>>>        
9869>>>        Get Create U_cRegistry to hoRegistry
9870>>>        Get RegistryKeyString to sKey
9871>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9874>>>        Get CreateKey of hoRegistry sKey to iError
9875>>>        If (iError = 0) Begin
9877>>>            Send WriteInteger of hoRegistry sValueName iValueData
9878>>>            Send CloseKey of hoRegistry
9879>>>        End
9879>>>>
9879>>>        
9879>>>        Send Destroy of hoRegistry
9880>>>    End_Procedure
9881>>>    
9881>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9881>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
9883>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
9884>>>    End_Procedure
9885>>>    
9885>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
9887>>>        String sKey
9887>>>        Handle hoRegistry
9887>>>        Integer iError
9887>>>        
9887>>>        Get Create U_cRegistry to hoRegistry
9888>>>        Get RegistryKeyString to sKey
9889>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9892>>>        Get CreateKey of hoRegistry sKey to iError
9893>>>        If (iError = 0) Begin
9895>>>            Send WriteUInt of hoRegistry sValueName uValueData
9896>>>            Send CloseKey of hoRegistry
9897>>>        End
9897>>>>
9897>>>        
9897>>>        Send Destroy of hoRegistry
9898>>>    End_Procedure
9899>>>
9899>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
9901>>>        String sKey
9901>>>        Handle hoRegistry
9901>>>        Integer iError
9901>>>        
9901>>>        Get Create U_cRegistry to hoRegistry
9902>>>        Get RegistryKeyString to sKey
9903>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9906>>>        Get CreateKey of hoRegistry sKey to iError
9907>>>        If (iError = 0) Begin
9909>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
9910>>>            Send CloseKey of hoRegistry
9911>>>        End
9911>>>>
9911>>>        
9911>>>        Send Destroy of hoRegistry
9912>>>    End_Procedure
9913>>>    
9913>>>    // returns true if both sub-key and value exists.
9913>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
9915>>>        String sKey
9915>>>        Handle hoRegistry
9915>>>        Boolean bOK
9915>>>        Get Create U_cRegistry to hoRegistry
9916>>>        Get RegistryKeyString to sKey
9917>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9920>>>        Get OpenKey of hoRegistry sKey to bOk
9921>>>        If (bOK) Begin
9923>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
9924>>>            Send CloseKey of hoRegistry
9925>>>        End
9925>>>>
9925>>>        Send Destroy of hoRegistry
9926>>>        Function_Return bOk
9927>>>    End_Function
9928>>>    
9928>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
9930>>>        String sKey sData
9930>>>        Handle hoRegistry
9930>>>        Boolean bOK
9930>>>        
9930>>>        Move sDefault to sData
9931>>>        Get Create U_cRegistry to hoRegistry
9932>>>        Get RegistryKeyString to sKey
9933>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9936>>>        Get OpenKey of hoRegistry sKey to bOk
9937>>>        If (bOK) Begin
9939>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
9942>>>            Send CloseKey of hoRegistry
9943>>>        End
9943>>>>
9943>>>        
9943>>>        Send Destroy of hoRegistry
9944>>>        Function_Return sData
9945>>>    End_Function
9946>>>    
9946>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
9948>>>        String sKey
9948>>>        Integer iData
9948>>>        Handle hoRegistry
9948>>>        Boolean bOK
9948>>>        
9948>>>        Move iDefault to iData
9949>>>        Get Create U_cRegistry to hoRegistry
9950>>>        Get RegistryKeyString to sKey
9951>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9954>>>        Get OpenKey of hoRegistry sKey to bOk
9955>>>        If bOK Begin
9957>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
9960>>>            Send CloseKey of hoRegistry
9961>>>        End
9961>>>>
9961>>>        
9961>>>        Send Destroy of hoRegistry
9962>>>        Function_Return iData
9963>>>    End_Function
9964>>>
9964>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9964>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
9966>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
9967>>>    End_Function
9968>>>    
9968>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
9970>>>        String sKey
9970>>>        UInteger uData
9970>>>        Handle hoRegistry
9970>>>        Boolean bOK
9970>>>        
9970>>>        Move uDefault to uData
9971>>>        Get Create U_cRegistry to hoRegistry
9972>>>        Get RegistryKeyString to sKey
9973>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9976>>>        Get OpenKey of hoRegistry sKey to bOk
9977>>>        If bOK Begin
9979>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
9982>>>            Send CloseKey of hoRegistry
9983>>>        End
9983>>>>
9983>>>        
9983>>>        Send Destroy of hoRegistry
9984>>>        Function_Return uData
9985>>>    End_Function
9986>>>    
9986>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9988>>>        String sKey
9988>>>        Handle hoRegistry
9988>>>        Boolean bOK bSuccess
9988>>>        
9988>>>        Get Create U_cRegistry to hoRegistry
9989>>>        Get RegistryKeyString to sKey
9990>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9993>>>        Get OpenKey of hoRegistry sKey to bOk
9994>>>        If bOK Begin
9996>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
9997>>>            Send CloseKey of hoRegistry
9998>>>        End
9998>>>>
9998>>>        
9998>>>        Send Destroy of hoRegistry
9999>>>        Function_Return bSuccess
10000>>>    End_Function
10001>>>    
10001>>>    Procedure DoOpenWorkspace String sWorkspace
10003>>>        // Tries to open in this order:
10003>>>        // 1) if absolute path, use that; otherwise
10003>>>        // 2) try to open in the path of the EXE; otherwise
10003>>>        // 3) load it via the Registered list
10003>>>        
10003>>>        Integer eOpened
10003>>>        String sError sWSFile
10003>>>        Handle hoWorkspace
10003>>>        Boolean bChangingWorkspace
10003>>>        
10003>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10003>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10003>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10003>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10003>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10003>>>        // that there should be no automatic opening of a worskpace.
10003>>>        Set psAutoOpenWorkspace to ""
10004>>>        
10004>>>        Get phoWorkspace to hoWorkspace
10005>>>        
10005>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10006>>>        If (bChangingWorkspace and ghoConnection) Begin
10008>>>            Send AutoDisconnect
10009>>>        End
10009>>>>
10009>>>        
10009>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10010>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10012>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10014>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10015>>>            End
10015>>>>
10015>>>        End
10015>>>>
10015>>>        If (eOpened <> wsWorkspaceOpened) Begin
10017>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10018>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10019>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10020>>>>
10020>>>            Abort
10021>>>>
10021>>>        End
10021>>>>
10021>>>        Else Begin
10022>>>            Send AutoConnect
10023>>>            Send OnWorkspaceOpened
10024>>>        End
10024>>>>
10024>>>    End_Procedure
10025>>>    
10025>>>    Procedure AutoConnect
10027>>>        If (ghoConnection) Begin
10029>>>            Send AutoConnect of ghoConnection
10030>>>        End
10030>>>>
10030>>>    End_Procedure
10031>>>    
10031>>>    Procedure AutoDisconnect
10033>>>        If (ghoConnection) Begin
10035>>>            Send AutoDisconnect of ghoConnection
10036>>>        End
10036>>>>
10036>>>    End_Procedure
10037>>>    
10037>>>    // send after a workspace is successfully opened and connected
10037>>>    Procedure OnWorkspaceOpened
10039>>>    End_Procedure
10040>>>    
10040>>>    Procedure OnCreate
10042>>>        // Event called when the Application object is ready to be used
10042>>>        // to open a Workspace, etc.
10042>>>    End_Procedure
10043>>>    
10043>>>    Procedure End_Construct_Object
10045>>>        String sName
10045>>>        Forward Send End_Construct_Object
10047>>>        Send OnCreate
10048>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10048>>>        Get psAutoOpenWorkspace to sName
10049>>>        If (sName<>"") Begin
10051>>>            Send DoOpenWorkspace sName
10052>>>        End
10052>>>>
10052>>>    End_Procedure
10053>>>    
10053>>>    Function GetApplicationFileName Returns String
10055>>>        // Returns the filename from Windows
10055>>>        Integer iNumChars
10055>>>        WString wFilename
10055>>>                
10055>>>        Move (Repeat(Character(0), 1024)) to wFilename
10056>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10057>>>        
10057>>>        Function_Return (CString(wFilename))
10058>>>    End_Function
10059>>>    
10059>>>    Function GetApplicationPath Returns String
10061>>>        // Returns the path of the Application (no trailing "\")
10061>>>        WString wApplicationFileName 
10061>>>        String sPath
10061>>>        Boolean bRemoved
10061>>>        
10061>>>        Get GetApplicationFileName  to wApplicationFileName
10062>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10063>>>        Move (CString(wApplicationFileName)) to sPath
10064>>>        
10064>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10067>>>        Function_Return sPath
10068>>>    End_Function
10069>>>    
10069>>>    Function GetApplicationName Returns String
10071>>>        // Returns the name of the Application (without its Path or Extension)
10071>>>        String sApplicationFileName 
10071>>>        WString wApplicationName
10071>>>        Boolean bRemoved
10071>>>        Integer iVoid
10071>>>        
10071>>>        Get GetApplicationFileName to sApplicationFileName
10072>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10073>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10074>>>        Function_Return (CString(wApplicationName))
10075>>>    End_Function
10076>>>    
10076>>>    Function DFRootPath Returns String
10078>>>        String sRoot
10078>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10081>>>        // Ensure it does not contain a trailing "\"
10081>>>        If (Right(sRoot,1) = "\") Begin
10083>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10084>>>        End
10084>>>>
10084>>>        Function_Return sRoot
10085>>>    End_Function
10086>>>    
10086>>>    Function DFBinPath Returns String
10088>>>        String sRoot
10088>>>        Get DFRootPath to sRoot
10089>>>        If (sRoot<>"") Begin
10091>>>            Move (sRoot+"\bin") to sRoot
10092>>>        End
10092>>>>
10092>>>        Else Begin
10093>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10093>>>            // bin path must be the same as the application path.
10093>>>            Get GetApplicationPath to sRoot
10094>>>        End
10094>>>>
10094>>>        Function_Return sRoot
10095>>>    End_Function
10096>>>    
10096>>>    // this just directs to the desktop property. If you are using an application object you are
10096>>>    // encouraged to set this here.
10096>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10098>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10099>>>    End_Procedure
10100>>>    
10100>>>    Function pbUseWindowsFont Returns Boolean
10102>>>        Boolean bUseWindowsFont
10102>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10103>>>        Function_Return bUseWindowsFont
10104>>>    End_Function
10105>>>    
10105>>>    // this just directs to the desktop property. If you are using an application object you are
10105>>>    // encouraged to set this here.
10105>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10107>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10108>>>    End_Procedure
10109>>>    
10109>>>    Function pbLegacyDialogRatio Returns Boolean
10111>>>        Boolean bLegacy
10111>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10112>>>        Function_Return bLegacy
10113>>>    End_Function
10114>>>End_Class
10115>>>
10115>>>
10115>Use cConnection.pkg
Including file: cConnection.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cConnection.pkg)
10115>>>Use vdfbase.pkg // Windows.pkg
10115>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cli.pkg)
10115>>>>>//                                                              
10115>>>>>//   CLI specific functionality. There are several connectivity kits     
10115>>>>>//   based on  SQL/92 CLI. Those are:                                    
10115>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
10115>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
10115>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
10115>>>>>//                                                                       
10115>>>>>//   This package defines the common functionality for all CLI based     
10115>>>>>//   drivers.                                                            
10115>>>>>
10115>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
10115>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
10115>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
10115>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
10115>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
10115>>>>>Define DF_FILE_TABLE_NAME               for 609
10115>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
10115>>>>>Define DF_FILE_SQL_FILTER               for 611
10115>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
10115>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
10115>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
10115>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
10115>>>>>Define DF_FILE_DATABASE_ID              for 622
10115>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
10115>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
10115>>>>>Define DF_FILE_BLOCK_SIZE               for 628
10115>>>>>Define DF_FILE_JIT_BINDING              for 630
10115>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
10115>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
10115>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
10115>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
10115>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
10115>>>>>
10115>>>>>Define DF_FIELD_STORE_TIME              for 702
10115>>>>>Define DF_FIELD_TIME                    for 703
10115>>>>>Define DF_FIELD_IS_NULL                 for 704
10115>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
10115>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
10115>>>>>Define DF_FIELD_FETCH_STATE             for 708
10115>>>>>Define DF_FIELD_READ_ONLY               for 710
10115>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
10115>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
10115>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
10115>>>>>Define DF_SQL_RELATION_COLUMN           for 716
10115>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
10115>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
10115>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
10115>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
10115>>>>>Define DF_FIELD_IS_IDENTITY             for 722
10115>>>>>
10115>>>>>Define DF_INDEX_NAME                    for 801
10115>>>>>Define DF_INDEX_UNIQUE                  for 802
10115>>>>>Define DF_INDEX_ON_BACKEND              for 804
10115>>>>>
10115>>>>>Define DF_INDEX_CLUSTERED               for 806
10115>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
10115>>>>>Define DF_INDEX_SQL_TYPE                for 810
10115>>>>>Define DF_INDEX_NUMBER                  for 812
10115>>>>>
10115>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
10115>>>>>Define DF_DATABASE_ID                            for 1002
10115>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
10115>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
10115>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
10115>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
10115>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
10115>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
10115>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
10115>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
10115>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
10115>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
10115>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
10115>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
10115>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
10115>>>>>
10115>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
10115>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
10115>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
10115>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
10115>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
10115>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
10115>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
10115>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
10115>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
10115>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
10115>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
10115>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
10115>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
10115>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
10115>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
10115>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
10115>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
10115>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
10115>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
10115>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
10115>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
10115>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
10115>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
10115>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
10115>>>>>
10115>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
10115>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
10115>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
10115>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
10115>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
10115>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
10115>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
10115>>>>>
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
10115>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
10115>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
10115>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
10115>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
10115>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
10115>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
10115>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
10115>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
10115>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
10115>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
10115>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
10115>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
10115>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
10115>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
10115>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
10115>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
10115>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
10115>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
10115>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
10115>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
10115>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
10115>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
10115>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
10115>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
10115>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
10115>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
10115>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
10115>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
10115>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
10115>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
10115>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
10115>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
10115>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
10115>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
10115>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
10115>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
10115>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
10115>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
10115>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
10115>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
10115>>>>>
10115>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
10115>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
10115>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
10115>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
10115>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
10115>>>>>
10115>>>>>
10115>>>>>// Replacement for logical column number that indicates all columns
10115>>>>>Define DF_ALL_COLUMNS for -1
10115>>>>>
10115>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
10115>>>>>Define RIM_NONE            for 0
10115>>>>>Define RIM_IDENTITY_COLUMN for 1
10115>>>>>Define RIM_DISPENSER_TABLE for 2
10115>>>>>Define RIM_EXTERNAL        for 3
10115>>>>>
10115>>>>>// Possible DF_FIELD_READ_ONLY values
10115>>>>>Define RO_NO            for 0
10115>>>>>Define RO_IGNORECHANGE  for 1
10115>>>>>Define RO_ACCEPTCHANGE  for 2
10115>>>>>Define RO_ERRORONCHANGE for 3
10115>>>>>
10115>>>>>
10115>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
10115>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
10115>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
10115>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
10115>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
10115>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
10115>>>>>
10115>>>>>
10115>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
10115>>>>>
10115>>>>>// Possible SQL Column type values
10115>>>>>//      SQL Server specific types defined in mssqldrv.pkg
10115>>>>>//      DB2 specific typesm defined in db2_drv.pkg
10115>>>>>
10115>>>>>Define SQL_UNKNOWN_TYPE   for    0
10115>>>>>Define SQL_CHAR           for    1
10115>>>>>Define SQL_NUMERIC        for    2
10115>>>>>Define SQL_DECIMAL        for    3
10115>>>>>Define SQL_INTEGER        for    4
10115>>>>>Define SQL_SMALLINT       for    5
10115>>>>>Define SQL_FLOAT          for    6
10115>>>>>Define SQL_REAL           for    7
10115>>>>>Define SQL_DOUBLE         for    8
10115>>>>>Define SQL_DATETIME       for    9
10115>>>>>Define SQL_VARCHAR        for   12
10115>>>>>Define SQL_TYPE_DATE      for   91
10115>>>>>Define SQL_TYPE_TIME      for   92
10115>>>>>Define SQL_TYPE_TIMESTAMP for   93
10115>>>>>
10115>>>>>Define SQL_DATE           for    9
10115>>>>>Define SQL_INTERVAL       for   10
10115>>>>>Define SQL_TIME           for   10
10115>>>>>Define SQL_TIMESTAMP      for   11
10115>>>>>Define SQL_LONGVARCHAR    for  (-1)
10115>>>>>Define SQL_BINARY         for  (-2)
10115>>>>>Define SQL_VARBINARY      for  (-3)
10115>>>>>Define SQL_LONGVARBINARY  for  (-4)
10115>>>>>Define SQL_BIGINT         for  (-5)
10115>>>>>Define SQL_TINYINT        for  (-6)
10115>>>>>Define SQL_BIT            for  (-7)
10115>>>>>Define SQL_WCHAR          for  (-8)
10115>>>>>Define SQL_WVARCHAR       for  (-9)
10115>>>>>Define SQL_WLONGVARCHAR   for (-10)
10115>>>>>Define SQL_GUID           for (-11)
10115>>>>>
10115>>>>>// Possible DF_INDEX_SQL_TYPE values
10115>>>>>Define DF_INDEX_CLIENT      for  1
10115>>>>>Define DF_INDEX_SERVER      for  2
10115>>>>>Define DF_INDEX_SERVER_ONLY for  3
10115>>>>>Define DF_INDEX_TEMPORARY   for  4
10115>>>>>
10115>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
10115>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
10115>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
10115>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
10115>>>>>
10115>>>>>// Driver level attributes
10115>>>>>Define DRVR_TOKEN_BASE                       for 1000
10115>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
10115>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
10115>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
10115>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
10115>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
10115>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
10115>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
10115>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
10115>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
10115>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
10115>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
10115>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
10115>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
10115>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
10115>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
10115>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
10115>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
10115>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
10115>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
10115>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
10115>>>>>
10115>>>>>
10115>>>>>// Error Number constants
10115>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
10115>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
10115>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
10115>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
10115>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
10115>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
10115>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
10115>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
10115>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
10115>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
10115>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
10115>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
10115>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
10115>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
10115>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
10115>>>>>Define CLIERR_SQL_ERROR                           for 12304
10115>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
10115>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
10115>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
10115>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
10115>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
10115>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
10115>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
10115>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
10115>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
10115>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
10115>>>>>Define CLIERR_FIELDREADONLY                       for 12315
10115>>>>>Define CLIERR_DBPROPERROR                         for 12316
10115>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
10115>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
10115>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
10115>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
10115>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
10115>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
10115>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
10115>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
10115>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
10115>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
10115>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
10115>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
10115>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
10115>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
10115>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
10115>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
10115>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
10115>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
10115>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
10115>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
10115>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
10115>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
10115>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
10115>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
10115>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
10115>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
10115>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
10115>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
10115>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
10115>>>>>
10115>>>>>
10115>>>>>// Call driver Function identifiers
10115>>>>>Define CLI_CONSTRAINT             for 10000
10115>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
10115>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
10115>>>>>Define CLI_BROWSECONNECT          for 10003
10115>>>>>Define CLI_DATASOURCES            for 10004
10115>>>>>Define CLI_CKREVISION             for 10005
10115>>>>>Define CLI_INITDATASOURCES        for 10006
10115>>>>>Define CLI_ENUMERATE_TABLES       for 10007
10115>>>>>Define CLI_TABLENAME              for 10008
10115>>>>>Define CLI_TABLESCHEMA            for 10009
10115>>>>>Define CLI_TABLETYPE              for 10010
10115>>>>>Define CLI_TABLECOMMENT           for 10011
10115>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
10115>>>>>Define CLI_COLUMNNAME             for 10013
10115>>>>>Define CLI_DUMPSTATUS             for 10014
10115>>>>>Define CLI_READCONFIGURATION      for 10015
10115>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
10115>>>>>Define CLI_GETDBATTRIBUTE         for 10017
10115>>>>>Define CLI_GETREGNAME             for 10018
10115>>>>>Define CLI_GETSERIALNUM           for 10019
10115>>>>>Define CLI_GETMAXUSERS            for 10020
10115>>>>>Define CLI_BCP                    for 10021
10115>>>>>Define CLI_DROPINDICES            for 10022
10115>>>>>Define CLI_CREATEINDICES          for 10023
10115>>>>>Define CLI_REDIRECTCONNECTION     for 10024
10115>>>>>Define CLI_CREATECONNECTIONID     for 10025
10115>>>>>Define CLI_DELETECONNECTIONID     for 10026
10115>>>>>
10115>>>>>
10115>>>>>// Init data source types
10115>>>>>Define SQL_FETCH_ALL     for  2
10115>>>>>Define SQL_FETCH_USER    for 31
10115>>>>>Define SQL_FETCH_SYSTEM  for 32
10115>>>>>
10115>>>>>
10115>>>>>// Dummy strings used in the commands
10115>>>>>String  CLI$StrDummy 255
10115>>>>>Integer CLI$IntDummy
10115>>>>>
10115>>>>>
10115>>>>>//   Setup a constraint for a file.                                    
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>// Set or get an attribute at driver level. These attributes, when set,
10115>>>>>// will be set for the remainder of the session or until set again. To 
10115>>>>>// permanently set driver level attributes change the driver           
10115>>>>>// configuration file.                                                 
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>// An instance of this class can be used as a broker object to
10115>>>>>// call several CLI releated methods.                         
10115>>>>>
10115>>>>>//Class cCLIHandler is a cObject
10115>>>>>Class cCLIHandler is an Array
10116>>>>>    
10116>>>>>    Procedure Construct_Object 
10118>>>>>        Forward Send Construct_object 
10120>>>>>        
10120>>>>>        Property String  psDriverID        ""
10121>>>>>    End_Procedure
10122>>>>>    
10122>>>>>    
10122>>>>>    
10122>>>>>    // The revsion of a CLI Connectivity Kit
10122>>>>>    Function CKRevision Returns String
10124>>>>>        String  sDriverID
10124>>>>>        String  sRevision
10124>>>>>        String  sVoid
10124>>>>>        Integer iRetval
10124>>>>>        
10124>>>>>        Get psDriverID to sDriverID
10125>>>>>        If (sDRiverID <> "") Begin
10127>>>>>            Move (Repeat(" ", 255)) to sRevision
10128>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
10133>>>>>        End
10133>>>>>>
10133>>>>>        
10133>>>>>        Function_Return sRevision
10134>>>>>    End_Function
10135>>>>>    
10135>>>>>    
10135>>>>>    
10135>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
10135>>>>>    // Returns : The part version number or -1 if there is no such part number.
10135>>>>>    //
10135>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
10137>>>>>        Integer iPartRev
10137>>>>>        Integer iCurrentPart
10137>>>>>        Integer iSeparatorPos
10137>>>>>        
10137>>>>>        If (iPartNum > 4) ;            Function_Return -1
10140>>>>>        
10140>>>>>        Move 0 to iCurrentPart
10141>>>>>        Repeat
10141>>>>>>
10141>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
10142>>>>>            If (iSeparatorPos > 0) Begin
10144>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
10145>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
10146>>>>>                Increment iCurrentPart
10147>>>>>            End
10147>>>>>>
10147>>>>>            Else If (sRevision <> "") Begin
10150>>>>>                Move sRevision to iPartRev
10151>>>>>                Move "" to sRevision
10152>>>>>                Increment iCurrentPart
10153>>>>>            End
10153>>>>>>
10153>>>>>            Else ;                Move -1 to iPartRev
10155>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
10157>>>>>        
10157>>>>>        Function_Return iPartRev
10158>>>>>    End_Function
10159>>>>>    
10159>>>>>    
10159>>>>>    
10159>>>>>    // Returns the major revision of the CK
10159>>>>>    //
10159>>>>>    Function CKMajorRevision Returns Integer
10161>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
10162>>>>>    End_Function
10163>>>>>    
10163>>>>>    
10163>>>>>    
10163>>>>>    // Returns the minor revision of the CK
10163>>>>>    //
10163>>>>>    Function CKMinorRevision Returns Integer
10165>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
10166>>>>>    End_Function
10167>>>>>    
10167>>>>>    
10167>>>>>    
10167>>>>>    // Returns the release revision of the CK
10167>>>>>    //
10167>>>>>    Function CKReleaseRevision Returns Integer
10169>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
10170>>>>>    End_Function
10171>>>>>    
10171>>>>>    
10171>>>>>    
10171>>>>>    // Returns the major revision of the CK
10171>>>>>    //
10171>>>>>    Function CKBuildRevision Returns Integer
10173>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
10174>>>>>    End_Function
10175>>>>>    
10175>>>>>    
10175>>>>>    
10175>>>>>    // Determines if the CK conforms to a passed minimal revsion.
10175>>>>>    //
10175>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
10177>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
10180>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
10183>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
10186>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
10189>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
10192>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
10196>>>>>            End
10196>>>>>>
10196>>>>>        End
10196>>>>>>
10196>>>>>        
10196>>>>>        Function_Return (False)
10197>>>>>    End_Function
10198>>>>>    
10198>>>>>    
10198>>>>>    
10198>>>>>    // Returns the Connectiivty Kit registration name.
10198>>>>>    //
10198>>>>>    Function RegistrationName Returns String
10200>>>>>        String  sRegistration
10200>>>>>        String  sDRiverId
10200>>>>>        String  sVoid
10200>>>>>        Integer iRetval
10200>>>>>        
10200>>>>>        Get psDriverID to sDriverID
10201>>>>>        If (sDRiverID <> "") Begin
10203>>>>>            Move (Repeat(" ", 255)) to sRegistration
10204>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
10209>>>>>        End
10209>>>>>>
10209>>>>>        
10209>>>>>        Function_Return sRegistration
10210>>>>>    End_Function
10211>>>>>    
10211>>>>>    // Returns the Connectiivty Kit serial number.
10211>>>>>    //
10211>>>>>    Function SerialNumber Returns Integer
10213>>>>>        String  sDRiverId
10213>>>>>        String  sVoid
10213>>>>>        Integer iRetval
10213>>>>>        
10213>>>>>        Get psDriverID to sDriverID
10214>>>>>        If (sDRiverID <> "") Begin
10216>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
10221>>>>>        End
10221>>>>>>
10221>>>>>        
10221>>>>>        Function_Return iRetval
10222>>>>>    End_Function
10223>>>>>    
10223>>>>>    
10223>>>>>    // Returns the Connectiivty Kit maximum number of users.
10223>>>>>    //
10223>>>>>    Function MaxUsers Returns Integer
10225>>>>>        String  sDRiverId
10225>>>>>        String  sVoid
10225>>>>>        Integer iRetval
10225>>>>>        
10225>>>>>        Get psDriverID to sDriverID
10226>>>>>        If (sDRiverID <> "") Begin
10228>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
10233>>>>>        End
10233>>>>>>
10233>>>>>        
10233>>>>>        Function_Return iRetval
10234>>>>>    End_Function
10235>>>>>    
10235>>>>>    
10235>>>>>    
10235>>>>>    // Dump the current status of the drver in the passed disk file.
10235>>>>>    //
10235>>>>>    Procedure DumpStatus String sFileName
10237>>>>>        String  sVoid
10237>>>>>        String  sDriverID
10237>>>>>        Integer iVoid
10237>>>>>        
10237>>>>>        Get psDriverID to sDriverID
10238>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
10245>>>>>    End_Procedure
10246>>>>>    
10246>>>>>    
10246>>>>>    
10246>>>>>    // Reset all driver level configurable attributes to the
10246>>>>>    // default value and then reread the configuration.
10246>>>>>    //
10246>>>>>    Procedure ReadConfiguration
10248>>>>>        String  sVoid
10248>>>>>        String  sDriverID
10248>>>>>        Integer iVoid
10248>>>>>        
10248>>>>>        Get psDriverID to sDriverID
10249>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
10256>>>>>    End_Procedure
10257>>>>>    
10257>>>>>    
10257>>>>>    
10257>>>>>    // Convert a text to the corresponding
10257>>>>>    // Generate_Record_ID_Method attribute value
10257>>>>>    //
10257>>>>>    Function TextToRIMValue String sText Returns Integer
10259>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
10262>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
10266>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
10270>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
10274>>>>>    End_Function
10275>>>>>    
10275>>>>>    
10275>>>>>    
10275>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10275>>>>>    // corresponding text.
10275>>>>>    //
10275>>>>>    Function RIMValueToText Integer iAttrValue Returns String
10277>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
10280>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
10284>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
10288>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
10292>>>>>    End_Function
10293>>>>>    
10293>>>>>    
10293>>>>>    
10293>>>>>    // Convert a text to the corresponding
10293>>>>>    // Generate_Record_ID_Method attribute value
10293>>>>>    //
10293>>>>>    Function TextToROValue String sText Returns Integer
10295>>>>>        If (sText = "No") ;            Function_Return RO_NO
10298>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
10302>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
10306>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
10310>>>>>    End_Function
10311>>>>>    
10311>>>>>    
10311>>>>>    
10311>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10311>>>>>    // corresponding text.
10311>>>>>    //
10311>>>>>    Function ROValueToText Integer iAttrValue Returns String
10313>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
10316>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
10320>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
10324>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
10328>>>>>    End_Function
10329>>>>>    
10329>>>>>    
10329>>>>>    
10329>>>>>    // Return the text f the last error geneated by the driver.
10329>>>>>    //
10329>>>>>    Function LastDriverError Returns String
10331>>>>>        String  sDriverID
10331>>>>>        String  sLastError
10331>>>>>        String  sLastErrorLength
10331>>>>>        Integer iLastErrorLength
10331>>>>>        Integer iVoid
10331>>>>>        
10331>>>>>        // Initialize
10331>>>>>        Move "" to sLastError
10332>>>>>        
10332>>>>>        Get psDriverID to sDriverID
10333>>>>>        If (sDriverID <> "") Begin
10335>>>>>            // Get the text of the last error
10335>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
10336>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
10341>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
10342>>>>>            
10342>>>>>            If (iLastErrorLength > 0) Begin
10344>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
10345>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
10350>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
10351>>>>>            End
10351>>>>>>
10351>>>>>        End
10351>>>>>>
10351>>>>>        
10351>>>>>        Function_Return sLastError
10352>>>>>    End_Function
10353>>>>>    
10353>>>>>    
10353>>>>>    
10353>>>>>    // Enumerate the tables in a database
10353>>>>>    //
10353>>>>>    Function EnumerateTables String sLogin Returns Integer
10355>>>>>        String  sDriver
10355>>>>>        String  sVoid
10355>>>>>        Integer iNumTables
10355>>>>>        Integer iVoid
10355>>>>>        
10355>>>>>        Get psDriverID to sDriver
10356>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
10363>>>>>        
10363>>>>>        Function_Return iNumTables
10364>>>>>    End_Function
10365>>>>>    
10365>>>>>    
10365>>>>>    
10365>>>>>    // Returns the name of the table enumerated at the given position
10365>>>>>    //
10365>>>>>    Function TableName Integer iIndex Returns String
10367>>>>>        String  sDriver
10367>>>>>        String  sTableName
10367>>>>>        String  sVoid
10367>>>>>        Integer iVoid
10367>>>>>        
10367>>>>>        Get psDriverID to sDriver
10368>>>>>        If (sDriver <> "") Begin
10370>>>>>            Move (Repeat(" ", 255)) to sTableName
10371>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
10376>>>>>        End
10376>>>>>>
10376>>>>>        
10376>>>>>        Function_Return sTableName
10377>>>>>    End_Function
10378>>>>>    
10378>>>>>    
10378>>>>>    
10378>>>>>    // Returns the name of the schema of the table enumerated at the given position
10378>>>>>    //
10378>>>>>    Function SchemaName Integer iIndex Returns String
10380>>>>>        String  sDriver
10380>>>>>        String  sSchemaName
10380>>>>>        String  sVoid
10380>>>>>        Integer iVoid
10380>>>>>        
10380>>>>>        Get psDriverID to sDriver
10381>>>>>        If (sDriver <> "") Begin
10383>>>>>            Move (Repeat(" ", 255)) to sSchemaName
10384>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
10389>>>>>        End
10389>>>>>>
10389>>>>>        
10389>>>>>        Function_Return sSchemaName
10390>>>>>    End_Function
10391>>>>>    
10391>>>>>    // Returns the type of the table enumerated at the given position.
10391>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
10391>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
10391>>>>>    Function TableType Integer iIndex Returns String
10393>>>>>        String  sDriver
10393>>>>>        String  sTableType
10393>>>>>        String  sVoid
10393>>>>>        Integer iVoid
10393>>>>>        
10393>>>>>        Get psDriverID to sDriver
10394>>>>>        If (sDriver <> "") Begin
10396>>>>>            Move (Repeat(" ", 25)) to sTableType
10397>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
10402>>>>>        End
10402>>>>>>
10402>>>>>        
10402>>>>>        Function_Return sTableType
10403>>>>>    End_Function
10404>>>>>    
10404>>>>>    
10404>>>>>    // Returns the comment of the table enumerated at the given position
10404>>>>>    //
10404>>>>>    Function TableComment Integer iIndex Returns String
10406>>>>>        String  sDriver
10406>>>>>        String  sTableComment
10406>>>>>        String  sVoid
10406>>>>>        Integer iVoid
10406>>>>>        
10406>>>>>        Get psDriverID to sDriver
10407>>>>>        If (sDriver <> "") Begin
10409>>>>>            Move (Repeat(" ", 1024)) to sTableComment
10410>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
10415>>>>>        End
10415>>>>>>
10415>>>>>        
10415>>>>>        Function_Return sTableComment
10416>>>>>    End_Function
10417>>>>>    
10417>>>>>    // Enumerate the columns in a table
10417>>>>>    //
10417>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
10419>>>>>        String  sDriver
10419>>>>>        Integer iNumColumns
10419>>>>>        Integer iVoid
10419>>>>>        
10419>>>>>        Get psDriverID to sDriver
10420>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
10427>>>>>        
10427>>>>>        Function_Return iNumColumns
10428>>>>>    End_Function
10429>>>>>    
10429>>>>>    
10429>>>>>    
10429>>>>>    // Returns the name of the column enumerated at the given position
10429>>>>>    //
10429>>>>>    Function ColumnName Integer iIndex Returns String
10431>>>>>        String  sDriver
10431>>>>>        String  sColumnName
10431>>>>>        String  sVoid
10431>>>>>        Integer iVoid
10431>>>>>        
10431>>>>>        Get psDriverID to sDriver
10432>>>>>        If (sDriver <> "") Begin
10434>>>>>            Move (Repeat(" ", 255)) to sColumnName
10435>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
10440>>>>>        End
10440>>>>>>
10440>>>>>        
10440>>>>>        Function_Return sColumnName
10441>>>>>    End_Function
10442>>>>>    
10442>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
10442>>>>>    //
10442>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
10444>>>>>        
10444>>>>>        Integer iDriverIndex
10444>>>>>        
10444>>>>>        String sSQLDate
10444>>>>>        Integer iOrgDateFmt
10444>>>>>        Integer iOrgDateSep
10444>>>>>        
10444>>>>>        // Change date format to military, SQL dates are military dates
10444>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10447>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10450>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10453>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10456>>>>>        
10456>>>>>        If (Integer(dDFDate = 0)) Begin
10458>>>>>            // Return the dummy zero date
10458>>>>>            Get DriverIndex sDriver to iDriverIndex
10459>>>>>            If (iDriverIndex <> 0) Begin
10461>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
10464>>>>>            End
10464>>>>>>
10464>>>>>            Else Begin
10465>>>>>                Move '0001-01-01' to sSQLDate
10466>>>>>            End
10466>>>>>>
10466>>>>>        End
10466>>>>>>
10466>>>>>        Else Begin
10467>>>>>            Move dDFDate to sSQLDate
10468>>>>>        End
10468>>>>>>
10468>>>>>        
10468>>>>>        // Change date format back to original
10468>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10471>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10474>>>>>        
10474>>>>>        Function_Return sSQLDate
10475>>>>>    End_Function
10476>>>>>    
10476>>>>>    
10476>>>>>    
10476>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
10476>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
10478>>>>>        
10478>>>>>        Integer iDriverIndex
10478>>>>>        
10478>>>>>        Date dDFDate
10478>>>>>        String sDummyDateValue
10478>>>>>        Integer iOrgDateFmt
10478>>>>>        Integer iOrgDateSep
10478>>>>>        
10478>>>>>        // Change date format to military, SQL dates are military dates
10478>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10481>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10484>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10487>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10490>>>>>        
10490>>>>>        // We only need to convert if the date is the dummy zero date value
10490>>>>>        Get DriverIndex sDriver to iDriverIndex
10491>>>>>        If (iDriverIndex <> 0) Begin
10493>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
10496>>>>>        End
10496>>>>>>
10496>>>>>        Else Begin
10497>>>>>            Move '0001-01-01' to sDummyDateValue
10498>>>>>        End
10498>>>>>>
10498>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
10501>>>>>        Else ;            Move sSQLDate to dDFDate
10503>>>>>        
10503>>>>>        // Change date format back to original
10503>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10506>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10509>>>>>        
10509>>>>>        Function_Return dDFDate
10510>>>>>    End_Function
10511>>>>>    
10511>>>>>    Function DriverIndex String sDriver Returns Integer
10513>>>>>        
10513>>>>>        String  sCurrentDriver
10513>>>>>        Integer iNumberOfDrivers iDriver iCount
10513>>>>>        
10513>>>>>        Move 0 to iDriver
10514>>>>>        
10514>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
10517>>>>>        For iCount from 1 to iNumberOfDrivers
10523>>>>>>
10523>>>>>            
10523>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
10526>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
10528>>>>>                Move iCount to iDriver
10529>>>>>            End
10529>>>>>>
10529>>>>>        Loop
10530>>>>>>
10530>>>>>        
10530>>>>>        Function_Return iDriver
10531>>>>>        
10531>>>>>    End_Function
10532>>>>>    
10532>>>>>    
10532>>>>>    // Redirect an exisitng connection. The existing connection
10532>>>>>    // will point to another database but all tables will stay
10532>>>>>    // open!
10532>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
10534>>>>>        String  sDriver
10534>>>>>        String  sVoid
10534>>>>>        Integer iResult
10534>>>>>        Integer iVoid
10534>>>>>        
10534>>>>>        Get psDriverID to sDriver
10535>>>>>        If (sDriver <> "") Begin
10537>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
10542>>>>>        End
10542>>>>>>
10542>>>>>        Function_Return iResult
10543>>>>>    End_Function
10544>>>>>    
10544>>>>>    // Redirect a connection of a connection ID
10544>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
10544>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
10544>>>>>    //
10544>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
10544>>>>>    // to the new connection (Server/Database specified in sConnectString)
10544>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
10544>>>>>    //
10544>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
10544>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
10544>>>>>    //
10544>>>>>    // Returns:
10544>>>>>    //     0 when the redirection was successful.
10544>>>>>    //     1 if the connection ID does not exist or can not be found.
10544>>>>>    //     2 login into the new connection failed.
10544>>>>>    //
10544>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
10546>>>>>        String  sDriver
10546>>>>>        String  sVoid
10546>>>>>        Integer iResult
10546>>>>>        
10546>>>>>        Integer iOption
10546>>>>>        
10546>>>>>        // iOption
10546>>>>>        // 0 = RedirectConnection
10546>>>>>        // 1 = RedirectIdConnectString
10546>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
10546>>>>>        If (bKeepLoggedIn) Begin
10548>>>>>            Move 2 to iOption
10549>>>>>        End
10549>>>>>>
10549>>>>>        Else Begin
10550>>>>>            Move 1 to iOption
10551>>>>>        End
10551>>>>>>
10551>>>>>        
10551>>>>>        Get psDriverID to sDriver
10552>>>>>        If (sDriver <> "") Begin
10554>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
10559>>>>>        End
10559>>>>>>
10559>>>>>        Function_Return iResult
10560>>>>>    End_Function
10561>>>>>    
10561>>>>>    
10561>>>>>    // Create a DataFlex side connection id that can be used later on.
10561>>>>>    //
10561>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
10563>>>>>        String  sDriver
10563>>>>>        Integer iResult
10563>>>>>        Integer iOptions
10563>>>>>        
10563>>>>>        Get psDriverID to sDriver
10564>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
10567>>>>>        Else ;            Move iOpt to iOptions
10569>>>>>        If (sDriver <> "") Begin
10571>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
10576>>>>>        End
10576>>>>>>
10576>>>>>        Function_Return iResult
10577>>>>>    End_Function
10578>>>>>    
10578>>>>>    
10578>>>>>    
10578>>>>>    // Delete a DataFlex side connection id.
10578>>>>>    //
10578>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
10580>>>>>        String  sDriver
10580>>>>>        Integer iResult
10580>>>>>        String sVoid
10580>>>>>        
10580>>>>>        Get psDriverID to sDriver
10581>>>>>        If (sDriver <> "") Begin
10583>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
10588>>>>>        End
10588>>>>>>
10588>>>>>        Function_Return iResult
10589>>>>>    End_Function
10590>>>>>    
10590>>>>>End_Class
10591>>>
10591>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dferror.pkg)
10591>>>>>Use LanguageText.pkg
10591>>>>>Use Windows.pkg
10591>>>>>Use msgbox.pkg
10591>>>>>Use GlobalFunctionsProcedures.pkg
10591>>>>>
10591>>>>>// Include or define all useful symbols.
10591>>>>>Use errornum.inc
10591>>>>>// these are kept for compatibility. Don't use them
10591>>>>>
10591>>>>>// used by error handler and UserError to pull a caption out of the error string
10591>>>>>Define C_ErrorCaption for "*CAPTION*="
10591>>>>>
10591>>>>>// This array stores the set of trapped errors as toggled ranges starting
10591>>>>>// with the errors that are trapped. The array should always contain 0 and
10591>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10591>>>>>// following items...
10591>>>>>//
10591>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10591>>>>>//
10591>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10591>>>>>// 10 through the rest are trapped.
10591>>>>>//
10591>>>>>Class Trapped_Errors_Array is an array
10592>>>>>    
10592>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10592>>>>>    Function findErrorLE Integer targetError Returns Integer
10594>>>>>        
10594>>>>>        Integer lowIndex hiIndex midIndex currError
10594>>>>>        
10594>>>>>        // If error is outside of boudary conditions, use
10594>>>>>        // value of closest valid error# instead.
10594>>>>>        If (targetError <= 0);            Move 1 to targetError
10597>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10601>>>>>        
10601>>>>>        Move 0 to lowIndex
10602>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10603>>>>>        
10603>>>>>        // midIndex will contain the closest error LE to target upon exit.
10603>>>>>        Repeat
10603>>>>>>
10603>>>>>            
10603>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10604>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10605>>>>>            
10605>>>>>            // midIndex is targetIndex if a match occurs
10605>>>>>            If (currError = targetError) ;                Function_Return midIndex
10608>>>>>            
10608>>>>>            // We are either on it or just below it.
10608>>>>>            If ( lowIndex = midIndex ) Begin
10610>>>>>                
10610>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10613>>>>>                
10613>>>>>                Function_Return midIndex
10614>>>>>                
10614>>>>>            End
10614>>>>>>
10614>>>>>            
10614>>>>>            // No match, so move the boundaries.
10614>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10617>>>>>            Else ;                Move midIndex to lowIndex
10619>>>>>            
10619>>>>>        Until lowIndex gt hiIndex
10621>>>>>        
10621>>>>>        Function_Return midIndex
10622>>>>>        
10622>>>>>    End_Function
10623>>>>>    
10623>>>>>    // Boundaries of the table are assumed to hold error limits.
10623>>>>>    Procedure initArray
10625>>>>>        Send delete_data
10626>>>>>        Set array_value 0 to 0
10627>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
10628>>>>>    End_Procedure
10629>>>>>    
10629>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10629>>>>>    Function IsTrapped Integer Error# Returns Integer
10631>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10632>>>>>    End_Function
10633>>>>>    
10633>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10633>>>>>    // This routine leaves the array unsorted.
10633>>>>>    Procedure addError Integer Error#
10635>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
10638>>>>>    End_Procedure
10639>>>>>    
10639>>>>>    // Set error to flagged state.
10639>>>>>    Procedure handleError Integer Error# Integer trapFlag
10641>>>>>        
10641>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10641>>>>>        
10641>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10643>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10644>>>>>>
10644>>>>>            Procedure_Return
10645>>>>>        End
10645>>>>>>
10645>>>>>        
10645>>>>>        Get findErrorLE Error# to prevErrIndex
10646>>>>>        Get isTrapped   Error# to prevErrFlag
10647>>>>>        
10647>>>>>        // if eq, Error already handled in some range.
10647>>>>>        If (prevErrFlag <> trapFlag) Begin
10649>>>>>            
10649>>>>>            // This is kind of complicated. If we are adding an error,
10649>>>>>            // we have to account for the error already being in the
10649>>>>>            // array as well as rejoining ranges that have been previously
10649>>>>>            // split and splitting ranges when adding a new flag.
10649>>>>>            
10649>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
10650>>>>>            Get integer_value prevErrIndex         to prevErrValue
10651>>>>>            
10651>>>>>            // Do this first so prevErrIndex stays valid.
10651>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10654>>>>>            Else ;                Send addError ( Error# + 1 )
10656>>>>>            
10656>>>>>            If ( prevErrValue lt Error# ) ;                Send addError Error#
10659>>>>>            Else ;                Send delete_item prevErrIndex
10661>>>>>        End
10661>>>>>>
10661>>>>>        Send sort_items UPWARD_DIRECTION
10662>>>>>        
10662>>>>>    End_Procedure
10663>>>>>    
10663>>>>>    // Flag error as trappable
10663>>>>>    Procedure Trap_Error Integer Error#
10665>>>>>        Send handleError Error# 1
10666>>>>>    End_Procedure
10667>>>>>    
10667>>>>>    // Flag error as non-trappable
10667>>>>>    Procedure Ignore_Error Integer Error#
10669>>>>>        Send handleError Error# 0
10670>>>>>    End_Procedure
10671>>>>>    
10671>>>>>    // Flag all errors as trappable
10671>>>>>    Procedure Trap_All
10673>>>>>        Send initArray
10674>>>>>    End_Procedure
10675>>>>>    
10675>>>>>    // Flag all errors as non-trappable
10675>>>>>    Procedure Ignore_All
10677>>>>>        Send delete_data
10678>>>>>        Set array_value 0 to 0
10679>>>>>        Set array_value 1 to 1
10680>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10681>>>>>    End_Procedure
10682>>>>>    
10682>>>>>End_Class
10683>>>>>
10683>>>>>
10683>>>>>Class ErrorSystem is a cObject
10684>>>>>    
10684>>>>>    Procedure construct_object
10686>>>>>        Forward Send construct_object
10688>>>>>        
10688>>>>>        Set delegation_mode to no_delegate_or_error
10689>>>>>        
10689>>>>>        Property Integer Verbose_State            True
10690>>>>>        Property Integer Current_Error_Number     0
10691>>>>>        Property Integer Error_Line_Number        0
10692>>>>>        
10692>>>>>        // If set false, this makes the error handler work the old way which
10692>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10692>>>>>        Property Boolean pbUnhandledErrorSupport       True
10693>>>>>        
10693>>>>>        // shows error numbers with user errors. Only set this true if your
10693>>>>>        // application has meaningful numbers that helps the end user. Note that
10693>>>>>        // unhandled errors always show numbers.
10693>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10693>>>>>        Property Boolean pbShowErrorNumber        False
10694>>>>>        
10694>>>>>        
10694>>>>>        // This is the caption that appears for unhandled errors dialog box
10694>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10695>>>>>        
10695>>>>>        // This is the caption that appears for standard user errors
10695>>>>>        Property String psUserErrorCaption C_$Error
10696>>>>>        
10696>>>>>        // Flag which is sent when error is being processed. This
10696>>>>>        // stops error recursion.
10696>>>>>        Property Integer Error_Processing_State  False
10697>>>>>        
10697>>>>>        // array of errors that we consider User Errors
10697>>>>>        Property Integer[] pUserErrorsArray
10698>>>>>        
10698>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10698>>>>>        //  ring a bell when these occur.
10698>>>>>        //
10698>>>>>        Property Integer Bell_on_Find_Error_State True
10699>>>>>        
10699>>>>>        Object TrappedErrors is a Trapped_Errors_Array
10701>>>>>            Send initArray
10702>>>>>        End_Object
10703>>>>>        
10703>>>>>        Send Trap_All
10704>>>>>        
10704>>>>>        // define the standard user error numbers
10704>>>>>        Send AddUserError 0
10705>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
10706>>>>>        Send AddUserError DFERR_WINDOW_RANGE
10707>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
10708>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
10709>>>>>        Send AddUserError DFERR_BAD_ENTRY
10710>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
10711>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
10712>>>>>        Send AddUserError DFERR_DUPLICATE_REC
10713>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
10714>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
10715>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
10716>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
10717>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
10718>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
10719>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
10720>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
10721>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
10722>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
10723>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
10724>>>>>        Send AddUserError DFERR_OPERATOR
10725>>>>>        Send AddUserError DFERR_XML_HTTP
10726>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
10727>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
10728>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
10729>>>>>        Send AddUserError DFERR_WINPRINT
10730>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
10731>>>>>        Send AddUserError DFERR_MAPI
10732>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
10733>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
10734>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
10735>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
10736>>>>>        // number of DDs.
10736>>>>>        Move Self to Error_Object_Id
10737>>>>>    End_Procedure
10738>>>>>    
10738>>>>>    Function Help_Context Integer Context_Type Returns String
10740>>>>>        Function_Return (Current_Error_Number(Self))
10741>>>>>    End_Function
10742>>>>>    
10742>>>>>    // Catch and display error Error#.
10742>>>>>    Procedure Trap_Error Integer Error#
10744>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
10745>>>>>    End_Procedure
10746>>>>>    
10746>>>>>    // Pass error Error# on to the regular DataFlex error handler.
10746>>>>>    Procedure Ignore_Error Integer Error#
10748>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
10749>>>>>    End_Procedure
10750>>>>>    
10750>>>>>    // Catch and display all errors.
10750>>>>>    Procedure Trap_All
10752>>>>>        Send Trap_All to ( trappedErrors( Self ) )
10753>>>>>    End_Procedure
10754>>>>>    
10754>>>>>    // Forward all error to regular DataFlex error handler.
10754>>>>>    Procedure Ignore_All
10756>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
10757>>>>>    End_Procedure
10758>>>>>    
10758>>>>>    // Build complete error description from Flexerrs and user error message.
10758>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
10760>>>>>        String Full_Error_Text
10760>>>>>        
10760>>>>>        Move (Trim(ErrMsg)) to ErrMsg
10761>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
10762>>>>>        
10762>>>>>        If (ErrMsg<>"") Begin
10764>>>>>            
10764>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
10766>>>>>                // Make sure last character of error text is a separating symbol.
10766>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
10766>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
10769>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
10770>>>>>            End
10770>>>>>>
10770>>>>>            Else ;                Move ErrMsg to Full_Error_Text
10772>>>>>            
10772>>>>>        End
10772>>>>>>
10772>>>>>        
10772>>>>>        Function_Return Full_Error_Text
10773>>>>>    End_Function
10774>>>>>    
10774>>>>>    // return true if an error number is critical
10774>>>>>    Function Is_Critical Integer Error# Returns Integer
10776>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
10777>>>>>    End_Function
10778>>>>>    
10778>>>>>    // adds a user error to the array
10778>>>>>    Procedure AddUserError Integer iError
10780>>>>>        Integer[] UserErrors
10781>>>>>        Get pUserErrorsArray to UserErrors
10782>>>>>        // We assume that there are few enough user errors to worry about speed of finding
10782>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
10782>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
10784>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
10785>>>>>            Set pUserErrorsArray to UserErrors
10786>>>>>        End
10786>>>>>>
10786>>>>>    End_Procedure
10787>>>>>    
10787>>>>>    // removes an error from the user array
10787>>>>>    Procedure RemoveUserError Integer iError
10789>>>>>        Integer[] UserErrors
10790>>>>>        Integer iIndex iSize
10790>>>>>        Get pUserErrorsArray to UserErrors
10791>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
10792>>>>>        If (iIndex<>-1) Begin
10794>>>>>            // replace the removed error with the last error and resize the array
10794>>>>>            Move (SizeOfArray(UserErrors)) to iSize
10795>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
10796>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
10797>>>>>        End
10797>>>>>>
10797>>>>>    End_Procedure
10798>>>>>    
10798>>>>>    // removes all user errors
10798>>>>>    Procedure RemoveAllUserErrors
10800>>>>>        Integer[] UserErrors
10801>>>>>        Set pUserErrorsArray to UserErrors
10802>>>>>    End_Procedure
10803>>>>>    
10803>>>>>    // returns true if this is an unhandled error (i.e., not a user error
10803>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10805>>>>>        Integer[] UserErrors
10806>>>>>        Get pUserErrorsArray to UserErrors
10807>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10808>>>>>    End_Function
10809>>>>>    
10809>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10811>>>>>        String sCaption sCRLF
10811>>>>>        Move (Character(13)+Character(10)) to sCRLF
10812>>>>>        Get psUnhandledErrorCaption to sCaption
10813>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10814>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10815>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10816>>>>>    End_Procedure
10817>>>>>    
10817>>>>>    // Handle error event, displaying error info to user.
10817>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
10819>>>>>        Integer iReply iIcon
10819>>>>>        String  sErrorText sMess
10819>>>>>        String  sSource sCaption
10819>>>>>        Integer iSrcPos iSrc iTxtLen
10819>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10819>>>>>        
10819>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
10821>>>>>            Procedure_Return                     // recursion
10822>>>>>        End
10822>>>>>>
10822>>>>>        
10822>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
10823>>>>>        
10823>>>>>        Set Current_Error_Number to ErrNum
10824>>>>>        Set Error_Line_Number    to Err_Line
10825>>>>>        
10825>>>>>        // if this is false, this will work old-style -- all errors go through message box
10825>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10826>>>>>        
10826>>>>>        Get Is_Critical errnum to bCritical
10827>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
10828>>>>>        
10828>>>>>        
10828>>>>>        //
10828>>>>>        //   Changes made so find errors don't report - just beep
10828>>>>>        //
10828>>>>>        
10828>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
10830>>>>>            Send Bell
10831>>>>>        End
10831>>>>>>
10831>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
10834>>>>>            // if trapped do nothing
10834>>>>>            
10834>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
10834>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
10834>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
10834>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
10834>>>>>        End
10834>>>>>>
10834>>>>>        Else Begin
10835>>>>>            
10835>>>>>            // See if source information is provided (Source = module.function). If so remove
10835>>>>>            // as detail. Must find last instance of this in string
10835>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
10836>>>>>            If iSrc Begin
10838>>>>>                Move (iSrc-1) to iSrcPos
10839>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10840>>>>>                Move ErrMsg to sSource
10841>>>>>                Repeat // this makes sure we find last instance of this
10841>>>>>>
10841>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10842>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10843>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10846>>>>>                Until (iSrc=0)
10848>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
10849>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
10852>>>>>            End
10852>>>>>>
10852>>>>>            
10852>>>>>            // the caption normally used for handled user errors
10852>>>>>            Get psUserErrorCaption to sCaption
10853>>>>>            // if an operator error this may be a Procedure UserError situation where the
10853>>>>>            // caption is passed in the error text. If so, get the caption
10853>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
10855>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
10856>>>>>                If iSrc Begin
10858>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
10859>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
10860>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
10861>>>>>                End
10861>>>>>>
10861>>>>>            End
10861>>>>>>
10861>>>>>            
10861>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
10862>>>>>            
10862>>>>>            // if the error source is identified we can get extended error
10862>>>>>            // text for our error message
10862>>>>>            If ghoErrorSource Begin
10864>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10865>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
10868>>>>>            End
10868>>>>>>
10868>>>>>            
10868>>>>>            If (bUnhandledSupport) Begin
10870>>>>>                // as of 14.1, this is the preferred way to do errors
10870>>>>>                If ( bCritical or bIsUnhandled) Begin
10872>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10873>>>>>                    If (sSource<>"") Begin
10875>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10876>>>>>                    End
10876>>>>>>
10876>>>>>                End
10876>>>>>>
10876>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10879>>>>>                    // if a user error, we provide a way to see error numbers.
10879>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10880>>>>>                End
10880>>>>>>
10880>>>>>            End
10880>>>>>>
10880>>>>>            Else Begin
10881>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10881>>>>>                // only for backwards compatibility. All errors go through the message box
10881>>>>>                Get Verbose_State to bVerbose
10882>>>>>                If (bVerbose)  Begin
10884>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
10885>>>>>                    If (sSource<>"") Begin
10887>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10888>>>>>                    End
10888>>>>>>
10888>>>>>                End
10888>>>>>>
10888>>>>>            End
10888>>>>>>
10888>>>>>            
10888>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10890>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
10891>>>>>            End
10891>>>>>>
10891>>>>>            Else Begin
10892>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10893>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
10894>>>>>            End
10894>>>>>>
10894>>>>>            
10894>>>>>            // abort on critical errors
10894>>>>>            If bCritical ;                Abort
10897>>>>>            
10897>>>>>        End
10897>>>>>>
10897>>>>>        Move 0 to ghoErrorSource
10898>>>>>        Set Error_Processing_State to False // no longer reporting an error
10899>>>>>    End_Procedure
10900>>>>>    
10900>>>>>    
10900>>>>>    // The following functions are rarely or never used.
10900>>>>>    
10900>>>>>    // The functions below are used to construct a general help
10900>>>>>    // name for errors that are generated by the system.  If processing
10900>>>>>    // comes here, then there was no module specific help found.  These
10900>>>>>    // functions will provide a more general help name that appears in
10900>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10900>>>>>    // places in the help file under this application and module name.
10900>>>>>    
10900>>>>>    // Returns "ERROR:errornum" to supply error help.
10900>>>>>    Function Help_Name Returns String
10902>>>>>        Function_Return (Append("ERROR:",lastErr))
10903>>>>>    End_Function
10904>>>>>    
10904>>>>>    Function Application_Name Returns String
10906>>>>>        Function_Return 'SYSTEM'
10907>>>>>    End_Function
10908>>>>>    
10908>>>>>    Function Module_Name Returns String
10910>>>>>        Function_Return ''
10911>>>>>    End_Function
10912>>>>>End_Class
10913>>>>>
10913>>>>>Object Error_Info_Object is a ErrorSystem
10915>>>>>End_Object
10916>>>>>
10916>>>>>
10916>>>>>Procedure UserError Global String sMessage String sCaption
10918>>>>>    String sCapt
10918>>>>>    If (Error_Object_Id=0) Begin
10920>>>>>        Error DFERR_PROGRAM "No Error Handler"
10921>>>>>>
10921>>>>>        Procedure_Return
10922>>>>>    End
10922>>>>>>
10922>>>>>    
10922>>>>>    // Accept not passing a caption in which case the error handler's
10922>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10922>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10922>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10922>>>>>    If (num_arguments>1) Begin
10924>>>>>        Move sCaption to sCapt
10925>>>>>    End
10925>>>>>>
10925>>>>>    
10925>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10926>>>>>>
10926>>>>>    
10926>>>>>End_Procedure
10927>>>
10927>>>
10927>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 20.0\Pkg\sql.pkg)
10927>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
10927>>>>>// Connectivty Kits.                                              
10927>>>>>Use CLI.pkg
10927>>>>>
10927>>>>>// Global storage for results
10927>>>>>Integer SQLResult
10927>>>>>
10927>>>>>// Embedded SQL function constants
10927>>>>>Define FUNC_SQLCONNECT             for 1000000
10927>>>>>Define FUNC_SQLFILECONNECT         for 1000001
10927>>>>>Define FUNC_SQLDISCONNECT          for 1000002
10927>>>>>Define FUNC_SQLOPEN                for 1000003
10927>>>>>Define FUNC_SQLCLOSE               for 1000004
10927>>>>>Define FUNC_SQLPREPARE             for 1000005
10927>>>>>Define FUNC_SQLEXECUTE             for 1000006
10927>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
10927>>>>>Define FUNC_SQLFETCH               for 1000008
10927>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
10927>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
10927>>>>>Define FUNC_SQLBINDFILE            for 1000011
10927>>>>>Define FUNC_SQLGETDATA             for 1000012
10927>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
10927>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
10927>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
10927>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
10927>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
10927>>>>>Define FUNC_SQLSETPROCARG          for 1000018
10927>>>>>Define FUNC_SQLCALL                for 1000019
10927>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
10927>>>>>Define FUNC_SQLGETPROCARG          for 1000021
10927>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
10927>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
10927>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
10927>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
10927>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
10927>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
10927>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
10927>>>>>
10927>>>>>// Embedded SQL statement attribute constants
10927>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
10927>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
10927>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
10927>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
10927>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
10927>>>>>
10927>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
10927>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
10927>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
10927>>>>>Define SQL_CURSOR_DYNAMIC           for 2
10927>>>>>Define SQL_CURSOR_STATIC            for 3
10927>>>>>
10927>>>>>
10927>>>>>// Embedded SQL column attribute constants
10927>>>>>Define SQLCOLATTRIB_SIZE           for 1
10927>>>>>Define SQLCOLATTRIB_LENGTH         for 1
10927>>>>>Define SQLCOLATTRIB_PRECISION      for 2
10927>>>>>Define SQLCOLATTRIB_LABEL          for 3
10927>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
10927>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
10927>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
10927>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
10927>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
10927>>>>>
10927>>>>>
10927>>>>>// Types used for conversion with ConvertToXml
10927>>>>>Define esqlTime      for 8
10927>>>>>Define esqlDatetime  for 9
10927>>>>>
10927>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
10927>>>>>Integer giLastSQLhdbc
10927>>>>>Integer giLastSQLhstmt
10927>>>>>
10927>>>>>Move -1 to giLastSQLhdbc
10928>>>>>Move -1 to giLastSQLhstmt
10929>>>>>
10929>>>>>Struct tSQLColumn
10929>>>>>    Integer iSQLType
10929>>>>>    Integer iSQLSize
10929>>>>>    Integer iSQLPrecision
10929>>>>>    Integer iVariableDataType
10929>>>>>End_Struct
10929>>>>>
10929>>>>>// Statement object for embedded sql                           
10929>>>>>//   An object is created for each statement. These will be children    
10929>>>>>//   of cSQLConnection objects which manage the create and destruction  
10929>>>>>//   of these.                                                          
10929>>>>>
10929>>>>>Class cSQLStatement is a cObject
10930>>>>>    
10930>>>>>    Procedure Construct_object
10932>>>>>        Forward Send Construct_object
10934>>>>>        
10934>>>>>        Property Handle  phCLIStatementHandle   0
10935>>>>>        Property Handle  phCLIConnectionHandle  0
10936>>>>>        Property String  psDriverID             ""
10937>>>>>        
10937>>>>>        Property Integer piLastColumn      0
10938>>>>>        Property Integer piLastArgument    0
10939>>>>>        Property Integer piBindFile        0
10940>>>>>        Property Integer piColumnCount     0
10941>>>>>        
10941>>>>>        // True if there is at least 1 column with a variable length data type
10941>>>>>        Property Integer piHasVariableDataType  0
10942>>>>>        
10942>>>>>        // Max size of buffer for variable length data. Default 16000
10942>>>>>        Property Integer piMaxVariableBufferLength 16000
10943>>>>>        
10943>>>>>        // Allocated buffer for SQLGetData.
10943>>>>>        Property WString psVariableBuffer  ""
10944>>>>>        
10944>>>>>        // Allocated size of psVariableBuffer
10944>>>>>        Property Integer piVariableBufferLength 0
10945>>>>>        
10945>>>>>        // Stores column properties of a result set.
10945>>>>>        Property tSQLColumn[] paSQLColumns
10946>>>>>        
10946>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
10946>>>>>        //   0    = Fetch returned no data.
10946>>>>>        //   <> 0 = Row fetched
10946>>>>>        Property Integer piFetchResult     0
10947>>>>>        
10947>>>>>        
10947>>>>>        Property String psDummyZeroDate              '0001-01-01'
10948>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
10949>>>>>        
10949>>>>>    End_Procedure
10950>>>>>    
10950>>>>>    // Store basic information about the statement.
10950>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
10952>>>>>        
10952>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
10953>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
10954>>>>>        Set psDriverID             to sDrvrId
10955>>>>>        
10955>>>>>    End_Procedure
10956>>>>>    
10956>>>>>    
10956>>>>>    // Destroy the cSQLStatement object
10956>>>>>    Procedure DestroySQLStatement
10958>>>>>        Send Destroy
10959>>>>>    End_Procedure
10960>>>>>    
10960>>>>>    // Handle an error that has occurred while checking properties.
10960>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
10962>>>>>        Integer iErrHandle
10962>>>>>        Integer iErrNum
10962>>>>>        String  sLocationInfo
10962>>>>>        
10962>>>>>        // Get the DataFlex statement identifier
10962>>>>>        Move Self to iErrHandle
10963>>>>>        
10963>>>>>        // Determine error number
10963>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
10966>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
10970>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
10974>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
10976>>>>>        
10976>>>>>        // Create location ifnormation
10976>>>>>        Move "[" to sLocationInfo
10977>>>>>        If (sOriginMsg <> "") Begin
10979>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
10980>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
10981>>>>>        End
10981>>>>>>
10981>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
10982>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
10983>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
10984>>>>>        
10984>>>>>        // Generate the error
10984>>>>>        Error iErrNum sLocationInfo
10985>>>>>>
10985>>>>>    End_Procedure
10986>>>>>    
10986>>>>>    // Handle general error not related to the properties
10986>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
10988>>>>>        Integer iErrHandle
10988>>>>>        String  sLocationInfo
10988>>>>>        
10988>>>>>        // Get the DataFlex statement identifier
10988>>>>>        Move Self to iErrHandle
10989>>>>>        
10989>>>>>        // Create location information
10989>>>>>        Move "[" to sLocationInfo
10990>>>>>        If (sOriginMsg <> "") Begin
10992>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
10993>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
10994>>>>>        End
10994>>>>>>
10994>>>>>        If (sErrtext <> "") Begin
10996>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
10997>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
10998>>>>>        End
10998>>>>>>
10998>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
10999>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
11000>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
11001>>>>>        
11001>>>>>        // Generate the error
11001>>>>>        Error iErrNum sLocationInfo
11002>>>>>>
11002>>>>>    End_Procedure
11003>>>>>    
11003>>>>>    // Handle an illegal attribute error
11003>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
11005>>>>>        Integer bReport
11005>>>>>        
11005>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
11008>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
11011>>>>>    End_Procedure
11012>>>>>    
11012>>>>>    // Check if a column number is legal
11012>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
11014>>>>>        Integer bLegal
11014>>>>>        Integer iNumColumns
11014>>>>>        
11014>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11015>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
11018>>>>>        Else ;            Move DFFALSE to bLegal
11020>>>>>        
11020>>>>>        Function_Return bLegal
11021>>>>>    End_Function
11022>>>>>    
11022>>>>>    
11022>>>>>    
11022>>>>>    // Close a statement and free all alllocated resources
11022>>>>>    Procedure SQLClose
11024>>>>>        Integer ihdbc
11024>>>>>        Integer ihstmt
11024>>>>>        Integer iVoid
11024>>>>>        String  sDrvrId
11024>>>>>        String  sEmpty
11024>>>>>        
11024>>>>>        // Initialize
11024>>>>>        Move "" to sEmpty
11025>>>>>        
11025>>>>>        // Get the cli handles
11025>>>>>        Get phCLIStatementHandle  to ihstmt
11026>>>>>        Get phCLIConnectionHandle to ihdbc
11027>>>>>        Get psDriverId            to sDrvrId
11028>>>>>        
11028>>>>>        // Free the CLI handle
11028>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11030>>>>>            // Call the driver function to close
11030>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11035>>>>>            
11035>>>>>            Move -1 to giLastSQLhstmt
11036>>>>>            // Free the DataFlex handle
11036>>>>>            Send DestroySQLStatement
11037>>>>>        End
11037>>>>>>
11037>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
11039>>>>>    End_Procedure
11040>>>>>    
11040>>>>>    // Prepare a statement for execution
11040>>>>>    Procedure SQLPrepare String sStatement
11042>>>>>        Integer ihdbc
11042>>>>>        Integer ihstmt
11042>>>>>        Integer iVoid
11042>>>>>        String  sDrvrId
11042>>>>>        
11042>>>>>        // Get the cli handles
11042>>>>>        Get phCLIStatementHandle  to ihstmt
11043>>>>>        Get phCLIConnectionHandle to ihdbc
11044>>>>>        Get psDriverId            to sDrvrId
11045>>>>>        
11045>>>>>        // Prepare
11045>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11047>>>>>            // Call the driver function to prepare
11047>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11052>>>>>            Set piLastArgument to 0
11053>>>>>
11053>>>>>        End
11053>>>>>>
11053>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
11055>>>>>    End_Procedure
11056>>>>>    
11056>>>>>    Procedure SQLGetStatementAttributes
11058>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
11058>>>>>        String sMaxValue
11058>>>>>        tSQLColumn[] aSQLColumns
11058>>>>>        tSQLColumn[] aSQLColumns
11059>>>>>        
11059>>>>>        Integer iSqlType
11059>>>>>        Integer iSQLSize
11059>>>>>        Integer iSQLprecision
11059>>>>>        Integer iVariableDataType
11059>>>>>        
11059>>>>>        String  sDrvrId
11059>>>>>        
11059>>>>>        Integer iHasVariableDataType
11059>>>>>        
11059>>>>>        Move 0 to iHasVariableDataType
11060>>>>>        
11060>>>>>        
11060>>>>>        // Get the cli handles
11060>>>>>        Get phCLIStatementHandle  to ihstmt
11061>>>>>        Get phCLIConnectionHandle to ihdbc
11062>>>>>        Get psDriverId            to sDrvrId
11063>>>>>        
11063>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11064>>>>>        
11064>>>>>        Set piColumnCount to iNumColumns
11065>>>>>        
11065>>>>>        // Fill columns array
11065>>>>>        For iCol from 1 to iNumColumns
11071>>>>>>
11071>>>>>            Move 0 to iVariableDataType
11072>>>>>            
11072>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
11073>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
11074>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
11075>>>>>            
11075>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
11077>>>>>                // text type
11077>>>>>                Move 1 to iVariableDataType
11078>>>>>            End
11078>>>>>>
11078>>>>>            Else Begin
11079>>>>>                If (sDrvrId = "MSSQLDRV") Begin
11081>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
11081>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
11083>>>>>                        
11083>>>>>                        Move 1 to iVariableDataType
11084>>>>>                    End
11084>>>>>>
11084>>>>>                End
11084>>>>>>
11084>>>>>            End
11084>>>>>>
11084>>>>>            
11084>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
11085>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
11086>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
11087>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
11088>>>>>            
11088>>>>>            If (not(iVariableDataType)) Begin
11090>>>>>                If (iSQLSize > iMaxSize) Begin
11092>>>>>                    Move iSQLSize to iMaxSize
11093>>>>>                End
11093>>>>>>
11093>>>>>            End
11093>>>>>>
11093>>>>>            Else Begin
11094>>>>>                Move 1 to iHasVariableDataType
11095>>>>>            End
11095>>>>>>
11095>>>>>            
11095>>>>>        Loop
11096>>>>>>
11096>>>>>        
11096>>>>>        Set paSQLColumns   to aSQLColumns
11097>>>>>        Set piHasVariableDataType to iHasVariableDataType
11098>>>>>        
11098>>>>>    End_Procedure
11099>>>>>    
11099>>>>>    // Execute a prepared statement
11099>>>>>    Procedure SQLExecute
11101>>>>>        Integer ihdbc
11101>>>>>        Integer ihstmt
11101>>>>>        Integer iVoid
11101>>>>>        String  sDrvrId
11101>>>>>        String  sEmpty
11101>>>>>        
11101>>>>>        // Initialize
11101>>>>>        Move "" to sEmpty
11102>>>>>        
11102>>>>>        // Get the cli handles
11102>>>>>        Get phCLIStatementHandle  to ihstmt
11103>>>>>        Get phCLIConnectionHandle to ihdbc
11104>>>>>        Get psDriverId            to sDrvrId
11105>>>>>        
11105>>>>>        // Execute
11105>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11107>>>>>            // Call the driver function to execute
11107>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11112>>>>>            Send SQLGetStatementAttributes
11113>>>>>            Set piLastArgument to 0
11114>>>>>        End
11114>>>>>>
11114>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
11116>>>>>    End_Procedure
11117>>>>>    
11117>>>>>    
11117>>>>>    
11117>>>>>    // Prepare and execute a statement
11117>>>>>    Procedure SQLExecDirect String sStatement
11119>>>>>        Integer ihdbc
11119>>>>>        Integer ihstmt
11119>>>>>        Integer iVoid
11119>>>>>        String  sDrvrId
11119>>>>>        
11119>>>>>        // Get the cli handles
11119>>>>>        Get phCLIStatementHandle  to ihstmt
11120>>>>>        Get phCLIConnectionHandle to ihdbc
11121>>>>>        Get psDriverId            to sDrvrId
11122>>>>>        
11122>>>>>        // ExecDirect
11122>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11124>>>>>            // Call the driver function to execdirect
11124>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11129>>>>>            Send SQLGetStatementAttributes
11130>>>>>        End
11130>>>>>>
11130>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
11132>>>>>    End_Procedure
11133>>>>>    
11133>>>>>    // Fetch the next row
11133>>>>>    // Returns  : 0   = No more data
11133>>>>>    //<>0 = Success
11133>>>>>    Function SQLFetch Returns Integer
11135>>>>>        Integer ihdbc
11135>>>>>        Integer ihstmt
11135>>>>>        Integer iResult
11135>>>>>        String  sDrvrId
11135>>>>>        String  sEmpty
11135>>>>>        
11135>>>>>        // Initialize
11135>>>>>        Move "" to sEmpty
11136>>>>>        Move 0  to iResult
11137>>>>>        
11137>>>>>        // Get the cli handles
11137>>>>>        Get phCLIStatementHandle  to ihstmt
11138>>>>>        Get phCLIConnectionHandle to ihdbc
11139>>>>>        Get psDriverId            to sDrvrId
11140>>>>>        
11140>>>>>        // Fetch
11140>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11142>>>>>            Move False to Err
11143>>>>>            
11143>>>>>            // Call the driver function to fetch
11143>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11148>>>>>            
11148>>>>>            // If something went wrong, adjust the result
11148>>>>>            If (Err) ;                Move 0 to iResult
11151>>>>>            
11151>>>>>            Set piLastcolumn to 0
11152>>>>>        End
11152>>>>>>
11152>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
11154>>>>>        
11154>>>>>        Function_Return iResult
11155>>>>>    End_Function
11156>>>>>    
11156>>>>>    // Fetch the next row and return an array with all column values
11156>>>>>    // Returns  : Array of strings with all column values
11156>>>>>    // Sets piFetchResult property
11156>>>>>    //   0    = No more data
11156>>>>>    //   <> 0 = Success
11156>>>>>    Function SQLFetchRowValues Returns String[]
11158>>>>>        
11158>>>>>        String[] asValues
11159>>>>>        
11159>>>>>        tSQLColumn[] aSQLColumns
11159>>>>>        tSQLColumn[] aSQLColumns
11160>>>>>        
11160>>>>>        Integer ihdbc
11160>>>>>        Integer ihstmt
11160>>>>>        Integer iResult iVoid
11160>>>>>        Integer iColCount iCol
11160>>>>>        String  sDrvrId
11160>>>>>        String  sEmpty
11160>>>>>        Longptr pResultWStr
11160>>>>>        WString wVariableResult
11160>>>>>        Integer iHasVariableDataType
11160>>>>>        Integer iLen
11160>>>>>        Integer iVariableBufferLength
11160>>>>>        
11160>>>>>        // Initialize
11160>>>>>        Move "" to sEmpty
11161>>>>>        Move 0  to iResult
11162>>>>>        
11162>>>>>        // Get the cli handles
11162>>>>>        Get phCLIStatementHandle  to ihstmt
11163>>>>>        Get phCLIConnectionHandle to ihdbc
11164>>>>>        Get psDriverId            to sDrvrId
11165>>>>>        
11165>>>>>        Get paSQLColumns to aSQLColumns
11166>>>>>        Get piColumnCount to iColCount
11167>>>>>        Get piHasVariableDataType to iHasVariableDataType
11168>>>>>        
11168>>>>>        If (iHasVariableDataType) Begin
11170>>>>>            
11170>>>>>            Get piVariableBufferLength      to iVariableBufferLength
11171>>>>>            Get piMaxVariableBufferLength   to iLen
11172>>>>>            
11172>>>>>            If (iLen > iVariableBufferLength) Begin
11174>>>>>                // Allocate
11174>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
11175>>>>>                
11175>>>>>                Set piVariableBufferLength to iLen
11176>>>>>                Set psVariableBuffer       to wVariableResult
11177>>>>>                
11177>>>>>                Get piVariableBufferLength to iVariableBufferLength
11178>>>>>            End
11178>>>>>>
11178>>>>>        End
11178>>>>>>
11178>>>>>        
11178>>>>>        // Fetch
11178>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11180>>>>>            Move (False) to Err
11181>>>>>            
11181>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11181>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11181>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11181>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11183>>>>>                // Setup function arguments
11183>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11188>>>>>                Move ihstmt to giLastSQLhstmt
11189>>>>>                Move ihdbc to giLastSQLhdbc
11190>>>>>            End
11190>>>>>>
11190>>>>>            
11190>>>>>            // Call the driver function to fetch
11190>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
11195>>>>>            
11195>>>>>            // If something went wrong, adjust the result
11195>>>>>            If (Err) ;                Move 0 to iResult
11198>>>>>            
11198>>>>>            If (iResult) Begin
11200>>>>>                For iCol from 1 to iColCount
11206>>>>>>
11206>>>>>                    
11206>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11208>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
11213>>>>>                            
11213>>>>>                        If (pResultWStr) Begin
11215>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
11216>>>>>                        End
11216>>>>>>
11216>>>>>                        Else Begin
11217>>>>>                            Move "" to asValues[iCol - 1]
11218>>>>>                        End
11218>>>>>>
11218>>>>>                        
11218>>>>>                    End
11218>>>>>>
11218>>>>>                    Else Begin
11219>>>>>                        Get psVariableBuffer       to wVariableResult
11220>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
11225>>>>>                        
11225>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
11226>>>>>                    End
11226>>>>>>
11226>>>>>                    
11226>>>>>                Loop
11227>>>>>>
11227>>>>>            End
11227>>>>>>
11227>>>>>        End
11227>>>>>>
11227>>>>>        Else Begin
11228>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
11229>>>>>        End
11229>>>>>>
11229>>>>>        
11229>>>>>        Set piFetchResult to iResult
11230>>>>>        
11230>>>>>        Function_Return asValues
11231>>>>>        
11231>>>>>    End_Function
11232>>>>>    
11232>>>>>    // Fetch a complete result set.
11232>>>>>    // Returns  : 2-dimensional array of strings with result set
11232>>>>>    // Sets piFetchResult property
11232>>>>>    //   0    = No more data
11232>>>>>    //   <> 0 = Success
11232>>>>>    Function SQLFetchResultsetValues Returns String[][]
11234>>>>>        
11234>>>>>        String[][] asValues
11235>>>>>        
11235>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
11235>>>>>        String sDrvrId sEmpty sMax
11235>>>>>        Longptr pResultWStr
11235>>>>>        WString wResult
11235>>>>>        
11235>>>>>        tSQLColumn[] aSQLColumns
11235>>>>>        tSQLColumn[] aSQLColumns
11236>>>>>        WString  wVariableResult
11236>>>>>        Integer iHasVariableDataType
11236>>>>>        Integer iLen
11236>>>>>        Integer iVariableBufferLength
11236>>>>>        
11236>>>>>        // Initialize
11236>>>>>        Move "" to sEmpty
11237>>>>>        Move 0  to iResult
11238>>>>>        
11238>>>>>        // Get the cli handles
11238>>>>>        Get phCLIStatementHandle  to ihstmt
11239>>>>>        Get phCLIConnectionHandle to ihdbc
11240>>>>>        Get psDriverId            to sDrvrId
11241>>>>>        
11241>>>>>        // Fetch
11241>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11243>>>>>            Move False to Err
11244>>>>>            
11244>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11244>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11244>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11244>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11246>>>>>                // Setup function arguments
11246>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11251>>>>>                Move ihstmt to giLastSQLhstmt
11252>>>>>                Move ihdbc to giLastSQLhdbc
11253>>>>>            End
11253>>>>>>
11253>>>>>            
11253>>>>>            Get piColumnCount to iColCount
11254>>>>>            If (iColCount) Begin
11256>>>>>                Get paSQLColumns to aSQLColumns
11257>>>>>                Get piHasVariableDataType to iHasVariableDataType
11258>>>>>                If (iHasVariableDataType) Begin
11260>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
11261>>>>>                    Get piMaxVariableBufferLength   to iLen
11262>>>>>                    If (iLen > iVariableBufferLength) Begin
11264>>>>>                        // Allocate
11264>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
11265>>>>>                        
11265>>>>>                        Set piVariableBufferLength to iLen
11266>>>>>                        Set psVariableBuffer       to wVariableResult
11267>>>>>                        
11267>>>>>                        Get piVariableBufferLength to iVariableBufferLength
11268>>>>>                    End
11268>>>>>>
11268>>>>>                    Else Begin
11269>>>>>                        Set psVariableBuffer       to wVariableResult
11270>>>>>                    End
11270>>>>>>
11270>>>>>                End
11270>>>>>>
11270>>>>>                
11270>>>>>                // Call the driver function to fetch
11270>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11275>>>>>                If (Err) ;                    Move 0 to iResult
11278>>>>>                
11278>>>>>                While (iResult <> 0)
11282>>>>>                    
11282>>>>>                    For iCol from 1 to (iColCount)
11288>>>>>>
11288>>>>>                        
11288>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11290>>>>>                            
11290>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
11295>>>>>                            
11295>>>>>                            If (pResultWStr) Begin
11297>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
11298>>>>>                            End
11298>>>>>>
11298>>>>>                            Else Begin
11299>>>>>                                Move "" to asValues[iRow][iCol - 1]
11300>>>>>                            End
11300>>>>>>
11300>>>>>                        End
11300>>>>>>
11300>>>>>                        Else Begin
11301>>>>>                            //Variable data
11301>>>>>                            Move wVariableResult to wResult
11302>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
11307>>>>>                            
11307>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
11308>>>>>                        End
11308>>>>>>
11308>>>>>                    Loop
11309>>>>>>
11309>>>>>                    
11309>>>>>                    Increment iRow
11310>>>>>                    
11310>>>>>                    // Call the driver function to fetch
11310>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11315>>>>>                    If (Err) ;                        Move 0 to iResult
11318>>>>>                    
11318>>>>>                Loop
11319>>>>>>
11319>>>>>            End
11319>>>>>>
11319>>>>>        End
11319>>>>>>
11319>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
11321>>>>>        
11321>>>>>        Set piFetchResult to iResult
11322>>>>>        
11322>>>>>        Function_Return asValues
11323>>>>>    End_Function
11324>>>>>    
11324>>>>>    // Get the next column
11324>>>>>    Function SQLNextColumn Returns String
11326>>>>>        Integer iCol
11326>>>>>        String  sResult
11326>>>>>        
11326>>>>>        Get piLastColumn to iCol
11327>>>>>        Increment iCol
11328>>>>>        Get SQLColumnValue iCol to sResult
11329>>>>>        Set piLastColumn to iCol
11330>>>>>        
11330>>>>>        Function_Return sResult
11331>>>>>    End_Function
11332>>>>>    
11332>>>>>    
11332>>>>>    // Returns the native type of a column
11332>>>>>    Function SQLColumnType Integer iCol Returns Integer
11334>>>>>        Integer ihdbc
11334>>>>>        Integer ihstmt
11334>>>>>        String  sDrvrId
11334>>>>>        Integer iSQLType
11334>>>>>        Integer iColumns
11334>>>>>        
11334>>>>>        tSQLColumn[] aSQLColumns
11334>>>>>        tSQLColumn[] aSQLColumns
11335>>>>>        
11335>>>>>        // Get the cli handles
11335>>>>>        Get phCLIStatementHandle  to ihstmt
11336>>>>>        Get phCLIConnectionHandle to ihdbc
11337>>>>>        Get psDriverId            to sDrvrId
11338>>>>>        
11338>>>>>        // Get the value
11338>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11340>>>>>            
11340>>>>>            Get paSQLColumns   to aSQLColumns
11341>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11342>>>>>            
11342>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11344>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
11345>>>>>            End
11345>>>>>>
11345>>>>>            Else Begin
11346>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
11347>>>>>            End
11347>>>>>>
11347>>>>>        End
11347>>>>>>
11347>>>>>        Else Begin
11348>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
11349>>>>>        End
11349>>>>>>
11349>>>>>        
11349>>>>>        Function_Return iSQLType
11350>>>>>    End_Function
11351>>>>>    
11351>>>>>    // Returns the size (max length) of a column
11351>>>>>    Function SQLColumnSize Integer iCol Returns Integer
11353>>>>>        Integer ihdbc
11353>>>>>        Integer ihstmt
11353>>>>>        String  sDrvrId
11353>>>>>        Integer iSQLSize
11353>>>>>        Integer iColumns
11353>>>>>        
11353>>>>>        tSQLColumn[] aSQLColumns
11353>>>>>        tSQLColumn[] aSQLColumns
11354>>>>>        
11354>>>>>        // Get the cli handles
11354>>>>>        Get phCLIStatementHandle  to ihstmt
11355>>>>>        Get phCLIConnectionHandle to ihdbc
11356>>>>>        Get psDriverId            to sDrvrId
11357>>>>>        
11357>>>>>        // Get the value
11357>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11359>>>>>            
11359>>>>>            Get paSQLColumns   to aSQLColumns
11360>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11361>>>>>            
11361>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11363>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
11364>>>>>            End
11364>>>>>>
11364>>>>>            Else Begin
11365>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
11366>>>>>            End
11366>>>>>>
11366>>>>>        End
11366>>>>>>
11366>>>>>        Else Begin
11367>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
11368>>>>>        End
11368>>>>>>
11368>>>>>        
11368>>>>>        Function_Return iSQLSize
11369>>>>>    End_Function
11370>>>>>    
11370>>>>>    //  Returns 1 for variable length datatypes.
11370>>>>>    //  For example SQL Server varchar(max) or text type
11370>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
11370>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
11372>>>>>        Integer ihdbc
11372>>>>>        Integer ihstmt
11372>>>>>        String  sDrvrId
11372>>>>>        Integer iVariableDataType
11372>>>>>        Integer iColumns
11372>>>>>        
11372>>>>>        tSQLColumn[] aSQLColumns
11372>>>>>        tSQLColumn[] aSQLColumns
11373>>>>>        
11373>>>>>        // Get the cli handles
11373>>>>>        Get phCLIStatementHandle  to ihstmt
11374>>>>>        Get phCLIConnectionHandle to ihdbc
11375>>>>>        Get psDriverId            to sDrvrId
11376>>>>>        
11376>>>>>        // Get the value
11376>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11378>>>>>            
11378>>>>>            Get paSQLColumns   to aSQLColumns
11379>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11380>>>>>            
11380>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11382>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
11383>>>>>            End
11383>>>>>>
11383>>>>>            Else Begin
11384>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
11385>>>>>            End
11385>>>>>>
11385>>>>>        End
11385>>>>>>
11385>>>>>        Else Begin
11386>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
11387>>>>>        End
11387>>>>>>
11387>>>>>        
11387>>>>>        Function_Return iVariableDataType
11388>>>>>    End_Function
11389>>>>>    
11389>>>>>    
11389>>>>>    // Return the value of a column in a fetched row of a given
11389>>>>>    // statement.
11389>>>>>    Function SQLColumnValue Integer iCol Returns String
11391>>>>>        Integer ihdbc
11391>>>>>        Integer ihstmt
11391>>>>>        String  sDrvrId sResult
11391>>>>>        Longptr pResultWStr
11391>>>>>        
11391>>>>>        Integer iVoid
11391>>>>>        Integer iColSize
11391>>>>>        Integer iColPrecision
11391>>>>>        String  sEmpty
11391>>>>>        Integer bLegalColumn
11391>>>>>        
11391>>>>>        // Initialize
11391>>>>>        Move "" to sResult
11392>>>>>        
11392>>>>>        // Get the cli handles
11392>>>>>        Get phCLIStatementHandle  to ihstmt
11393>>>>>        Get phCLIConnectionHandle to ihdbc
11394>>>>>        Get psDriverId            to sDrvrId
11395>>>>>        
11395>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11395>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
11395>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
11395>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11397>>>>>            // Setup function arguments
11397>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
11402>>>>>            Move ihstmt to giLastSQLhstmt
11403>>>>>            Move ihdbc to giLastSQLhdbc
11404>>>>>        End
11404>>>>>>
11404>>>>>        
11404>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11406>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
11411>>>>>            
11411>>>>>            If (pResultWStr) Begin
11413>>>>>                Move (PointerToWString(pResultWStr)) to sResult
11414>>>>>            End
11414>>>>>>
11414>>>>>            Else Begin
11415>>>>>                Move "" to sResult
11416>>>>>            End
11416>>>>>>
11416>>>>>        End
11416>>>>>>
11416>>>>>        Else Begin
11417>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
11418>>>>>        End
11418>>>>>>
11418>>>>>        
11418>>>>>        Function_Return sResult
11419>>>>>        
11419>>>>>    End_Function
11420>>>>>    
11420>>>>>    // Add a file to the files used to place the statement result in.
11420>>>>>    Procedure SQLBindFile Integer iFileNum
11422>>>>>        Integer ihdbc
11422>>>>>        Integer ihstmt
11422>>>>>        Integer iVoid
11422>>>>>        String  sDrvrId
11422>>>>>        String  sFileType
11422>>>>>        Integer bIsOpen
11422>>>>>        
11422>>>>>        // Get the cli handles
11422>>>>>        Get phCLIStatementHandle  to ihstmt
11423>>>>>        Get phCLIConnectionHandle to ihdbc
11424>>>>>        Get psDriverId            to sDrvrId
11425>>>>>        
11425>>>>>        // If a file number is not passed see if we can use the statement's
11425>>>>>        // default file number which is usually set with SetFileConnection
11425>>>>>        If (iFileNum = 0) Begin
11427>>>>>            Get piBindFile to iFileNum
11428>>>>>            If (iFileNum = 0) Begin
11430>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
11430>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
11431>>>>>                
11431>>>>>                Move 0 to SQLResult
11432>>>>>                Procedure_Return
11433>>>>>            End
11433>>>>>>
11433>>>>>        End
11433>>>>>>
11433>>>>>        
11433>>>>>        // Bind the file
11433>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11435>>>>>            // Chek if the file is open
11435>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
11438>>>>>            If (bIsOpen) Begin
11440>>>>>                // Check if the file has the correct type
11440>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
11443>>>>>                If (sFileType = sDrvrId) Begin
11445>>>>>                    // Call the driver function to add a file to a statement
11445>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
11450>>>>>                End
11450>>>>>>
11450>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
11452>>>>>            End
11452>>>>>>
11452>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
11454>>>>>        End
11454>>>>>>
11454>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
11456>>>>>    End_Procedure
11457>>>>>    
11457>>>>>    
11457>>>>>    
11457>>>>>    // Get data of a column.                                  
11457>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
11459>>>>>        Integer ihdbc
11459>>>>>        Integer ihstmt
11459>>>>>        Integer iVoid
11459>>>>>        Integer iColSize
11459>>>>>        Integer iResult
11459>>>>>        String  sDrvrId
11459>>>>>        WString wResult
11459>>>>>        String  sEmpty
11459>>>>>        Integer bLegalColumn
11459>>>>>        
11459>>>>>        Integer iVariableBufferLength
11459>>>>>        
11459>>>>>        // Initialize
11459>>>>>        Move "" to sEmpty
11460>>>>>        Move 0 to iResult
11461>>>>>        
11461>>>>>        // Get the cli handles
11461>>>>>        Get phCLIStatementHandle  to ihstmt
11462>>>>>        Get phCLIConnectionHandle to ihdbc
11463>>>>>        Get psDriverId            to sDrvrId
11464>>>>>        
11464>>>>>        // Get the data
11464>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11466>>>>>            // Check if the column exists
11466>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11468>>>>>                If (iLen = 0) Begin
11470>>>>>                    Get SQLColumnValue iCol to wResult
11471>>>>>                End
11471>>>>>>
11471>>>>>                Else Begin
11472>>>>>                    // Add 1 for string terminator
11472>>>>>                    Move (iLen + 1) to iLen
11473>>>>>                    
11473>>>>>                    Get piVariableBufferLength to iVariableBufferLength
11474>>>>>                    If (iLen > iVariableBufferLength) Begin
11476>>>>>                        // Allocate
11476>>>>>                        Move (Repeat(' ', iLen)) to wResult
11477>>>>>                        
11477>>>>>                        Set piVariableBufferLength to iLen
11478>>>>>                        Set psVariableBuffer       to wResult
11479>>>>>                    End
11479>>>>>>
11479>>>>>                    Else Begin
11480>>>>>                        Get psVariableBuffer       to wResult
11481>>>>>                    End
11481>>>>>>
11481>>>>>                    
11481>>>>>                    
11481>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11481>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
11481>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
11481>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11483>>>>>                        // Setup function arguments
11483>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
11488>>>>>                        Move ihstmt to giLastSQLhstmt
11489>>>>>                        Move ihdbc to giLastSQLhdbc
11490>>>>>                    End
11490>>>>>>
11490>>>>>                    
11490>>>>>                    Move False to Err
11491>>>>>                    // Call the driver function to get the data
11491>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
11496>>>>>                    
11496>>>>>                    // If something went wrong, adjust the result
11496>>>>>                    If (Err) Begin
11498>>>>>                        Move 0 to iResult
11499>>>>>                    End
11499>>>>>>
11499>>>>>                    
11499>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11499>>>>>                    If (iResult = -4) Begin
11501>>>>>                        Move (SizeOfWString(wResult)) to iResult
11502>>>>>                    End
11502>>>>>>
11502>>>>>                End
11502>>>>>>
11502>>>>>            End
11502>>>>>>
11502>>>>>            Else Begin
11503>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11504>>>>>            End
11504>>>>>>
11504>>>>>        End
11504>>>>>>
11504>>>>>        Else Begin
11505>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11506>>>>>        End
11506>>>>>>
11506>>>>>        
11506>>>>>        // Fill global result
11506>>>>>        If (iResult > 0) Begin
11508>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11509>>>>>        End
11509>>>>>>
11509>>>>>        Else Begin
11510>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11511>>>>>        End
11511>>>>>>
11511>>>>>        
11511>>>>>        Function_Return (CString(wResult))
11512>>>>>    End_Function
11513>>>>>
11513>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
11513>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
11513>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
11515>>>>>        Integer ihdbc
11515>>>>>        Integer ihstmt
11515>>>>>        Integer iVoid
11515>>>>>        Integer iColSize
11515>>>>>        Integer iResult
11515>>>>>        String  sDrvrId
11515>>>>>        UChar[] uaResult
11516>>>>>        
11516>>>>>        Integer iSQLType
11516>>>>>        Integer iBinaryType
11516>>>>>        Integer iLenArray
11516>>>>>        Integer iResizeSize
11516>>>>>        
11516>>>>>        Move 0 to iResult
11517>>>>>        
11517>>>>>        // Get the cli handles
11517>>>>>        Get phCLIStatementHandle  to ihstmt
11518>>>>>        Get phCLIConnectionHandle to ihdbc
11519>>>>>        Get psDriverId            to sDrvrId
11520>>>>>        
11520>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11522>>>>>            // Check if the column exists
11522>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11524>>>>>                            
11524>>>>>                Get SQLColumnType iCol to iSQLType
11525>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
11527>>>>>                    Move 1 to iBinaryType
11528>>>>>                End
11528>>>>>>
11528>>>>>                Else Begin
11529>>>>>                    Move 0 to iBinaryType 
11530>>>>>                End
11530>>>>>>
11530>>>>>    
11530>>>>>                If (iBinaryType) Begin
11532>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
11533>>>>>                End
11533>>>>>>
11533>>>>>                Else Begin
11534>>>>>                    // Character type
11534>>>>>                    // returned as wstring (2 bytes per character)
11534>>>>>                    // Add 1 for string terminator
11534>>>>>                    Move (iLen + 1) to iLen
11535>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
11536>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
11537>>>>>                End
11537>>>>>>
11537>>>>>
11537>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11537>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
11537>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11539>>>>>                    // Setup function arguments
11539>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11544>>>>>                    Move ihstmt to giLastSQLhstmt
11545>>>>>                    Move ihdbc to giLastSQLhdbc
11546>>>>>                End
11546>>>>>>
11546>>>>>                
11546>>>>>                Move False to Err
11547>>>>>                
11547>>>>>                // Call the driver function to get the data
11547>>>>>                // iResult will be the length of the data in bytes 
11547>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
11552>>>>>                
11552>>>>>                // If something went wrong, adjust the result
11552>>>>>                If (Err) Begin
11554>>>>>                    Move 0 to iResult
11555>>>>>                End
11555>>>>>>
11555>>>>>                
11555>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11555>>>>>                If (iResult = -4) Begin
11557>>>>>                    Move (SizeOfArray(uaResult)) to iResult
11558>>>>>                End
11558>>>>>>
11558>>>>>                
11558>>>>>                If (iBinaryType) Begin
11560>>>>>                    If (iResult < iLen) Begin
11562>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
11563>>>>>                    End
11563>>>>>>
11563>>>>>                End
11563>>>>>>
11563>>>>>                Else Begin
11564>>>>>                    // Character data
11564>>>>>                    //   iResult has length of data in bytes (without zero terminator)
11564>>>>>                    //   uaResult will have data + zero terminator
11564>>>>>                    If (iResult < (iLenArray - 2) ) Begin
11566>>>>>                        // Received less than requested, strip off trailing zeroes.
11566>>>>>                        Move iResult to iResizeSize
11567>>>>>                    End
11567>>>>>>
11567>>>>>                    Else Begin
11568>>>>>                        // Strip off zero terminator
11568>>>>>                        Move (iLenArray - 2) to iResizeSize
11569>>>>>                    End
11569>>>>>>
11569>>>>>                    
11569>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
11570>>>>>                    
11570>>>>>                End
11570>>>>>>
11570>>>>>            End
11570>>>>>>
11570>>>>>            Else Begin
11571>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11572>>>>>            End
11572>>>>>>
11572>>>>>        End
11572>>>>>>
11572>>>>>        Else Begin
11573>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11574>>>>>        End
11574>>>>>>
11574>>>>>        
11574>>>>>        // Fill global result
11574>>>>>        If (iResult > 0) Begin
11576>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11577>>>>>        End
11577>>>>>>
11577>>>>>        Else Begin
11578>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11579>>>>>        End
11579>>>>>>
11579>>>>>        
11579>>>>>        Function_Return uaResult
11580>>>>>
11580>>>>>    End_Function
11581>>>>>    
11581>>>>>    
11581>>>>>    // Map a column name to a number, if the name id not found no
11581>>>>>    // error is generated the returned number will be 0 (zero) in
11581>>>>>    // that case
11581>>>>>    Function SQLColumnMap String sColname Returns Integer
11583>>>>>        Integer ihdbc
11583>>>>>        Integer ihstmt
11583>>>>>        Integer iNumColumns
11583>>>>>        Integer iColCount
11583>>>>>        Integer iColNum
11583>>>>>        String  sDrvrId
11583>>>>>        String  sCurColName
11583>>>>>        
11583>>>>>        // Get the cli handles
11583>>>>>        Get phCLIStatementHandle  to ihstmt
11584>>>>>        Get phCLIConnectionHandle to ihdbc
11585>>>>>        Get psDriverId            to sDrvrId
11586>>>>>        
11586>>>>>        // Get the number by looping through the column names
11586>>>>>        Move 0 to iColNum
11587>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11588>>>>>        For iColCount from 1 to iNumColumns
11594>>>>>>
11594>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
11595>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
11598>>>>>            
11598>>>>>            If (iColNum) ;                Break
11601>>>>>        Loop
11602>>>>>>
11602>>>>>        
11602>>>>>        Function_Return iColNum
11603>>>>>    End_Function
11604>>>>>    
11604>>>>>    
11604>>>>>    // SQLStmtAttribute
11604>>>>>    // Moved to SQLGetStatementAttribute. 
11604>>>>>    // This function is still here for backward compatibility.
11604>>>>>
11604>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
11606>>>>>        String  sResult
11606>>>>>
11606>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
11607>>>>>        
11607>>>>>        Function_Return sResult
11608>>>>>    End_Function
11609>>>>>
11609>>>>> 
11609>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
11611>>>>>        Integer ihdbc
11611>>>>>        Integer ihstmt
11611>>>>>        String  sResult
11611>>>>>        String  sDrvrId
11611>>>>>        
11611>>>>>        // Initialize
11611>>>>>        Move "" to sResult
11612>>>>>        
11612>>>>>        // Get the cli handles
11612>>>>>        Get phCLIStatementHandle  to ihstmt
11613>>>>>        Get phCLIConnectionHandle to ihdbc
11614>>>>>        Get psDriverId            to sDrvrId
11615>>>>>        
11615>>>>>        // Get the attribute
11615>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
11618>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
11620>>>>>        
11620>>>>>        Function_Return sResult
11621>>>>>    End_Function
11622>>>>>
11622>>>>>    
11622>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
11624>>>>>
11624>>>>>        Integer ihdbc
11624>>>>>        Integer ihstmt
11624>>>>>        String  sDrvrId
11624>>>>>        
11624>>>>>        Integer iLen
11624>>>>>        Integer bLegalAttrib
11624>>>>>        Integer iVoid
11624>>>>>        Integer iAttribValue
11624>>>>>
11624>>>>>        Get phCLIStatementHandle  to ihstmt
11625>>>>>        Get phCLIConnectionHandle to ihdbc
11626>>>>>        Get psDriverId            to sDrvrId
11627>>>>>        
11627>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11629>>>>>            Case Begin
11629>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11631>>>>>                    Move DFTRUE to bLegalAttrib
11632>>>>>                    Break
11633>>>>>                    
11633>>>>>                Case Else
11633>>>>>                    Move DFFALSE to bLegalAttrib
11634>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
11635>>>>>            Case End
11635>>>>>
11635>>>>>            If (bLegalAttrib) Begin
11637>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
11639>>>>>                    
11639>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
11640>>>>>                    Case Begin
11640>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
11642>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
11645>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
11648>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
11651>>>>>                            Break
11652>>>>>                            
11652>>>>>                        Case Else
11652>>>>>                            Move DFFALSE to bLegalAttrib
11653>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
11654>>>>>
11654>>>>>                    Case End
11654>>>>>                End
11654>>>>>>
11654>>>>>            End
11654>>>>>>
11654>>>>>
11654>>>>>            
11654>>>>>            If (bLegalAttrib) Begin
11656>>>>>                
11656>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
11661>>>>>                
11661>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
11666>>>>>            End
11666>>>>>>
11666>>>>>        End
11666>>>>>>
11666>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11668>>>>>        
11668>>>>>        
11668>>>>>        
11668>>>>>    End_Procedure
11669>>>>>    
11669>>>>>    
11669>>>>>    
11669>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11671>>>>>        String  sResult
11671>>>>>        Integer iLen
11671>>>>>        Integer bLegalAttrib
11671>>>>>        
11671>>>>>        // Initialize
11671>>>>>        Move ""     to sResult
11672>>>>>        
11672>>>>>        // Get the attribute
11672>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11674>>>>>            Case Begin
11674>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
11676>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
11679>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
11682>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
11685>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11688>>>>>                    Move DFTRUE to bLegalAttrib
11689>>>>>                    Break
11690>>>>>                    
11690>>>>>                Case Else
11690>>>>>                    Move DFFALSE to bLegalAttrib
11691>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
11692>>>>>            Case End
11692>>>>>            
11692>>>>>            If (bLegalAttrib) Begin
11694>>>>>                // Setup function arguments
11694>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
11699>>>>>            End
11699>>>>>>
11699>>>>>        End
11699>>>>>>
11699>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11701>>>>>        
11701>>>>>        Function_Return sResult
11702>>>>>    End_Function
11703>>>>>    
11703>>>>>    
11703>>>>>    
11703>>>>>    // Get a column's attribute
11703>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
11705>>>>>        Integer ihdbc
11705>>>>>        Integer ihstmt
11705>>>>>        String  sResult
11705>>>>>        String  sDrvrId
11705>>>>>        
11705>>>>>        // Initialize
11705>>>>>        Move "" to sResult
11706>>>>>        
11706>>>>>        // Get the cli handles
11706>>>>>        Get phCLIStatementHandle  to ihstmt
11707>>>>>        Get phCLIConnectionHandle to ihdbc
11708>>>>>        Get psDriverId            to sDrvrId
11709>>>>>        
11709>>>>>        // Get the attribute
11709>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
11712>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
11714>>>>>        
11714>>>>>        Function_Return sResult
11715>>>>>    End_Function
11716>>>>>    
11716>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11718>>>>>        String  sResult
11718>>>>>        String  sEmpty
11718>>>>>        Integer bIsStringAttribute
11718>>>>>        Integer iLen
11718>>>>>        Integer iVoid
11718>>>>>        Integer bLegalAttrib
11718>>>>>        Integer bLegalColumn
11718>>>>>        
11718>>>>>        // Initialize
11718>>>>>        Move "" to sResult
11719>>>>>        Move "" to sEmpty
11720>>>>>        Move 0  to iLen
11721>>>>>        
11721>>>>>        // Get the attribute
11721>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11723>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
11724>>>>>            If (bLegalColumn) Begin
11726>>>>>                // Determine the atributes type
11726>>>>>                Case Begin
11726>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
11728>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
11731>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
11734>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
11737>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
11740>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
11743>>>>>                        Move DFFALSE to bIsStringAttribute
11744>>>>>                        Move DFTRUE to bLegalAttrib
11745>>>>>                        Break
11746>>>>>                        
11746>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
11749>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
11752>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
11755>>>>>                        Move DFTRUE to bIsStringAttribute
11756>>>>>                        Move DFTRUE to bLegalAttrib
11757>>>>>                        Break
11758>>>>>                        
11758>>>>>                    Case Else
11758>>>>>                        Move DFFALSE to bLegalAttrib
11759>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
11760>>>>>                Case End
11760>>>>>                
11760>>>>>                If (bLegalAttrib) Begin
11762>>>>>                    // Setup function arguments
11762>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11767>>>>>                    
11767>>>>>                    If (bIsStringAttribute) Begin
11769>>>>>                        // Call the driver function to get the data length
11769>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
11774>>>>>                        
11774>>>>>                        If (iLen) Begin
11776>>>>>                            // Allocate
11776>>>>>                            Move (Repeat(' ', iLen)) to sResult
11777>>>>>                            
11777>>>>>                            // Call the driver function to get the name
11777>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
11782>>>>>                        End
11782>>>>>>
11782>>>>>                    End
11782>>>>>>
11782>>>>>                    Else Begin
11783>>>>>                        // get the attribute
11783>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
11788>>>>>                    End
11788>>>>>>
11788>>>>>                End
11788>>>>>>
11788>>>>>            End
11788>>>>>>
11788>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
11790>>>>>        End
11790>>>>>>
11790>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
11792>>>>>        
11792>>>>>        Function_Return sResult
11793>>>>>    End_Function
11794>>>>>    
11794>>>>>    
11794>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
11794>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
11796>>>>>        Integer ihdbc
11796>>>>>        Integer ihstmt
11796>>>>>        String  sDrvrId
11796>>>>>        Integer iVoid
11796>>>>>        String  sSchema
11796>>>>>        String  sEmpty
11796>>>>>        
11796>>>>>        // Initialize
11796>>>>>        Move "" to sEmpty
11797>>>>>        
11797>>>>>        // Get the cli handles
11797>>>>>        Get phCLIStatementHandle  to ihstmt
11798>>>>>        Get phCLIConnectionHandle to ihdbc
11799>>>>>        Get psDriverId            to sDrvrId
11800>>>>>        
11800>>>>>        // Call the procedure
11800>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11802>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
11805>>>>>            Else ;                Move "" to sSchema
11807>>>>>            
11807>>>>>            If (sSchema <> "") Begin
11809>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
11814>>>>>            End
11814>>>>>>
11814>>>>>            
11814>>>>>            // Call the procedure
11814>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
11819>>>>>            
11819>>>>>            Set piLastArgument to 0
11820>>>>>        End
11820>>>>>>
11820>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
11822>>>>>    End_Procedure
11823>>>>>    
11823>>>>>    // Pass the next argument
11823>>>>>    Procedure SQLSetNextArgument String sArgument
11825>>>>>        Integer iArgnum
11825>>>>>        
11825>>>>>        Get piLastArgument to iArgnum
11826>>>>>        Increment iArgnum
11827>>>>>        Send SQLSetArgument iArgnum sArgument
11828>>>>>        Set piLastArgument to iArgnum
11829>>>>>    End_Procedure
11830>>>>>    
11830>>>>>    
11830>>>>>    
11830>>>>>    // Set the next argument
11830>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
11832>>>>>        Integer ihdbc
11832>>>>>        Integer ihstmt
11832>>>>>        String  sDrvrId
11832>>>>>        Integer iVoid
11832>>>>>        String  sEmpty
11832>>>>>        
11832>>>>>        // Initialize
11832>>>>>        Move "" to sEmpty
11833>>>>>        
11833>>>>>        // Get the cli handles
11833>>>>>        Get phCLIStatementHandle  to ihstmt
11834>>>>>        Get phCLIConnectionHandle to ihdbc
11835>>>>>        Get psDriverId            to sDrvrId
11836>>>>>        
11836>>>>>        // Call the procedure
11836>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11838>>>>>            // Pass the information
11838>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
11843>>>>>            
11843>>>>>            // Pass the argument
11843>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
11848>>>>>        End
11848>>>>>>
11848>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
11850>>>>>    End_Procedure
11851>>>>>    
11851>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
11853>>>>>        Integer iParamNum 
11853>>>>>        Integer iType
11853>>>>>        
11853>>>>>        If (num_arguments < 2) Begin
11855>>>>>            Move typeString to iType
11856>>>>>        End
11856>>>>>>
11856>>>>>        Else Begin
11857>>>>>            Move iParamType to iType
11858>>>>>        End
11858>>>>>>
11858>>>>>        
11858>>>>>        Get piLastArgument to iParamNum
11859>>>>>        Increment iParamNum
11860>>>>>        Send SQLSetParameter iParamNum sParamValue iType
11861>>>>>        Set piLastArgument to iParamNum
11862>>>>>    End_Procedure
11863>>>>>
11863>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
11865>>>>>        
11865>>>>>        Integer ihdbc
11865>>>>>        Integer ihstmt
11865>>>>>        String  sDrvrId
11865>>>>>        Integer iVoid
11865>>>>>        String  sEmpty
11865>>>>>        Integer iType
11865>>>>>        
11865>>>>>        If (num_arguments < 3) Begin
11867>>>>>            Move typeString to iType
11868>>>>>        End
11868>>>>>>
11868>>>>>        Else Begin
11869>>>>>            Move iParamType to iType
11870>>>>>        End
11870>>>>>>
11870>>>>>        
11870>>>>>        Case Begin
11870>>>>>            Case (iType = typeDate )    
11872>>>>>
11872>>>>>                If (sParamValue <> "") Begin
11874>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
11875>>>>>                End
11875>>>>>>
11875>>>>>                
11875>>>>>                Break
11876>>>>>
11876>>>>>            Case (iType = typeDatetime )    
11879>>>>>
11879>>>>>                If (sParamValue <> "") Begin
11881>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
11882>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
11883>>>>>                End
11883>>>>>>
11883>>>>>
11883>>>>>                Break
11884>>>>>
11884>>>>>            Case (iType = typeNumber )    
11887>>>>>
11887>>>>>                If (sParamValue <> "") Begin
11889>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
11890>>>>>                End
11890>>>>>>
11890>>>>>                
11890>>>>>                Break
11891>>>>>            
11891>>>>>            Case (iType = typeTime )    
11894>>>>>
11894>>>>>                If (sParamValue <> "") Begin
11896>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
11897>>>>>                End
11897>>>>>>
11897>>>>>                
11897>>>>>                Break
11898>>>>>                
11898>>>>>            Case Else
11898>>>>>                    // sParamValue is a string type or a type that must be passed as a string
11898>>>>>                    Break
11899>>>>>                
11899>>>>>        Case End
11899>>>>>        
11899>>>>>        
11899>>>>>        // Initialize
11899>>>>>        Move "" to sEmpty
11900>>>>>        
11900>>>>>        // Get the cli handles
11900>>>>>        Get phCLIStatementHandle  to ihstmt
11901>>>>>        Get phCLIConnectionHandle to ihdbc
11902>>>>>        Get psDriverId            to sDrvrId
11903>>>>>        
11903>>>>>        // Call the procedure
11903>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11905>>>>>            // Pass the information
11905>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
11910>>>>>            
11910>>>>>            // Pass the argument
11910>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
11915>>>>>        End
11915>>>>>>
11915>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
11917>>>>>    End_Procedure
11918>>>>>    
11918>>>>>    
11918>>>>>    // Call a stored procedure
11918>>>>>    Procedure SQLCall
11920>>>>>        Integer ihdbc
11920>>>>>        Integer ihstmt
11920>>>>>        String  sDrvrId
11920>>>>>        Integer iVoid
11920>>>>>        String  sEmpty
11920>>>>>        
11920>>>>>        // Initialize
11920>>>>>        Move "" to sEmpty
11921>>>>>        
11921>>>>>        // Get the cli handles
11921>>>>>        Get phCLIStatementHandle  to ihstmt
11922>>>>>        Get phCLIConnectionHandle to ihdbc
11923>>>>>        Get psDriverId            to sDrvrId
11924>>>>>        
11924>>>>>        // Call the procedure
11924>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11926>>>>>            // Call the procedure
11926>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11931>>>>>            
11931>>>>>            Send SQLGetStatementAttributes
11932>>>>>            Set piLastArgument to 0
11933>>>>>        End
11933>>>>>>
11933>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
11935>>>>>    End_Procedure
11936>>>>>    
11936>>>>>    
11936>>>>>    // Get the next argument
11936>>>>>    Function SQLGetNextArgument Returns String
11938>>>>>        Integer iArgnum
11938>>>>>        String  sResult
11938>>>>>        
11938>>>>>        Get piLastArgument to iArgnum
11939>>>>>        Increment iArgnum
11940>>>>>        Get SQLGetArgument iArgnum to sResult
11941>>>>>        Set piLastArgument to iArgnum
11942>>>>>        
11942>>>>>        Function_Return sResult
11943>>>>>    End_Function
11944>>>>>    
11944>>>>>    
11944>>>>>    
11944>>>>>    // Get the specified argument from a procedure
11944>>>>>    Function SQLGetArgument Integer iArgnum Returns String
11946>>>>>        Integer ihdbc
11946>>>>>        Integer ihstmt
11946>>>>>        String  sDrvrId
11946>>>>>        Integer iVoid
11946>>>>>        String  sEmpty
11946>>>>>        String  sArgument
11946>>>>>        Integer iLen
11946>>>>>        
11946>>>>>        // Initialize
11946>>>>>        Move "" to sEmpty
11947>>>>>        Move "" to sArgument
11948>>>>>        
11948>>>>>        // Get the cli handles
11948>>>>>        Get phCLIStatementHandle  to ihstmt
11949>>>>>        Get phCLIConnectionHandle to ihdbc
11950>>>>>        Get psDriverId            to sDrvrId
11951>>>>>        
11951>>>>>        // Call the procedure
11951>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11953>>>>>            // Pass the information
11953>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
11958>>>>>            
11958>>>>>            // Get the length
11958>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
11963>>>>>            
11963>>>>>            If (iLen) Begin
11965>>>>>                // Allocate
11965>>>>>                Move (Repeat(' ', iLen)) to sArgument
11966>>>>>                
11966>>>>>                // Pass the argument
11966>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
11971>>>>>            End
11971>>>>>>
11971>>>>>        End
11971>>>>>>
11971>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
11973>>>>>        
11973>>>>>        Function_Return sArgument
11974>>>>>    End_Function
11975>>>>>    
11975>>>>>    
11975>>>>>    // Get the return value of a stored function
11975>>>>>    Function SQLReturnValue Returns String
11977>>>>>        Integer ihdbc
11977>>>>>        Integer ihstmt
11977>>>>>        String  sDrvrId
11977>>>>>        Integer iVoid
11977>>>>>        String  sEmpty
11977>>>>>        String  sRetval
11977>>>>>        Integer iLen
11977>>>>>        
11977>>>>>        // Initialize
11977>>>>>        Move "" to sEmpty
11978>>>>>        Move "" to sRetval
11979>>>>>        
11979>>>>>        // Get the cli handles
11979>>>>>        Get phCLIStatementHandle  to ihstmt
11980>>>>>        Get phCLIConnectionHandle to ihdbc
11981>>>>>        Get psDriverId            to sDrvrId
11982>>>>>        
11982>>>>>        // Call the procedure
11982>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11984>>>>>            // Get the length
11984>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
11989>>>>>            
11989>>>>>            If (iLen) Begin
11991>>>>>                // Allocate
11991>>>>>                Move (Repeat(' ', iLen)) to sRetval
11992>>>>>                
11992>>>>>                // Pass the argument
11992>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
11997>>>>>            End
11997>>>>>>
11997>>>>>        End
11997>>>>>>
11997>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
11999>>>>>        
11999>>>>>        Function_Return sRetval
12000>>>>>    End_Function
12001>>>>>    
12001>>>>>    
12001>>>>>    // Switch to the next set
12001>>>>>    // Returns : 0   = No more result sets
12001>>>>>    //     <>0 = Switched to next set
12001>>>>>    Function SQLNextResultSet Returns Integer
12003>>>>>        Integer ihdbc
12003>>>>>        Integer ihstmt
12003>>>>>        String  sDrvrId
12003>>>>>        Integer iResult
12003>>>>>        String  sEmpty
12003>>>>>        
12003>>>>>        // Initialize
12003>>>>>        Move "" to sEmpty
12004>>>>>        Move 0  to iResult
12005>>>>>        
12005>>>>>        // Get the cli handles
12005>>>>>        Get phCLIStatementHandle  to ihstmt
12006>>>>>        Get phCLIConnectionHandle to ihdbc
12007>>>>>        Get psDriverId            to sDrvrId
12008>>>>>        
12008>>>>>        // Call the procedure
12008>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12010>>>>>            // Get the length
12010>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
12015>>>>>            
12015>>>>>            Send SQLGetStatementAttributes
12016>>>>>            Set piLastArgument to 0
12017>>>>>        End
12017>>>>>>
12017>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
12019>>>>>        
12019>>>>>        Function_Return iResult
12020>>>>>    End_Function
12021>>>>>    
12021>>>>>    
12021>>>>>    // Setup a file that will be acivated after a succesfull
12021>>>>>    //fetch on the statement
12021>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
12023>>>>>        Integer ihdbc
12023>>>>>        Integer ihstmt
12023>>>>>        String  sDrvrId
12023>>>>>        Integer iResult
12023>>>>>        Integer bIsOpen
12023>>>>>        Integer iVoid
12023>>>>>        String  sFileType
12023>>>>>        
12023>>>>>        // Check if file is open
12023>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12026>>>>>        If (bIsOpen) Begin
12028>>>>>            // Get the cli handles
12028>>>>>            Get phCLIStatementHandle  to ihstmt
12029>>>>>            Get phCLIConnectionHandle to ihdbc
12030>>>>>            Get psDriverId            to sDrvrId
12031>>>>>            
12031>>>>>            // Call the procedure
12031>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12033>>>>>                // Check if the file has the correct type
12033>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
12036>>>>>                If (sFileType = sDrvrId) Begin
12038>>>>>                    // Setup the buffer
12038>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
12043>>>>>                End
12043>>>>>>
12043>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
12045>>>>>            End
12045>>>>>>
12045>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
12047>>>>>        End
12047>>>>>>
12047>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
12049>>>>>    End_Procedure
12050>>>>>    
12050>>>>>    
12050>>>>>    
12050>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
12052>>>>>        Integer ihdbc
12052>>>>>        Integer ihstmt
12052>>>>>        String  sDrvrId
12052>>>>>        String  sMessage
12052>>>>>        Integer iVoid
12052>>>>>        
12052>>>>>        // Initialize
12052>>>>>        Move "" to sMessage
12053>>>>>        
12053>>>>>        // Get the cli handles
12053>>>>>        Get phCLIStatementHandle  to ihstmt
12054>>>>>        Get phCLIConnectionHandle to ihdbc
12055>>>>>        Get psDriverId            to sDrvrId
12056>>>>>        
12056>>>>>        // Call the procedure
12056>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12058>>>>>            // Setup function arguments
12058>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
12063>>>>>            
12063>>>>>            Move (Repeat(' ', 1024)) to sMessage
12064>>>>>            // Get the length
12064>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
12069>>>>>        End
12069>>>>>>
12069>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
12071>>>>>        
12071>>>>>        Function_Return sMessage
12072>>>>>    End_Function
12073>>>>>    
12073>>>>>    
12073>>>>>    
12073>>>>>    // Remove the component identifier from a diagnostic message
12073>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
12075>>>>>        While (Left(sDiagMessage, 1) = "[")
12079>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
12080>>>>>        Loop
12081>>>>>>
12081>>>>>        
12081>>>>>        Function_Return sDiagMessage
12082>>>>>    End_Function
12083>>>>>    
12083>>>>>    
12083>>>>>    
12083>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
12083>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
12085>>>>>        
12085>>>>>        Integer iType
12085>>>>>        String  sSQLDate
12085>>>>>        Integer iOrgDateFmt
12085>>>>>        Integer iOrgDateSep
12085>>>>>        
12085>>>>>        String sDriverId
12085>>>>>        String sDummyZeroDate
12085>>>>>        String sDummyZeroDateMssqlDatetime
12085>>>>>        
12085>>>>>        // Change date format to military, SQL dates are military dates
12085>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12088>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12091>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12094>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12097>>>>>        
12097>>>>>        // We only need to convert if the date is 0
12097>>>>>        If (Integer(dDFDate = 0)) Begin
12099>>>>>            
12099>>>>>            If (num_arguments < 2) Begin
12101>>>>>                Move SQL_TYPE_TIMESTAMP to iType
12102>>>>>            End
12102>>>>>>
12102>>>>>            Else Begin
12103>>>>>                Move iSQLType to iType
12104>>>>>            End
12104>>>>>>
12104>>>>>            
12104>>>>>            
12104>>>>>            Get psDriverID to sDriverId
12105>>>>>            Get psDummyZeroDate to sDummyZeroDate
12106>>>>>            
12106>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
12108>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12109>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
12110>>>>>            End
12110>>>>>>
12110>>>>>            Else Begin
12111>>>>>                Move sDummyZeroDate to sSQLDate
12112>>>>>            End
12112>>>>>>
12112>>>>>            
12112>>>>>        End
12112>>>>>>
12112>>>>>        Else Begin
12113>>>>>            Move dDFDate to sSQLDate
12114>>>>>        End
12114>>>>>>
12114>>>>>        
12114>>>>>        // Change date format back to original
12114>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12117>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12120>>>>>        
12120>>>>>        Function_Return sSQLDate
12121>>>>>    End_Function
12122>>>>>    
12122>>>>>    
12122>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
12122>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
12124>>>>>        
12124>>>>>        Integer iType
12124>>>>>        Date    dDFDate
12124>>>>>        Integer iOrgDateFmt
12124>>>>>        Integer iOrgDateSep
12124>>>>>        
12124>>>>>        String  sDriverId
12124>>>>>        String  sDummyZeroDate
12124>>>>>        String  sDummyZeroDateMssqlDatetime
12124>>>>>        
12124>>>>>        Get psDriverID to sDriverId
12125>>>>>        
12125>>>>>        Get psDummyZeroDate to sDummyZeroDate
12126>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12127>>>>>        
12127>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12130>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12133>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12136>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12139>>>>>        
12139>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
12140>>>>>        
12140>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
12142>>>>>            Move 0 to dDFDate
12143>>>>>        End
12143>>>>>>
12143>>>>>        Else Begin
12144>>>>>            Move sSQLDate to dDFDate
12145>>>>>        End
12145>>>>>>
12145>>>>>        
12145>>>>>        // Change date format back to original
12145>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12148>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12151>>>>>        
12151>>>>>        Function_Return dDFDate
12152>>>>>    End_Function
12153>>>>>    
12153>>>>>End_Class
12154>>>>>
12154>>>>>
12154>>>>>// Connection object for embedded SQL                          
12154>>>>>// This provides the ability to create a connection for a driver.     
12154>>>>>// It will contain child statement objects                            
12154>>>>>
12154>>>>>Class cSQLConnection is a cObject
12155>>>>>    
12155>>>>>    Procedure Construct_object
12157>>>>>        Forward Send Construct_object
12159>>>>>        
12159>>>>>        Property Integer phCLIConnectionHandle       0
12160>>>>>        
12160>>>>>        Property String  psDriverID        ""
12161>>>>>        Property Integer piBindFile        0
12162>>>>>        
12162>>>>>        Property String psDummyZeroDate              '0001-01-01'
12163>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
12164>>>>>        
12164>>>>>    End_Procedure
12165>>>>>    
12165>>>>>    
12165>>>>>    
12165>>>>>    // Store basic information about the connection
12165>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
12167>>>>>        
12167>>>>>        String sDummyZeroDate
12167>>>>>        Integer iDriverIndex
12167>>>>>        
12167>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
12168>>>>>        Set psDriverID            to sDrvrId
12169>>>>>        
12169>>>>>        Case Begin
12169>>>>>            Case (sDrvrId = "MSSQLDRV")
12171>>>>>                Set psDummyZeroDate to '0001-01-01'
12172>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
12173>>>>>                Break
12174>>>>>            Case (sDrvrId = "DB2_DRV")
12177>>>>>                Set psDummyZeroDate to '0001-01-01'
12178>>>>>                Break
12179>>>>>            Case (sDrvrId = "ODBC_DRV")
12182>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
12183>>>>>                If (iDriverIndex <> 0) Begin
12185>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
12188>>>>>                End
12188>>>>>>
12188>>>>>                Else Begin
12189>>>>>                    Move '0001-01-01' to sDummyZeroDate
12190>>>>>                End
12190>>>>>>
12190>>>>>
12190>>>>>                Set psDummyZeroDate to sDummyZeroDate
12191>>>>>                Break
12192>>>>>                
12192>>>>>        Case End
12192>>>>>        
12192>>>>>    End_Procedure
12193>>>>>    
12193>>>>>    Function DriverIndex String sDriver Returns Integer
12195>>>>>        
12195>>>>>        String  sCurrentDriver
12195>>>>>        Integer iNumberOfDrivers iDriver iCount
12195>>>>>        
12195>>>>>        Move 0 to iDriver
12196>>>>>        
12196>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
12199>>>>>        For iCount from 1 to iNumberOfDrivers
12205>>>>>>
12205>>>>>            
12205>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
12208>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
12210>>>>>                Move iCount to iDriver
12211>>>>>            End
12211>>>>>>
12211>>>>>        Loop
12212>>>>>>
12212>>>>>        
12212>>>>>        Function_Return iDriver
12213>>>>>        
12213>>>>>    End_Function
12214>>>>>
12214>>>>>    
12214>>>>>    // Destroy the SQLConnection object
12214>>>>>    Procedure DestroySQLConnection
12216>>>>>        Send Destroy
12217>>>>>    End_Procedure
12218>>>>>    
12218>>>>>    
12218>>>>>    // Connect to a database server
12218>>>>>    // Returns : 1 Succesfully connected
12218>>>>>    //           0 Not connected
12218>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12220>>>>>        Integer ihdbc
12220>>>>>        String  sEmpty
12220>>>>>        
12220>>>>>        // Initialize
12220>>>>>        Move "" to sEmpty
12221>>>>>        Move 0  to ihdbc
12222>>>>>        
12222>>>>>        Move False to Err
12223>>>>>        
12223>>>>>        // Call the driver function to connect
12223>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
12228>>>>>        
12228>>>>>        // If there was an error, make result invalid
12228>>>>>        If (Err) ;            Move 0 to ihdbc
12231>>>>>        
12231>>>>>        // Check result and store it
12231>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12234>>>>>        
12234>>>>>        // Return success status
12234>>>>>        Function_Return (ihdbc <> 0)
12235>>>>>    End_Function
12236>>>>>    
12236>>>>>    
12236>>>>>    // Use a connection of an already open file
12236>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
12238>>>>>        Integer ihdbc
12238>>>>>        Integer bIsOpen
12238>>>>>        String  sDrvrId
12238>>>>>        String  sEmpty
12238>>>>>        
12238>>>>>        // Initialize
12238>>>>>        Move "" to sEmpty
12239>>>>>        Move 0  to ihdbc
12240>>>>>        
12240>>>>>        // Check if file is open
12240>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12243>>>>>        If (bIsOpen) Begin
12245>>>>>            // Fill the driver id, assume longest is 255 characters
12245>>>>>            Move (Repeat(' ', 255)) to sDrvrId
12246>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12249>>>>>            
12249>>>>>            Move False to Err
12250>>>>>            
12250>>>>>            // Call the driver function to connect
12250>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
12255>>>>>            
12255>>>>>            // If there was an error, make result invalid
12255>>>>>            If (Err) ;                Move 0 to ihdbc
12258>>>>>            
12258>>>>>            // Check result and store it
12258>>>>>            If (ihdbc <> 0) Begin
12260>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
12260>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12263>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
12264>>>>>                
12264>>>>>                // Set filenum so it can be used for fetching
12264>>>>>                Set piBindFile to iFileNum
12265>>>>>            End
12265>>>>>>
12265>>>>>        End
12265>>>>>>
12265>>>>>        
12265>>>>>        // Return success status
12265>>>>>        Function_Return (ihdbc <> 0)
12266>>>>>    End_Function
12267>>>>>    
12267>>>>>    
12267>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12267>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12267>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12267>>>>>    // The connectstring must be an exact match, but can be case insensitive
12267>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
12267>>>>>    // If no matching connectstring is found, this function will return 0
12267>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12267>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12269>>>>>        Integer ihdbc
12269>>>>>        String  sEmpty
12269>>>>>        Integer iFileNum
12269>>>>>        
12269>>>>>        // Initialize
12269>>>>>        Move "" to sEmpty
12270>>>>>        Move 0  to ihdbc
12271>>>>>        
12271>>>>>        Move False to Err
12272>>>>>        
12272>>>>>        // Call the driver function
12272>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
12272>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
12272>>>>>        Move 0 to iFileNum
12273>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
12278>>>>>        
12278>>>>>        // If there was an error, make result invalid
12278>>>>>        If (Err) ;            Move 0 to ihdbc
12281>>>>>        
12281>>>>>        // Check result and store it
12281>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12284>>>>>        
12284>>>>>        // Return success status
12284>>>>>        Function_Return (ihdbc <> 0)
12285>>>>>    End_Function
12286>>>>>    
12286>>>>>    
12286>>>>>    // Disconnect from an embedded SQL server and free allocated
12286>>>>>    // resources
12286>>>>>    Procedure SQLDisconnect
12288>>>>>        Integer ihdbc
12288>>>>>        Integer iVoid
12288>>>>>        String  sDrvrId
12288>>>>>        String  sEmpty
12288>>>>>        
12288>>>>>        // Initialize
12288>>>>>        Move "" to sEmpty
12289>>>>>        
12289>>>>>        // Get the cli handle
12289>>>>>        Get phCLIConnectionHandle to ihdbc
12290>>>>>        Get psDriverId to sDrvrId
12291>>>>>        
12291>>>>>        // Free the CLI handle
12291>>>>>        If (ihdbc <> 0) Begin
12293>>>>>            // Call the driver function to disconnect
12293>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
12298>>>>>            
12298>>>>>            Move -1 to giLastSQLhdbc
12299>>>>>            
12299>>>>>            // Free the DataFlex handle
12299>>>>>            Send DestroySQLConnection
12300>>>>>        End
12300>>>>>>
12300>>>>>    End_Procedure
12301>>>>>    
12301>>>>>    // Create a cSQLStatement object
12301>>>>>    Function CreateSQLStatement Returns Handle
12303>>>>>        
12303>>>>>        Handle hoSQLStatement
12303>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
12304>>>>>        
12304>>>>>        // If the connection has a default Bind File, assign it to the
12304>>>>>        // statement object. The default is set when you open a file with a
12304>>>>>        // SetFileConnection command.
12304>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
12305>>>>>        
12305>>>>>        Function_Return hoSQLStatement
12306>>>>>    End_Function
12307>>>>>    
12307>>>>>    
12307>>>>>    // Open a statement for use
12307>>>>>    Function SQLOpen Returns Handle
12309>>>>>        Handle  hoSQLStatement
12309>>>>>        Integer ihdbc
12309>>>>>        Integer ihstmt
12309>>>>>        Integer iVoid
12309>>>>>        String  sDrvrId
12309>>>>>        String  sEmpty
12309>>>>>        String  sDummyZeroDate
12309>>>>>        String  sDummyZeroDateMssqlDatetime
12309>>>>>        
12309>>>>>        // Initialize
12309>>>>>        Move "" to sEmpty
12310>>>>>        
12310>>>>>        // Get the cli handle to the connection
12310>>>>>        Get phCLIConnectionHandle to ihdbc
12311>>>>>        Get psDriverId  to sDrvrId
12312>>>>>        
12312>>>>>        // Allocate a new handle and populate it
12312>>>>>        If (ihdbc <> 0) Begin
12314>>>>>            // Create a new cSQLStatement object
12314>>>>>            Get CreateSQLStatement to hoSQLStatement
12315>>>>>            
12315>>>>>            // Call the driver function to allocate a cli statement handle
12315>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
12320>>>>>            
12320>>>>>            // If unsuccessful destroy hoSQLStatement
12320>>>>>            If (ihstmt = 0) Begin
12322>>>>>                Send DestroySQLStatement of hoSQLStatement
12323>>>>>                Move 0 to hoSQLStatement
12324>>>>>            End
12324>>>>>>
12324>>>>>            Else Begin
12325>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
12326>>>>>                
12326>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
12326>>>>>                Get psDummyZeroDate              to sDummyZeroDate
12327>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12328>>>>>                
12328>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
12329>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
12330>>>>>                
12330>>>>>            End
12330>>>>>>
12330>>>>>        End
12330>>>>>>
12330>>>>>        
12330>>>>>        Function_Return hoSQLStatement
12331>>>>>    End_Function
12332>>>>>    
12332>>>>>End_Class
12333>>>>>
12333>>>>>// Manager for embedded SQL handles.                           
12333>>>>>// We want to be able to use multiple drivers and multiple            
12333>>>>>// connections within a driver and multiple statements within a       
12333>>>>>// connection. To allow this we have placed our own handle logic on   
12333>>>>>// top of the driver handle logic. This way we can handle the         
12333>>>>>// situation where two driver handles may be equal.                   
12333>>>>>
12333>>>>>Class cSQLHandleManager is a cObject
12334>>>>>    
12334>>>>>    Procedure Construct_object
12336>>>>>        Forward Send Construct_object
12338>>>>>        
12338>>>>>        Property String  psDefaultDriver      ""
12339>>>>>        Property String  psDefaultConnection  ""
12340>>>>>        
12340>>>>>    End_Procedure
12341>>>>>    
12341>>>>>    // Create a cSQLConnection object
12341>>>>>    Function CreateSQLConnection Returns Handle
12343>>>>>        Handle hoSQLConnection
12343>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
12344>>>>>        Function_Return hoSQLConnection
12345>>>>>    End_Function
12346>>>>>    
12346>>>>>    
12346>>>>>    // Store default connection information
12346>>>>>    Procedure SQLSetConnect String sDriver String sConnect
12348>>>>>        Set psDefaultDriver      to sDriver
12349>>>>>        Set psDefaultConnection  to sConnect
12350>>>>>    End_Procedure
12351>>>>>    
12351>>>>>    
12351>>>>>    // Make a connection to an embedded SQL server
12351>>>>>    // Returns : The DataFlex handle to the connection
12351>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12353>>>>>        Handle hoSQLConnection
12353>>>>>        Integer bOK
12353>>>>>        
12353>>>>>        // Check arguments
12353>>>>>        If (sDrvrID = "" and sConnect = "") Begin
12355>>>>>            Get psDefaultDriver      to sDrvrId
12356>>>>>            Get psDefaultConnection  to sConnect
12357>>>>>        End
12357>>>>>>
12357>>>>>        
12357>>>>>        // Create a cSQLConnection object
12357>>>>>        Get CreateSQLConnection to hoSQLConnection
12358>>>>>        // Connect to the database
12358>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
12359>>>>>        
12359>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12359>>>>>        If (not(bOK)) Begin
12361>>>>>            Send DestroySQLConnection of hoSQLConnection
12362>>>>>            Move 0 to hoSQLConnection
12363>>>>>        End
12363>>>>>>
12363>>>>>        
12363>>>>>        Function_Return hoSQLConnection
12364>>>>>    End_Function
12365>>>>>    
12365>>>>>    
12365>>>>>    
12365>>>>>    // Make an existing connection available for use with Embedded SQL.
12365>>>>>    // The connection is identified by the number of a file
12365>>>>>    // that is open for that connection.
12365>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
12367>>>>>        Handle hoSQLConnection
12367>>>>>        Integer bOK
12367>>>>>        
12367>>>>>        // Create a cSQLConnection object
12367>>>>>        Get CreateSQLConnection to hoSQLConnection
12368>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
12369>>>>>        
12369>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12369>>>>>        If (not(bOK)) Begin
12371>>>>>            Send DestroySQLConnection of hoSQLConnection
12372>>>>>            Move 0 to hoSQLConnection
12373>>>>>        End
12373>>>>>>
12373>>>>>        
12373>>>>>        Function_Return hoSQLConnection
12374>>>>>    End_Function
12375>>>>>    
12375>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12375>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12375>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12375>>>>>    // The connectstrings must be an exact match, but can be case insensitive
12375>>>>>    // If no matching connectstring is found, this function will return 0
12375>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12375>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12377>>>>>        Handle hoSQLConnection
12377>>>>>        Integer bOK
12377>>>>>        
12377>>>>>        // Check arguments
12377>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
12379>>>>>            Get psDefaultDriver      to sDrvrId
12380>>>>>            Get psDefaultConnection  to sConnectString
12381>>>>>        End
12381>>>>>>
12381>>>>>        
12381>>>>>        // Create a cSQLConnection object
12381>>>>>        Get CreateSQLConnection to hoSQLConnection
12382>>>>>        // Connect to the database
12382>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
12383>>>>>        
12383>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12383>>>>>        If (not(bOK)) Begin
12385>>>>>            Send DestroySQLConnection of hoSQLConnection
12386>>>>>            Move 0 to hoSQLConnection
12387>>>>>        End
12387>>>>>>
12387>>>>>        
12387>>>>>        Function_Return hoSQLConnection
12388>>>>>    End_Function
12389>>>>>    
12389>>>>>    
12389>>>>>End_Class
12390>>>Use cApplication.pkg
12390>>>
12390>>>// constants
12390>>>Define C_ConnectionId for "DFCONNID=" // symbol used in INT/SERVER for connection Id
12390>>>Define C_ConnectionIdCmdLineName for "dfconnid=" // left side of name used in command line argument for dfconnid.ini file
12390>>>Define C_ConnectionIniFileName for "DFConnId.ini" // default name of connections INI file.
12390>>>Define C_ConnectionIniSectionBaseName for "connection" // normally assumes a suffix like connection1, conneciton 2, etc.
12390>>>Define C_ConnectionIniSectionId for "id" // Name of connection id
12390>>>Define C_ConnectionIniSectionDriver for "driver" // left side of [id] section for driver
12390>>>Define C_ConnectionIniSectionConnection for "connection" // left side of [id] section for connection
12390>>>Define C_ConnectionIniSectionUID for "UID"
12390>>>Define C_ConnectionIniSectionPWD for "PWD"
12390>>>Define C_ConnectionIniSectionTrusted for "trusted_connection"
12390>>>Define C_ConnectionIniSectionDisabled for "disabled"
12390>>>
12390>>>// connection ID information
12390>>>Struct tConnection
12390>>>    String sId                // connection id
12390>>>    String sString            // server-string as added via the ini file
12390>>>    String sUID               // User Id
12390>>>    String sPWD               // non-encrypted password
12390>>>    Boolean bTrustedConnection // Trusted connection
12390>>>    Integer iOptions          // connection ID options (don't use)
12390>>>    String sDriver            // name of driver
12390>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
12390>>>    String sConnectionString  // Full connection string assembled from various strings
12390>>>    String sSection           // this is usually the section name as it appears
12390>>>    // in the connections ini file (e.g., [Connection1])
12390>>>    Boolean bDisabled         // if set, this is not an active Id
12390>>>End_Struct
12390>>>
12390>>>// used to search loaded (registered) drivers to find CLI connection handle
12390>>>Struct tDriverCLIDictionary
12390>>>    String sDriver // registered driver name
12390>>>    Handle hoCLI   // CLI handle of object created when driver was loaded
12390>>>End_Struct
12390>>>
12390>>>// privately used to write INI sections
12390>>>Struct tConnectionIniSection
12390>>>    String sSection // section INI name. Should be unique
12390>>>    String[] Keys
12390>>>    String[] Values
12390>>>End_Struct
12390>>>
12390>>>// search tConnection by case insensitive ID
12390>>>Function ComparetConnectionById Desktop tConnection C1 tConnection C2 Returns Integer
12392>>>    String sId1 sId2
12392>>>    Move (Uppercase(C1.sId)) to sId1
12393>>>    Move (Uppercase(C2.sId)) to sId2
12394>>>    If (sId1>sId2) Begin
12396>>>        Function_Return (GT)
12397>>>    End
12397>>>>
12397>>>    Else If (sId1<sId2) Begin
12400>>>        Function_Return (LT)
12401>>>    End
12401>>>>
12401>>>    Function_Return (EQ)
12402>>>End_Function
12403>>>
12403>>>Class cConnection is a cObject
12404>>>    
12404>>>    Procedure Construct_Object
12406>>>        Forward Send Construct_Object
12408>>>        
12408>>>        // If you want to do this all manually set this False
12408>>>        Property Boolean pbUseConnectionIni True
12409>>>        
12409>>>        // When using managed logins, login again if already logged in?
12409>>>        Property Boolean pbSkipDuplicateLogin True
12410>>>        
12410>>>        // can be set to false, to require a login before an open. This gets
12410>>>        // set when the driver is registered.
12410>>>        Property Boolean private_pbLoginOnOpen True
12411>>>        
12411>>>        // name of connections ini file. Only set this if you want to override
12411>>>        // the normal mechanism of getting a name.
12411>>>        Property String psConnectionIni ""
12412>>>        
12412>>>        // as a scurity precaution this can be disabled so someone cannot run a
12412>>>        // cmdline option that redirects to a different database
12412>>>        Property Boolean pbCmdLineIniAllowed True
12413>>>        
12413>>>        // normally this is dfconnid="name" but it can be customized in the case where
12413>>>        // an application would have a conflict with this.
12413>>>        Property String psConnectionIdCmdLine C_ConnectionIdCmdLineName
12414>>>        
12414>>>        // Determines AutoConnect behavior (usually sent by cApplication after workspace
12414>>>        // is opened. Default is to RegisterAll and LoginAll and abort if error). If set
12414>>>        // false, nothing happens.
12414>>>        Property Boolean pbAutoConnect True
12415>>>        
12415>>>        // is a login dialog used? If so, it must be created and registered in ghoLoginConnectDialog
12415>>>        Property Boolean pbLoginDialogRequired True
12416>>>        
12416>>>        // is encryption used? If so, it must be created and registered in ghoLoginEncryption
12416>>>        Property Boolean pbEncryptPassword True
12417>>>        
12417>>>        // class to use for driver connection objects. Advanced use for sub-classing
12417>>>        Property Handle phcDriverConnection (RefClass(cCLIHandler))
12418>>>        
12418>>>        // can be used by error trapping / handling
12418>>>        Property Integer piErrorNumber
12419>>>        Property Integer piErrorLine
12420>>>        Property String psErrorText
12421>>>        Property Handle phoOldError
12422>>>        
12422>>>        Property tDriverCLIDictionary[] pRegisteredDriversDict
12423>>>        
12423>>>        Property tConnection[] pConnections
12424>>>        
12424>>>        Move Self to ghoConnection
12425>>>        
12425>>>    End_Procedure
12426>>>    
12426>>>    // error trapping for this object
12426>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
12428>>>        Set piErrorLine to iErrorLine
12429>>>        Set piErrorNumber to iErrorNumber
12430>>>        Set psErrorText to sErrorText
12431>>>    End_Procedure
12432>>>    
12432>>>    Procedure TrapErrors
12434>>>        If (Error_Object_Id = Self) Begin
12436>>>            Error DFERR_PROGRAM "ASSERT: cConnection: TrapErrors called twice!"
12437>>>>
12437>>>            Procedure_Return
12438>>>        End
12438>>>>
12438>>>        Set phoOldError to Error_Object_Id
12439>>>        Set piErrorNumber to 0
12440>>>        Move Self to Error_Object_Id
12441>>>    End_Procedure
12442>>>    
12442>>>    Procedure UnTrapErrors
12444>>>        Get phoOldError to Error_Object_Id
12445>>>    End_Procedure
12446>>>    
12446>>>    // Report a connections configuration error as a handled user error.
12446>>>    Procedure ConfigurationError Integer iError String sError
12448>>>        Send UserError sError C_$DriverConfigurationError
12449>>>    End_Procedure
12450>>>    
12450>>>    // Setting this property will change this new and all existing managed drivers
12450>>>    Procedure Set pbLoginOnOpen Boolean bLoginOnOpen
12452>>>        tDriverCLIDictionary[] DriverMap
12452>>>        tDriverCLIDictionary[] DriverMap
12453>>>        Integer i iDriver
12453>>>        Set private_pbLoginOnOpen to bLoginOnOpen
12454>>>        
12454>>>        // set any existing registered drivers
12454>>>        Get pRegisteredDriversDict to DriverMap
12455>>>        For i from 0 to (SizeOfArray(DriverMap)-1)
12461>>>>
12461>>>            Get DriverIndex DriverMap[i].sDriver to iDriver
12462>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bLoginOnOpen
12465>>>        Loop
12466>>>>
12466>>>        
12466>>>    End_Procedure
12467>>>    
12467>>>    Function pbLoginOnOpen Returns Boolean
12469>>>        Boolean bLogin
12469>>>        Get private_pbLoginOnOpen to bLogin
12470>>>        Function_Return bLogin
12471>>>    End_Function
12472>>>    
12472>>>    
12472>>>    // returns the Index from list of loaded drivers for sDriver. 0 if not found
12472>>>    // This searches all loaded drivers which may include drivers that were
12472>>>    // not registered.
12472>>>    Function DriverIndex String sDriver Returns Integer
12474>>>        Integer iDrivers i
12474>>>        String sADriver
12474>>>        Move (Uppercase(sDriver)) to sDriver
12475>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12478>>>        For i from 1 to iDrivers
12484>>>>
12484>>>            Get_Attribute DF_DRIVER_NAME of i to sADriver
12487>>>            If (sDriver=Uppercase(sADriver)) Begin
12489>>>                Function_Return i
12490>>>            End
12490>>>>
12490>>>        Loop
12491>>>>
12491>>>        Function_Return 0
12492>>>    End_Function
12493>>>    
12493>>>    // returns cConnectionCLIHandler object for this driver id.
12493>>>    // This must be a registered managed driver. If not found return 0
12493>>>    // This can be used to test if a driver is registered (and therefore loaded)
12493>>>    Function DriverCLIHandler String sDriver Returns Handle
12495>>>        Integer iIndex
12495>>>        tDriverCLIDictionary[] DriverMap
12495>>>        tDriverCLIDictionary[] DriverMap
12496>>>        tDriverCLIDictionary DriverItem
12496>>>        tDriverCLIDictionary DriverItem
12496>>>        Move (Trim(Uppercase(sDriver))) to sDriver
12497>>>        Move sDriver to DriverItem.sDriver
12498>>>        Get pRegisteredDriversDict to DriverMap
12499>>>        Move (SearchArray(DriverItem,DriverMap)) to iIndex
12500>>>        If (iIndex<>-1) Begin
12502>>>            Function_Return DriverMap[iIndex].hoCLI
12503>>>        End
12503>>>>
12503>>>        Function_Return 0
12504>>>    End_Function
12505>>>    
12505>>>    // low level load which does not register the driver - only loads
12505>>>    Function LoadDriver String sDriver Returns Boolean
12507>>>        Integer iErrorNumber
12507>>>        Send TrapErrors
12508>>>        Load_Driver sDriver
12509>>>        Send UnTrapErrors
12510>>>        Get piErrorNumber to iErrorNumber
12511>>>        Function_Return (iErrorNumber=0)
12512>>>    End_Function
12513>>>    
12513>>>    Function TestDriverConformance String sDriver Integer iDriver Handle hoCLI Returns Boolean
12515>>>        Integer iConformance
12515>>>        Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
12518>>>        If (not(iConformance iand 8)) Begin // bit 4 is managed driver conformance
12520>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverIsNotManaged,sDriver))
12521>>>            Function_Return False
12522>>>        End
12522>>>>
12522>>>        Function_Return True
12523>>>    End_Function
12524>>>    
12524>>>    // Register this driver. Load driver if not yet loaded
12524>>>    // return cConnectionCLIHandler handle for this driver
12524>>>    // If registered, just return the handle
12524>>>    // return 0 if driver cannot be loaded
12524>>>    // If newly registered here, sends OnDriverRegistered event
12524>>>    // raise error if driver cannot be loaded or does not conform
12524>>>    Function RegisterDriver String sDriver Returns Handle
12526>>>        Integer iIndex iDriver iConformance
12526>>>        Handle hoCLI hClass
12526>>>        Boolean bOk
12526>>>        Boolean bAutoLogin
12526>>>        tDriverCLIDictionary[] DriverMap
12526>>>        tDriverCLIDictionary[] DriverMap
12527>>>        Integer iIds iRet
12527>>>        String sId
12527>>>        Get DriverCLIHandler sDriver to hoCLI
12528>>>        If (hoCLI=0) Begin // driver not registered yet
12530>>>            Get pRegisteredDriversDict to DriverMap
12531>>>            Get phcDriverConnection to hClass
12532>>>            Get CreateNamed hClass ("oCLI_"+sDriver) to hoCLI
12533>>>            Move (SizeOfArray(DriverMap)) to iIndex
12534>>>            Move (Trim(Uppercase(sDriver)))  to DriverMap[iIndex].sDriver
12535>>>            Move hoCLI to DriverMap[iIndex].hoCLI
12536>>>            Set pRegisteredDriversDict to DriverMap
12537>>>            Set psDriverID of hoCLI to DriverMap[iIndex].sDriver
12538>>>            
12538>>>            Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12539>>>            Move (iDriver>0) to bOk // is driver already loaded (just not registered)
12540>>>            If not bOk Begin
12542>>>                Get LoadDriver DriverMap[iIndex].sDriver to bOk
12543>>>                If bOk Begin
12545>>>                    Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12546>>>                End
12546>>>>
12546>>>                Else Begin
12547>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverNotFound,sDriver))
12548>>>                End
12548>>>>
12548>>>            End
12548>>>>
12548>>>            
12548>>>            // finally make sure loaded driver supports managed connections and any other
12548>>>            // tests that might be applied by the developer
12548>>>            If bOk Begin
12550>>>                Get TestDriverConformance sDriver iDriver hoCLI to bOk
12551>>>            End
12551>>>>
12551>>>            
12551>>>            If not bOk Begin
12553>>>                Send Destroy of hoCLI
12554>>>                Move 0 to hoCLI
12555>>>                Move (RemoveFromArray(DriverMap,iIndex)) to DriverMap
12556>>>                Set pRegisteredDriversDict to DriverMap
12557>>>            End
12557>>>>
12557>>>            Else Begin
12558>>>                // driver is loaded and valid, complete registration
12558>>>                
12558>>>                // Is auto-login on open supported?
12558>>>                Get pbLoginOnOpen to bAutoLogin
12559>>>                Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bAutoLogin
12562>>>                
12562>>>                // remove existing connection IDs as defined in the driver.int file. If you are
12562>>>                // using registered connections, you are using registered drivers!
12562>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iIds
12565>>>                While (iIds>0)
12569>>>                    Decrement iIds
12570>>>                    Get DeleteConnectionID of hoCLI "" iIds to iRet
12571>>>                Loop
12572>>>>
12572>>>                
12572>>>                Send OnDriverRegistered sDriver iDriver hoCLI
12573>>>            End
12573>>>>
12573>>>        End
12573>>>>
12573>>>        Function_Return hoCLI
12574>>>    End_Function
12575>>>    
12575>>>    
12575>>>    
12575>>>    // returns a string array of loaded drivers (managed and unmanaged)
12575>>>    Function LoadedDrivers Returns String[]
12577>>>        Integer iDrivers i
12577>>>        String[] ArrayOfDrivers
12578>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12581>>>        For i from 1 to iDrivers
12587>>>>
12587>>>            Get_Attribute DF_DRIVER_NAME of i to ArrayOfDrivers[i-1]
12590>>>        Loop
12591>>>>
12591>>>        Function_Return ArrayOfDrivers
12592>>>    End_Function
12593>>>    
12593>>>    // List of all Server connection-strings logged into this driver.
12593>>>    // This includes managed/registered strings and strings used in non-managed ways (e.g., in int file)
12593>>>    Function DriverServerNames String sDriver Returns String[]
12595>>>        Integer iConnections i iDriver
12595>>>        String[] Connections
12596>>>        Get DriverIndex sDriver to iDriver
12597>>>        If (iDriver>0) Begin
12599>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iConnections
12602>>>            For i from 0 to (iConnections-1)
12608>>>>
12608>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver (i+1) to Connections[i]
12611>>>            Loop
12612>>>>
12612>>>        End
12612>>>>
12612>>>        Function_Return Connections
12613>>>    End_Function
12614>>>    
12614>>>    // this does a low level login, which basically wraps the login command with some error handling
12614>>>    // and the ability to make a login silent.
12614>>>    // This is essentially a Login command surrounded by error checking and trapping
12614>>>    Function BasicLogin String sDriver String sServer String sName String sPassword Returns Integer
12616>>>        Integer iError iIndex
12616>>>        Handle hoConnect
12616>>>        Get DriverIndex sDriver to iIndex
12617>>>        If (iIndex>0) Begin
12619>>>            Send TrapErrors
12620>>>            Login sServer sName sPassword sDriver
12622>>>            Send UnTrapErrors
12623>>>            Get piErrorNumber to iError
12624>>>        End
12624>>>>
12624>>>        Else Begin
12625>>>            Move DFERR_PROGRAM to iError
12626>>>            Error iError (SFormat(C_$DriverNotFound,  sDriver))
12627>>>>
12627>>>        End
12627>>>>
12627>>>        Function_Return iError
12628>>>    End_Function
12629>>>    
12629>>>    
12629>>>    // get array of managed connections across all drivers
12629>>>    // returns array of connections in tConnection.
12629>>>    Function ConnectionIDs Returns tConnection[]
12631>>>        tConnection[] Connections
12631>>>        tConnection[] Connections
12632>>>        Get pConnections to Connections
12633>>>        Function_Return Connections
12634>>>    End_Function
12635>>>    
12635>>>    // return index of Id from pConnections array. -1 if missing
12635>>>    Function ConnectionIdIndex String sId Returns Integer
12637>>>        tConnection[] Connections
12637>>>        tConnection[] Connections
12638>>>        tConnection Connection
12638>>>        tConnection Connection
12638>>>        Integer iIndex
12638>>>        Move (trim(sId)) to Connection.sId
12639>>>        Get pConnections to Connections
12640>>>        Move (SearchArray(Connection,Connections,Desktop,RefFunc(ComparetConnectionById))) to iIndex
12641>>>        Function_Return iIndex
12642>>>    End_Function
12643>>>    
12643>>>    // return handle of cConnectionCLIHandler object for this id. 0 if none
12643>>>    Function ConnectionIdCLIHandler String sId Returns Handle
12645>>>        tConnection[] Ids
12645>>>        tConnection[] Ids
12646>>>        Integer iIndex
12646>>>        Handle hoCLI
12646>>>        Get ConnectionIds to Ids
12647>>>        Get ConnectionIdIndex sId to iIndex
12648>>>        If (iIndex<>-1) Begin
12650>>>            Get DriverCLIHandler Ids[iIndex].sDriver to hoCLI
12651>>>            Function_Return hoCLI
12652>>>        End
12652>>>>
12652>>>        Function_Return 0
12653>>>    End_Function
12654>>>    
12654>>>    // return connection info for this id. Programming error if Id does not exist
12654>>>    Function ConnectionIdInfo String sId Returns tConnection
12656>>>        tConnection[] ConnIDs
12656>>>        tConnection[] ConnIDs
12657>>>        tConnection ConnId
12657>>>        tConnection ConnId
12657>>>        Integer iIndex i
12657>>>        Handle hoCLI
12657>>>        Get ConnectionIdCLIHandler sId to hoCLI
12658>>>        If (hoCLI) Begin
12660>>>            Get ConnectionIdIndex sId to iIndex
12661>>>            Get ConnectionIDs to ConnIDs
12662>>>            Move ConnIDs[iIndex] to ConnId
12663>>>        End
12663>>>>
12663>>>        Else Begin
12664>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12665>>>>
12665>>>        End
12665>>>>
12665>>>        Function_Return ConnId
12666>>>    End_Function
12667>>>    
12667>>>    
12667>>>    // add or upate connection to pConnections. Do not call directly
12667>>>    Function AddToConnections tConnection Connection Returns Integer
12669>>>        tConnection[] Connections
12669>>>        tConnection[] Connections
12670>>>        Integer iIndex
12670>>>        Get pConnections to Connections
12671>>>        Get ConnectionIdIndex Connection.sId to iIndex
12672>>>        If (iIndex=-1) Begin
12674>>>            Move (SizeOfArray(Connections)) to iIndex
12675>>>        End
12675>>>>
12675>>>        Move Connection to Connections[iIndex]
12676>>>        Set pConnections to Connections
12677>>>        Function_Return iIndex
12678>>>    End_Function
12679>>>    
12679>>>    // Remove connection ID from pConnection. Don't call directly
12679>>>    Function RemoveFromConnections String sId Returns Boolean
12681>>>        tConnection[] Connections
12681>>>        tConnection[] Connections
12682>>>        Integer iIndex
12682>>>        Get pConnections to Connections
12683>>>        Get ConnectionIdIndex sId to iIndex
12684>>>        If (iIndex<>-1) Begin
12686>>>            Move (RemoveFromArray(Connections,iIndex)) to Connections
12687>>>            Set pConnections to Connections
12688>>>        End
12688>>>>
12688>>>        Function_Return (iIndex<>-1)
12689>>>    End_Function
12690>>>    
12690>>>    // Return the connection ID syntax used for IDs in the INT file (e.g., DFCONNID=ID1)
12690>>>    // helper so you don't have to remember this syntax. Does not verify Id
12690>>>    Function ConnectionIDServerString String sId Returns String
12692>>>        Function_Return (C_ConnectionId - sId)
12693>>>    End_Function
12694>>>    
12694>>>    // Returns Connection.Ini file name if passed from the command line.
12694>>>    // requires cApplication object
12694>>>    // It's looking for something like dfconnid=myconnid.ini
12694>>>    Function ConnectionIniFromCmdLine Returns String
12696>>>        Handle hoCmdLine
12696>>>        Integer iCount iArg iPos
12696>>>        String sArg sFile sLeft
12696>>>        Get psConnectionIdCmdLine to sLeft
12697>>>        Get phoCommandLine of ghoApplication to hoCmdLine
12698>>>        Get CountOfArgs of hoCmdLine to iCount
12699>>>        For iArg from 1 to iCount
12705>>>>
12705>>>            Get Argument of hoCmdLine iArg to sArg
12706>>>            If (Pos(Lowercase(sLeft),Trim(Lowercase(sArg)))=1) Begin
12708>>>                Move (Trim(Remove(sArg,1,Length(C_ConnectionIdCmdLineName)))) to sFile
12709>>>                Function_Return sFile
12710>>>            End
12710>>>>
12710>>>        Loop
12711>>>>
12711>>>        Function_Return ""
12712>>>    End_Function
12713>>>    
12713>>>    // get qualified version of connections INI file using the rules for
12713>>>    // acquring this name. This file may not exist.
12713>>>    Function ConnectionIniFile Returns String
12715>>>        String sConnections sPath sPName
12715>>>        Boolean bCmdLineIniAllowed
12715>>>        Handle hoWorkspace
12715>>>        
12715>>>        Get pbCmdLineIniAllowed to bCmdLineIniAllowed
12716>>>        Get phoWorkspace of ghoApplication to hoWorkspace
12717>>>        
12717>>>        // order of naming precedence
12717>>>        // 1. If defined directly via a set, use that name
12717>>>        // 2. If command line allowed and exists use that name
12717>>>        // 3. If workspace has a definition (from config.ws) use that name
12717>>>        // 4. Else the default of data\dfconnid.ini
12717>>>        
12717>>>        Get psConnectionIni to sConnections
12718>>>        If (sConnections="" and bCmdLineIniAllowed) Begin
12720>>>            Get ConnectionIniFromCmdLine to sConnections
12721>>>        End
12721>>>>
12721>>>        If (sConnections="") Begin
12723>>>            Get psConnectionIni of hoWorkspace to sConnections
12724>>>        End
12724>>>>
12724>>>        If (sConnections="") Begin
12726>>>            Move C_ConnectionIniFileName to sConnections
12727>>>        End
12727>>>>
12727>>>        Move (Trim(sConnections)) to sConnections
12728>>>        
12728>>>        If (sConnections<>"") Begin
12730>>>            // first data path
12730>>>            If (Pos("<datapath>\",Lowercase(sConnections))) Begin
12732>>>                Get psDataPath of hoWorkspace to sPath
12733>>>                Move "<datapath>\" to sPName
12734>>>            End
12734>>>>
12734>>>            // first programs path
12734>>>            Else If (Pos("<apppath>\",Lowercase(sConnections))) Begin
12737>>>                Get GetApplicationPath of hoWorkspace to sPath
12738>>>                Move "<apppath>\" to sPName
12739>>>            End
12739>>>>
12739>>>            // first workspace home path
12739>>>            Else If (Pos("<homepath>\",Lowercase(sConnections))) Begin
12742>>>                Get psHome of hoWorkspace to sPath
12743>>>                Move "<homepath>\" to sPName
12744>>>            End
12744>>>>
12744>>>            // if no special path, use first data path
12744>>>            Else If (not(IsFilenameQualified(sConnections))) Begin
12747>>>                Get psDataPath of hoWorkspace to sPath
12748>>>                Move '' to sPName
12749>>>            End
12749>>>>
12749>>>            
12749>>>            If (sPath<>"") Begin
12751>>>                Get PathAtIndex of hoWorkspace sPath 1 to sPath
12752>>>                If (sPName<>"") Begin
12754>>>                    Move (Replace(sPName, sConnections, (sPath + "\"))) to sConnections
12755>>>                End
12755>>>>
12755>>>                Else Begin
12756>>>                    Move (sPath + "\" + sConnections) to sConnections
12757>>>                End
12757>>>>
12757>>>            End
12757>>>>
12757>>>        End
12757>>>>
12757>>>        Function_Return sConnections
12758>>>    End_Function
12759>>>    
12759>>>    Procedure OnReadCredentials String sSection String sId Handle hoIni String ByRef sUID String ByRef sPWDEncrypted Boolean ByRef bTrusted
12761>>>        String sTrusted
12761>>>        If (hoIni) Begin
12763>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionUID "" to sUID
12764>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionPWD "" to sPWDEncrypted
12765>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionTrusted "" to sTrusted
12766>>>            Move (lowercase(sTrusted)="yes") to bTrusted
12767>>>        End
12767>>>>
12767>>>    End_Procedure
12768>>>    
12768>>>    Procedure OnWriteCredentials String sSection String sId Handle hoIni String sUID String sPWDEncrypted Boolean bTrusted
12770>>>        If hoIni Begin
12772>>>            If (not(bTrusted) and  sUID<>"") Begin
12774>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionUID sUID
12775>>>            End
12775>>>>
12775>>>            Else Begin
12776>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionUID
12777>>>            End
12777>>>>
12777>>>            
12777>>>            If (not(bTrusted) and sUID<>"" and sPWDEncrypted<>"") Begin
12779>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionPWD sPWDEncrypted
12780>>>            End
12780>>>>
12780>>>            Else Begin
12781>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionPWD
12782>>>            End
12782>>>>
12782>>>            
12782>>>            If (bTrusted) Begin
12784>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionTrusted "yes"
12785>>>            End
12785>>>>
12785>>>            Else Begin
12786>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionTrusted
12787>>>            End
12787>>>>
12787>>>        End
12787>>>>
12787>>>    End_Procedure
12788>>>    
12788>>>    // returns a list of connection Ids from the connections.ini file.
12788>>>    // Driver does not have to be loaded (if not loaded, hoCLI=0)
12788>>>    // If pbUseConnectionIni is False, this does Nothing
12788>>>    // and must be augmented to do anything useful
12788>>>    Function LoadStoredConnections tConnection[] ByRef Connects Returns Boolean
12790>>>        String sConnectPath sId sConnect sDriver sUID sPWD sSection sDisabled
12790>>>        String[] Sections
12791>>>        Handle hoWorkspace hoArray hoIniFile
12791>>>        Integer i iConns iIndex
12791>>>        Boolean bUseConnectionIni bOk bTrusted bDisabled
12791>>>        tConnection ConnNew
12791>>>        tConnection ConnNew
12791>>>        
12791>>>        Get pbUseConnectionIni to bUseConnectionIni
12792>>>        
12792>>>        If bUseConnectionIni Begin
12794>>>            
12794>>>            Get ConnectionIniFile of ghoConnection to sConnectPath
12795>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
12797>>>                Function_Return True // if file does not exist, that's ok - no connections
12798>>>            End
12798>>>>
12798>>>            
12798>>>            Get Create (RefClass(cIniFile)) to hoIniFile
12799>>>            Get Create (RefClass(Array)) to hoArray
12800>>>            Set psFilename of hoIniFile to sConnectPath
12801>>>            
12801>>>            Send ReadSections of hoIniFile hoArray
12802>>>            
12802>>>            // create an array of all Connection sections.
12802>>>            For i from 0 to (Item_Count(hoArray) -1)
12808>>>>
12808>>>                Get Value of hoArray i to sSection
12809>>>                Move (Trim(sSection)) to sSection
12810>>>                If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
12812>>>                    // make sure id is not a duplicate
12812>>>                    Move sId to ConnNew.sId
12813>>>                    Move (SearchArray(sSection, Sections, Desktop,RefFunc(DFSTRICMP))) to iIndex
12814>>>                    If (iIndex<>-1) Begin
12816>>>                        Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniDupSection,sConnectPath,sSection))
12817>>>                        Function_Return False
12818>>>                    End
12818>>>>
12818>>>                    Move (trim(sSection)) to Sections[SizeOfArray(Sections)]
12819>>>                End
12819>>>>
12819>>>            Loop
12820>>>>
12820>>>            
12820>>>            For i from 0 to (SizeOfArray(Sections)-1)
12826>>>>
12826>>>                Move Sections[i] to sSection
12827>>>                
12827>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionId "" to sId
12828>>>                If (sId="") Begin
12830>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadId,sConnectPath,sSection))
12831>>>                    Function_Return False
12832>>>                End
12832>>>>
12832>>>                
12832>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDriver "" to sDriver
12833>>>                If (sDriver="") Begin
12835>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadDriver,sConnectPath,sSection))
12836>>>                    Function_Return False
12837>>>                End
12837>>>>
12837>>>                
12837>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionConnection "" to sConnect
12838>>>                If (sConnect="") Begin
12840>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadConnection,sConnectPath,sSection))
12841>>>                    Function_Return False
12842>>>                End
12842>>>>
12842>>>                
12842>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDisabled "" to sDisabled
12843>>>                Move (Lowercase(sDisabled)="yes") to bDisabled
12844>>>                
12844>>>                Send OnReadCredentials sSection sId hoIniFile (&sUID) (&sPWD) (&bTrusted)
12845>>>                
12845>>>                If (sPWD<>"") Begin
12847>>>                    Get DecryptPassword sPWD to sPWD
12848>>>                End
12848>>>>
12848>>>                
12848>>>                Move sSection to Connects[iConns].sSection
12849>>>                Move sDriver to Connects[iConns].sDriver
12850>>>                Move sId to Connects[iConns].sId
12851>>>                Move sConnect to Connects[iConns].sString
12852>>>                Move bDisabled to Connects[iConns].bDisabled
12853>>>                Move sPWD to Connects[iConns].sPWD
12854>>>                Move bTrusted to Connects[iConns].bTrustedConnection
12855>>>                Move sUID to Connects[iConns].sUID
12856>>>                
12856>>>                Increment iConns
12857>>>            Loop
12858>>>>
12858>>>            Send Destroy of hoArray
12859>>>            Send Destroy of hoIniFile
12860>>>        End
12860>>>>
12860>>>        
12860>>>        Function_Return True
12861>>>    End_Function
12862>>>    
12862>>>    Function DecryptPassword String sPWD Returns String
12864>>>        Handle hoLoginEncrypt
12864>>>        Boolean bEncryptPassword
12864>>>        Get pbEncryptPassword to bEncryptPassword
12865>>>        If (bEncryptPassword) Begin
12867>>>            Move ghoLoginEncryption to hoLoginEncrypt
12868>>>            // if not registered an error will occur - programming error
12868>>>            Get DecryptPassword of hoLoginEncrypt sPWD to sPWD
12869>>>        End
12869>>>>
12869>>>        Function_Return sPWD
12870>>>    End_Function
12871>>>    
12871>>>    Function EncryptPassword String sPWD Returns String
12873>>>        Handle hoLoginEncrypt
12873>>>        Boolean bEncryptPassword
12873>>>        Get pbEncryptPassword to bEncryptPassword
12874>>>        If (bEncryptPassword) Begin
12876>>>            Move ghoLoginEncryption to hoLoginEncrypt
12877>>>            // if not registered an error will occur - programming error
12877>>>            Get EncryptPassword of hoLoginEncrypt sPWD to sPWD
12878>>>        End
12878>>>>
12878>>>        Function_Return sPWD
12879>>>    End_Function
12880>>>    
12880>>>    // Assemble connect string based on connect string, user id, password and trusted connection
12880>>>    // If connect string already contains user id, etc. it is still appended which is consistent
12880>>>    // with odbc connection strings. The last one wins.
12880>>>    // sConnect should contain the SERVER= or DSN= information.
12880>>>    Function AssembleConnectionString String sConnect String sUID String sPWD Boolean bTrusted Returns String
12882>>>        String sConnectString
12882>>>        Move sConnect to sConnectString
12883>>>        If (bTrusted) Begin
12885>>>            Move (sConnectString+";trusted_connection=yes") to sConnectString
12886>>>        End
12886>>>>
12886>>>        Else Begin
12887>>>            If (sUID<>"") Begin
12889>>>                Move (sConnectString+";UID="+sUID) to sConnectString
12890>>>            End
12890>>>>
12890>>>            If (sPWD<>"") Begin
12892>>>                Move (sConnectString+";PWD="+sPWD) to sConnectString
12893>>>            End
12893>>>>
12893>>>        End
12893>>>>
12893>>>        Function_Return sConnectString
12894>>>    End_Function
12895>>>    
12895>>>    Function AddConnectionToDriverCLI Handle hoCLI tConnection Connection Returns Integer
12897>>>        Integer iResult iIndex
12897>>>        Get ConnectionIdIndex Connection.sId to iIndex
12898>>>        If (iIndex<>-1) Begin
12900>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIdAlreadyExists,Connection.sId))
12901>>>            Function_Return 1
12902>>>        End
12902>>>>
12902>>>        Get CreateConnectionID of hoCLI Connection.sId Connection.sConnectionString Connection.iOptions to iResult
12903>>>        If (iResult=0) Begin
12905>>>            Get AddToConnections Connection to iIndex
12906>>>        End
12906>>>>
12906>>>        Function_Return iResult
12907>>>    End_Function
12908>>>    
12908>>>    
12908>>>    // add a connection id for this driver.
12908>>>    // pass server string, user id, password and trusted connection info. The
12908>>>    // server string that gets added will combine all of these. The password
12908>>>    // may require decoding by calling decode password.
12908>>>    Function AddConnection String sDriver String sId String sString String sUID String sPWD Boolean bTrusted String sSection Returns Integer
12910>>>        Handle hoCLI
12910>>>        Integer iResult
12910>>>        tConnection Connection
12910>>>        tConnection Connection
12910>>>        String sConnectString
12910>>>        Get RegisterDriver sDriver to hoCLI
12911>>>        If (hoCLI=0) Begin
12913>>>            // will have raised an error
12913>>>            Function_Return False
12914>>>        End
12914>>>>
12914>>>        Get DriverIndex sDriver to Connection.iDriverIndex
12915>>>        Move sDriver to Connection.sDriver
12916>>>        Get AssembleConnectionString sString sUID sPWD bTrusted to sConnectString
12917>>>        
12917>>>        // assemble the connection struct variable.
12917>>>        Move (Trim(sSection)) to Connection.sSection
12918>>>        Move (Trim(sId)) to Connection.sId
12919>>>        Move sString to Connection.sString
12920>>>        Move sUID to Connection.sUID
12921>>>        Move sPWD to Connection.sPWD
12922>>>        Move bTrusted to Connection.bTrustedConnection
12923>>>        Move True to Connection.iOptions // login always silent.
12924>>>        Move sConnectString to Connection.sConnectionString
12925>>>        Send OnAddConnection (&Connection) // further customize connection
12926>>>        Get AddConnectionToDriverCLI hoCLI Connection to iResult
12927>>>        Function_Return (iResult=0)
12928>>>    End_Function
12929>>>    
12929>>>    // add connectionIds for all registered drivers
12929>>>    // if driver not loaded/registered, do so first
12929>>>    // If any error occurs, stop process and return false, else true
12929>>>    Function AddAllConnections Returns Boolean
12931>>>        tConnection[] Connects
12931>>>        tConnection[] Connects
12932>>>        Integer i iResult
12932>>>        Boolean bOk
12932>>>        Handle hoCLI
12932>>>        Get LoadStoredConnections (&Connects) to bOk
12933>>>        If not bOk Begin
12935>>>            Function_Return False
12936>>>        End
12936>>>>
12936>>>        
12936>>>        For i from 0 to (SizeOfArray(Connects)-1)
12942>>>>
12942>>>            If (not(Connects[i].bDisabled)) Begin
12944>>>                Get AddConnection Connects[i].sDriver Connects[i].sId Connects[i].sString Connects[i].sUID Connects[i].sPWD Connects[i].bTrustedConnection Connects[i].sSection to bOk
12945>>>                If not bOk Begin
12947>>>                    Function_Return False
12948>>>                End
12948>>>>
12948>>>            End
12948>>>>
12948>>>        Loop
12949>>>>
12949>>>        Function_Return True
12950>>>    End_Function
12951>>>    
12951>>>    // returns the DF_DATABASE_ID handle for the passed connection
12951>>>    // should only be called with data obtained from ConnectionIdInfo
12951>>>    // of ConnectionIds and not LoadStoredConnections
12951>>>    // If this returns 0, the connection is not logged in
12951>>>    Function ConnectionDatabaseIdHandle tConnection Conn Returns Handle
12953>>>        Handle hConnectionHandle
12953>>>        String sServerString
12953>>>        Get ConnectionIDServerString Conn.sId to sServerString
12954>>>        Get ServerDatabaseIdHandle Conn.sDriver Conn.iDriverIndex sServerString to hConnectionHandle
12955>>>        Function_Return hConnectionHandle
12956>>>    End_Function
12957>>>    
12957>>>    Function ServerDatabaseIdHandle String sDriver Integer iDriver String sServerString Returns Handle
12959>>>        Integer i
12959>>>        String[] ServerNames
12960>>>        Handle hConnectionHandle
12960>>>        Get DriverServerNames sDriver to ServerNames
12961>>>        Move (SearchArray(sServerString,ServerNames,Desktop,RefFunc(DFSTRICMP))) to i
12962>>>        If (i<>-1) Begin
12964>>>            Get_Attribute DF_DATABASE_ID of iDriver (i+1) to hConnectionHandle
12967>>>        End
12967>>>>
12967>>>        Function_Return hConnectionHandle
12968>>>    End_Function
12969>>>    
12969>>>    // Is connection ID logged in. Pass just the id (e.g. ID1)
12969>>>    // If connection ID is not registered, raise an error
12969>>>    Function IsConnectionIdLoggedIn String sId Returns Boolean
12971>>>        tConnection Connect
12971>>>        tConnection Connect
12971>>>        Handle hConnectionHandle
12971>>>        Get ConnectionIdInfo sId to Connect
12972>>>        Get ConnectionDatabaseIdHandle Connect to hConnectionHandle
12973>>>        Function_Return (hConnectionHandle<>0)
12974>>>    End_Function
12975>>>    
12975>>>    // login to this managed connection via connection id. return 0 if ok
12975>>>    // If ID not found, raise a program error
12975>>>    // Login by connect Id - main interface.
12975>>>    Function LoginConnectionId String sId Returns Integer
12977>>>        Integer iResult
12977>>>        Handle hoCli
12977>>>        Boolean bSkipDup bConnected
12977>>>        String sDriver sServer sError sDesc
12977>>>        tConnection Connect
12977>>>        tConnection Connect
12977>>>        Get ConnectionIdCLIHandler sId to hoCLI
12978>>>        
12978>>>        If hoCli Begin
12980>>>            Get pbSkipDuplicateLogin to bSkipDup
12981>>>            If (bSkipDup) Begin
12983>>>                Get IsConnectionIdLoggedIn sId to bConnected
12984>>>            End
12984>>>>
12984>>>            If not bConnected Begin
12986>>>                Get LoginConnectIdBase sId False to iResult
12987>>>                If (iResult) Begin
12989>>>                    Get psErrorText to sError
12990>>>                    Get ConnectionIdInfo sId to Connect
12991>>>                    Move (sDesc + sFormat("Connection Id=%1.\n\n",sId) + sError) to sError
12992>>>                    Set psErrorText to sError
12993>>>                End
12993>>>>
12993>>>            End
12993>>>>
12993>>>        End
12993>>>>
12993>>>        Else Begin
12994>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12995>>>>
12995>>>            Move 1 to iResult
12996>>>        End
12996>>>>
12996>>>        Function_Return iResult
12997>>>    End_Function
12998>>>    
12998>>>    // does unconditional login for connection Id. This
12998>>>    // can be customized.
12998>>>    Function LoginConnectIdBase String sId Boolean bSilent Returns Integer
13000>>>        Integer iError
13000>>>        Boolean bOk bSkipDialog
13000>>>        String sConn
13000>>>        tConnection Connect
13000>>>        tConnection Connect
13000>>>        Get ConnectionIdInfo sId to Connect
13001>>>        Get ConnectionIDServerString Connect.sId to sConn
13002>>>        // first try a silent login. If it works we are done
13002>>>        Get BasicLogin Connect.sDriver sConn "" "" to iError
13003>>>        If (iError=0) Begin
13005>>>            Function_Return 0
13006>>>        End
13006>>>>
13006>>>        
13006>>>        // If login failed because of incorrect client, skip the login dialog.
13006>>>        // This is the first place this version test occurs.
13006>>>        If (iError=CLIERR_NOCLIENTSERVERVERSIONMATCH or iError=CLIERR_MINIMUMCLIENTVERSIONNOTFOUND) Begin
13008>>>            Function_Return 1
13009>>>        End
13009>>>>
13009>>>        
13009>>>        // If we have a compliant login dialog, try that.
13009>>>        If (not(bSilent)) Begin
13011>>>            Get LoginConnectIdDialog Connect.sId to bOk
13012>>>        End
13012>>>>
13012>>>        Function_Return (If(bOk,0,1))
13013>>>    End_Function
13014>>>    
13014>>>    
13014>>>    Function LoginConnectIdDialog String sId Returns Boolean
13016>>>        Handle hoLoginConnectDialog bLoginDialogRequired
13016>>>        Boolean bOk
13016>>>        
13016>>>// web applications don't use an embedded database login
13016>>>        Get pbLoginDialogRequired to bLoginDialogRequired
13017>>>        If (bLoginDialogRequired) Begin
13019>>>            Move ghoLoginConnectDialog to hoLoginConnectDialog
13020>>>            // if object missing an error is raised - programming error
13020>>>            Get LoginConnectIdDialog of hoLoginConnectDialog sId to bOk
13021>>>        End
13021>>>>
13021>>>        
13021>>>        Function_Return bOk
13022>>>    End_Function
13023>>>    
13023>>>    // Change Connect string based on passed credentials
13023>>>    // Update the driver's map of connect Id/Connect strings.
13023>>>    // If there is no change in the connection string, this does nothing.
13023>>>    // This will log out and disconnect from the existing connection and connect (but
13023>>>    // not login) to the new one.
13023>>>    // The Id must exist or errors
13023>>>    Function ChangeConnectIdCredentials String sId String sUser String sPwd Boolean bTrust Returns tConnection
13025>>>        tConnection Connect
13025>>>        tConnection Connect
13025>>>        Integer iError
13025>>>        String sConnStr
13025>>>        Get ConnectionIdInfo sId to Connect
13026>>>        Get AssembleConnectionString Connect.sString sUser sPwd bTrust to Connect.sConnectionString
13027>>>        If (Connect.sConnectionString<>sConnStr) Begin
13029>>>            Send LogoutConnectionId Connect.sId
13030>>>            Send DeleteConnectionId Connect.sId
13031>>>            
13031>>>            Move bTrust to Connect.bTrustedConnection
13032>>>            Move (If(bTrust,"",sUser))  to Connect.sUID
13033>>>            Move (If(bTrust,"",sPwd)) to Connect.sPWD
13034>>>            
13034>>>            Get AddConnection Connect.sDriver Connect.sId Connect.sString Connect.sUID Connect.sPWD Connect.bTrustedConnection Connect.sSection to iError
13035>>>        End
13035>>>>
13035>>>        Function_Return Connect
13036>>>    End_Function
13037>>>    
13037>>>    // attempt connection Id login using ID with passed credentials.
13037>>>    // These credentials will update the driver's map of connect Id/Connect strings.
13037>>>    // The Id must exist or errors
13037>>>    Function LoginConnectIdNewCredentials String sId String sUser String sPwd Boolean bTrust Returns Integer
13039>>>        Integer iError
13039>>>        tConnection Connect
13039>>>        tConnection Connect
13039>>>        Get ChangeConnectIdCredentials sId sUser sPwd bTrust to Connect
13040>>>        Get LoginConnectIdBase sId True to iError // silent
13041>>>        Function_Return iError
13042>>>    End_Function
13043>>>    
13043>>>    // Store credentials for Id. By default store in connections INI file, if used.
13043>>>    // Can be augmented or overridden
13043>>>    Function StoreConnectionIdCredentials String sId String sUID String sPWD Boolean bTrusted Returns Boolean
13045>>>        String sConnectPath
13045>>>        Handle hoIniFile
13045>>>        Boolean bUseConnectionIni
13045>>>        tConnection Connect
13045>>>        tConnection Connect
13045>>>        
13045>>>        Get pbUseConnectionIni to bUseConnectionIni
13046>>>        
13046>>>        If bUseConnectionIni Begin
13048>>>            
13048>>>            Get ConnectionIniFile to sConnectPath
13049>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
13051>>>                Function_Return True // empty is ok
13052>>>            End
13052>>>>
13052>>>            
13052>>>            Get ConnectionIdInfo sId to Connect
13053>>>            Get Create (RefClass(cIniFile)) to hoIniFile
13054>>>            Set psFilename of hoIniFile to sConnectPath
13055>>>            
13055>>>            If (sPWD<>"") Begin
13057>>>                Get EncryptPassword sPWD to sPWD
13058>>>            End
13058>>>>
13058>>>            
13058>>>            Send OnWriteCredentials Connect.sSection sId hoIniFile sUid sPWD bTrusted
13059>>>            
13059>>>            Send Destroy of hoIniFile
13060>>>        End
13060>>>>
13060>>>        Function_Return True
13061>>>    End_Function
13062>>>    
13062>>>    // logout of this managed connection id. If Id does not exist, do nothing
13062>>>    // note that logging out closes all tables for this connection
13062>>>    Procedure LogoutConnectionId String sId
13064>>>        Handle hoCli
13064>>>        String sDriver sServer
13064>>>        Get ConnectionIdCLIHandler sId to hoCLI
13065>>>        If hoCLI Begin
13067>>>            Get psDriverID of hoCli to sDriver
13068>>>            Get ConnectionIDServerString sId to sServer
13069>>>            Logout sDriver sServer
13070>>>        End
13070>>>>
13070>>>    End_Procedure
13071>>>    
13071>>>    // delete this managed connection id. If Id does not exist, do nothing
13071>>>    // if logged in raise a programming error.
13071>>>    Procedure DeleteConnectionId String sId
13073>>>        Handle hoCli
13073>>>        Integer iResult
13073>>>        Boolean bOk bLoggedIn
13073>>>        Get ConnectionIdCLIHandler sId to hoCli
13074>>>        If hoCLI Begin
13076>>>            // if the connection is logged in, this is an error. Precede this call with
13076>>>            // LogoutConnectionId. This is not done automatically so it is clear to the
13076>>>            // developer that they are logging out of existing connections, which closes
13076>>>            // open tables.
13076>>>            Get IsConnectionIdLoggedIn sId to bLoggedIn
13077>>>            If bLoggedIn Begin
13079>>>                Error DFERR_PROGRAM (SFormat("Connection ID '%1' is still logged-in and cannot be deleted",sId))
13080>>>>
13080>>>                Procedure_Return
13081>>>            End
13081>>>>
13081>>>            Get DeleteConnectionID of hoCli sId -1 to iResult
13082>>>            Get RemoveFromConnections sId to bOk
13083>>>        End
13083>>>>
13083>>>    End_Procedure
13084>>>    
13084>>>    
13084>>>    // login to all managed connection Ids for all drivers
13084>>>    // if error return false on first failure
13084>>>    Function LoginAllConnections Returns Boolean
13086>>>        tConnection[] ConnIds
13086>>>        tConnection[] ConnIds
13087>>>        Integer i iResult
13087>>>        Get ConnectionIDs to ConnIds
13088>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13094>>>>
13094>>>            Get LoginConnectionId ConnIds[i].sId to iResult
13095>>>            If (iResult) Begin
13097>>>                Function_Return False
13098>>>            End
13098>>>>
13098>>>        Loop
13099>>>>
13099>>>        Function_Return True
13100>>>    End_Function
13101>>>    
13101>>>    // logout of all managed connections for all drivers
13101>>>    Procedure LogoutAllConnections
13103>>>        tConnection[] ConnIds
13103>>>        tConnection[] ConnIds
13104>>>        Integer i
13104>>>        Get ConnectionIDs to ConnIds
13105>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13111>>>>
13111>>>            Send LogoutConnectionId ConnIds[i].sId
13112>>>        Loop
13113>>>>
13113>>>    End_Procedure
13114>>>    
13114>>>    // "unregister" all managed connections for all drivers
13114>>>    // Logout and then delete the connection. Note there is no DeleteAllConnections
13114>>>    // because you will always want to logout and delete in a single step.
13114>>>    Procedure UnRegisterAllConnections
13116>>>        tConnection[] ConnIds
13116>>>        tConnection[] ConnIds
13117>>>        Integer i
13117>>>        Get ConnectionIDs to ConnIds
13118>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13124>>>>
13124>>>            Send LogoutConnectionId ConnIds[i].sId
13125>>>            Send DeleteConnectionId ConnIds[i].sId
13126>>>        Loop
13127>>>>
13127>>>    End_Procedure
13128>>>    
13128>>>    // you can redefine a connection-string for a logged in server and all open tables will get
13128>>>    // redirected to the new connection. You can choose to leave the old connection open so if you switch back
13128>>>    // it can be done quickly.
13128>>>    // This assumes that two servers contain the same tables with the same definitions. If they don't things
13128>>>    // will not work. It is the developer's responsibility to make sure this is the case.
13128>>>    // Use with care.
13128>>>    Function RedirectConnectionId String sId String sServer String sUID String sPWD Boolean bTrusted Boolean bKeepOpen Returns Boolean
13130>>>        Handle hoCli
13130>>>        Integer iIndex iRet
13130>>>        tConnection[] Connections
13130>>>        tConnection[] Connections
13131>>>        tConnection Connection
13131>>>        tConnection Connection
13131>>>        String sConnectString
13131>>>        
13131>>>        Get ConnectionIdIndex sId to iIndex
13132>>>        If (iIndex=-1) Begin
13134>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13135>>>>
13135>>>            Function_Return 1
13136>>>        End
13136>>>>
13136>>>        
13136>>>        Get ConnectionIdCLIHandler sId to hoCli
13137>>>        Get pConnections to Connections
13138>>>        Move Connections[iIndex] to Connection
13139>>>        
13139>>>        Get AssembleConnectionString sServer sUID sPWD bTrusted to sConnectString
13140>>>        Move sServer to Connection.sString
13141>>>        Move sUID to Connection.sUID
13142>>>        Move sPWD to Connection.sPWD
13143>>>        Move bTrusted to Connection.bTrustedConnection
13144>>>        Move sConnectString to Connection.sConnectionString
13145>>>        Get ConnectionIDServerString sId to sId
13146>>>        
13146>>>        Send TrapErrors
13147>>>        Get RedirectIdConnectString of hoCli sId sConnectString bKeepOpen to iRet
13148>>>        Send UnTrapErrors
13149>>>        // if 1, we have the ID but it must not be not logged-in. We can still
13149>>>        // switch to the non-logged in connection
13149>>>        If (iRet=0 or iRet=1) Begin
13151>>>            // if all is ok, update the connection info
13151>>>            Move Connection to Connections[iIndex]
13152>>>            Set pConnections to Connections
13153>>>            Move 0 to iRet
13154>>>            Set piErrorNumber to 0
13155>>>        End
13155>>>>
13155>>>        Function_Return (iRet=0)
13156>>>    End_Function
13157>>>    
13157>>>    // This gets sent when a mangaged driver is registerd (it might already be loaded).
13157>>>    // Can be used to set CLI driver settings like use-cache etc.
13157>>>    Procedure OnDriverRegistered String sDriver Integer iDriver Handle hoCLIHandler
13159>>>    End_Procedure
13160>>>    
13160>>>    
13160>>>    // this can be used to do whatever you want to the various connection
13160>>>    // info. You might use this to handle your own default UID/PWD enoding logic
13160>>>    // etc.
13160>>>    Procedure OnAddConnection tConnection ByRef Connection
13162>>>    End_Procedure
13163>>>    
13163>>>    Function WriteConnectionsIniString Handle hoIniFile String sSection String sKey String sValue Returns Integer
13165>>>        Integer iErrorNumber
13165>>>        Send TrapErrors
13166>>>        Send WriteString of hoIniFile sSection sKey sValue
13167>>>        Send UnTrapErrors
13168>>>        Get piErrorNumber to iErrorNumber
13169>>>        Function_Return iErrorNumber
13170>>>    End_Function
13171>>>    
13171>>>    // update the connections ini file with passed Ids. Note that the section name
13171>>>    // for each ID is not the name that will be written. It exists if this was the
13171>>>    // initial section name.
13171>>>    Function WriteConnectionsIni String sQFile tConnection[] Ids Returns Boolean
13173>>>        Integer i iErrorNumber iIndex iSec iSections
13173>>>        String  sDriver sValue sPWD sSection
13173>>>        Handle hoIniFile hoArray hoSection
13173>>>        Boolean bOk bExists
13173>>>        String[] Keys Values
13175>>>        tConnectionIniSection[] Sections
13175>>>        tConnectionIniSection[] Sections
13176>>>        tConnectionIniSection SectionTarget
13176>>>        tConnectionIniSection SectionTarget
13176>>>        
13176>>>        // if filename not passed, use the default
13176>>>        If (sQFile="") Begin
13178>>>            Get ConnectionIniFile of ghoConnection to sQFile
13179>>>        End
13179>>>>
13179>>>        
13179>>>        Get Create (RefClass(cIniFile)) to hoIniFile
13180>>>        Get Create (RefClass(Array)) to hoArray
13181>>>        Get Create (RefClass(Array)) to hoSection
13182>>>        Set psFilename of hoIniFile to sQFile
13183>>>        
13183>>>        // first save off all info from an existing section name. This section may get
13183>>>        // renamed but we want to write it out later under that new section name. Hence
13183>>>        // we must store all values.
13183>>>        For i from 0 to (SizeOfArray(Ids)-1)
13189>>>>
13189>>>            If (Ids[i].sSection<>"") Begin
13191>>>                Get SectionExists of hoIniFile Ids[i].sSection to bExists
13192>>>                If bExists Begin
13194>>>                    Move (Lowercase(Ids[i].sSection)) to sSection
13195>>>                    Move sSection to Sections[iSections].sSection
13196>>>                    Send Delete_Data of hoSection
13197>>>                    Send ReadSection of hoIniFile sSection hoSection
13198>>>                    For iSec from 0 to (Item_Count(hoSection)-1)
13204>>>>
13204>>>                        Get Value of hoSection iSec to Sections[iSections].Keys[iSec]
13205>>>                        Get ReadString of hoIniFile sSection Sections[iSections].Keys[iSec] "" to Sections[iSections].Values[iSec]
13206>>>                    Loop
13207>>>>
13207>>>                    Increment iSections
13208>>>                End
13208>>>>
13208>>>            End
13208>>>>
13208>>>        Loop
13209>>>>
13209>>>        
13209>>>        // Now remove all existing connection sections
13209>>>        Send ReadSections of hoIniFile hoArray
13210>>>        For i from 0 to (Item_Count(hoArray) -1)
13216>>>>
13216>>>            Get Value of hoArray i to sSection
13217>>>            Move (Trim(sSection)) to sSection
13218>>>            If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
13220>>>                Send DeleteSection of hoIniFile sSection
13221>>>            End
13221>>>>
13221>>>            If (iErrorNumber<>0) ;                Break
13224>>>        Loop
13225>>>>
13225>>>        
13225>>>        // now write the new connections, with each connection renamed.
13225>>>        For i from 0 to (SizeOfArray(Ids)-1)
13231>>>>
13231>>>            Move (C_ConnectionIniSectionBaseName+String(i+1)) to sSection
13232>>>            
13232>>>            // if the section already existed, write all existing data back under what
13232>>>            // might be a new section name. Some of this may get overridden below
13232>>>            Move (Lowercase(Ids[i].sSection)) to SectionTarget.sSection
13233>>>            Move (SearchArray(SectionTarget,Sections)) to iIndex
13234>>>            If (iIndex<>-1) Begin
13236>>>                For iSec from 0 to (SizeOfArray(Sections[iIndex].Keys)-1)
13242>>>>
13242>>>                    Get WriteConnectionsIniString hoIniFile sSection Sections[iIndex].Keys[iSec] Sections[iIndex].Values[iSec] to iErrorNumber
13243>>>                    If iErrorNumber ;                        Break
13246>>>                Loop
13247>>>>
13247>>>            End
13247>>>>
13247>>>            If iErrorNumber ;                Break
13250>>>            
13250>>>            // now write / overwrite new data
13250>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionId Ids[i].sId to iErrorNumber
13251>>>            If iErrorNumber ;                Break
13254>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDriver Ids[i].sDriver to iErrorNumber
13255>>>            If iErrorNumber ;                Break
13258>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionConnection Ids[i].sString to iErrorNumber
13259>>>            If iErrorNumber ;                Break
13262>>>
13262>>>            If (Ids[i].bDisabled) Begin
13264>>>                Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDisabled "yes" to iErrorNumber
13265>>>            End
13265>>>>
13265>>>            Else Begin
13266>>>                Send DeleteKey of hoIniFile sSection C_ConnectionIniSectionDisabled
13267>>>            End
13267>>>>
13267>>>            If iErrorNumber ;                Break
13270>>>
13270>>>            Move Ids[i].sPWD to sPWD
13271>>>            If (sPWD<>"") Begin
13273>>>                Get EncryptPassword sPWD to sPWD
13274>>>            End
13274>>>>
13274>>>            
13274>>>            Send OnWriteCredentials sSection Ids[i].sId hoIniFile Ids[i].sUID sPWD Ids[i].bTrustedConnection
13275>>>        Loop
13276>>>>
13276>>>        
13276>>>        Send Destroy of hoSection
13277>>>        Send Destroy of hoArray
13278>>>        Send Destroy of hoIniFile
13279>>>        Function_Return (iErrorNumber=0)
13280>>>    End_Function
13281>>>    
13281>>>    // creates an SQL Connection handler for SQL usage. It is up to you to destroy this
13281>>>    // by default it creates a cSQLConnection object. This can be augmented to create use
13281>>>    // a different class
13281>>>    Function CreateESQLConnectionHandler Returns Handle
13283>>>        Handle hoSQLConnection
13283>>>        Get CreateNamed (RefClass(cSQLConnection)) "oSQLConnectionHandler" to hoSQLConnection
13284>>>        Function_Return hoSQLConnection
13285>>>    End_Function
13286>>>    
13286>>>    // get a new ESQL connection handle for this connection Id.
13286>>>    // Programmer must destroy this handle when done
13286>>>    // Id must exist. Programming error if it does not
13286>>>    Function SQLConnectionId String sId Returns Handle
13288>>>        Handle hoSQLConnection hoCLI
13288>>>        Integer bOK
13288>>>        String sDrvrID sServer
13288>>>        
13288>>>        Get ConnectionIdCLIHandler sId to hoCLI
13289>>>        If hoCLI Begin
13291>>>            Get ConnectionIDServerString sId to sServer
13292>>>            Get psDriverID of hoCLI to sDrvrId
13293>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13294>>>            
13294>>>            // force it to use existing connection
13294>>>            Get SQLConnectionConnect of hoSQLConnection sDrvrID sServer to bOK
13295>>>            
13295>>>            If (not(bOK)) Begin
13297>>>                Send DestroySQLConnection of hoSQLConnection
13298>>>                Move 0 to hoSQLConnection
13299>>>            End
13299>>>>
13299>>>        End
13299>>>>
13299>>>        Else Begin
13300>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13301>>>>
13301>>>        End
13301>>>>
13301>>>        Function_Return hoSQLConnection
13302>>>    End_Function
13303>>>    
13303>>>    // these are interfaces that do not require connection Ids. You can pass a
13303>>>    // driver and a server connect string. Generally there are ID versions of these
13303>>>    // that should be used when possible.
13303>>>    
13303>>>    // is this connection to a server logged in. Pass driver and connect string
13303>>>    // connect string should be INT style. Either full string or DFCONNID=xx
13303>>>    // if driver not loaded, raise an error
13303>>>    Function IsDriverConnectionLoggedIn String sDriver String sConnect Returns Boolean
13305>>>        Handle hConnectionHandle hoCLI
13305>>>        Integer iDriver
13305>>>        Get DriverCLIHandler sDriver to hoCLI
13306>>>        If (hoCLI) Begin
13308>>>            Get DriverIndex sDriver to iDriver
13309>>>            Get ServerDatabaseIdHandle sDriver iDriver sConnect to hConnectionHandle
13310>>>        End
13310>>>>
13310>>>        Else Begin
13311>>>            Error DFERR_PROGRAM (SFormat(C_$DriverNotFound,sDriver))
13312>>>>
13312>>>        End
13312>>>>
13312>>>        Function_Return (hConnectionHandle<>0)
13313>>>    End_Function
13314>>>    
13314>>>    // login to this managed connection via driver and connection string.
13314>>>    // Normally you'd not use this and use LoginConnectionId
13314>>>    // If pbSkipDuplicateLogin=T it will skip the login if it is already connected
13314>>>    // If driver not loaded, attempt to load it.
13314>>>    // If it cannot be loaded, raise a configuration Error
13314>>>    // This is low level - use carefully
13314>>>    Function LoginServer String sDriver String sConnectString String sUID String sPWD Boolean bSilent Returns Integer
13316>>>        Integer iResult iDriver
13316>>>        Handle hoCli
13316>>>        Boolean bSkipDup bConnected bOldSilent
13316>>>        Get RegisterDriver sDriver to hoCLI
13317>>>        If hoCli Begin
13319>>>            Get pbSkipDuplicateLogin to bSkipDup
13320>>>            If (bSkipDup) Begin
13322>>>                Get IsDriverConnectionLoggedIn sDriver sConnectString to bConnected
13323>>>            End
13323>>>>
13323>>>            If not bConnected Begin
13325>>>                Get DriverIndex sDriver to iDriver
13326>>>                // note that passing the server as dfconnid=Id will not recognize bSilent
13326>>>                Get_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13329>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bSilent
13332>>>                Get BasicLogin sDriver sConnectString sUID sPWD to iResult
13333>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13336>>>            End
13336>>>>
13336>>>        End
13336>>>>
13336>>>        Else Begin
13337>>>            // if driver cannot be loaded, an error will be raised in RegisterDriver
13337>>>            Move 1 to iResult
13338>>>        End
13338>>>>
13338>>>        Function_Return iResult
13339>>>    End_Function
13340>>>    
13340>>>    // can connect using any server connect string for this driver
13340>>>    // returns new  ESQL connection handler, which the developer must destroy.
13340>>>    Function SQLConnection String sDriver String sConnect Returns Handle
13342>>>        Handle hoSQLConnection
13342>>>        String sDrvrID
13342>>>        Handle hoCLI
13342>>>        Boolean bOk
13342>>>        
13342>>>        // will raise configuration error if driver cannot be loaded
13342>>>        Get RegisterDriver sDriver to hoCLI
13343>>>        If hoCli Begin
13345>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13346>>>            
13346>>>            // force it to use existing connection
13346>>>            Get SQLConnectionConnect of hoSQLConnection sDriver sConnect to bOK
13347>>>            
13347>>>            If (not(bOK)) Begin
13349>>>                Send DestroySQLConnection of hoSQLConnection
13350>>>                Move 0 to hoSQLConnection
13351>>>            End
13351>>>>
13351>>>            
13351>>>        End
13351>>>>
13351>>>        Function_Return hoSQLConnection
13352>>>    End_Function
13353>>>    
13353>>>    // get a new ESQL connection handle for this open table. Programmer must
13353>>>    // destroy this handle when done
13353>>>    Function SQLConnectionByTable Handle hoTable Returns Handle
13355>>>        Handle hoSQLConnection
13355>>>        Boolean bOk
13355>>>        
13355>>>        Get CreateESQLConnectionHandler to hoSQLConnection
13356>>>        Get SQLFileConnect of hoSQLConnection hoTable to bOk
13357>>>        If (not(bOK)) Begin
13359>>>            Send DestroySQLConnection of hoSQLConnection
13360>>>            Move 0 to hoSQLConnection
13361>>>        End
13361>>>>
13361>>>        
13361>>>        Function_Return hoSQLConnection
13362>>>    End_Function
13363>>>    
13363>>>    // load all managed drivers and set up all managed connections. Abort if a failure
13363>>>    // if you don't want automatic abort, use RegisterAllDrivers and AddAllConnections
13363>>>    // This should succeed - if not it's a programming error
13363>>>    Procedure RegisterAllConnections
13365>>>        Boolean bOk
13365>>>        Get AddAllConnections to bOk
13366>>>        If not bOk Begin
13368>>>            Send UserError "Could not load and register managed drivers. The application cannot be run"
13369>>>            Abort
13370>>>>
13370>>>        End
13370>>>>
13370>>>    End_Procedure
13371>>>    
13371>>>    // Login to all managed connections in all managed drivers. Abort if any fail
13371>>>    // if you don't want automatic abort, use the function LoginAllConnections or
13371>>>    // LoginConnectionId
13371>>>    Procedure LoginAll
13373>>>        Boolean bOk
13373>>>        Integer iError
13373>>>        String sError
13373>>>        Get LoginAllConnections to bOk
13374>>>        If not bOk Begin
13376>>>            Get psErrorText to sError
13377>>>            Get piErrorNumber to iError
13378>>>            Send UserError (C_$LoginAllFailedWillAbort + "\n\n" + sError)
13379>>>            Abort
13380>>>>
13380>>>        End
13380>>>>
13380>>>    End_Procedure
13381>>>    
13381>>>    // Standard Auto-connect behavior.
13381>>>    // if pbAutoConnect is T it does a registerAll & LoginAll and aborts if an error occurs
13381>>>    // if pbAutoConnect is F, it does nothing.
13381>>>    // Note that RegisterAll and LoginIn don't do anything if managed connections are not used.
13381>>>    // This is called by cApplication when a workspace is opened.
13381>>>    Procedure AutoConnect
13383>>>        Boolean bAutoConnect
13383>>>        Get pbAutoConnect to bAutoConnect
13384>>>        If bAutoConnect Begin
13386>>>            Send RegisterAllConnections // might abort on failure
13387>>>            Send LoginAll // might abort on failure
13388>>>        End
13388>>>>
13388>>>    End_Procedure
13389>>>    
13389>>>    // This is called by cApplication when a workspace is opened.
13389>>>    Procedure AutoDisconnect
13391>>>        Boolean bAutoConnect
13391>>>        Get pbAutoConnect to bAutoConnect
13392>>>        If bAutoConnect Begin
13394>>>            Send UnRegisterAllConnections
13395>>>        End
13395>>>>
13395>>>    End_Procedure
13396>>>    
13396>>>    // EnumerateConnections:
13396>>>    // List the current registered connection ids.
13396>>>    //
13396>>>    Procedure EnumerateConnections Handle hoCallBack Handle hmGeneric
13398>>>        tConnection[] ConnIds
13398>>>        tConnection[] ConnIds
13399>>>        Integer i iConnIds
13399>>>        String sConnectionsIni
13399>>>        
13399>>>        Get ConnectionIniFile to sConnectionsIni
13400>>>        
13400>>>        Send hmGeneric of hoCallBack C_$ManagedConnections
13401>>>        Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIniFile, ConnectionIniFile(Self)))
13402>>>        
13402>>>        Get ConnectionIDs to ConnIds
13403>>>        Move (SizeOfArray(ConnIds)) to iConnIds
13404>>>        If (iConnIds=0) Begin
13406>>>            Send hmGeneric of hoCallBack C_$ManagedConnectionsNone
13407>>>        End
13407>>>>
13407>>>        Else Begin
13408>>>            For i from 0 to (iConnIds-1)
13414>>>>
13414>>>                Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIdLine, ConnIds[i].sId, ConnIds[i].sString, ConnIds[i].sDriver))
13415>>>            Loop
13416>>>>
13416>>>        End
13416>>>>
13416>>>    End_Procedure
13417>>>    
13417>>>End_Class
13418>
13418>Object oApplication is a cApplication
13420>    
13420>    Object oConnection is a cConnection
13422>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\LoginEncryption.pkg)
13422>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLoginEncryption.pkg)
13422>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCryptographerEx.pkg)
13422>>>>>>>Use VdfBase.pkg
13422>>>>>>>
13422>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.0\Pkg\CryptographerConstants.pkg)
13422>>>>>>>>>//   Author  : Ulbe Stellema
13422>>>>>>>>>// Algorithm classes
13422>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
13422>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
13422>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
13422>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
13422>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
13422>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
13422>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
13422>>>>>>>>>
13422>>>>>>>>>// Algorithm types
13422>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
13422>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
13422>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
13422>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
13422>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
13422>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
13422>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
13422>>>>>>>>>
13422>>>>>>>>>// Generic sub-ids
13422>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
13422>>>>>>>>>
13422>>>>>>>>>// RSA sub-ids
13422>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
13422>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
13422>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
13422>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
13422>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
13422>>>>>>>>>
13422>>>>>>>>>// DSS sub-ids
13422>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
13422>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
13422>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
13422>>>>>>>>>
13422>>>>>>>>>// DES sub_ids
13422>>>>>>>>>Define ALG_SID_DES                      for 1
13422>>>>>>>>>Define ALG_SID_3DES                     for 3
13422>>>>>>>>>Define ALG_SID_DESX                     for 4
13422>>>>>>>>>Define ALG_SID_IDEA                     for 5
13422>>>>>>>>>Define ALG_SID_CAST                     for 6
13422>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
13422>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
13422>>>>>>>>>Define ALG_SID_3DES_112                 for 9
13422>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
13422>>>>>>>>>Define ALG_SID_RC5                      for 13
13422>>>>>>>>>Define ALG_SID_AES_128                  for 14
13422>>>>>>>>>Define ALG_SID_AES_192                  for 15
13422>>>>>>>>>Define ALG_SID_AES_256                  for 16
13422>>>>>>>>>Define ALG_SID_AES                      for 17
13422>>>>>>>>>
13422>>>>>>>>>// Fortezza sub-ids
13422>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
13422>>>>>>>>>Define ALG_SID_TEK                      for 11
13422>>>>>>>>>
13422>>>>>>>>>// RC2 sub-ids
13422>>>>>>>>>Define ALG_SID_RC2                      for 2
13422>>>>>>>>>
13422>>>>>>>>>// Stream cipher sub-ids
13422>>>>>>>>>Define ALG_SID_RC4                      for 1
13422>>>>>>>>>Define ALG_SID_SEAL                     for 2
13422>>>>>>>>>
13422>>>>>>>>>// Diffie-Hellman sub-ids
13422>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
13422>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
13422>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
13422>>>>>>>>>Define ALG_SID_KEA                      for 4
13422>>>>>>>>>
13422>>>>>>>>>// Hash sub ids
13422>>>>>>>>>Define ALG_SID_MD2                      for 1
13422>>>>>>>>>Define ALG_SID_MD4                      for 2
13422>>>>>>>>>Define ALG_SID_MD5                      for 3
13422>>>>>>>>>Define ALG_SID_SHA                      for 4
13422>>>>>>>>>Define ALG_SID_SHA1                     for 4
13422>>>>>>>>>Define ALG_SID_MAC                      for 5
13422>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
13422>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
13422>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
13422>>>>>>>>>Define ALG_SID_HMAC                     for 9
13422>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
13422>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
13422>>>>>>>>>Define ALG_SID_SHA_256                  for 12
13422>>>>>>>>>Define ALG_SID_SHA_384                  for 13
13422>>>>>>>>>Define ALG_SID_SHA_512                  for 14
13422>>>>>>>>>
13422>>>>>>>>>// secure channel sub ids
13422>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
13422>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
13422>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
13422>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
13422>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
13422>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
13422>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
13422>>>>>>>>>
13422>>>>>>>>>// algorithm identifier definitions
13422>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
13422>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
13422>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
13422>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
13422>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
13422>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
13422>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13422>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
13422>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
13422>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13422>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
13422>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
13422>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
13422>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
13422>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
13422>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
13422>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
13422>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
13422>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
13422>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
13422>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
13422>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
13422>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
13422>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
13422>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
13422>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
13422>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
13422>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
13422>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
13422>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
13422>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
13422>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
13422>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
13422>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
13422>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
13422>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
13422>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
13422>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
13422>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
13422>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
13422>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
13422>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
13422>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
13422>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
13422>>>>>>>>>
13422>>>>>>>>>// Providers
13422>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
13422>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
13422>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
13422>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
13422>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
13422>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
13422>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
13422>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
13422>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
13422>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
13422>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
13422>>>>>>>>>
13422>>>>>>>>>// dwFlags definitions for CryptAcquireContext
13422>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
13422>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
13422>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
13422>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
13422>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
13422>>>>>>>>>
13422>>>>>>>>>// dwFlag definitions for CryptGenKey
13422>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
13422>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
13422>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
13422>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
13422>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
13422>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
13422>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
13422>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
13422>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
13422>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
13422>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
13422>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
13422>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
13422>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
13422>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
13422>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
13422>>>>>>>>>
13422>>>>>>>>>// Provider types
13422>>>>>>>>>Define PROV_RSA_FULL                    for 1
13422>>>>>>>>>Define PROV_RSA_SIG                     for 2
13422>>>>>>>>>Define PROV_DSS                         for 3
13422>>>>>>>>>Define PROV_FORTEZZA                    for 4
13422>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
13422>>>>>>>>>Define PROV_SSL                         for 6
13422>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
13422>>>>>>>>>Define PROV_DSS_DH                      for 13
13422>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
13422>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
13422>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
13422>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
13422>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
13422>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
13422>>>>>>>>>Define PROV_RNG                         for 21
13422>>>>>>>>>Define PROV_INTEL_SEC                   for 22
13422>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
13422>>>>>>>>>Define PROV_RSA_AES                     for 24
13422>>>>>>>>>
13422>>>>>>>>>// KP_MODE
13422>>>>>>>>>// KP_MODE
13422>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
13422>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
13422>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
13422>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
13422>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
13422>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
13422>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
13422>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
13422>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
13422>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
13422>>>>>>>>>
13422>>>>>>>>>// dwParam definitions for CryptGetKeyParam
13422>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
13422>>>>>>>>>Define KP_SALT                          for 2       // Salt value
13422>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
13422>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
13422>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
13422>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
13422>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
13422>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
13422>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
13422>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
13422>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
13422>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
13422>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
13422>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
13422>>>>>>>>>Define KP_Y                             for 15      // Y value
13422>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
13422>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
13422>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
13422>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
13422>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
13422>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
13422>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
13422>>>>>>>>>Define KP_RP                            for 23
13422>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
13422>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
13422>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
13422>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
13422>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
13422>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
13422>>>>>>>>>Define KP_KEYVAL                        for 30
13422>>>>>>>>>Define KP_ADMIN_PIN                     for 31
13422>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
13422>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
13422>>>>>>>>>Define KP_PREHASH                       for 34
13422>>>>>>>>>Define KP_ROUNDS                        for 35
13422>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
13422>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
13422>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
13422>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
13422>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
13422>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
13422>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
13422>>>>>>>>>
13422>>>>>>>>>// dwParam definitions for CryptGetHashParam
13422>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
13422>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
13422>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
13422>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
13422>>>>>>>>>
13422>>>>>>>>>// key BLOB types
13422>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
13422>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
13422>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
13422>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
13422>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
13422>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
13422>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
13422>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
13422>>>>>>>>>
13422>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
13422>>>>>>>>>
13422>>>>>>>>>// KP_PADDING
13422>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
13422>>>>>>>>>Define RANDOM_PADDING                   for 2
13422>>>>>>>>>Define ZERO_PADDING                     for 3
13422>>>>>>>>>
13422>>>>>>>>>//  Structure cryptimportkey
13422>>>>>>>>>Struct PUBLICKEYSTRUC
13422>>>>>>>>>    UChar    bType
13422>>>>>>>>>    UChar    bVersion
13422>>>>>>>>>    UShort   reserved
13422>>>>>>>>>    UInteger aiKeyAlg
13422>>>>>>>>>End_Struct
13422>>>>>>>>>
13422>>>>>>>>>Struct tPLAINTEXTKEYBLOB
13422>>>>>>>>>    PUBLICKEYSTRUC hdr
13422>>>>>>>>>    PUBLICKEYSTRUC hdr
13422>>>>>>>>>    UInteger       dwKeySize
13422>>>>>>>>>//    UChar[]        rgbKeyData
13422>>>>>>>>>End_Struct
13422>>>>>>>>>
13422>>>>>>>>>
13422>>>>>>>>>
13422>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
13422>>>>>>>>>Struct HMAC_INFO
13422>>>>>>>>>    UInteger HashAlgid
13422>>>>>>>>>    Pointer pbInnerString
13422>>>>>>>>>    DWord cbInnerString
13422>>>>>>>>>    Pointer pbOuterString
13422>>>>>>>>>    DWord cbOuterString
13422>>>>>>>>>End_Struct
13422>>>>>>>>>
13422>>>>>>>>>Struct BLOBHEADER
13422>>>>>>>>>    UChar   bType
13422>>>>>>>>>    UChar   bVersion
13422>>>>>>>>>    Short   reserved
13422>>>>>>>>>    Integer aiKeyAlg
13422>>>>>>>>>End_Struct
13422>>>>>>>>>
13422>>>>>>>>>Struct CryptoBlob
13422>>>>>>>>>    BLOBHEADER  header
13422>>>>>>>>>    BLOBHEADER  header
13422>>>>>>>>>    Integer     cbKeySize
13422>>>>>>>>>    UChar[32]   rgbKeyData
13422>>>>>>>>>End_Struct
13422>>>>>>>>>
13422>>>>>>>>>
13422>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
13422>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13423>>>>>>>>>
13423>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
13423>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13425>>>>>>>>>    
13425>>>>>>>>>    Boolean bResult
13425>>>>>>>>>    UWide   uwContainer uwProvider
13425>>>>>>>>>    UWide   uwContainer uwProvider
13425>>>>>>>>>
13425>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
13426>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
13427>>>>>>>>>    
13427>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
13428>>>>>>>>>
13428>>>>>>>>>    Function_Return bResult
13429>>>>>>>>>End_Function
13430>>>>>>>>>
13430>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
13431>>>>>>>>>
13431>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
13432>>>>>>>>>
13432>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
13433>>>>>>>>>
13433>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
13434>>>>>>>>>
13434>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13435>>>>>>>>>
13435>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
13436>>>>>>>>>
13436>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
13437>>>>>>>>>
13437>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13438>>>>>>>>>
13438>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
13439>>>>>>>>>    
13439>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
13440>>>>>>>>>
13440>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
13441>>>>>>>>>
13441>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13442>>>>>>>>>
13442>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
13443>>>>>>>>>    
13443>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
13444>>>>>>>>>    
13444>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13445>>>>>>>>>    
13445>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13446>>>>>>>
13446>>>>>>>Class cCryptographerEx is a cObject
13447>>>>>>>    
13447>>>>>>>    Procedure Construct_Object
13449>>>>>>>        Forward Send Construct_Object
13451>>>>>>>        
13451>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
13452>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
13453>>>>>>>        Property Integer    piCipher    CALG_RC4
13454>>>>>>>        Property Integer    piHash      CALG_MD5
13455>>>>>>>        
13455>>>>>>>        // Private properties
13455>>>>>>>        Property Handle     Private_phProv
13456>>>>>>>        
13456>>>>>>>        // Block cipher properties
13456>>>>>>>        Property UChar[]    paKey
13457>>>>>>>        Property UChar[]    paIV
13458>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
13459>>>>>>>        Property Integer    piKeyType       CALG_AES_256
13460>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
13461>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
13462>>>>>>>        Property Integer    piBlockSize     16
13463>>>>>>>    End_Procedure
13464>>>>>>>    
13464>>>>>>>    
13464>>>>>>>    // Acquire key container handle
13464>>>>>>>    Function AcquireContext Returns Handle
13466>>>>>>>        Integer iProvider
13466>>>>>>>        WString wProvider
13466>>>>>>>        Handle hProv
13466>>>>>>>        Boolean bOk
13466>>>>>>>        Pointer pProv
13466>>>>>>>        
13466>>>>>>>        Move 0 to hProv
13467>>>>>>>        Get piProvider to iProvider
13468>>>>>>>        Get psProvider to wProvider
13469>>>>>>>        
13469>>>>>>>        //  Determine address to be passed as provider
13469>>>>>>>        If (Trim(wProvider) <> "") Begin
13471>>>>>>>            Move (AddressOf(wProvider)) to pProv
13472>>>>>>>        End
13472>>>>>>>>
13472>>>>>>>        Else Begin
13473>>>>>>>            Move 0 to pProv
13474>>>>>>>        End
13474>>>>>>>>
13474>>>>>>>        
13474>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
13474>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
13475>>>>>>>        If (not(bOk) or hProv = 0) Begin
13477>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
13478>>>>>>>        End
13478>>>>>>>>
13478>>>>>>>        
13478>>>>>>>        If (not(bOk) or hProv = 0) Begin
13480>>>>>>>            // Fallback to original
13480>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
13481>>>>>>>            
13481>>>>>>>            If (not(bOk) or hProv = 0) Begin
13483>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
13484>>>>>>>            End
13484>>>>>>>>
13484>>>>>>>        End
13484>>>>>>>>
13484>>>>>>>        Set Private_phProv to hProv
13485>>>>>>>        
13485>>>>>>>        Function_Return hProv
13486>>>>>>>    End_Function
13487>>>>>>>    
13487>>>>>>>    // Releases key container handle
13487>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
13489>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
13490>>>>>>>    End_Function
13491>>>>>>>    
13491>>>>>>>    // Creates hash object
13491>>>>>>>    Function CreateHash Handle hProv Returns Handle
13493>>>>>>>        Integer iAlgorithm
13493>>>>>>>        Handle hHash
13493>>>>>>>        Boolean bOk
13493>>>>>>>        
13493>>>>>>>        Move 0 to hHash
13494>>>>>>>        Get piHash to iAlgorithm
13495>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
13496>>>>>>>        
13496>>>>>>>        Function_Return hHash
13497>>>>>>>    End_Function
13498>>>>>>>    
13498>>>>>>>    // Destroys the hash object
13498>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
13500>>>>>>>        Function_Return (CryptDestroyHash(hHash))
13501>>>>>>>    End_Function
13502>>>>>>>    
13502>>>>>>>    // Adds data to hash object
13502>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
13504>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
13505>>>>>>>    End_Function
13506>>>>>>>    
13506>>>>>>>    // Generates session key
13506>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
13508>>>>>>>        Integer iAlgorithm
13508>>>>>>>        Handle hKey
13508>>>>>>>        Boolean bOk
13508>>>>>>>        
13508>>>>>>>        Move 0 to hKey
13509>>>>>>>        Get piCipher to iAlgorithm
13510>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
13511>>>>>>>        
13511>>>>>>>        Function_Return hKey
13512>>>>>>>    End_Function
13513>>>>>>>    
13513>>>>>>>    // Imports a plain text key
13513>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
13515>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13515>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13515>>>>>>>        Boolean   bSuccess
13515>>>>>>>        Handle    hKey
13515>>>>>>>        Integer   iHeadSize iKeySize
13515>>>>>>>        UChar[]   ucaKeyblob
13516>>>>>>>        Integer iVoid
13516>>>>>>>        
13516>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
13517>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
13518>>>>>>>        
13518>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
13519>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
13520>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
13521>>>>>>>        Move iKeySize           to blobhead.dwKeySize
13522>>>>>>>        
13522>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
13523>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
13524>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
13525>>>>>>>        
13525>>>>>>>        Move 0 to hKey
13526>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
13527>>>>>>>        If (not(bSuccess)) Begin
13529>>>>>>>            Move (ShowLastError()) to iVoid
13530>>>>>>>        End
13530>>>>>>>>
13530>>>>>>>        
13530>>>>>>>        Function_Return hKey
13531>>>>>>>    End_Function
13532>>>>>>>    
13532>>>>>>>    // Destroys the key
13532>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
13534>>>>>>>        Function_Return (CryptDestroyKey(hKey))
13535>>>>>>>    End_Function
13536>>>>>>>    
13536>>>>>>>    // Retrieves key data
13536>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
13538>>>>>>>        Integer iBuffer iLen
13538>>>>>>>        Boolean bOk
13538>>>>>>>        
13538>>>>>>>        Move (SizeOfType(Integer)) to iLen
13539>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
13540>>>>>>>        Function_Return iBuffer
13541>>>>>>>    End_Function
13542>>>>>>>    
13542>>>>>>>    // Retrieves a hash value
13542>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
13544>>>>>>>        UChar[] ucHash
13545>>>>>>>        Integer liResult
13545>>>>>>>        DWord   dwDataLen
13545>>>>>>>        
13545>>>>>>>        Move 0 to dwDataLen
13546>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
13547>>>>>>>        If (liResult = 0) ;            Function_Return ""
13550>>>>>>>        
13550>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
13551>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
13552>>>>>>>        If (liResult = 0) ;            Function_Return ""
13555>>>>>>>        
13555>>>>>>>        Function_Return ucHash
13556>>>>>>>    End_Function
13557>>>>>>>
13557>>>>>>>    // Encrypts data
13557>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13559>>>>>>>        Handle hProv hHash hKey
13559>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
13559>>>>>>>        Boolean bOk
13559>>>>>>>        
13559>>>>>>>        Get AcquireContext to hProv
13560>>>>>>>        If (hProv) Begin
13562>>>>>>>            Get CreateHash hProv to hHash
13563>>>>>>>            If (hHash) Begin
13565>>>>>>>                Get HashData hHash ucPassword to bOk
13566>>>>>>>                If (bOk) Begin
13568>>>>>>>                    Get piCipher to iAlgorithm
13569>>>>>>>                    Get DeriveKey hProv hHash to hKey
13570>>>>>>>                End
13570>>>>>>>>
13570>>>>>>>                Get DestroyHash hHash to bOk
13571>>>>>>>            End
13571>>>>>>>>
13571>>>>>>>            
13571>>>>>>>            If (hKey) Begin
13573>>>>>>>                //  First call to determine resulting data size
13573>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13574>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
13575>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
13576>>>>>>>                
13576>>>>>>>                //  Reserve space in string
13576>>>>>>>                If (iDataLen < iCipherLen) Begin
13578>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
13579>>>>>>>                End
13579>>>>>>>>
13579>>>>>>>                
13579>>>>>>>                //  Call to really decrypt
13579>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
13580>>>>>>>                //If (not(bOk)) Begin
13580>>>>>>>                //Move "" to sData
13580>>>>>>>                //Move (GetLastError()) to iErr
13580>>>>>>>                //End
13580>>>>>>>                
13580>>>>>>>                Get DestroyKey hKey to bOk
13581>>>>>>>            End 
13581>>>>>>>>
13581>>>>>>>            Get ReleaseContext hProv to bOk
13582>>>>>>>        End 
13582>>>>>>>>
13582>>>>>>>        Function_Return ucData
13583>>>>>>>    End_Function
13584>>>>>>>    
13584>>>>>>>    // Decrypts data
13584>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13586>>>>>>>        Handle hProv hHash hKey
13586>>>>>>>        Integer iAlgorithm iDataLen
13586>>>>>>>        Boolean bOk
13586>>>>>>>        
13586>>>>>>>        Get AcquireContext to hProv
13587>>>>>>>        If (hProv) Begin
13589>>>>>>>            Get CreateHash hProv to hHash
13590>>>>>>>            If (hHash) Begin
13592>>>>>>>                Get HashData hHash ucPassword to bOk
13593>>>>>>>                If (bOk) Begin
13595>>>>>>>                    Get piCipher to iAlgorithm
13596>>>>>>>                    Get DeriveKey hProv hHash to hKey
13597>>>>>>>                End
13597>>>>>>>>
13597>>>>>>>                Get DestroyHash hHash to bOk
13598>>>>>>>            End
13598>>>>>>>>
13598>>>>>>>            
13598>>>>>>>            If (hKey) Begin
13600>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13601>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
13602>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
13602>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
13604>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
13605>>>>>>>                End
13605>>>>>>>>
13605>>>>>>>                
13605>>>>>>>                Get DestroyKey hKey to bOk
13606>>>>>>>            End
13606>>>>>>>>
13606>>>>>>>            Get ReleaseContext hProv to bOk
13607>>>>>>>        End
13607>>>>>>>>
13607>>>>>>>        Function_Return ucData
13608>>>>>>>    End_Function
13609>>>>>>>    
13609>>>>>>>    // Creates a key
13609>>>>>>>    Function CreateKey Handle hProv Returns Handle
13611>>>>>>>        Integer iAlg iType iByte iLength iSize
13611>>>>>>>        CryptoBlob keyBlob
13611>>>>>>>        CryptoBlob keyBlob
13611>>>>>>>        Boolean bOk
13611>>>>>>>        Handle hKey
13611>>>>>>>        UChar[] aKey
13612>>>>>>>
13612>>>>>>>        Get paKey to aKey
13613>>>>>>>        Get piKeyAlg to iAlg
13614>>>>>>>        Get piKeyType to iType
13615>>>>>>>        Move iAlg                   to keyBlob.header.bType
13616>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
13617>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
13618>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
13619>>>>>>>        
13619>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
13620>>>>>>>        For iByte from 0 to iLength
13626>>>>>>>>
13626>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
13627>>>>>>>        Loop
13628>>>>>>>>
13628>>>>>>>        
13628>>>>>>>        Move 0 to hKey
13629>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
13630>>>>>>>        Function_Return hKey
13631>>>>>>>    End_Function
13632>>>>>>>    
13632>>>>>>>    // Sets the key parameters
13632>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
13634>>>>>>>        Integer iPadding iMode
13634>>>>>>>        Boolean bOk
13634>>>>>>>        UChar[] aIV
13635>>>>>>>        
13635>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
13635>>>>>>>        //For iByte from 0 to iLength
13635>>>>>>>        //    Move iByte to aIV[iByte]
13635>>>>>>>        //Loop
13635>>>>>>>
13635>>>>>>>        // Set initialization vector
13635>>>>>>>        Get paIV to aIV
13636>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
13637>>>>>>>        If (bOk) Begin
13639>>>>>>>            // Set padding
13639>>>>>>>            Get piKeyPadding to iPadding
13640>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
13641>>>>>>>            If (bOk) Begin
13643>>>>>>>                // Set move
13643>>>>>>>                Get piKeyMode to iMode
13644>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
13645>>>>>>>            End
13645>>>>>>>>
13645>>>>>>>        End
13645>>>>>>>>
13645>>>>>>>        Function_Return bOk        
13646>>>>>>>    End_Function
13647>>>>>>>    
13647>>>>>>>    // Encrypts using block cipher
13647>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
13649>>>>>>>        Handle hProv hKey
13649>>>>>>>        Integer iLen iSize iBlocks
13649>>>>>>>        Boolean bOk
13649>>>>>>>        
13649>>>>>>>        Get AcquireContext to hProv
13650>>>>>>>        If (hProv) Begin
13652>>>>>>>            // Create key
13652>>>>>>>            Get CreateKey hProv to hKey
13653>>>>>>>            If (hKey) Begin
13655>>>>>>>                Get SetKeyParameters hKey to bOk
13656>>>>>>>                If (bOk) Begin
13658>>>>>>>                    // Buffer for block ciphers can be up to block length larger
13658>>>>>>>                    Get piBlockSize to iSize
13659>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13660>>>>>>>                    
13660>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
13661>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
13662>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
13663>>>>>>>                End
13663>>>>>>>>
13663>>>>>>>                Get DestroyKey hKey to bOk
13664>>>>>>>            End
13664>>>>>>>>
13664>>>>>>>            Get ReleaseContext hProv to bOk
13665>>>>>>>        End
13665>>>>>>>>
13665>>>>>>>        Function_Return ucData
13666>>>>>>>    End_Function
13667>>>>>>>    
13667>>>>>>>    // Decrypts using block cipher
13667>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
13669>>>>>>>        Handle hProv hKey
13669>>>>>>>        Integer iLen
13669>>>>>>>        Boolean bOk
13669>>>>>>>        
13669>>>>>>>        Get AcquireContext to hProv
13670>>>>>>>        If (hProv) Begin
13672>>>>>>>            // Create key
13672>>>>>>>            Get CreateKey hProv to hKey
13673>>>>>>>            If (hKey) Begin
13675>>>>>>>                Get SetKeyParameters hKey to bOk
13676>>>>>>>                If (bOk) Begin
13678>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13679>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
13680>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
13681>>>>>>>                End
13681>>>>>>>>
13681>>>>>>>                Get DestroyKey hKey to bOk
13682>>>>>>>            End
13682>>>>>>>>
13682>>>>>>>            Get ReleaseContext hProv to bOk
13683>>>>>>>        End
13683>>>>>>>>
13683>>>>>>>        Function_Return ucData
13684>>>>>>>    End_Function
13685>>>>>>>    
13685>>>>>>>    
13685>>>>>>>    //  Generates random data.
13685>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
13687>>>>>>>        Handle hProv
13687>>>>>>>        UChar[] uaResult
13688>>>>>>>        Boolean bRes
13688>>>>>>>        
13688>>>>>>>        Get AcquireContext to hProv
13689>>>>>>>        
13689>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
13690>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
13691>>>>>>>        
13691>>>>>>>        Get ReleaseContext hProv to bRes
13692>>>>>>>        
13692>>>>>>>        Function_Return uaResult
13693>>>>>>>    End_Function
13694>>>>>>>    
13694>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
13694>>>>>>>    Function GenerateRandomString Integer iLength Returns String
13696>>>>>>>        String sResult
13696>>>>>>>        UChar[] ucData
13697>>>>>>>        Pointer pBase64
13697>>>>>>>        Integer iVoid
13697>>>>>>>        
13697>>>>>>>        Get GenerateRandom iLength to ucData
13698>>>>>>>        
13698>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
13699>>>>>>>        Move (PointerToString(pBase64)) to sResult
13700>>>>>>>        Move (Free(pBase64)) to iVoid
13701>>>>>>>        
13701>>>>>>>        Function_Return (Left(sResult, iLength))
13702>>>>>>>    End_Function
13703>>>>>>>    
13703>>>>>>>End_Class
13704>>>>>
13704>>>>>Class cLoginEncryption is a cObject
13705>>>>>    
13705>>>>>    Procedure Construct_Object
13707>>>>>        Forward Send Construct_Object
13709>>>>>        // this must be set to a multi (40ish) character random key
13709>>>>>        Property String psEncryptPassword ""
13710>>>>>        
13710>>>>>        Object oDataCrypter is a cCryptographerEx
13712>>>>>            Set piHash to CALG_SHA_256
13713>>>>>            Set piCipher to CALG_AES_256
13714>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
13715>>>>>            Set piProvider to PROV_RSA_AES
13716>>>>>        End_Object
13717>>>>>    End_Procedure
13718>>>>>    
13718>>>>>    // This can be augmented to return a password encryption key using any
13718>>>>>    // hidden mechanism desired.
13718>>>>>    Function GetEncryptionPassword Returns String
13720>>>>>        String sPassword
13720>>>>>        Get psEncryptPassword to sPassword
13721>>>>>        Function_Return sPassword
13722>>>>>    End_Function
13723>>>>>    
13723>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
13723>>>>>    //
13723>>>>>    // Params:
13723>>>>>    //   sPlainText     String to encrypt.
13723>>>>>    // Returns:
13723>>>>>    //   Base64 encoded hash.
13723>>>>>    Function EncryptPassword String sPlainText Returns String
13725>>>>>        String sEncryptPassword sBase64
13725>>>>>        UChar[] ucBinary
13726>>>>>        Pointer pBase64
13726>>>>>        Integer iVoid
13726>>>>>        
13726>>>>>        //  Encrypt Key
13726>>>>>        Get GetEncryptionPassword to sEncryptPassword
13727>>>>>        If (sEncryptPassword = "") Begin
13729>>>>>            Error DFERR_PROGRAM "No encryption password set"
13730>>>>>>
13730>>>>>        End
13730>>>>>>
13730>>>>>        
13730>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
13731>>>>>        
13731>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
13733>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
13734>>>>>>
13734>>>>>            Function_Return ""
13735>>>>>        End
13735>>>>>>
13735>>>>>        
13735>>>>>        //  Encode binary hash to Base64
13735>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
13736>>>>>        Move (PointerToString(pBase64)) to sBase64
13737>>>>>        Move (Free(pBase64)) to iVoid
13738>>>>>        
13738>>>>>        Function_Return sBase64
13739>>>>>    End_Function
13740>>>>>    
13740>>>>>    
13740>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
13740>>>>>    //
13740>>>>>    // Params:
13740>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
13740>>>>>    // Returns:
13740>>>>>    //   Readable plain text password
13740>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
13742>>>>>        String sEncryptPassword
13742>>>>>        UChar[] ucBinary ucPlain
13744>>>>>        Boolean bIsHex
13744>>>>>        Integer iLen iVoid
13744>>>>>        Pointer pBinary
13744>>>>>        
13744>>>>>        If (sBase64EncryptedPassword <> "") Begin
13746>>>>>            //  Decode from Base64
13746>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
13747>>>>>            
13747>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
13748>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
13749>>>>>                        
13749>>>>>            Move (Free(pBinary)) to iVoid
13750>>>>>            
13750>>>>>            //  Encrypted binary hash to string
13750>>>>>            Get GetEncryptionPassword to sEncryptPassword
13751>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
13752>>>>>        End
13752>>>>>>
13752>>>>>        
13752>>>>>        Function_Return (UCharArrayToString(ucPlain))
13753>>>>>    End_Function
13754>>>>>End_Class
13755>>>
13755>>>Object oLoginEncryption is a cLoginEncryption
13757>>>
13757>>>    // this must be created in your appsrc directory and must contain an encryption
13757>>>    // key that is set to psEncryptPassword. It will look something like this
13757>>>    //
13757>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
13757>>>    //  
Including file: LoginEncryptionKey.inc    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\AppSrc\LoginEncryptionKey.inc)
13757>>>>// Studio generated login encryption key
13757>>>>Set psEncryptPassword to "^EQaqq#xfhp>NK0gd8/^)Hfs(eSL%P^:?YqZY>Zj"
13758>>>>
13758>>>    
13758>>>    // use this to register this object to your cConnection Object. This object
13758>>>    // must be created after the cConnection object
13758>>>    Move Self to ghoLoginEncryption
13759>>>End_Object
13760>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.0\Pkg\DatabaseLoginDialog.dg)
13760>>>
13760>>>Use Windows.pkg
13760>>>Use cConnection.pkg
13760>>>Use dfLine.pkg
Including file: Dfline.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dfline.pkg)
13760>>>>>Use windows.pkg
13760>>>>>
13760>>>>>//
13760>>>>>// Line Styles
13760>>>>>//
13760>>>>>Enumeration_List
13760>>>>>    Define lnDIP        // grey (Shadow) top line, light bottom (highlight)
13760>>>>>    Define lnBUMP       // light top (highlight), grey (Shadow) bottom
13760>>>>>    Define lnSINGLE     // Single dark line
13760>>>>>    Define lnCUSTOM     // create your own with line_color1 & 2.
13760>>>>>End_Enumeration_List
13760>>>>>
13760>>>>>Class LineControl is a DFBaseLineControl
13761>>>>>    
13761>>>>>    Procedure Construct_Object
13763>>>>>        Forward Send Construct_Object
13765>>>>>        Property Integer Line_Color1  COLOR_BTNSHADOW
13766>>>>>        Property Integer Line_Color2  COLOR_BTNHIGHLIGHT
13767>>>>>        // we do not want control to participate in forward backwards object navigation
13767>>>>>        Set Skip_State to True
13768>>>>>    End_Procedure
13769>>>>>    
13769>>>>>    Procedure Notify Longptr wParam Longptr lParam
13771>>>>>    End_Procedure
13772>>>>>    
13772>>>>>    Procedure Set Line_Color1 Integer theColor
13774>>>>>        Set top_line_color to theColor
13775>>>>>    End_Procedure
13776>>>>>    
13776>>>>>    Procedure Set Line_Color2 Integer theColor
13778>>>>>        Set bottom_line_color to theColor
13779>>>>>    End_Procedure
13780>>>>>    
13780>>>>>    Function Line_Color1 Returns Integer
13782>>>>>        Function_Return (top_line_color(Self))
13783>>>>>    End_Function
13784>>>>>    
13784>>>>>    Function Line_Color2 Returns Integer
13786>>>>>        Function_Return (bottom_line_color(Self))
13787>>>>>    End_Function
13788>>>>>End_Class
13789>>>>>
13789>>>
13789>>>Object oDatabaseLoginDialog is a ModalPanel
13791>>>    Set Label to "Database Login"
13792>>>    Set Location to 2 2
13793>>>    Set Size to 110 211
13794>>>    
13794>>>    Property String psId
13796>>>    Property Boolean pbOk False
13798>>>    Property Boolean pbChanged False
13800>>>    Property Boolean pbAllowRemember True
13802>>>    
13802>>>    // this registers this object with the cConnection object.
13802>>>    Move Self to ghoLoginConnectDialog
13803>>>    
13803>>>    Object oUserIDForm is a Form
13805>>>        Set Label to "User Name"
13806>>>        Set Size to 12 85
13807>>>        Set Location to 34 79
13808>>>        Set Label_Col_Offset to 64
13809>>>        Set peAnchors to anTopLeftRight
13810>>>    End_Object
13811>>>    
13811>>>    Object oPwdForm is a Form
13813>>>        Set Size to 12 85
13814>>>        Set Location to 49 79
13815>>>        Set Label_Col_Offset to 64
13816>>>        Set Password_State to True
13817>>>        Set peAnchors to anTopLeftRight
13818>>>        Set Label to "Password"
13819>>>    End_Object
13820>>>    
13820>>>    Object oTrustedConnection is a CheckBox
13822>>>        Set Size to 10 50
13823>>>        Set Location to 65 79
13824>>>        Set Label to "Trusted Connection"
13825>>>    End_Object
13826>>>    
13826>>>    Object oRemember is a CheckBox
13828>>>        Set Size to 10 50
13829>>>        Set Location to 79 14
13830>>>        Set Label to "Remember and don't ask again"
13831>>>        Set Checked_State to True
13832>>>    End_Object
13833>>>    
13833>>>    Object oLogin_btn is a Button
13835>>>        Set Label to "&Login"
13836>>>        Set Location to 92 102
13837>>>        Set peAnchors to anBottomRight
13838>>>        Set Default_State to True
13839>>>        
13839>>>        Procedure OnClick
13842>>>            Boolean bTrust
13842>>>            String sUser sPwd sConn sErr sId
13842>>>            Integer iError
13842>>>            Get psId to sId
13843>>>            Get Value of oUserIDForm to sUser
13844>>>            Get Value of oPwdForm to sPwd
13845>>>            Get Checked_State of oTrustedConnection to bTrust
13846>>>            
13846>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
13847>>>            If (iError=0) Begin
13849>>>                Set pbOk to True
13850>>>                Set pbChanged to True
13851>>>                Send Close_Panel
13852>>>            End
13852>>>>
13852>>>            Else Begin
13853>>>                Get psErrorText of ghoConnection to sErr
13854>>>                Send UserError sErr "Login Error"
13855>>>            End
13855>>>>
13855>>>        End_Procedure
13856>>>    End_Object
13857>>>    
13857>>>    Object oCancel_btn is a Button
13859>>>        Set Label to "&Cancel"
13860>>>        Set Location to 92 157
13861>>>        Set peAnchors to anBottomRight
13862>>>        
13862>>>        Procedure OnClick
13865>>>            Send Close_Panel
13866>>>        End_Procedure
13867>>>    End_Object
13868>>>    
13868>>>    Object oConnectionIdInfo is a TextBox
13870>>>        Set Size to 10 50
13871>>>        Set Location to 4 14
13872>>>        Set Label to 'Connection Id='
13873>>>    End_Object
13874>>>    
13874>>>    Object oConnectionServerInfo is a TextBox
13876>>>        Set Size to 10 50
13877>>>        Set Location to 16 14
13878>>>        Set Label to 'Server'
13879>>>    End_Object
13880>>>    
13880>>>    Object oLineControl1 is a LineControl
13882>>>        Set Size to 2 202
13883>>>        Set Location to 29 5
13884>>>    End_Object
13885>>>    
13885>>>    Function LoginConnectIdDialog String sId Returns Boolean
13888>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
13888>>>        String sUser sPwd sDescription
13888>>>        tConnection Connect
13888>>>        tConnection Connect
13888>>>        
13888>>>        Get pbAllowRemember to bAllowRemember
13889>>>        
13889>>>        
13889>>>        If not bAllowRemember Begin
13891>>>            Set Enabled_State of oRemember to bRemember
13892>>>            Set Visible_State of oRemember to bRemember
13893>>>        End
13893>>>>
13893>>>        
13893>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
13894>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
13895>>>        Set Value of oConnectionServerInfo to Connect.sString
13896>>>        
13896>>>        Set psId to sId
13897>>>        Set pbOk to False
13898>>>        Set pbChanged to False
13899>>>        Set Value of oUserIDForm to Connect.sUID
13900>>>        Set Value of oPwdForm to ""
13901>>>        
13901>>>        Send Popup
13902>>>        
13902>>>        Get pbOk to bOk
13903>>>        Get pbChanged to bChanged
13904>>>        If (bChanged and bOk) Begin
13906>>>            If bAllowRemember Begin
13908>>>                Get Checked_State of oRemember to bRemember
13909>>>                If bRemember Begin
13911>>>                    Get Checked_State of oTrustedConnection to bTrusted
13912>>>                    If not (bTrusted) Begin
13914>>>                        Get Value of oUserIDForm to sUser
13915>>>                        Get Value of oPwdForm to sPwd
13916>>>                    End
13916>>>>
13916>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
13917>>>                End
13917>>>>
13917>>>            End
13917>>>>
13917>>>        End
13917>>>>
13917>>>        Function_Return bOk
13918>>>    End_Function
13919>>>    
13919>>>    
13919>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
13920>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
13921>>>End_Object
13922>>>
13922>    End_Object
13923>    
13923>End_Object
13924>
13924>Open Ingredients
Including file: Ingredients.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\Ingredients.fd)
13926>Open Recipe
Including file: Recipe.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\Recipe.fd)
13928>Open Kitchen
Including file: Kitchen.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\Kitchen.fd)
13930>
13930>Clear Ingredients
13931>Find GT Ingredients by 1
13932>While (Found)
13936>    Relate Ingredients
13937>    
13937>    Showln (SFormat ("Name: %1, Amount: %2, Recipe: %3, Kitchen: %4", Trim(Ingredients.Name), Trim(Ingredients.Amount), Trim(Recipe.Name), Trim(Kitchen.Name)))
13939>    
13939>    Find GT Ingredients by 1
13940>Loop
13941>
13941>Send Info_Box "Hello World" "DataFlex Basic Project"
13942>
Summary
Memory Available: 3790163968
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 12855
Total Resources: 0
Total Commands : 13941
Total Windows  : 0
Total Pages    : 0
Static Data    : 164620
Message area   : 73114
Total Blocks   : 7474
