Compiling Program: C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\AppSrc\LocalBuffer =.src
Memory Available: 8873701376
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 20.0\Pkg\windows.x64.pkd)
8041>Use cHtmlHelp.pkg
Including file: cHtmlHelp.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cHtmlHelp.pkg)
8041>>>Use windows.pkg
8041>>>Use LanguageText.pkg
8041>>>Use cHtmlHelp.inc // API Functions and Constants, etc.
Including file: cHtmlHelp.inc    (C:\Program Files\DataFlex 20.0\Pkg\cHtmlHelp.inc)
8041>>>>>Use Unicode.Pkg
8041>>>>>
8041>>>>>// Do not call directly, use the wrapper function instead
8041>>>>>External_Function HtmlHelp "HtmlHelpW" HHCTRL.OCX ;    Handle  hwndCaller ;    WString sFile ;    Integer uCommand ;    Longptr dwData ;      // The Windows Kits source defines this as a DWORD_PTR, while the MSDN documentation says it is DWORD !!    Returns Handle
8042>>>>>
8042>>>>>// Declarations. Note HH_DISPLAY_TOPIC and HH_HELP_FINDER perform the same function for backward compatibility
8042>>>>>Define HH_DISPLAY_TOPIC         for |CI$0000
8042>>>>>Define HH_HELP_FINDER           for |CI$0000
8042>>>>>Define HH_DISPLAY_TOC           for |CI$0001
8042>>>>>Define HH_DISPLAY_INDEX         for |CI$0002
8042>>>>>Define HH_DISPLAY_SEARCH        for |CI$0003
8042>>>>>Define HH_SET_WIN_TYPE          for |CI$0004
8042>>>>>Define HH_GET_WIN_TYPE          for |CI$0005
8042>>>>>Define HH_GET_WIN_HANDLE        for |CI$0006
8042>>>>>Define HH_ENUM_INFO_TYPE        for |CI$0007
8042>>>>>Define HH_SET_INFO_TYPE         for |CI$0008
8042>>>>>Define HH_SYNC                  for |CI$0009
8042>>>>>Define HH_KEYWORD_LOOKUP        for |CI$000D
8042>>>>>Define HH_DISPLAY_TEXT_POPUP    for |CI$000E
8042>>>>>Define HH_HELP_CONTEXT          for |CI$000F
8042>>>>>Define HH_TP_HELP_CONTEXTMENU   for |CI$0010
8042>>>>>Define HH_TP_HELP_WM_HELP       for |CI$0011
8042>>>>>Define HH_CLOSE_ALL             for |CI$0012
8042>>>>>Define HH_ALINK_LOOKUP          for |CI$0013
8042>>>>>Define HH_GET_LAST_ERROR        for |CI$0014
8042>>>>>Define HH_ENUM_CATEGORY         for |CI$0015
8042>>>>>Define HH_ENUM_CATEGORY_IT      for |CI$0016
8042>>>>>Define HH_RESET_IT_FILTER       for |CI$0017
8042>>>>>Define HH_SET_INCLUSIVE_FILTER  for |CI$0018
8042>>>>>Define HH_SET_EXCLUSIVE_FILTER  for |CI$0019
8042>>>>>Define HH_INITIALIZE            for |CI$001C
8042>>>>>Define HH_UNINITIALIZE          for |CI$001D
8042>>>>>Define HH_PRETRANSLATEMESSAGE   for |CI$00FD
8042>>>>>Define HH_SET_GLOBAL_PROPERTY   for |CI$00FC
8042>>>>>
8042>>>>>
8042>>>Use GlobalFunctionsProcedures.pkg
8042>>>Use HelpSystemConstants.pkg
8042>>>
8042>>>Register_Function phoMainPanel Returns Integer
8042>>>
8042>>>
8042>>>Class cHtmlHelp is a cObject
8043>>>    Procedure Construct_Object
8045>>>        Forward Send Construct_Object
8047>>>        
8047>>>        
8047>>>        Move Self to ghoHtmlHelp // registers the object-handle globally
8048>>>        
8048>>>        Property String  psHelpFile ""
8049>>>        Property Handle  phoOwner           // object that is the owner of the HTML help window
8050>>>        Property Boolean pbAlwaysOnTop True // if true, help is always on top.
8051>>>        
8051>>>        Property Integer private_piCookie
8052>>>        
8052>>>        Send DoInitialize
8053>>>        
8053>>>    End_Procedure
8054>>>    
8054>>>    Procedure Destroy_Object
8056>>>        Send DoDeInitialize
8057>>>        Forward Send Destroy_Object
8059>>>    End_Procedure
8060>>>    
8060>>>    // get owner's window handle. if phoOwner not defined use
8060>>>    // handle of application objects phoMainPanel. If no owner return 0
8060>>>    Function GetOwnerWindowHandle Returns Handle
8062>>>        Handle hoOwner
8062>>>        // if not always on top we want to use the windows desktop window handle. When the desktop is the owner
8062>>>        // you don't get on-top behavior and the help windows does not minimize when you minimize
8062>>>        // main program. When the Main panel has the focus, you get the on-top behavior.
8062>>>        If (pbAlwaysOnTop(Self)) Begin
8064>>>            Get phoOwner to hoOwner
8065>>>            If (hoOwner=0 and ghoApplication) ;                Get phoMainPanel of ghoApplication to hoOwner
8068>>>            If hoOwner ;                Get window_handle of hoOwner to hoOwner // the DF objects window handle
8071>>>        End
8071>>>>
8071>>>        // owner will be 0, if we could not find a main active handle or, the more likely
8071>>>        // case, pbAlwaysOnTop is set false. Using the windows destkop stops help on top.
8071>>>        If (hoOwner=0) Begin
8073>>>            Move (GetDesktopWindow()) to hoOwner
8074>>>        End
8074>>>>
8074>>>        Function_Return hoOwner
8075>>>    End_Function
8076>>>    
8076>>>    Function GetHelpFile Returns String
8078>>>        String sHelpFile
8078>>>        Get psHelpFile to sHelpFile
8079>>>        // if name is not directly set object, see if we can get it from the application object
8079>>>        If (sHelpFile="" and ghoApplication and peHelpType(ghoApplication)=htHtmlHelp);            Get psHelpFile of ghoApplication to sHelpFile
8082>>>        If (sHelpFile<>"") ;            Get_File_Path sHelpFile to sHelpFile
8085>>>        Function_Return sHelpFile
8086>>>    End_Function
8087>>>    
8087>>>    // It appears that using hh_initialize/hh_uninitialze causes keyboard problems with
8087>>>    // embedded help which causing ctrl+c to not work. According to messages found on a Newsgroup this
8087>>>    // is a known issue and that not using these is the solution. The general advice was to stay
8087>>>    // away from these messages - and it does seem to solve the problem (jjt)
8087>>>    
8087>>>    Procedure DoInitialize
8089>>>//        //Must be sent before any HTML commands can be used
8089>>>//        Handle hRetVal
8089>>>//        Integer dwCookie
8089>>>//        String sBuffer
8089>>>//        Pointer pBuffer
8089>>>        
8089>>>//        Zerotype tDWORD TO sBuffer
8089>>>//        GetAddress OF sBuffer TO pBuffer
8089>>>        
8089>>>//        Move (HtmlHelp(0, "", HH_INITIALIZE, pBuffer)) TO hRetVal
8089>>>//        GetBuff From sBuffer AT tDWORD.DWord TO dwCookie
8089>>>//        Set private_piCookie TO dwCookie
8089>>>    End_Procedure
8090>>>    
8090>>>    Procedure DoDeInitialize
8092>>>//        //Must be sent to free resources
8092>>>//        Dword dwCookie
8092>>>//        Handle hRetVal
8092>>>//        String sHelpFile
8092>>>//        Get private_piCookie TO dwCookie
8092>>>        
8092>>>//        Move (HtmlHelp(0, "", HH_UNINITIALIZE, dwCookie))TO hRetVal
8092>>>    End_Procedure
8093>>>    
8093>>>    Procedure DoDisplayTopic WString wTopic
8095>>>        //Most-used command. Pops up the tri-pane Help Viewer.
8095>>>        Handle hRetVal
8095>>>        String sHelpFile
8095>>>        Get GetHelpFile to sHelpFile
8096>>>        If (sHelpFile<>"") Begin
8098>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOPIC, AddressOf(wTopic))) to hRetVal
8099>>>        End
8099>>>>
8099>>>    End_Procedure
8100>>>    
8100>>>    Procedure DoDisplayIndex
8102>>>        //Another commonly-used command. Pops up the topic for the current index entry.
8102>>>        Handle hRetVal
8102>>>        String sHelpFile
8102>>>        Get GetHelpFile to sHelpFile
8103>>>        If (sHelpFile<>"") Begin
8105>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, 0)) to hRetVal
8106>>>        End
8106>>>>
8106>>>    End_Procedure
8107>>>    
8107>>>    Procedure DoDisplayIndexString WString wIndex
8109>>>        //Another commonly-used command. Shows the Index, and highlights the sIndex entry
8109>>>        Handle hRetVal
8109>>>        String sHelpFile
8109>>>        Get GetHelpFile to sHelpFile
8110>>>        If (sHelpFile<>"") Begin
8112>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_INDEX, AddressOf(wIndex))) to hRetVal
8113>>>        End
8113>>>>
8113>>>    End_Procedure
8114>>>    
8114>>>    Procedure DoShowMapId Longptr iMapID
8116>>>        //Passed an integer of the MapID allocated to the topic
8116>>>        Handle hRetVal
8116>>>        String sHelpFile
8116>>>        Get GetHelpFile to sHelpFile
8117>>>        
8117>>>        If (sHelpFile<>"") Begin
8119>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_HELP_CONTEXT, iMapID)) to hRetVal
8120>>>            Send DoDisplayTOC
8121>>>            //Send DoSyncToc
8121>>>        End
8121>>>>
8121>>>    End_Procedure
8122>>>    
8122>>>    Procedure DoDisplayKeyword WString wKeyword
8124>>>        Handle hRetVal
8124>>>        String sHelpFile sErrorText
8124>>>        tWinHH_AKLink AKLink
8124>>>        tWinHH_AKLink AKLink
8124>>>        Get GetHelpFile to sHelpFile
8125>>>        If (sHelpFile<>"") Begin
8127>>>            
8127>>>            Move (SFormat(C_$SorryIsNotInTheIndex, wKeyword)) to sErrorText
8128>>>            
8128>>>            Move (SizeOfType(tWinHH_AKLink)) to AkLink.cbStruct
8129>>>            Move 0            to AkLink.fReserved
8130>>>            Move (AddressOf(wKeyword))   to AkLink.pszKeywords
8131>>>            Move 0            to AkLink.pszUrl
8132>>>            //Move (Addressof(sErrorText)) to AkLink.pszMsgText
8132>>>            Move 0  to AkLink.pszMsgText
8133>>>            Move 0  to AkLink.pszMsgTitle
8134>>>            Move 0  to AkLink.pszWindow
8135>>>            Move 0  to AkLink.fIndexOnFail
8136>>>            
8136>>>            Send DoDisplayIndexString wKeyword
8137>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_KEYWORD_LOOKUP, AddressOf(AkLink))) to hRetVal
8138>>>        End
8138>>>>
8138>>>    End_Procedure
8139>>>    
8139>>>    Procedure DoDisplayTOC
8141>>>        Handle hRetVal
8141>>>        String sHelpFile
8141>>>        Get GetHelpFile to sHelpFile
8142>>>        If (sHelpFile<>"") Begin
8144>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_TOC, 0)) to hRetVal
8145>>>        End
8145>>>>
8145>>>    End_Procedure
8146>>>    
8146>>>    Procedure DoSyncToc
8148>>>        Handle hRetVal
8148>>>        String sHelpFile
8148>>>        Get GetHelpFile to sHelpFile
8149>>>        If (sHelpFile<>"") Begin
8151>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_SYNC, 0)) to hRetVal
8152>>>        End
8152>>>>
8152>>>    End_Procedure
8153>>>    
8153>>>    Procedure DO_HH_DISPLAY_SEARCH WString wTopic
8155>>>        Handle hRetVal
8155>>>        String sHelpFile
8155>>>        Get GetHelpFile to sHelpFile
8156>>>        If (sHelpFile<>"") Begin
8158>>>            Move (HtmlHelp(GetOwnerWindowHandle(Self), sHelpFile, HH_DISPLAY_SEARCH, AddressOf(wTopic))) to hRetVal
8159>>>        End
8159>>>>
8159>>>    End_Procedure
8160>>>    
8160>>>End_Class
8161>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cApplication.pkg)
8161>>>Use Windows.pkg
8161>>>
8161>>>Use LanguageText.pkg
8161>>>Use WinUser.pkg
8161>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files\DataFlex 20.0\Pkg\WinShell.pkg)
8161>>>>>Use DLL.pkg
8161>>>>>
8161>>>>>Define S_OK                                     for |CI$00000000 // Operation successful
8161>>>>>Define E_ABORT                                  for |CI$80004004 // Operation aborted
8161>>>>>Define E_ACCESSDENIED                               for |CI$80070005 // General access denied error 
8161>>>>>Define E_FAIL                                   for |CI$80004005 // Unspecified failure
8161>>>>>Define E_HANDLE                                 for |CI$80070006 // Handle that is not valid
8161>>>>>Define E_INVALIDARG                             for |CI$80070057 // One or more arguments are not valid
8161>>>>>Define E_NOINTERFACE                            for |CI$80004002 // No such interface supported
8161>>>>>Define E_NOTIMPL                                for |CI$80004001 // not implemented
8161>>>>>Define E_OUTOFMEMORY                            for |CI$8007000E // Failed to allocate necessary memory
8161>>>>>Define E_POINTER                                for |CI$80004003 // Pointer that is not valid
8161>>>>>Define E_UNEXPECTED                             for |CI$8000FFFF // Unexpected failure
8161>>>>>
8161>>>>>External_Function PathFileExists "PathFileExistsW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8162>>>>>
8162>>>>>External_Function PathIsRelative "PathIsRelativeW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8163>>>>>
8163>>>>>// When called directly, be sure to use WString types.
8163>>>>>External_Function PathRemoveExtensionW "PathRemoveExtensionW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer // void
8164>>>>>
8164>>>>>// Compatibility Wrapper Function PathRemoveExtension
8164>>>>>Function PathRemoveExtension Global ;    Pointer lpPath ;    Returns Integer // Boolean
8166>>>>>    
8166>>>>>    Integer iResult
8166>>>>>    UWide   uwPath
8166>>>>>    UWide   uwPath
8166>>>>>
8166>>>>>    Send StringToWide lpPath (&uwPath)
8167>>>>>                    
8167>>>>>    Move (PathRemoveExtensionW (uwPath.lpUText)) to iResult 
8168>>>>>    
8168>>>>>    Send WideToString (&uwPath) lpPath
8169>>>>>        
8169>>>>>    Function_Return iResult
8170>>>>>End_Function
8171>>>>>
8171>>>>>// When called directly, be sure to use WString types.
8171>>>>>External_Function PathRemoveFileSpecW "PathRemoveFileSpecW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer
8172>>>>>    
8172>>>>>// Compatibility Wrapper Function PathRemoveFileSpec
8172>>>>>Function PathRemoveFileSpec Global ;    Pointer lpPath ;    Returns Integer // Boolean
8174>>>>>    
8174>>>>>    Integer iResult
8174>>>>>    UWide   uwPath
8174>>>>>    UWide   uwPath
8174>>>>>
8174>>>>>    Send StringToWide lpPath (&uwPath)
8175>>>>>                    
8175>>>>>    Move (PathRemoveFileSpecW (uwPath.lpUText)) to iResult 
8176>>>>>
8176>>>>>    Send WideToString (&uwPath) lpPath
8177>>>>>        
8177>>>>>    Function_Return iResult
8178>>>>>End_Function 
8179>>>>>
8179>>>>>Define URL_UNESCAPE_INPLACE                     for |CI$00100000
8179>>>>>Define URL_UNESCAPE_AS_UTF8                     for |CI$00040000
8179>>>>>Define URL_ESCAPE_SEGMENT_ONLY                  for |CI$00002000
8179>>>>>
8179>>>>>// When called directly, be sure to use WString types.
8179>>>>>External_Function UrlUnescapeW "UrlUnescapeW" shlwapi.dll;    Pointer pszwURL;    Pointer pszwUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8180>>>>>
8180>>>>>// Compatibility Wrapper Function UrlUnescape
8180>>>>>Function UrlUnescape Global ;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8182>>>>>    
8182>>>>>    Integer iResult
8182>>>>>    UWide   uwUrl uwUnescaped
8182>>>>>    UWide   uwUrl uwUnescaped
8182>>>>>
8182>>>>>    Send StringToWide pszURL (&uwUrl)
8183>>>>>
8183>>>>>    Send WideSetBuffer pszUnescaped pcchUnescaped (&uwUnescaped)
8184>>>>>                        
8184>>>>>    Move (UrlUnescapeW (uwUrl.lpUText, uwUnescaped.lpUText, uwUnescaped.lpSize, dwFlags)) to iResult
8185>>>>>    
8185>>>>>    If (dwFlags = URL_UNESCAPE_INPLACE) Begin
8187>>>>>        Send WideToString (&uwUrl) pszUrl 
8188>>>>>    End
8188>>>>>>
8188>>>>>    Else Begin
8189>>>>>        Send WideToString (&uwUnescaped) pszUnescaped  
8190>>>>>    End    
8190>>>>>>
8190>>>>>    
8190>>>>>    Function_Return iResult
8191>>>>>End_Function  
8192>>>>>
8192>>>>>// When called directly, be sure to use WString types.
8192>>>>>External_Function UrlEscapeW "UrlEscapeW" shlwapi.dll;    Pointer pszwUrl;    Pointer pszwEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8193>>>>>    
8193>>>>>// Compatibility Wrapper Function UrlEscape
8193>>>>>Function UrlEscape Global ;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8195>>>>>    
8195>>>>>    Integer iResult
8195>>>>>    UWide   uwUrl uwEscaped
8195>>>>>    UWide   uwUrl uwEscaped
8195>>>>>
8195>>>>>    Send StringToWide pszURL (&uwUrl)
8196>>>>>
8196>>>>>    Send WideSetBuffer pszEscaped pcchEscaped (&uwEscaped)
8197>>>>>                        
8197>>>>>    Move (UrlEscapeW (uwUrl.lpUText, uwEscaped.lpUText, pcchEscaped, dwFlags)) to iResult
8198>>>>>
8198>>>>>    Send WideToString (&uwEscaped) pszEscaped      
8199>>>>>    
8199>>>>>    Function_Return iResult
8200>>>>>End_Function 
8201>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cWorkspace.pkg)
8201>>>>>Use VdfBase.pkg
8201>>>>>Use tWinStructs.pkg
8201>>>>>Use LanguageText.pkg
8201>>>>>Use WinShell.pkg // Shell API functions
8201>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 20.0\Pkg\seq_chnl.pkg)
8201>>>>>>>Use LanguageText.pkg
8201>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 20.0\Pkg\errornum.inc)
8201>>>>>>>>
8201>>>>>>>>//
8201>>>>>>>>// these will get defined in fmac
8201>>>>>>>>//
8201>>>>>>>>// already defined
8201>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
8201>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
8201>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
8201>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
8201>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
8201>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
8201>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
8201>>>>>>>>// new compiler errors used by fmac
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
8201>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
8201>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
8201>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
8201>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
8201>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
8201>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
8201>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
8201>>>>>>>>
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_STRING_CMD       |CI4531 // pertaining to string commands
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TYPE_CMD         |CI4532 // pertaining to type/end_type commands
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CMD              |CI4533 // pertaining to a more generic obsolete command 
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_GLOBAL_FUNCTION  |CI4534 // Global function is obsolete
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TECHNIQUE        |CI4535 // Using some older technique
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_PACKAGE          |CI4536 // Package is obsolete, remove it if you can
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CLASS            |CI4537 // Class is obsolete, remove it if you can
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_INDICATOR_USE    |CI4538 // Using indicators anywhere
8201>>>>>>>>//    
8201>>>>>>>>//    #Replace DFERR_COMP_ILLEGAL_CONVERSION                            |CI4539 // Datatype conversion is illegal, would cause runtime-error
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_OBJECT_FUNCTION  |CI4540 // Global function is obsolete
8201>>>>>>>>//    #Replace DFERR_INVALID_LOCALE_CODE                    |CI4541 // Error thown by Set_Attribute DF_LOCALE_CODE on invalid value
8201>>>>>>>>//    #Replace DFERR_STRING_COMPARISON_ERROR                |CI4542 // Error during string comparison (ICU returned an error)
8201>>>>>>>>//    #Replace DFERR_COMP_WARNING_REDEFINING_RETURN_TYPE    |CI4543 // Warning when redefining a function with a different return type
8201>>>>>>>>//    #Replace DFERR_COMP_AMBIGUOUS_FUNCTION_EXPRESSION     |CI4544 // Error when using ambiguous function in expression
8201>>>>>>>>    
8201>>>>>>>>
8201>>>>>>>>
8201>>>>>>>
8201>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8201>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8201>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8201>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8201>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8201>>>>>>>// so that programs that use direct_input/output
8201>>>>>>>// w/o specifying a channel will work.
8201>>>>>>>Enum_List
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8201>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8201>>>>>>>End_Enum_List
8201>>>>>>>
8201>>>>>>>Enum_List
8201>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8201>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8201>>>>>>>End_Enum_List
8201>>>>>>>
8201>>>>>>>Integer Seq$Channel$Error$Mode
8201>>>>>>>
8201>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
8203>>>>>>>    Move Mode to Seq$Channel$Error$Mode
8204>>>>>>>End_Procedure
8205>>>>>>>
8205>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8207>>>>>>>    Function_Return Seq$Channel$Error$Mode
8208>>>>>>>End_Function
8209>>>>>>>
8209>>>>>>>Object Seq_Channel_List is an Array
8211>>>>>>>    Procedure Initialize
8214>>>>>>>        Integer Itm
8214>>>>>>>        
8214>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
8215>>>>>>>        
8215>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
8219>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
8220>>>>>>>            Increment Itm
8221>>>>>>>        Loop
8222>>>>>>>>
8222>>>>>>>    End_Procedure
8223>>>>>>>    
8223>>>>>>>    Send Initialize
8224>>>>>>>End_Object
8225>>>>>>>
8225>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8226>>>>>>>
8226>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
8228>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
8229>>>>>>>End_Function
8230>>>>>>>
8230>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
8232>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
8233>>>>>>>End_Procedure
8234>>>>>>>
8234>>>>>>>Function Seq_New_Channel Global Returns Integer
8236>>>>>>>    Integer Obj Chnl
8236>>>>>>>    
8236>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
8237>>>>>>>    
8237>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
8241>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8243>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8244>>>>>>>            Function_Return Chnl
8245>>>>>>>        End
8245>>>>>>>>
8245>>>>>>>        
8245>>>>>>>        Increment Chnl
8246>>>>>>>    Loop
8247>>>>>>>>
8247>>>>>>>    
8247>>>>>>>    // wrap back to beginning
8247>>>>>>>    Move 0 to Chnl
8248>>>>>>>    
8248>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
8252>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8254>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8255>>>>>>>            Function_Return Chnl
8256>>>>>>>        End
8256>>>>>>>>
8256>>>>>>>        
8256>>>>>>>        Increment Chnl
8257>>>>>>>    Loop
8258>>>>>>>>
8258>>>>>>>    
8258>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8259>>>>>>>End_Function
8260>>>>>>>
8260>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
8262>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
8265>>>>>>>End_Procedure
8266>>>>>>>
8266>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
8268>>>>>>>    Integer Chnl
8268>>>>>>>    
8268>>>>>>>    Move (Seq_New_Channel()) to Chnl
8269>>>>>>>    
8269>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8271>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
8274>>>>>>>        Function_Return Chnl
8275>>>>>>>    End
8275>>>>>>>>
8275>>>>>>>    
8275>>>>>>>    Move False to Err
8276>>>>>>>    Direct_Input channel Chnl Dvc
8278>>>>>>>    
8278>>>>>>>    If (Err) Begin
8280>>>>>>>        Send Seq_Release_Channel Chnl
8281>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8282>>>>>>>    End
8282>>>>>>>>
8282>>>>>>>    
8282>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
8283>>>>>>>    
8283>>>>>>>    Function_Return Chnl
8284>>>>>>>End_Function
8285>>>>>>>
8285>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
8287>>>>>>>    Integer Chnl
8287>>>>>>>    
8287>>>>>>>    Move (Seq_New_Channel()) to Chnl
8288>>>>>>>    
8288>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8290>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8292>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8293>>>>>>>>
8293>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8294>>>>>>>        End
8294>>>>>>>>
8294>>>>>>>        
8294>>>>>>>        Function_Return Chnl
8295>>>>>>>    End
8295>>>>>>>>
8295>>>>>>>    
8295>>>>>>>    Move False to Err
8296>>>>>>>    Direct_Output channel Chnl Dvc
8298>>>>>>>    
8298>>>>>>>    If (Err) Begin
8300>>>>>>>        Send Seq_Release_Channel Chnl
8301>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8302>>>>>>>    End
8302>>>>>>>>
8302>>>>>>>    
8302>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8303>>>>>>>    
8303>>>>>>>    Function_Return Chnl
8304>>>>>>>End_Function
8305>>>>>>>
8305>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
8307>>>>>>>    Integer Chnl
8307>>>>>>>    
8307>>>>>>>    Move (Seq_New_Channel()) to Chnl
8308>>>>>>>    
8308>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8310>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8312>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8313>>>>>>>>
8313>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8314>>>>>>>        End
8314>>>>>>>>
8314>>>>>>>        
8314>>>>>>>        Function_Return Chnl
8315>>>>>>>    End
8315>>>>>>>>
8315>>>>>>>    
8315>>>>>>>    Move False to Err
8316>>>>>>>    Append_Output channel Chnl Dvc
8318>>>>>>>    
8318>>>>>>>    If (Err) Begin
8320>>>>>>>        Send Seq_Release_Channel Chnl
8321>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8322>>>>>>>    End
8322>>>>>>>>
8322>>>>>>>    
8322>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8323>>>>>>>    
8323>>>>>>>    Function_Return Chnl
8324>>>>>>>End_Function
8325>>>>>>>
8325>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
8327>>>>>>>    Integer Mode
8327>>>>>>>    
8327>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
8329>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
8330>>>>>>>        
8330>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
8334>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
8339>>>>>>>        // If channel not open, release it! No (fatal) Error.
8339>>>>>>>        Send Seq_Release_Channel Chnl
8340>>>>>>>    End
8340>>>>>>>>
8340>>>>>>>End_Procedure
8341>>>>>>>
8341>>>>>Use GlobalFunctionsProcedures.pkg
8341>>>>>
8341>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8341>>>>>Register_Function VdfSystemDfPath   Returns String
8341>>>>>Register_Function VdfSystemMakePath Returns String
8341>>>>>
8341>>>>>Enum_List
8341>>>>>    Define wsWorkspaceOpened       // WS opened ok
8341>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8341>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8341>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8341>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8341>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8341>>>>>End_Enum_List
8341>>>>>
8341>>>>>
8341>>>>>Define INVALID_HANDLE_VALUE for -1
8341>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8341>>>>>
8341>>>>>
8341>>>>>// Wide version
8341>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8342>>>>>
8342>>>>>// Wrapper Function winFindNextFile
8342>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8344>>>>>    
8344>>>>>    Handle  hResult
8344>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8344>>>>>    Integer iSizeOfStructWithoutStrings
8344>>>>>    String  sFileName sAlternateFileName
8344>>>>>    WString wFileName wAlternateFileName
8344>>>>>    Pointer pWFD
8344>>>>>    tWin32FindDataW tWFD
8344>>>>>    tWin32FindDataW tWFD
8344>>>>>    
8344>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8344>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8344>>>>>
8344>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8345>>>>>    Move (AddressOf(tWFD)) to pWFD
8346>>>>>    
8346>>>>>    // Call the function
8346>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8347>>>>>
8347>>>>>    // Copy the struct contents back to the incoming one.
8347>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8348>>>>>    
8348>>>>>    // But do the strings separately and convert them to UTF8
8348>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8349>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8350>>>>>    
8350>>>>>    // Extend string with 0 to the maximum number of characters
8350>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8353>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8356>>>>>        
8356>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8357>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8358>>>>>    
8358>>>>>    Function_Return hResult
8359>>>>>End_Function
8360>>>>>
8360>>>>>// When used directly, be sure to use WString types (UTF16).
8360>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8361>>>>>
8361>>>>>// Wrapper Function winFindNextFile
8361>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8363>>>>>    
8363>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8363>>>>>    Integer iSizeOfStructWithoutStrings
8363>>>>>    String  sFileName sAlternateFileName
8363>>>>>    WString wFileName wAlternateFileName
8363>>>>>    Pointer pWFD
8363>>>>>    tWin32FindDataW tWFD
8363>>>>>    tWin32FindDataW tWFD
8363>>>>>
8363>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8363>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8363>>>>>
8363>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8363>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8364>>>>>    Move (AddressOf(tWFD)) to pWFD
8365>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8366>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8366>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8367>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8368>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8369>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8370>>>>>    
8370>>>>>    // Call the function
8370>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8371>>>>>
8371>>>>>    // Copy the struct contents back to the incoming one.
8371>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8372>>>>>    
8372>>>>>    // But do the strings separately and convert them to UTF8
8372>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8373>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8374>>>>>    
8374>>>>>    // Extend string with 0 to the maximum number of characters
8374>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8377>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8380>>>>>        
8380>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8381>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8382>>>>>    
8382>>>>>    Function_Return iResult
8383>>>>>End_Function
8384>>>>>
8384>>>>>
8384>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8385>>>>>
8385>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8387>>>>>    tWin32FindDataW Win32FindData
8387>>>>>    tWin32FindDataW Win32FindData
8387>>>>>    String sMask
8387>>>>>    Integer iVoid
8387>>>>>    Handle hFileFind
8387>>>>>    
8387>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8388>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8390>>>>>        Move (winFindClose(hFileFind)) to iVoid
8391>>>>>    End
8391>>>>>>
8391>>>>>    
8391>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8392>>>>>End_Function
8393>>>>>
8393>>>>>
8393>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cIniFile.pkg)
8393>>>>>>>Use Dll.pkg
8393>>>>>>>Use errornum.inc
8393>>>>>>>Use LanguageText.pkg
8393>>>>>>>Use GlobalFunctionsProcedures.pkg
8393>>>>>>>Use seq_chnl.pkg
8393>>>>>>>Use CharTranslate.pkg
8393>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCharTranslate.pkg)
8393>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Variant.pkg)
8393>>>>>>>>>>>Use ui
8393>>>>>>>>>>>Use errornum.inc
8393>>>>>>>>>>>
8393>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8393>>>>>>>>>>>
8393>>>>>>>>>>>
8393>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8394>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8395>>>>>>>>>>>
8395>>>>>>>>>>>// Returns the character length of the variant string. 
8395>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8397>>>>>>>>>>>    Pointer pVariant
8397>>>>>>>>>>>    Integer iLen iType
8397>>>>>>>>>>>
8397>>>>>>>>>>>    Move (AddressOf(bStr)) to pVariant
8398>>>>>>>>>>>    Move (DeRefW(pVariant,0)) to iType
8399>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8401>>>>>>>>>>>        Function_Return 0
8402>>>>>>>>>>>    End
8402>>>>>>>>>>>>
8402>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8404>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8405>>>>>>>>>>>>
8405>>>>>>>>>>>        Function_Return 0
8406>>>>>>>>>>>    End
8406>>>>>>>>>>>>
8406>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(pVariant,8))) to iLen
8407>>>>>>>>>>>    Function_Return iLen
8408>>>>>>>>>>>End_Function
8409>>>>>>>>>>>
8409>>>>>>>>>>>
8409>>>>>>>>>>>// returns true if char string in the buffer can fit into a string
8409>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8411>>>>>>>>>>>    Integer iMax
8411>>>>>>>>>>>    Get_Argument_Size to iMax
8412>>>>>>>>>>>    Function_Return (CStringSize(pData)<=iMax)
8413>>>>>>>>>>>End_Function
8414>>>>>>>>>>>    
8414>>>>>>>>>Use CharTranslate.pkg
8414>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8414>>>>>>>>>
8414>>>>>>>>>// special for UTF16, which is really not a code page at all
8414>>>>>>>>>Define CP_UTF16 for -1
8414>>>>>>>>>
8414>>>>>>>>>Class cCharTranslate is a cObject
8415>>>>>>>>>    
8415>>>>>>>>>    
8415>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8415>>>>>>>>>    
8415>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8415>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8415>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8417>>>>>>>>>        Pointer pWideBuf
8417>>>>>>>>>        Integer iWideBufLen iStrLen
8417>>>>>>>>>        Move 0 to pWideBuf
8418>>>>>>>>>        Move 0 to iLen
8419>>>>>>>>>        If (pMultiCharBuffer) Begin
8421>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8422>>>>>>>>>            If (iStrLen) Begin
8424>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8425>>>>>>>>>                If (iLen=0) Begin
8427>>>>>>>>>                    Function_Return 0
8428>>>>>>>>>                End
8428>>>>>>>>>>
8428>>>>>>>>>            End
8428>>>>>>>>>>
8428>>>>>>>>>        End
8428>>>>>>>>>>
8428>>>>>>>>>        Function_Return pWideBuf
8429>>>>>>>>>    End_Function
8430>>>>>>>>>    
8430>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8432>>>>>>>>>        Pointer pValue
8432>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8433>>>>>>>>>        Function_Return pValue
8434>>>>>>>>>    End_Function
8435>>>>>>>>>    
8435>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8435>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8435>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8437>>>>>>>>>        Pointer pRetBuf
8437>>>>>>>>>        Integer iRetBufLen
8437>>>>>>>>>        Move 0 to pRetBuf
8438>>>>>>>>>        If (pWideBuf and iLen) Begin
8440>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8441>>>>>>>>>            If (iRetBufLen=0) Begin
8443>>>>>>>>>                Function_Return 0
8444>>>>>>>>>            End
8444>>>>>>>>>>
8444>>>>>>>>>        End
8444>>>>>>>>>>
8444>>>>>>>>>        Function_Return pRetBuf
8445>>>>>>>>>    End_Function
8446>>>>>>>>>    
8446>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8448>>>>>>>>>        String sValue
8448>>>>>>>>>        Pointer pValue
8448>>>>>>>>>        Boolean bOk
8448>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8449>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8451>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8452>>>>>>>>>>
8452>>>>>>>>>        End
8452>>>>>>>>>>
8452>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8453>>>>>>>>>        Move (Free(pValue)) to bOk
8454>>>>>>>>>        Function_Return sValue
8455>>>>>>>>>    End_Function
8456>>>>>>>>>    
8456>>>>>>>>>    
8456>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8456>>>>>>>>>    
8456>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8458>>>>>>>>>        Pointer pWideBuf
8458>>>>>>>>>        Pointer pUtf8Buf
8458>>>>>>>>>        Integer iLen iMultiBufLen
8458>>>>>>>>>        Boolean bOk
8458>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8459>>>>>>>>>        If (iLen=0) Begin
8461>>>>>>>>>            Function_Return 0
8462>>>>>>>>>        End
8462>>>>>>>>>>
8462>>>>>>>>>        Move 0 to pUtf8Buf
8463>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8464>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8465>>>>>>>>>        Function_Return pUtf8Buf
8466>>>>>>>>>    End_Function
8467>>>>>>>>>    
8467>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8469>>>>>>>>>        Pointer pValue
8469>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8470>>>>>>>>>        Function_Return pValue
8471>>>>>>>>>    End_Function
8472>>>>>>>>>    
8472>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8474>>>>>>>>>        Pointer pRetBuf pWideBuf
8474>>>>>>>>>        Integer iWideBufLen
8474>>>>>>>>>        Integer iRetBufLen
8474>>>>>>>>>        Boolean bOk
8474>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8475>>>>>>>>>        If (iWideBufLen=0) Begin
8477>>>>>>>>>            Function_Return 0
8478>>>>>>>>>        End
8478>>>>>>>>>>
8478>>>>>>>>>        Move 0 to pRetBuf
8479>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8480>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8481>>>>>>>>>        Function_Return pRetBuf
8482>>>>>>>>>    End_Function
8483>>>>>>>>>    
8483>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8485>>>>>>>>>        String sValue
8485>>>>>>>>>        Pointer pValue
8485>>>>>>>>>        Boolean bOk
8485>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8486>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8488>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8489>>>>>>>>>>
8489>>>>>>>>>        End
8489>>>>>>>>>>
8489>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8490>>>>>>>>>        Move (Free(pValue)) to bOk
8491>>>>>>>>>        Function_Return sValue
8492>>>>>>>>>    End_Function
8493>>>>>>>>>    
8493>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8493>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8493>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8493>>>>>>>>>    
8493>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8493>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8495>>>>>>>>>        Pointer pBSTR pRetStr
8495>>>>>>>>>        Integer iLen iBufLen
8495>>>>>>>>>        Boolean bOk
8495>>>>>>>>>        Move 0 to pRetStr
8496>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8497>>>>>>>>>        If (iLen) Begin
8499>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8500>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8501>>>>>>>>>        End
8501>>>>>>>>>>
8501>>>>>>>>>        Function_Return pRetStr
8502>>>>>>>>>    End_Function
8503>>>>>>>>>    
8503>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8503>>>>>>>>>    
8503>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8505>>>>>>>>>        String sValue
8505>>>>>>>>>        Pointer pValue
8505>>>>>>>>>        Boolean bOk
8505>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8506>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8508>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8509>>>>>>>>>>
8509>>>>>>>>>        End
8509>>>>>>>>>>
8509>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8510>>>>>>>>>        Move (Free(pValue)) to bOk
8511>>>>>>>>>        Function_Return sValue
8512>>>>>>>>>    End_Function
8513>>>>>>>>>    
8513>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8513>>>>>>>>>    
8513>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8515>>>>>>>>>        Variant vValue
8515>>>>>>>>>        Pointer pvValue
8515>>>>>>>>>        Boolean bOk
8515>>>>>>>>>        Pointer pWStr
8515>>>>>>>>>        Move "" to vValue
8516>>>>>>>>>        If (pSource) Begin
8518>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8518>>>>>>>>>            Move 0 to pWStr
8519>>>>>>>>>            //Convert the Ansi string to Unicode
8519>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8520>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8520>>>>>>>>>            Move 0 to vValue
8521>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8522>>>>>>>>>            //Change the Variant type to VT_BSTR
8522>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8523>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8523>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8524>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8524>>>>>>>>>            Move (Free(pWStr)) to bOk
8525>>>>>>>>>        End
8525>>>>>>>>>>
8525>>>>>>>>>        Function_Return vValue
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8527>>>>>>>>>    
8527>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8529>>>>>>>>>        Variant vValue
8529>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8530>>>>>>>>>        Function_Return vValue
8531>>>>>>>>>    End_Function
8532>>>>>>>>>    
8532>>>>>>>>>    // Create buffer of utf16 data from variant.
8532>>>>>>>>>    // Returns newly created memory address and length (by reference)
8532>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8534>>>>>>>>>        Pointer pBSTR pRetStr
8534>>>>>>>>>        Boolean bOk
8534>>>>>>>>>        Move 0 to pRetStr
8535>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8536>>>>>>>>>        If (iLen) Begin
8538>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8539>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8540>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8541>>>>>>>>>        End
8541>>>>>>>>>>
8541>>>>>>>>>        Function_Return pRetStr
8542>>>>>>>>>    End_Function
8543>>>>>>>>>    
8543>>>>>>>>>    // Create variant from buffer of utf16 data
8543>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8545>>>>>>>>>        Variant vValue
8545>>>>>>>>>        Pointer pvValue
8545>>>>>>>>>        Boolean bOk
8545>>>>>>>>>        Move "" to vValue
8546>>>>>>>>>        If (pSource) Begin
8548>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8548>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8548>>>>>>>>>            Move 0 to vValue
8549>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8550>>>>>>>>>            //Change the Variant type to VT_BSTR
8550>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8551>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8551>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8552>>>>>>>>>        End
8552>>>>>>>>>>
8552>>>>>>>>>        Function_Return vValue
8553>>>>>>>>>    End_Function
8554>>>>>>>>>    
8554>>>>>>>>>    // Create Uchar array from variant string.
8554>>>>>>>>>    // Data buffer is encoded by eCharType
8554>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8556>>>>>>>>>        Pointer pBSTR pRetStr
8556>>>>>>>>>        Integer iLen iBufLen
8556>>>>>>>>>        Boolean bOk
8556>>>>>>>>>        UChar[] UC1
8557>>>>>>>>>        Move 0 to pRetStr
8558>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8559>>>>>>>>>        If (iLen) Begin
8561>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8562>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8564>>>>>>>>>                Move (iLen*2) to iBufLen
8565>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8566>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8567>>>>>>>>>            End
8567>>>>>>>>>>
8567>>>>>>>>>            Else Begin
8568>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8569>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8570>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8571>>>>>>>>>                Move (Free(pRetStr)) to bOk
8572>>>>>>>>>            End
8572>>>>>>>>>>
8572>>>>>>>>>        End
8572>>>>>>>>>>
8572>>>>>>>>>        Function_Return UC1
8573>>>>>>>>>    End_Function
8574>>>>>>>>>    
8574>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8574>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8576>>>>>>>>>        Variant vValue
8576>>>>>>>>>        Pointer pvValue
8576>>>>>>>>>        Boolean bOk
8576>>>>>>>>>        Pointer pWStr
8576>>>>>>>>>        Move "" to vValue
8577>>>>>>>>>        
8577>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8577>>>>>>>>>        Move 0 to pWStr
8578>>>>>>>>>        //Convert the Ansi string to Unicode
8578>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8580>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8581>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8582>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8583>>>>>>>>>        End
8583>>>>>>>>>>
8583>>>>>>>>>        Else Begin
8584>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8585>>>>>>>>>        End
8585>>>>>>>>>>
8585>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8585>>>>>>>>>        Move 0 to vValue
8586>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8587>>>>>>>>>        //Change the Variant type to VT_BSTR
8587>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8588>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8588>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8589>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8589>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8591>>>>>>>>>            Move (Free(pWStr)) to bOk
8592>>>>>>>>>        End
8592>>>>>>>>>>
8592>>>>>>>>>        Function_Return vValue
8593>>>>>>>>>    End_Function
8594>>>>>>>>>    
8594>>>>>>>>>    
8594>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8594>>>>>>>>>    // a new UChar array with to-encoding
8594>>>>>>>>>    
8594>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8596>>>>>>>>>        Pointer pFromBuf pToBuf
8596>>>>>>>>>        Integer iBytes iChars
8596>>>>>>>>>        Boolean bOk
8596>>>>>>>>>        
8596>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8597>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8599>>>>>>>>>            Function_Return UCharData
8600>>>>>>>>>        End
8600>>>>>>>>>>
8600>>>>>>>>>        
8600>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8602>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8603>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8604>>>>>>>>>        End
8604>>>>>>>>>>
8604>>>>>>>>>        Else Begin
8605>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8606>>>>>>>>>        End
8606>>>>>>>>>>
8606>>>>>>>>>        
8606>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8608>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8610>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8611>>>>>>>>>            End
8611>>>>>>>>>>
8611>>>>>>>>>            Else Begin
8612>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8613>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8614>>>>>>>>>            End
8614>>>>>>>>>>
8614>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8615>>>>>>>>>        End
8615>>>>>>>>>>
8615>>>>>>>>>        Else Begin
8616>>>>>>>>>            Move (iChars*2) to iBytes
8617>>>>>>>>>            Move pFromBuf to pToBuf
8618>>>>>>>>>        End
8618>>>>>>>>>>
8618>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8619>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8620>>>>>>>>>        Move (Free(pToBuf)) to bOk
8621>>>>>>>>>        Function_Return UCharData
8622>>>>>>>>>    End_Function
8623>>>>>>>>>    
8623>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8623>>>>>>>>>    // Variant strings. Binary data is always buffer
8623>>>>>>>>>    
8623>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8625>>>>>>>>>        Pointer pBase64
8625>>>>>>>>>        String sResult
8625>>>>>>>>>        Integer iVoid iMax
8625>>>>>>>>>        Get_Argument_Size to iMax
8626>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8627>>>>>>>>>        If (iMax<CStringSize(pBase64)) Begin
8629>>>>>>>>>            Error DFERR_PROGRAM "Base64 encoded string exceeds max string size"
8630>>>>>>>>>>
8630>>>>>>>>>        End
8630>>>>>>>>>>
8630>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8631>>>>>>>>>        Move (Free(pBase64)) to iVoid
8632>>>>>>>>>        Function_Return sResult
8633>>>>>>>>>    End_Function
8634>>>>>>>>>    
8634>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8636>>>>>>>>>        Pointer pBinaryData
8636>>>>>>>>>        String sBinary
8636>>>>>>>>>        Integer iVoid
8636>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8637>>>>>>>>>        Function_Return pBinaryData
8638>>>>>>>>>    End_Function
8639>>>>>>>>>    
8639>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8641>>>>>>>>>        Pointer pBase64
8641>>>>>>>>>        Variant vVar
8641>>>>>>>>>        Integer iBase64Len iVoid
8641>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8643>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8644>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8645>>>>>>>>>            Move (Free(pBase64)) to iVoid
8646>>>>>>>>>        End
8646>>>>>>>>>>
8646>>>>>>>>>        Function_Return vVar
8647>>>>>>>>>    End_Function
8648>>>>>>>>>    
8648>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8650>>>>>>>>>        Pointer pBase64 pBinaryData
8650>>>>>>>>>        Integer iVoid
8650>>>>>>>>>        Move 0 to iBinaryLen
8651>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8652>>>>>>>>>        If (pBase64) Begin
8654>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8655>>>>>>>>>            Move (Free(pBase64)) to iVoid
8656>>>>>>>>>        End
8656>>>>>>>>>>
8656>>>>>>>>>        Function_Return pBinaryData
8657>>>>>>>>>    End_Function
8658>>>>>>>>>    
8658>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8658>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8660>>>>>>>>>        Pointer pBase64
8660>>>>>>>>>        Integer iLen
8660>>>>>>>>>        Boolean bOk
8660>>>>>>>>>        
8660>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8661>>>>>>>>>        If (iLen) Begin
8663>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8664>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8665>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8666>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8667>>>>>>>>>            Move (Free(pBase64)) to bOk
8668>>>>>>>>>        End
8668>>>>>>>>>>
8668>>>>>>>>>        Function_Return UCharData
8669>>>>>>>>>    End_Function
8670>>>>>>>>>    
8670>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8670>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8672>>>>>>>>>        Pointer pData
8672>>>>>>>>>        Integer iLen
8672>>>>>>>>>        Boolean bOk
8672>>>>>>>>>        
8672>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8673>>>>>>>>>        If (iLen) Begin
8675>>>>>>>>>            Move 0 to UCharData[iLen]
8676>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8677>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8678>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8679>>>>>>>>>            Move (Free(pData)) to bOk
8680>>>>>>>>>        End
8680>>>>>>>>>>
8680>>>>>>>>>        Function_Return UCharData
8681>>>>>>>>>    End_Function
8682>>>>>>>>>    
8682>>>>>>>>>End_Class
8683>>>>>>>>>
8683>>>>>>>>>
8683>>>>>>>
8683>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8683>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8683>>>>>>>
8683>>>>>>>
8683>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8684>>>>>>>
8684>>>>>>>
8684>>>>>>>// When called directly, be sure to use WString types.
8684>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8685>>>>>>>
8685>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8686>>>>>>>    
8686>>>>>>>// When called directly, be sure to use String types.
8686>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8687>>>>>>>    
8687>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8687>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8687>>>>>>>    
8687>>>>>>>
8687>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8687>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8689>>>>>>>    
8689>>>>>>>    Integer iResult
8689>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8689>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8689>>>>>>>
8689>>>>>>>    Send StringToWide pSection (&uwSection)
8690>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8691>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8692>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8693>>>>>>>                           
8693>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8694>>>>>>>       
8694>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8695>>>>>>>        
8695>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8696>>>>>>>    
8696>>>>>>>    Function_Return iResult
8697>>>>>>>End_Function
8698>>>>>>> 
8698>>>>>>>
8698>>>>>>>Class cIniFile is a cObject
8699>>>>>>>    Procedure Construct_Object
8701>>>>>>>        Forward Send Construct_Object
8703>>>>>>>        
8703>>>>>>>        
8703>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8703>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8703>>>>>>>        Property Boolean pbWideAPI True
8704>>>>>>>        
8704>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8704>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8704>>>>>>>        // converted on first write (WriteString).
8704>>>>>>>        Property Boolean pbStoreAsUTF16 False
8705>>>>>>>        
8705>>>>>>>        Property String psPrivate_FileName ""
8706>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8707>>>>>>>    End_Procedure
8708>>>>>>>    
8708>>>>>>>    Procedure Set psFileName String sVal
8710>>>>>>>        Set pbPrivate_FirstWrite to True
8711>>>>>>>        Set psPrivate_FileName to sVal
8712>>>>>>>    End_Procedure
8713>>>>>>>    
8713>>>>>>>    Function psFileName Returns String
8715>>>>>>>        Function_Return (psPrivate_FileName(Self))
8716>>>>>>>    End_Function
8717>>>>>>>    
8717>>>>>>>    Procedure InitFile
8719>>>>>>>        Boolean bExists bHasBom
8719>>>>>>>        Integer iChnl
8719>>>>>>>        UChar[] ucData
8720>>>>>>>        Handle hoTranslate
8720>>>>>>>        
8720>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8722>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8723>>>>>>>            If (not(bExists)) Begin
8725>>>>>>>                //  Create the file with a UTF-16 BOM so
8725>>>>>>>                Move (Seq_New_Channel()) to iChnl
8726>>>>>>>                Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8728>>>>>>>                Write channel iChnl C_BOM_UTF16LE
8730>>>>>>>                Close_Output channel iChnl
8732>>>>>>>                Send Seq_Release_Channel iChnl
8733>>>>>>>            End
8733>>>>>>>>
8733>>>>>>>            Else Begin
8734>>>>>>>                //  Check for BOM
8734>>>>>>>                Move (Seq_New_Channel()) to iChnl
8735>>>>>>>                Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8737>>>>>>>                Read_Block channel iChnl ucData 2
8739>>>>>>>                
8739>>>>>>>                Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8740>>>>>>>                
8740>>>>>>>                //  If no BOM we'll have to read the entire file to convert it
8740>>>>>>>                If (not(bHasBom)) Begin
8742>>>>>>>                    Set_Channel_Position iChnl to 0
8743>>>>>>>>
8743>>>>>>>                    Read_Block ucData -1
8744>>>>>>>                End
8744>>>>>>>>
8744>>>>>>>
8744>>>>>>>                Close_Input channel iChnl
8746>>>>>>>                
8746>>>>>>>                If (not(bHasBom)) Begin
8748>>>>>>>                    //  Convert thedata
8748>>>>>>>                    Get Create (RefClass(cCharTranslate)) to hoTranslate
8749>>>>>>>                    Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8750>>>>>>>                    
8750>>>>>>>                    //  Write out the UTF 16 file with BOM
8750>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8752>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8754>>>>>>>                    
8754>>>>>>>                    Write channel iChnl ucData
8756>>>>>>>                    
8756>>>>>>>                    Close_Output channel iChnl
8758>>>>>>>                    
8758>>>>>>>                    Send Destroy of hoTranslate
8759>>>>>>>                End
8759>>>>>>>>
8759>>>>>>>                
8759>>>>>>>                Send Seq_Release_Channel iChnl
8760>>>>>>>            End
8760>>>>>>>>
8760>>>>>>>            
8760>>>>>>>            Set pbPrivate_FirstWrite to False
8761>>>>>>>        End
8761>>>>>>>>
8761>>>>>>>    End_Procedure
8762>>>>>>>    
8762>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8764>>>>>>>        Boolean bSuccess
8764>>>>>>>        String sFileName
8764>>>>>>>        
8764>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8766>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8767>>>>>>>>
8767>>>>>>>            Procedure_Return
8768>>>>>>>        End
8768>>>>>>>>
8768>>>>>>>        
8768>>>>>>>        Send InitFile
8769>>>>>>>        
8769>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8769>>>>>>>        If (pbWideAPI(Self)) Begin
8771>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8772>>>>>>>        End
8772>>>>>>>>
8772>>>>>>>        Else Begin
8773>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8774>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8775>>>>>>>        End
8775>>>>>>>>
8775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8778>>>>>>>    End_Procedure
8779>>>>>>>    
8779>>>>>>>    
8779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8781>>>>>>>        Integer iNumChars iSizeValue
8781>>>>>>>        WString wValue wFileName wSection wKey wDefault
8781>>>>>>>        String sFileName sValue
8781>>>>>>>        
8781>>>>>>>        Move 2047 to iSizeValue
8782>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8783>>>>>>>        
8783>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8785>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8786>>>>>>>>
8786>>>>>>>            Function_Return ''
8787>>>>>>>        End
8787>>>>>>>>
8787>>>>>>>        
8787>>>>>>>        If (pbWideAPI(Self)) Begin
8789>>>>>>>            Move sSection to wSection
8790>>>>>>>            Move sKey to wKey
8791>>>>>>>            Move sDefault to wDefault
8792>>>>>>>            Move sValue to wValue
8793>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8794>>>>>>>            Move wValue to sValue
8795>>>>>>>        End
8795>>>>>>>>
8795>>>>>>>        Else Begin
8796>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8797>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8798>>>>>>>        End
8798>>>>>>>>
8798>>>>>>>        
8798>>>>>>>        Function_Return  (CString(sValue))
8799>>>>>>>    End_Function
8800>>>>>>>    
8800>>>>>>>    Function SectionExists String sSection Returns Boolean
8802>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8802>>>>>>>        Handle hoKeys
8802>>>>>>>        Integer icKey iKey
8802>>>>>>>        
8802>>>>>>>        Get Create U_ARRAY to hoKeys
8803>>>>>>>        Send ReadSection sSection hoKeys
8804>>>>>>>        Get Item_Count of hoKeys to icKey
8805>>>>>>>        Send Destroy of hoKeys
8806>>>>>>>        
8806>>>>>>>        Function_Return (icKey >0)
8807>>>>>>>    End_Function
8808>>>>>>>    
8808>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8810>>>>>>>        Integer iNumChars iSizeValue iPos
8810>>>>>>>        Pointer lpsKeys
8810>>>>>>>        WString wKeys wKey
8810>>>>>>>        
8810>>>>>>>        Move 16384 to iSizeValue
8811>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wKeys
8812>>>>>>>        
8812>>>>>>>        Move (AddressOf(wKeys)) to lpsKeys
8813>>>>>>>        
8813>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8815>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8816>>>>>>>>
8816>>>>>>>            Procedure_Return
8817>>>>>>>        End
8817>>>>>>>>
8817>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8817>>>>>>>        Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8818>>>>>>>        If (iNumChars >0) Begin
8820>>>>>>>            Repeat
8820>>>>>>>>
8820>>>>>>>                Move (Pos(Character(0),wKeys)) to iPos
8821>>>>>>>                If (iPos >1) Begin
8823>>>>>>>                    Move (Left(wKeys,iPos -1))  to wKey
8824>>>>>>>                    Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8825>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to wKey
8826>>>>>>>                End
8826>>>>>>>>
8826>>>>>>>            Until (iPos <=1)
8828>>>>>>>        End
8828>>>>>>>>
8828>>>>>>>    End_Procedure
8829>>>>>>>    
8829>>>>>>>    Procedure ReadSections Handle hoArray
8831>>>>>>>        Integer iNumChars iSizeValue iPos
8831>>>>>>>        Pointer lpwSections
8831>>>>>>>        WString wSections
8831>>>>>>>        String sSection
8831>>>>>>>        
8831>>>>>>>        Move 16384 to iSizeValue
8832>>>>>>>        
8832>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8833>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8834>>>>>>>        
8834>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8836>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8837>>>>>>>>
8837>>>>>>>            Procedure_Return
8838>>>>>>>        End
8838>>>>>>>>
8838>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8838>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8839>>>>>>>        If (iNumChars >0) Begin
8841>>>>>>>            Repeat
8841>>>>>>>>
8841>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8842>>>>>>>                If (iPos >1) Begin
8844>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8845>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8846>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8847>>>>>>>                End
8847>>>>>>>>
8847>>>>>>>            Until (iPos <=1)
8849>>>>>>>        End
8849>>>>>>>>
8849>>>>>>>        
8849>>>>>>>    End_Procedure
8850>>>>>>>    
8850>>>>>>>    Procedure DeleteSection String sSection
8852>>>>>>>        
8852>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8854>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8855>>>>>>>>
8855>>>>>>>            Procedure_Return
8856>>>>>>>        End
8856>>>>>>>>
8856>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8859>>>>>>>    End_Procedure
8860>>>>>>>    
8860>>>>>>>    Procedure DeleteKey String sSection String sKey
8862>>>>>>>        Integer iVoid
8862>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8864>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8865>>>>>>>>
8865>>>>>>>            Procedure_Return
8866>>>>>>>        End
8866>>>>>>>>
8866>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8867>>>>>>>    End_Procedure
8868>>>>>>>    
8868>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
8870>>>>>>>        Handle hoKeys
8870>>>>>>>        Integer iKey
8870>>>>>>>        Boolean bExists
8870>>>>>>>        
8870>>>>>>>        Move (False) to bExists
8871>>>>>>>        
8871>>>>>>>        Move (Uppercase(sKey)) to sKey
8872>>>>>>>        
8872>>>>>>>        Get Create U_ARRAY to hoKeys
8873>>>>>>>        
8873>>>>>>>        Send ReadSection sSection hoKeys
8874>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
8880>>>>>>>>
8880>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
8882>>>>>>>                Move (True) to bExists
8883>>>>>>>            End
8883>>>>>>>>
8883>>>>>>>        Loop
8884>>>>>>>>
8884>>>>>>>        
8884>>>>>>>        Send Destroy of hoKeys
8885>>>>>>>        
8885>>>>>>>        Function_Return bExists
8886>>>>>>>    End_Function
8887>>>>>>>    
8887>>>>>>>End_Class
8888>>>>>
8888>>>>>Class cWorkspace is a cObject
8889>>>>>    
8889>>>>>    Procedure Construct_Object
8891>>>>>        Forward Send Construct_Object
8893>>>>>        
8893>>>>>        
8893>>>>>        Property String psAppSrcPath
8894>>>>>        Property String psBitmapPath
8895>>>>>        Property String psDataPath
8896>>>>>        Property String psDdSrcPath
8897>>>>>        Property String psDescription
8898>>>>>        Property String psFileList
8899>>>>>        Property String psHelpPath
8900>>>>>        Property String psHome
8901>>>>>        Property String psIdeSrcPath
8902>>>>>        Property String psProgramPath
8903>>>>>        Property String psAppHtmlPath
8904>>>>>        Property String psWorkspaceName
8905>>>>>        Property String psWorkspaceWSFile
8906>>>>>        Property String psConnectionIni
8907>>>>>        
8907>>>>>        Property String psSystemDfPath // took from the Registry!
8908>>>>>        Property String psSystemMakePath // took from the Registry!
8909>>>>>        Property String psDfPath        // Calculated
8910>>>>>        
8910>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
8911>>>>>        
8911>>>>>    End_Procedure
8912>>>>>    
8912>>>>>    Function FullPathNames String sShortPathNames Returns String
8914>>>>>        String sFileName
8914>>>>>        String sFullPathNames 
8914>>>>>        WString sFullPathName sShortPathName
8914>>>>>        Pointer lpsFilePart
8914>>>>>        Integer icChar // the number of characters returned
8914>>>>>        Integer iPos
8914>>>>>        
8914>>>>>        Move (Pos(";", sShortPathNames)) to iPos
8915>>>>>        While (length(sShortPathNames) >0)
8919>>>>>            If (iPos =0) Begin
8921>>>>>                Move sShortPathNames to sShortPathName
8922>>>>>                Move "" to sShortPathNames
8923>>>>>            End
8923>>>>>>
8923>>>>>            Else Begin // multiple paths
8924>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
8925>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
8926>>>>>            End
8926>>>>>>
8926>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
8927>>>>>            Move -1 to lpsFilePart
8928>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
8929>>>>>            Append sFullPathNames (CString(sFullPathName))
8930>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
8933>>>>>            Move (Pos(";", sShortPathNames)) to iPos
8934>>>>>        Loop
8935>>>>>>
8935>>>>>        
8935>>>>>        Function_Return sFullPathNames
8936>>>>>    End_Function
8937>>>>>    
8937>>>>>    Function GetApplicationPath Returns String
8939>>>>>        // Returns the path of the Application (no trailing "\")
8939>>>>>        WString wApplicationFileName 
8939>>>>>        Boolean bRemoved
8939>>>>>        Integer iNumChars
8939>>>>>        String sFilename sPath
8939>>>>>        
8939>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
8940>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
8941>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
8942>>>>>        
8942>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
8943>>>>>        Move (CString(wApplicationFileName)) to sPath
8944>>>>>        
8944>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8947>>>>>        Function_Return sPath
8948>>>>>    End_Function
8949>>>>>    
8949>>>>>    Procedure DoClearPaths
8951>>>>>        // Call this prior to changing from one WorkspAce to another
8951>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
8951>>>>>        Set psHome           to ""
8952>>>>>        Set psAppSrcPath     to ""
8953>>>>>        Set psBitmapPath     to ""
8954>>>>>        Set psDataPath       to ""
8955>>>>>        Set psDdSrcPath      to ""
8956>>>>>        Set psDescription    to ""
8957>>>>>        Set psFileList       to ""
8958>>>>>        Set psHelpPath       to ""
8959>>>>>        Set psIdeSrcPath     to ""
8960>>>>>        Set psAppHtmlPath    to ""
8961>>>>>        Set psProgramPath    to ""
8962>>>>>        Set psWorkspaceName  to ""
8963>>>>>        Set psSystemDfPath   to ""
8964>>>>>        Set psSystemMakePath to ""
8965>>>>>        Set psWorkspaceWSFile to ""
8966>>>>>        Set psConnectionIni to ""
8967>>>>>    End_Procedure
8968>>>>>    
8968>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
8970>>>>>        WString wApplicationStartPath
8970>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
8970>>>>>        Boolean bRemoved
8970>>>>>        Handle hoIniFile
8970>>>>>        Boolean bSuccess // call succeeded?
8970>>>>>        String sOldDirectory
8970>>>>>        String sSystemDfPath sSystemMakePath
8970>>>>>        Boolean bExist // does the WS file exist?
8970>>>>>        Boolean bChangingWorkspace
8970>>>>>        
8970>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
8970>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
8970>>>>>        
8970>>>>>        Set psWorkspaceWSFile to ""
8971>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
8974>>>>>        
8974>>>>>        // Append extension if not supplied...
8974>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
8976>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
8977>>>>>        End
8977>>>>>>
8977>>>>>        
8977>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
8978>>>>>        
8978>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
8980>>>>>            // Set the properties to the paths of the Workspace
8980>>>>>            // Find the WS file (with program)...
8980>>>>>            Get GetApplicationPath to wApplicationStartPath
8981>>>>>            
8981>>>>>            Move sWorkspaceFile to sWsName
8982>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
8983>>>>>        End
8983>>>>>>
8983>>>>>        Else Begin
8984>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
8985>>>>>            
8985>>>>>            Move sWorkspaceFile to wApplicationStartPath
8986>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
8987>>>>>        End
8987>>>>>>
8987>>>>>        
8987>>>>>        // Ensure that the file can be found...
8987>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
8987>>>>>        // [JVH] Turn off support for
8987>>>>>        // Ansi extended characters in workspace until we can
8987>>>>>        // resolve all open issues
8987>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
8988>>>>>        File_Exist sWorkspaceFile bExist
8989>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
8992>>>>>        
8992>>>>>        Get psHome           to sHome
8993>>>>>        Get psAppSrcPath     to sAppSrcPath
8994>>>>>        Get psAppHtmlPath    to sAppHtmlPath
8995>>>>>        Get psBitmapPath     to sBitmapPath
8996>>>>>        Get psDataPath       to sDataPath
8997>>>>>        Get psDdSrcPath      to sDdSrcPath
8998>>>>>        Get psDescription    to sDescription
8999>>>>>        Get psFileList       to sFileList
9000>>>>>        Get psHelpPath       to sHelpPath
9001>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9002>>>>>        Get psProgramPath    to sProgramPath
9003>>>>>        Get psSystemDfPath   to sSystemDfPath
9004>>>>>        Get psSystemMakePath to sSystemMakePath
9005>>>>>        Get psWorkspaceName  to sWorkspaceName
9006>>>>>        Get psConnectionIni to sConnectionIni
9007>>>>>        
9007>>>>>        Get_Current_Directory to sOldDirectory
9008>>>>>        // Note- this conversion is temporarily rolled back
9008>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9008>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9009>>>>>        
9009>>>>>        Get Create U_cIniFile to hoIniFile
9010>>>>>        Set pbWideAPI of hoIniFile to False
9011>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9012>>>>>        
9012>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9015>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9018>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9021>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9024>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9027>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9030>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9033>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9036>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9039>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9042>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9045>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9048>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9051>>>>>        
9051>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9054>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9057>>>>>        
9057>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9058>>>>>        
9058>>>>>        // Set CWD to Home...
9058>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9059>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9060>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9061>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9062>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9063>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9064>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9065>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9066>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9067>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9068>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9069>>>>>        
9069>>>>>        Set psWorkspaceName to sWorkspaceName
9070>>>>>        Set psDescription   to sDescription
9071>>>>>        
9071>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9072>>>>>        
9072>>>>>        // Restore CWD...
9072>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9073>>>>>        
9073>>>>>        // Check for error conditions:
9073>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9073>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9076>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9079>>>>>        
9079>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9080>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9083>>>>>        
9083>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9086>>>>>        
9086>>>>>        Send DoAssignPaths // set psDfPath
9087>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9088>>>>>        Set pbWorkspaceOpened to True
9089>>>>>        
9089>>>>>        Function_Return wsWorkspaceOpened
9090>>>>>    End_Function
9091>>>>>    
9091>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9093>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9093>>>>>        
9093>>>>>        Handle hoSections hoIniFile
9093>>>>>        Integer iWorkspace eOpened
9093>>>>>        String sWorkspaceName sPath
9093>>>>>        String sVdfRootDir
9093>>>>>        
9093>>>>>        Get Create U_Array    to hoSections
9094>>>>>        Get Create U_cIniFile to hoIniFile
9095>>>>>        
9095>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9098>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9101>>>>>        
9101>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9102>>>>>        
9102>>>>>        Send ReadSections of hoIniFile hoSections
9103>>>>>        
9103>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9109>>>>>>
9109>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9110>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9112>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9113>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9116>>>>>                
9116>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9117>>>>>                Send Destroy of hoSections
9118>>>>>                Send Destroy of hoIniFile
9119>>>>>                Function_Return eOpened
9120>>>>>            End
9120>>>>>>
9120>>>>>        Loop
9121>>>>>>
9121>>>>>        
9121>>>>>        Send Destroy of hoSections
9122>>>>>        Send Destroy of hoIniFile
9123>>>>>        Function_Return wsWorkspaceNotFound
9124>>>>>    End_Function
9125>>>>>    
9125>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9127>>>>>        Boolean bRegistered
9127>>>>>        Handle hoIniFile
9127>>>>>        String sVdfRootDir
9127>>>>>        
9127>>>>>        Get Create U_cIniFile to hoIniFile
9128>>>>>        
9128>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9131>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9134>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9135>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9136>>>>>        
9136>>>>>        Send Destroy of hoIniFile
9137>>>>>        
9137>>>>>        Function_Return bRegistered
9138>>>>>    End_Function
9139>>>>>    
9139>>>>>    Function VdfSystemDfPath Returns String
9141>>>>>        String sSystemDfPath
9141>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9144>>>>>        
9144>>>>>        Function_Return sSystemDfPath
9145>>>>>    End_Function
9146>>>>>    
9146>>>>>    Function VdfSystemMakePath Returns String
9148>>>>>        String sSystemMakePath
9148>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9151>>>>>        
9151>>>>>        Function_Return sSystemMakePath
9152>>>>>    End_Function
9153>>>>>    
9153>>>>>    Procedure DoAssignPaths
9155>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9155>>>>>        
9155>>>>>        Get psDataPath     to sDataPath
9156>>>>>        Get psBitmapPath   to sBitmapPath
9157>>>>>        Get psHelpPath     to sHelpPath
9158>>>>>        Get psProgramPath  to sProgramPath
9159>>>>>        Get psSystemDfPath to sSystemDfPath
9160>>>>>        
9160>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9161>>>>>        
9161>>>>>    End_Procedure
9162>>>>>    
9162>>>>>    Procedure DoSetPaths
9164>>>>>        // [JVH] must convert paths to Ansi before setting these values
9164>>>>>        // Note- this conversion is temporarily rolled back
9164>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9164>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9164>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9167>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9170>>>>>    End_Procedure
9171>>>>>    
9171>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9173>>>>>        String sPath
9173>>>>>        
9173>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9176>>>>>        Else Begin
9177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9179>>>>>            Send hmGeneric to hoCallBack ""
9180>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9181>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9182>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9183>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9184>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9185>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9186>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9187>>>>>        End
9187>>>>>>
9187>>>>>    End_Procedure
9188>>>>>    
9188>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9190>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9190>>>>>        // returns a corresponding message string.
9190>>>>>        String sError
9190>>>>>        
9190>>>>>        Case Begin
9190>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9192>>>>>                Move C_$NoErrors to sError
9193>>>>>                Case Break
9194>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9197>>>>>                Move C_$NoWsName to sError
9198>>>>>                Case Break
9199>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9202>>>>>                Move C_$NoWsFileFound to sError
9203>>>>>                Case Break
9204>>>>>            Case (eErrorCode = wsDataPathEmpty)
9207>>>>>                Move C_$NoWsDataPath to sError
9208>>>>>                Case Break
9209>>>>>            Case (eErrorCode = wsFileListEmpty)
9212>>>>>                Move C_$NoWsFileList to sError
9213>>>>>                Case Break
9214>>>>>            Case (eErrorCode = wsFileListNotExist)
9217>>>>>                Move C_$NoFileListCfg to sError
9218>>>>>                Case Break
9219>>>>>            Case Else
9219>>>>>                Move C_$UnknownError to sError
9220>>>>>                Case Break
9221>>>>>        Case End
9221>>>>>        
9221>>>>>        Function_Return (sError-".")
9222>>>>>    End_Function
9223>>>>>    
9223>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9225>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9225>>>>>        String sVdfRootDir
9225>>>>>        Handle hoIniFile
9225>>>>>        String sPath
9225>>>>>        String sFileName
9225>>>>>        String sWorkspacePath
9225>>>>>        
9225>>>>>        Move "" to sFileName
9226>>>>>        
9226>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9229>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9232>>>>>        
9232>>>>>        Get Create U_cIniFile to hoIniFile
9233>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9234>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9235>>>>>        If (sWorkspacePath <>"") Begin
9237>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9240>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9241>>>>>        End
9241>>>>>>
9241>>>>>        Send Destroy of hoIniFile
9242>>>>>        
9242>>>>>        Function_Return sFileName
9243>>>>>    End_Function
9244>>>>>    
9244>>>>>    Function CountOfPaths String sPaths Returns Integer
9246>>>>>        // Returns the number of paths defined in a string of paths
9246>>>>>        Integer iChar icChar icPath
9246>>>>>        
9246>>>>>        If (sPaths ="") ;            Function_Return 0
9249>>>>>        
9249>>>>>        Move (Length(sPaths) -1) to icChar
9250>>>>>        For iChar from 1 to icChar
9256>>>>>>
9256>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9259>>>>>        Loop
9260>>>>>>
9260>>>>>        
9260>>>>>        Function_Return (icPath +1)
9261>>>>>    End_Function
9262>>>>>    
9262>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9264>>>>>        // Returns the path at the 1-based index of passed paths.
9264>>>>>        // If the path contains a trailing "\", it will be removed
9264>>>>>        Integer iChar icPath iPath iPos
9264>>>>>        String sPath
9264>>>>>        
9264>>>>>        Move (sPaths +";") to sPaths
9265>>>>>        For iPath from 1 to iIndex
9271>>>>>>
9271>>>>>            Move (Pos(";", sPaths)) to iPos
9272>>>>>            If iPos Begin
9274>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9275>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9278>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9279>>>>>            End
9279>>>>>>
9279>>>>>            Else ;                Function_Return "" // index past number of paths
9281>>>>>        Loop
9282>>>>>>
9282>>>>>        
9282>>>>>        Function_Return sPath
9283>>>>>    End_Function
9284>>>>>    
9284>>>>>End_Class
9285>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCommandLine.pkg)
9285>>>>>Use VDFBase.pkg
9285>>>>>
9285>>>>>Class cCommandLine is a cObject
9286>>>>>    
9286>>>>>    Procedure Construct_Object
9288>>>>>        Forward Send Construct_Object
9290>>>>>        
9290>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9291>>>>>    End_Procedure
9292>>>>>    
9292>>>>>    Procedure Private_DoCreateArgsArray
9294>>>>>        // creates the array for holding the arguments. Created upon demand only!
9294>>>>>        Integer icArg
9294>>>>>        String sArg
9294>>>>>        
9294>>>>>        Object oArgs is an Array
9296>>>>>            Delegate Set phoArgs to Self
9298>>>>>            Repeat
9298>>>>>>
9298>>>>>                CmdLine sArg
9299>>>>>>
9299>>>>>                If (sArg <> "") Begin
9301>>>>>                    Increment icArg
9302>>>>>                    Set Value  (icArg -1) to sArg
9303>>>>>                End
9303>>>>>>
9303>>>>>            Until (sArg = "")
9305>>>>>        End_Object
9306>>>>>    End_Procedure
9307>>>>>    
9307>>>>>    Function CountOfArgs Returns Integer
9309>>>>>        //Returns the number of arguments passed
9309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9312>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9313>>>>>    End_Function
9314>>>>>    
9314>>>>>    Function Argument Integer iIndex Returns String
9316>>>>>        //Returns the one-based argument string
9316>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9319>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9320>>>>>    End_Function
9321>>>>>    
9321>>>>>End_Class
9322>>>>>
9322>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cRegistry.pkg)
9322>>>>>Use Dll.pkg
9322>>>>>Use RegistryAPI.pkg
9322>>>>>
9322>>>>>Enum_List // Registry Data types
9322>>>>>    Define rdString
9322>>>>>    Define rdDword
9322>>>>>    Define rdBinary
9322>>>>>    Define rdUnknown
9322>>>>>End_Enum_List
9322>>>>>
9322>>>>>
9322>>>>>Class cRegistry is a cObject
9323>>>>>    Procedure Construct_Object
9325>>>>>        Forward Send Construct_Object
9327>>>>>        
9327>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9328>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9329>>>>>        Property Handle phCurrentKey
9330>>>>>        Property Boolean pbLazyWrite True
9331>>>>>    End_Procedure
9332>>>>>    
9332>>>>>    Function CountOfSubkeys Returns Integer
9334>>>>>        Integer dwCountOfSubkeys
9334>>>>>        Integer iError
9334>>>>>        String sError
9334>>>>>        
9334>>>>>        Move 0 to dwCountOfSubkeys
9335>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9336>>>>>        If iError Begin
9338>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9339>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9340>>>>>>
9340>>>>>        End
9340>>>>>>
9340>>>>>        Function_Return dwCountOfSubkeys
9341>>>>>    End_Function
9342>>>>>    
9342>>>>>    Function CountOfValues Returns Integer
9344>>>>>        Integer dwCountOfValues
9344>>>>>        Integer iError
9344>>>>>        String sError
9344>>>>>        
9344>>>>>        Move 0 to dwCountOfValues
9345>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9346>>>>>        If iError Begin
9348>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9349>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9350>>>>>>
9350>>>>>        End
9350>>>>>>
9350>>>>>        
9350>>>>>        Function_Return dwCountOfValues
9351>>>>>    End_Function
9352>>>>>    
9352>>>>>    Function LongestSubkeyLength Returns Integer
9354>>>>>        Integer dwLongestSubkeyLength
9354>>>>>        Integer iError
9354>>>>>        String sError
9354>>>>>        
9354>>>>>        Move 0 to dwLongestSubkeyLength
9355>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9356>>>>>        If iError Begin
9358>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9359>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9360>>>>>>
9360>>>>>        End
9360>>>>>>
9360>>>>>        
9360>>>>>        Function_Return dwLongestSubkeyLength
9361>>>>>    End_Function
9362>>>>>    
9362>>>>>    Function LongestValueLength Returns Integer
9364>>>>>        Integer dwLongestValueLength
9364>>>>>        Integer iError
9364>>>>>        String sError
9364>>>>>        
9364>>>>>        Move 0 to dwLongestValueLength
9365>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9366>>>>>        If iError Begin
9368>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9369>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9370>>>>>>
9370>>>>>        End
9370>>>>>>
9370>>>>>        
9370>>>>>        Function_Return dwLongestValueLength
9371>>>>>    End_Function
9372>>>>>    
9372>>>>>    Function LongestDataLength Returns Integer
9374>>>>>        Integer dwLongestDataLength
9374>>>>>        Integer iError
9374>>>>>        String sError
9374>>>>>        
9374>>>>>        Move 0 to dwLongestDataLength
9375>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9376>>>>>        If iError Begin
9378>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9379>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9380>>>>>>
9380>>>>>        End
9380>>>>>>
9380>>>>>        
9380>>>>>        Function_Return dwLongestDataLength
9381>>>>>    End_Function
9382>>>>>    
9382>>>>>    Function ValueType String sValueName Returns Integer
9384>>>>>        Integer dwType
9384>>>>>        Integer iError eType
9384>>>>>        String sError
9384>>>>>        
9384>>>>>        Move 0 to dwType
9385>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9386>>>>>        If iError Begin
9388>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9389>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9390>>>>>>
9390>>>>>        End
9390>>>>>>
9390>>>>>        
9390>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9393>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9397>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9401>>>>>        Else ;            Move rdUnknown to eType
9403>>>>>        
9403>>>>>        Function_Return eType
9404>>>>>    End_Function
9405>>>>>    
9405>>>>>    Function ValueLength String sValueName Returns Integer
9407>>>>>        Integer dwSize
9407>>>>>        Integer iError
9407>>>>>        String sError
9407>>>>>        
9407>>>>>        Move 0 to dwSize
9408>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9409>>>>>        If iError Begin
9411>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9412>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9413>>>>>>
9413>>>>>        End
9413>>>>>>
9413>>>>>        
9413>>>>>        Function_Return dwSize
9414>>>>>    End_Function
9415>>>>>    
9415>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9417>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9417>>>>>        Handle hKey hKeyOpened
9417>>>>>        Integer iError
9417>>>>>        String sError
9417>>>>>        
9417>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9418>>>>>        
9418>>>>>        Get phRootKey to hKey
9419>>>>>        
9419>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9420>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9423>>>>>        Else Begin
9424>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9425>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9426>>>>>>
9426>>>>>        End
9426>>>>>>
9426>>>>>        Function_Return iError
9427>>>>>    End_Function
9428>>>>>    
9428>>>>>    Procedure CloseKey
9430>>>>>        Integer iError
9430>>>>>        Handle hKey
9430>>>>>        
9430>>>>>        Get phCurrentKey to hKey
9431>>>>>        
9431>>>>>        If (hKey <>0) Begin
9433>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9436>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9438>>>>>            
9438>>>>>            Set phCurrentKey to 0
9439>>>>>        End
9439>>>>>>
9439>>>>>    End_Procedure
9440>>>>>    
9440>>>>>    Function OpenKey String sKeyName Returns Boolean
9442>>>>>        Handle hKey hKeyOpened
9442>>>>>        Integer iError
9442>>>>>        
9442>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9443>>>>>        
9443>>>>>        Get phRootKey to hKey
9444>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9445>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9448>>>>>        
9448>>>>>        Function_Return (iError=0)
9449>>>>>    End_Function
9450>>>>>    
9450>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9452>>>>>        Handle hKey
9452>>>>>        Integer iError
9452>>>>>        Integer iData
9452>>>>>        String sError
9452>>>>>        
9452>>>>>        Move iValueData to iData
9453>>>>>        Get phCurrentKey to hKey
9454>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9455>>>>>        If iError Begin
9457>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9458>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9459>>>>>>
9459>>>>>        End
9459>>>>>>
9459>>>>>    End_Procedure
9460>>>>>    
9460>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9460>>>>>    Procedure WriteDword String sValue Integer iValueData
9462>>>>>        Send WriteInteger of Self sValue iValueData
9463>>>>>    End_Procedure
9464>>>>>    
9464>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9466>>>>>        Handle hKey
9466>>>>>        Integer iError
9466>>>>>        UInteger uData
9466>>>>>        String sError
9466>>>>>        
9466>>>>>        Move uValueData to uData
9467>>>>>        Get phCurrentKey to hKey
9468>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9469>>>>>        If iError Begin
9471>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9472>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9473>>>>>>
9473>>>>>        End
9473>>>>>>
9473>>>>>    End_Procedure
9474>>>>>
9474>>>>>    Procedure WriteString WString sValue WString wValueData
9476>>>>>        Handle hKey
9476>>>>>        Integer iError cbData
9476>>>>>        String sError
9476>>>>>        
9476>>>>>        If (wValueData = "") Begin
9478>>>>>            Move (Character(0)) to wValueData
9479>>>>>            Move 1 to cbData
9480>>>>>        End
9480>>>>>>
9480>>>>>        Else Begin
9481>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9482>>>>>        End
9482>>>>>>
9482>>>>>        Get phCurrentKey to hKey
9483>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9484>>>>>        If iError Begin
9486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9488>>>>>>
9488>>>>>        End
9488>>>>>>
9488>>>>>    End_Procedure
9489>>>>>    
9489>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9491>>>>>        Handle hKey
9491>>>>>        Integer iError
9491>>>>>        String sError
9491>>>>>        
9491>>>>>        Get phCurrentKey to hKey
9492>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9493>>>>>        If iError Begin
9495>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9496>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9497>>>>>>
9497>>>>>        End
9497>>>>>>
9497>>>>>    End_Procedure
9498>>>>>    
9498>>>>>    Function ReadInteger WString sValueName Returns Integer
9500>>>>>        Handle hKey
9500>>>>>        Integer iError
9500>>>>>        Integer iValueData iValueDataLength
9500>>>>>        String sError
9500>>>>>        
9500>>>>>        Move 0           to iValueData
9501>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9502>>>>>        
9502>>>>>        Get phCurrentKey to hKey
9503>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9504>>>>>        If iError Begin
9506>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9507>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9508>>>>>>
9508>>>>>        End
9508>>>>>>
9508>>>>>        
9508>>>>>        Function_Return iValueData
9509>>>>>    End_Function
9510>>>>>    
9510>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9510>>>>>    Function ReadDword String sValueName Returns Integer
9512>>>>>        Function_Return (ReadInteger(Self, sValueName))
9513>>>>>    End_Function
9514>>>>>
9514>>>>>    Function ReadUInt WString sValueName Returns UInteger
9516>>>>>        Handle hKey
9516>>>>>        Integer iError
9516>>>>>        UInteger uValueData uValueDataLength
9516>>>>>        String sError
9516>>>>>        
9516>>>>>        Move 0           to uValueData
9517>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9518>>>>>        
9518>>>>>        Get phCurrentKey to hKey
9519>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9520>>>>>        If iError Begin
9522>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9523>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9524>>>>>>
9524>>>>>        End
9524>>>>>>
9524>>>>>        
9524>>>>>        Function_Return uValueData
9525>>>>>    End_Function
9526>>>>>    
9526>>>>>    Function ReadString String sValueName Returns String
9528>>>>>        Handle hKey
9528>>>>>        Integer iError
9528>>>>>        WString wValueData
9528>>>>>        DWord dwValueDataLength dwType
9528>>>>>        Pointer lpsValueData
9528>>>>>        String sError
9528>>>>>        
9528>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9529>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9530>>>>>        
9530>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9531>>>>>        
9531>>>>>        Move REG_SZ to dwType
9532>>>>>        
9532>>>>>        Get phCurrentKey to hKey
9533>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9534>>>>>        If iError Begin
9536>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9537>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9538>>>>>>
9538>>>>>        End
9538>>>>>>
9538>>>>>        
9538>>>>>        Function_Return (CString(wValueData))
9539>>>>>    End_Function
9540>>>>>    
9540>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9542>>>>>        Handle hKey
9542>>>>>        Integer iError
9542>>>>>        String sError
9542>>>>>        
9542>>>>>        Get phCurrentKey to hKey
9543>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9544>>>>>        If iError Begin
9546>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9547>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9548>>>>>>
9548>>>>>        End
9548>>>>>>
9548>>>>>        
9548>>>>>        Function_Return (iDataLength >0)
9549>>>>>    End_Function
9550>>>>>    
9550>>>>>    
9550>>>>>    // Private....
9550>>>>>    Function GetBaseKey Returns Handle
9552>>>>>        Handle hBaseKey
9552>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9555>>>>>        Else ;            Get phCurrentKey to hBaseKey
9557>>>>>        
9557>>>>>        Function_Return hBaseKey
9558>>>>>    End_Function
9559>>>>>    
9559>>>>>    Function GetKey String sKeyName Returns Handle
9561>>>>>        Handle hKeyOpened
9561>>>>>        Integer iError
9561>>>>>        
9561>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9562>>>>>        
9562>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9563>>>>>        
9563>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9566>>>>>        Else ;            Function_Return 0
9568>>>>>    End_Function
9569>>>>>    
9569>>>>>    // Public
9569>>>>>    Function KeyExists String sKeyName Returns Boolean
9571>>>>>        Handle hKey
9571>>>>>        Integer iVoid
9571>>>>>        
9571>>>>>        Get GetKey sKeyName to hKey
9572>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9575>>>>>        Function_Return (hKey <>0)
9576>>>>>    End_Function
9577>>>>>    
9577>>>>>    Function ValueExists String sValueName Returns Boolean
9579>>>>>        // Determines whether a Value exists for the currently-opened Key.
9579>>>>>        Integer iError
9579>>>>>        DWord dwDataType
9579>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9580>>>>>        
9580>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9581>>>>>        
9581>>>>>        Function_Return (iError=0)
9582>>>>>    End_Function
9583>>>>>    
9583>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9585>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9586>>>>>    End_Function
9587>>>>>    
9587>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9589>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9590>>>>>    End_Function
9591>>>>>    
9591>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9593>>>>>        Integer iError
9593>>>>>        Integer icValue iLongestSubkey
9593>>>>>        Handle hKey
9593>>>>>        DWord dwSubkeyNameLength
9593>>>>>        WString wSubkeyName
9593>>>>>        tWinFileTime FileTime
9593>>>>>        tWinFileTime FileTime
9593>>>>>        
9593>>>>>        Get LongestSubkeyLength to iLongestSubkey
9594>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9595>>>>>        
9595>>>>>        Get phCurrentKey to hKey
9596>>>>>        Repeat
9596>>>>>>
9596>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9597>>>>>            
9597>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9598>>>>>            If (iError =0) Begin
9600>>>>>                Increment icValue
9601>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9602>>>>>            End
9602>>>>>>
9602>>>>>        Until (iError)
9604>>>>>        Function_Return icValue
9605>>>>>        
9605>>>>>    End_Function
9606>>>>>    
9606>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9608>>>>>        Integer iError
9608>>>>>        Integer icValue iLongestValue
9608>>>>>        Handle hKey
9608>>>>>        DWord dwValueNameLength
9608>>>>>        WString wValueName 
9608>>>>>        String sValueNameSize
9608>>>>>        Pointer lpsValueName
9608>>>>>        
9608>>>>>        Get LongestValueLength to iLongestValue
9609>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9610>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9611>>>>>        
9611>>>>>        Get phCurrentKey to hKey
9612>>>>>        Repeat
9612>>>>>>
9612>>>>>            Move (iLongestValue +1) to dwValueNameLength
9613>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9614>>>>>            If (iError =0) Begin
9616>>>>>                Increment icValue
9617>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9618>>>>>            End
9618>>>>>>
9618>>>>>        Until (iError)
9620>>>>>        Function_Return icValue
9621>>>>>        
9621>>>>>    End_Function
9622>>>>>    
9622>>>>>End_Class
9623>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cVersionInfo.pkg)
9623>>>>>Use VdfBase.pkg
9623>>>>>Use DLL.pkg
9623>>>>>Use tWinStructs.pkg
9623>>>>>Use WinKern.pkg
9623>>>>>
9623>>>>>Define VS_FF_DEBUG         for |CI$00000001
9623>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9623>>>>>Define VS_FF_PATCHED       for |CI$00000004
9623>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9623>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9623>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9623>>>>>
9623>>>>>// Note: String pointer lpFilename must refer to WString type.
9623>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9624>>>>>    
9624>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9624>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9626>>>>>    
9626>>>>>    DWord  dwResult
9626>>>>>    UWide  uwFileName
9626>>>>>    UWide  uwFileName
9626>>>>>
9626>>>>>    Send StringToWide aFilename (&uwFileName)
9627>>>>>    
9627>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9628>>>>>    Function_Return dwResult
9629>>>>>End_Function
9630>>>>>
9630>>>>>// Note: String pointers should be referring to WString items.
9630>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9631>>>>>    
9631>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9631>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9633>>>>>    
9633>>>>>    Integer iResult
9633>>>>>    UWide   uwFileName
9633>>>>>    UWide   uwFileName
9633>>>>>
9633>>>>>    Send StringToWide aFilename (&uwFileName)
9634>>>>>    
9634>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9635>>>>>    Function_Return iResult
9636>>>>>End_Function    
9637>>>>>
9637>>>>>// Note: String pointers should be referring to WString items.
9637>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9638>>>>>
9638>>>>>// Wrapper Function VerQueryValue (when using strings)
9638>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9640>>>>>    
9640>>>>>    Integer iResult
9640>>>>>    UWide   uwSubBlock
9640>>>>>    UWide   uwSubBlock
9640>>>>>    
9640>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9641>>>>>    
9641>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9642>>>>>    
9642>>>>>    Function_Return iResult
9643>>>>>End_Function
9644>>>>>
9644>>>>>
9644>>>>>Class cVersionInfo is a cObject
9645>>>>>    Procedure Construct_Object
9647>>>>>        Forward Send Construct_Object
9649>>>>>        
9649>>>>>        
9649>>>>>        Property Integer piVersionMajor
9650>>>>>        Property Integer piVersionMinor
9651>>>>>        Property Integer piVersionRelease
9652>>>>>        Property Integer piVersionBuild
9653>>>>>        
9653>>>>>        Property Boolean pbIncluded
9654>>>>>        Property Boolean pbSpecialBuild
9655>>>>>        Property Boolean pbPrivateBuild
9656>>>>>        
9656>>>>>    End_Procedure
9657>>>>>    
9657>>>>>    Procedure DoCreate WString sFileName
9659>>>>>        DWord dwHandle
9659>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9659>>>>>        WString sData
9659>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9659>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9659>>>>>        WString sSubBlock
9659>>>>>        Pointer pVsFixedFileInfo
9659>>>>>        
9659>>>>>        Move 0 to pVsFixedFileInfo
9660>>>>>        Move 0 to dwHandle
9661>>>>>        Move 0 to iVerSize
9662>>>>>        
9662>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9663>>>>>        Set pbIncluded to (iInfoSize <>0)
9664>>>>>        
9664>>>>>        If (pbIncluded(Self)) Begin
9666>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9667>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9668>>>>>            
9668>>>>>            If (iSuccess <>0) Begin
9670>>>>>                Move "\" to sSubBlock
9671>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9673>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9674>>>>>                    
9674>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9675>>>>>                    Set piVersionMajor to (Hi(iVersion))
9676>>>>>                    Set piVersionMinor to (Low(iVersion))
9677>>>>>                    
9677>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9678>>>>>                    Set piVersionRelease to (Hi(iVersion))
9679>>>>>                    Set piVersionBuild   to (Low(iVersion))
9680>>>>>                    
9680>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9681>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9682>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9683>>>>>                End
9683>>>>>>
9683>>>>>            End
9683>>>>>>
9683>>>>>            
9683>>>>>        End
9683>>>>>>
9683>>>>>    End_Procedure
9684>>>>>    
9684>>>>>End_Class
9685>>>Use GlobalFunctionsProcedures.pkg
9685>>>Use tWinStructs.pkg
9685>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9685>>>
9685>>>Register_Function phoWorkspace Returns Handle
9685>>>Register_Function phoCommandLine Returns Handle
9685>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9685>>>Register_Function GetApplicationName Returns String
9685>>>Register_Function GetApplicationFileName Returns String
9685>>>
9685>>>Register_Function Statusbar_State Returns Integer
9685>>>Register_Function Toolbar_State Returns Integer
9685>>>Register_Procedure Set Statusbar_State
9685>>>Register_Procedure Set Toolbar_State
9685>>>
9685>>>
9685>>>Class cApplication is a cObject
9686>>>    Procedure Construct_Object
9688>>>        Forward Send Construct_Object
9690>>>        
9690>>>        Move Self to ghoApplication
9691>>>        
9691>>>        Property Handle phoVersionInfo
9692>>>        Property Handle phoWorkspace
9693>>>        Property Handle phoCommandLine
9694>>>        Property Handle phoMainPanel       // main panel will set this for us.
9695>>>        Property String psHelpFile         // type of file is determined by peHelpType
9696>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9697>>>        
9697>>>        Property String psCompany "Data Access Worldwide"
9698>>>        Property String psProduct "DataFlex Applications"
9699>>>        Property String psVersion C_DFVersion
9700>>>        Property String psProgram (Module_Name(desktop))
9701>>>        
9701>>>        // set to '' to stop the auto open workspace behavior
9701>>>        Property String psAutoOpenWorkspace 'Config.ws'
9702>>>        
9702>>>        
9702>>>        Property Boolean pbPreserveEnvironment True
9703>>>        
9703>>>        Object oCommandLine is a cCommandLine
9705>>>            Delegate Set phoCommandLine to Self
9707>>>        End_Object
9708>>>        
9708>>>        Object oWorkspace is a cWorkspace
9710>>>            Delegate Set phoWorkspace to Self
9712>>>        End_Object
9713>>>        
9713>>>        Object oVersionInfo is a cVersionInfo
9715>>>            Delegate Set phoVersionInfo to Self
9717>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9718>>>        End_Object
9719>>>        
9719>>>        Set pbUseWindowsFont to True
9720>>>        
9720>>>    End_Procedure
9721>>>    
9721>>>    Procedure Destroy_Object
9723>>>        If (ghoApplication=Self) Begin
9725>>>            Move 0 to ghoApplication
9726>>>        End
9726>>>>
9726>>>        Forward Send Destroy_Object
9728>>>    End_Procedure
9729>>>    
9729>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9729>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9729>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9731>>>        Move bNext to gbKEnterNext
9732>>>    End_Procedure
9733>>>    
9733>>>    Function pbEnterKeyAsTabKey Returns Boolean
9735>>>        Function_Return gbKEnterNext
9736>>>    End_Function
9737>>>    
9737>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9739>>>// not used with webapp
9739>>>        Handle hoRegistry hoCommandBars
9739>>>        Handle hMonitor
9739>>>        Integer iError cxy
9739>>>        tWinWindowPlacement WindowPlacement
9739>>>        tWinWindowPlacement WindowPlacement
9739>>>        String sKey
9739>>>        Boolean bSuccess
9739>>>        String sObjectName
9739>>>        
9739>>>        If (pbPreserveEnvironment(Self)) Begin
9741>>>            Get Create U_cRegistry to hoRegistry
9742>>>            Set pfAccessRights of hoRegistry to KEY_READ
9743>>>            
9743>>>            Get RegistryKeyString to sKey
9744>>>            
9744>>>            If (bProgram = False) Begin
9746>>>                Move (sKey +"\WINDOWS") to sKey
9747>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9748>>>                Move (sKey +"\" +sObjectName) to sKey
9749>>>            End
9749>>>>
9749>>>            Else ;                Move (sKey + "\Preferences") to sKey
9751>>>            
9751>>>            Get OpenKey of hoRegistry sKey to bSuccess
9752>>>            
9752>>>            If bSuccess Begin
9754>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9756>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9757>>>                    If bSuccess Begin
9759>>>                        // Do not restore size if the window is not resizable
9759>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9761>>>                            // restore always works with outer size
9761>>>                            Get GuiWindowSize     of hoContainer to cxy
9762>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9763>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9764>>>                        End
9764>>>>
9764>>>                        
9764>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9764>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9764>>>                        If (bProgram) Begin
9766>>>                            // Test the top left point
9766>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9767>>>                            
9767>>>                            If (hMonitor = 0) Begin
9769>>>                                // test the bottom right point
9769>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9770>>>                            End
9770>>>>
9770>>>                            
9770>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9770>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9770>>>                            If (hMonitor = 0) Begin
9772>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9773>>>                            End
9773>>>>
9773>>>                        End
9773>>>>
9773>>>                        
9773>>>                        // Set the placement
9773>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9774>>>                    End
9774>>>>
9774>>>                End
9774>>>>
9774>>>                If bProgram Begin
9776>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9777>>>                    If not hoCommandBars Begin
9779>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9782>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9785>>>                    End
9785>>>>
9785>>>                End
9785>>>>
9785>>>                
9785>>>                Send CloseKey of hoRegistry
9786>>>            End
9786>>>>
9786>>>            
9786>>>            Send Destroy of hoRegistry
9787>>>        End
9787>>>>
9787>>>    End_Procedure
9788>>>    
9788>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9790>>>// not used with webapp
9790>>>        Handle hoRegistry
9790>>>        Integer iError
9790>>>        tWinWindowPlacement WindowPlacement
9790>>>        tWinWindowPlacement WindowPlacement
9790>>>        String sKey
9790>>>        Boolean bSuccess
9790>>>        Integer eShowCmd
9790>>>        String sObjectName
9790>>>        
9790>>>        If (pbPreserveEnvironment(Self)) Begin
9792>>>            Get Create U_cRegistry to hoRegistry
9793>>>            Get RegistryKeyString to sKey
9794>>>            
9794>>>            If (bProgram = False) Begin
9796>>>                Move (sKey +"\WINDOWS") to sKey
9797>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9798>>>                Move (sKey +"\" +sObjectName) to sKey
9799>>>            End
9799>>>>
9799>>>            Else ;                Move (sKey +"\Preferences") to sKey
9801>>>            
9801>>>            Get CreateKey of hoRegistry sKey to iError
9802>>>            If (iError = 0) Begin
9804>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9805>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9806>>>                If bSuccess Begin
9808>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9808>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9810>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9811>>>                    End
9811>>>>
9811>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9812>>>                End
9812>>>>
9812>>>                
9812>>>                If bProgram Begin
9814>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9815>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9816>>>                End
9816>>>>
9816>>>                
9816>>>                
9816>>>                Send CloseKey of hoRegistry
9817>>>            End
9817>>>>
9817>>>            
9817>>>            Send Destroy of hoRegistry
9818>>>        End
9818>>>>
9818>>>    End_Procedure
9819>>>    
9819>>>    
9819>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9821>>>        Integer ixySize ixSize iySize
9821>>>        Integer ixOffset iyOffset
9821>>>        
9821>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9821>>>        Move (0 - WindowPos.left) to ixOffset
9822>>>        Move (0 - WindowPos.top) to iyOffset
9823>>>        
9823>>>        Move 0 to WindowPos.left
9824>>>        Move 0 to WindowPos.top
9825>>>        
9825>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9826>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9827>>>        
9827>>>        // also make sure that the size of the window is <= the size of the main monitor
9827>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9828>>>        Move (low(ixySize))      to ixSize
9829>>>        Move (hi(ixySize))       to iySize
9830>>>        
9830>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9831>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9832>>>    End_Procedure
9833>>>    
9833>>>    
9833>>>    Function RegistryKeyString Returns String
9835>>>        String sCompany sProduct sVersion sProgram
9835>>>        
9835>>>        Get psCompany to sCompany
9836>>>        Get psProduct to sProduct
9837>>>        Get psVersion to sVersion
9838>>>        Get psProgram to sProgram
9839>>>        
9839>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9842>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9845>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
9848>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
9851>>>        
9851>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
9852>>>    End_Function
9853>>>    
9853>>>    Procedure WriteString String sSubKey String sValueName String sValueData
9855>>>        String sKey
9855>>>        Handle hoRegistry
9855>>>        Integer iError
9855>>>        
9855>>>        Get Create U_cRegistry to hoRegistry
9856>>>        Get RegistryKeyString to sKey
9857>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9860>>>        Get CreateKey of hoRegistry sKey to iError
9861>>>        If (iError = 0) Begin
9863>>>            Send WriteString of hoRegistry sValueName sValueData
9864>>>            Send CloseKey of hoRegistry
9865>>>        End
9865>>>>
9865>>>        
9865>>>        Send Destroy of hoRegistry
9866>>>    End_Procedure
9867>>>    
9867>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
9869>>>        String sKey
9869>>>        Handle hoRegistry
9869>>>        Integer iError
9869>>>        
9869>>>        Get Create U_cRegistry to hoRegistry
9870>>>        Get RegistryKeyString to sKey
9871>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9874>>>        Get CreateKey of hoRegistry sKey to iError
9875>>>        If (iError = 0) Begin
9877>>>            Send WriteInteger of hoRegistry sValueName iValueData
9878>>>            Send CloseKey of hoRegistry
9879>>>        End
9879>>>>
9879>>>        
9879>>>        Send Destroy of hoRegistry
9880>>>    End_Procedure
9881>>>    
9881>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9881>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
9883>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
9884>>>    End_Procedure
9885>>>    
9885>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
9887>>>        String sKey
9887>>>        Handle hoRegistry
9887>>>        Integer iError
9887>>>        
9887>>>        Get Create U_cRegistry to hoRegistry
9888>>>        Get RegistryKeyString to sKey
9889>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9892>>>        Get CreateKey of hoRegistry sKey to iError
9893>>>        If (iError = 0) Begin
9895>>>            Send WriteUInt of hoRegistry sValueName uValueData
9896>>>            Send CloseKey of hoRegistry
9897>>>        End
9897>>>>
9897>>>        
9897>>>        Send Destroy of hoRegistry
9898>>>    End_Procedure
9899>>>
9899>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
9901>>>        String sKey
9901>>>        Handle hoRegistry
9901>>>        Integer iError
9901>>>        
9901>>>        Get Create U_cRegistry to hoRegistry
9902>>>        Get RegistryKeyString to sKey
9903>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9906>>>        Get CreateKey of hoRegistry sKey to iError
9907>>>        If (iError = 0) Begin
9909>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
9910>>>            Send CloseKey of hoRegistry
9911>>>        End
9911>>>>
9911>>>        
9911>>>        Send Destroy of hoRegistry
9912>>>    End_Procedure
9913>>>    
9913>>>    // returns true if both sub-key and value exists.
9913>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
9915>>>        String sKey
9915>>>        Handle hoRegistry
9915>>>        Boolean bOK
9915>>>        Get Create U_cRegistry to hoRegistry
9916>>>        Get RegistryKeyString to sKey
9917>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9920>>>        Get OpenKey of hoRegistry sKey to bOk
9921>>>        If (bOK) Begin
9923>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
9924>>>            Send CloseKey of hoRegistry
9925>>>        End
9925>>>>
9925>>>        Send Destroy of hoRegistry
9926>>>        Function_Return bOk
9927>>>    End_Function
9928>>>    
9928>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
9930>>>        String sKey sData
9930>>>        Handle hoRegistry
9930>>>        Boolean bOK
9930>>>        
9930>>>        Move sDefault to sData
9931>>>        Get Create U_cRegistry to hoRegistry
9932>>>        Get RegistryKeyString to sKey
9933>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9936>>>        Get OpenKey of hoRegistry sKey to bOk
9937>>>        If (bOK) Begin
9939>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
9942>>>            Send CloseKey of hoRegistry
9943>>>        End
9943>>>>
9943>>>        
9943>>>        Send Destroy of hoRegistry
9944>>>        Function_Return sData
9945>>>    End_Function
9946>>>    
9946>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
9948>>>        String sKey
9948>>>        Integer iData
9948>>>        Handle hoRegistry
9948>>>        Boolean bOK
9948>>>        
9948>>>        Move iDefault to iData
9949>>>        Get Create U_cRegistry to hoRegistry
9950>>>        Get RegistryKeyString to sKey
9951>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9954>>>        Get OpenKey of hoRegistry sKey to bOk
9955>>>        If bOK Begin
9957>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
9960>>>            Send CloseKey of hoRegistry
9961>>>        End
9961>>>>
9961>>>        
9961>>>        Send Destroy of hoRegistry
9962>>>        Function_Return iData
9963>>>    End_Function
9964>>>
9964>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9964>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
9966>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
9967>>>    End_Function
9968>>>    
9968>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
9970>>>        String sKey
9970>>>        UInteger uData
9970>>>        Handle hoRegistry
9970>>>        Boolean bOK
9970>>>        
9970>>>        Move uDefault to uData
9971>>>        Get Create U_cRegistry to hoRegistry
9972>>>        Get RegistryKeyString to sKey
9973>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9976>>>        Get OpenKey of hoRegistry sKey to bOk
9977>>>        If bOK Begin
9979>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
9982>>>            Send CloseKey of hoRegistry
9983>>>        End
9983>>>>
9983>>>        
9983>>>        Send Destroy of hoRegistry
9984>>>        Function_Return uData
9985>>>    End_Function
9986>>>    
9986>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9988>>>        String sKey
9988>>>        Handle hoRegistry
9988>>>        Boolean bOK bSuccess
9988>>>        
9988>>>        Get Create U_cRegistry to hoRegistry
9989>>>        Get RegistryKeyString to sKey
9990>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9993>>>        Get OpenKey of hoRegistry sKey to bOk
9994>>>        If bOK Begin
9996>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
9997>>>            Send CloseKey of hoRegistry
9998>>>        End
9998>>>>
9998>>>        
9998>>>        Send Destroy of hoRegistry
9999>>>        Function_Return bSuccess
10000>>>    End_Function
10001>>>    
10001>>>    Procedure DoOpenWorkspace String sWorkspace
10003>>>        // Tries to open in this order:
10003>>>        // 1) if absolute path, use that; otherwise
10003>>>        // 2) try to open in the path of the EXE; otherwise
10003>>>        // 3) load it via the Registered list
10003>>>        
10003>>>        Integer eOpened
10003>>>        String sError sWSFile
10003>>>        Handle hoWorkspace
10003>>>        Boolean bChangingWorkspace
10003>>>        
10003>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10003>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10003>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10003>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10003>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10003>>>        // that there should be no automatic opening of a worskpace.
10003>>>        Set psAutoOpenWorkspace to ""
10004>>>        
10004>>>        Get phoWorkspace to hoWorkspace
10005>>>        
10005>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10006>>>        If (bChangingWorkspace and ghoConnection) Begin
10008>>>            Send AutoDisconnect
10009>>>        End
10009>>>>
10009>>>        
10009>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10010>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10012>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10014>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10015>>>            End
10015>>>>
10015>>>        End
10015>>>>
10015>>>        If (eOpened <> wsWorkspaceOpened) Begin
10017>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10018>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10019>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10020>>>>
10020>>>            Abort
10021>>>>
10021>>>        End
10021>>>>
10021>>>        Else Begin
10022>>>            Send AutoConnect
10023>>>            Send OnWorkspaceOpened
10024>>>        End
10024>>>>
10024>>>    End_Procedure
10025>>>    
10025>>>    Procedure AutoConnect
10027>>>        If (ghoConnection) Begin
10029>>>            Send AutoConnect of ghoConnection
10030>>>        End
10030>>>>
10030>>>    End_Procedure
10031>>>    
10031>>>    Procedure AutoDisconnect
10033>>>        If (ghoConnection) Begin
10035>>>            Send AutoDisconnect of ghoConnection
10036>>>        End
10036>>>>
10036>>>    End_Procedure
10037>>>    
10037>>>    // send after a workspace is successfully opened and connected
10037>>>    Procedure OnWorkspaceOpened
10039>>>    End_Procedure
10040>>>    
10040>>>    Procedure OnCreate
10042>>>        // Event called when the Application object is ready to be used
10042>>>        // to open a Workspace, etc.
10042>>>    End_Procedure
10043>>>    
10043>>>    Procedure End_Construct_Object
10045>>>        String sName
10045>>>        Forward Send End_Construct_Object
10047>>>        Send OnCreate
10048>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10048>>>        Get psAutoOpenWorkspace to sName
10049>>>        If (sName<>"") Begin
10051>>>            Send DoOpenWorkspace sName
10052>>>        End
10052>>>>
10052>>>    End_Procedure
10053>>>    
10053>>>    Function GetApplicationFileName Returns String
10055>>>        // Returns the filename from Windows
10055>>>        Integer iNumChars
10055>>>        WString wFilename
10055>>>                
10055>>>        Move (Repeat(Character(0), 1024)) to wFilename
10056>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10057>>>        
10057>>>        Function_Return (CString(wFilename))
10058>>>    End_Function
10059>>>    
10059>>>    Function GetApplicationPath Returns String
10061>>>        // Returns the path of the Application (no trailing "\")
10061>>>        WString wApplicationFileName 
10061>>>        String sPath
10061>>>        Boolean bRemoved
10061>>>        
10061>>>        Get GetApplicationFileName  to wApplicationFileName
10062>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10063>>>        Move (CString(wApplicationFileName)) to sPath
10064>>>        
10064>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10067>>>        Function_Return sPath
10068>>>    End_Function
10069>>>    
10069>>>    Function GetApplicationName Returns String
10071>>>        // Returns the name of the Application (without its Path or Extension)
10071>>>        String sApplicationFileName 
10071>>>        WString wApplicationName
10071>>>        Boolean bRemoved
10071>>>        Integer iVoid
10071>>>        
10071>>>        Get GetApplicationFileName to sApplicationFileName
10072>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10073>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10074>>>        Function_Return (CString(wApplicationName))
10075>>>    End_Function
10076>>>    
10076>>>    Function DFRootPath Returns String
10078>>>        String sRoot
10078>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10081>>>        // Ensure it does not contain a trailing "\"
10081>>>        If (Right(sRoot,1) = "\") Begin
10083>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10084>>>        End
10084>>>>
10084>>>        Function_Return sRoot
10085>>>    End_Function
10086>>>    
10086>>>    Function DFBinPath Returns String
10088>>>        String sRoot
10088>>>        Get DFRootPath to sRoot
10089>>>        If (sRoot<>"") Begin
10091>>>            Move (sRoot+"\bin") to sRoot
10092>>>        End
10092>>>>
10092>>>        Else Begin
10093>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10093>>>            // bin path must be the same as the application path.
10093>>>            Get GetApplicationPath to sRoot
10094>>>        End
10094>>>>
10094>>>        Function_Return sRoot
10095>>>    End_Function
10096>>>    
10096>>>    // this just directs to the desktop property. If you are using an application object you are
10096>>>    // encouraged to set this here.
10096>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10098>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10099>>>    End_Procedure
10100>>>    
10100>>>    Function pbUseWindowsFont Returns Boolean
10102>>>        Boolean bUseWindowsFont
10102>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10103>>>        Function_Return bUseWindowsFont
10104>>>    End_Function
10105>>>    
10105>>>    // this just directs to the desktop property. If you are using an application object you are
10105>>>    // encouraged to set this here.
10105>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10107>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10108>>>    End_Procedure
10109>>>    
10109>>>    Function pbLegacyDialogRatio Returns Boolean
10111>>>        Boolean bLegacy
10111>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10112>>>        Function_Return bLegacy
10113>>>    End_Function
10114>>>End_Class
10115>>>
10115>>>
10115>Use cConnection.pkg
Including file: cConnection.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cConnection.pkg)
10115>>>Use vdfbase.pkg // Windows.pkg
10115>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cli.pkg)
10115>>>>>//                                                              
10115>>>>>//   CLI specific functionality. There are several connectivity kits     
10115>>>>>//   based on  SQL/92 CLI. Those are:                                    
10115>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
10115>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
10115>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
10115>>>>>//                                                                       
10115>>>>>//   This package defines the common functionality for all CLI based     
10115>>>>>//   drivers.                                                            
10115>>>>>
10115>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
10115>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
10115>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
10115>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
10115>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
10115>>>>>Define DF_FILE_TABLE_NAME               for 609
10115>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
10115>>>>>Define DF_FILE_SQL_FILTER               for 611
10115>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
10115>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
10115>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
10115>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
10115>>>>>Define DF_FILE_DATABASE_ID              for 622
10115>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
10115>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
10115>>>>>Define DF_FILE_BLOCK_SIZE               for 628
10115>>>>>Define DF_FILE_JIT_BINDING              for 630
10115>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
10115>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
10115>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
10115>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
10115>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
10115>>>>>
10115>>>>>Define DF_FIELD_STORE_TIME              for 702
10115>>>>>Define DF_FIELD_TIME                    for 703
10115>>>>>Define DF_FIELD_IS_NULL                 for 704
10115>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
10115>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
10115>>>>>Define DF_FIELD_FETCH_STATE             for 708
10115>>>>>Define DF_FIELD_READ_ONLY               for 710
10115>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
10115>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
10115>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
10115>>>>>Define DF_SQL_RELATION_COLUMN           for 716
10115>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
10115>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
10115>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
10115>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
10115>>>>>Define DF_FIELD_IS_IDENTITY             for 722
10115>>>>>
10115>>>>>Define DF_INDEX_NAME                    for 801
10115>>>>>Define DF_INDEX_UNIQUE                  for 802
10115>>>>>Define DF_INDEX_ON_BACKEND              for 804
10115>>>>>
10115>>>>>Define DF_INDEX_CLUSTERED               for 806
10115>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
10115>>>>>Define DF_INDEX_SQL_TYPE                for 810
10115>>>>>Define DF_INDEX_NUMBER                  for 812
10115>>>>>
10115>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
10115>>>>>Define DF_DATABASE_ID                            for 1002
10115>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
10115>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
10115>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
10115>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
10115>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
10115>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
10115>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
10115>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
10115>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
10115>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
10115>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
10115>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
10115>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
10115>>>>>
10115>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
10115>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
10115>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
10115>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
10115>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
10115>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
10115>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
10115>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
10115>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
10115>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
10115>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
10115>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
10115>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
10115>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
10115>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
10115>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
10115>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
10115>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
10115>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
10115>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
10115>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
10115>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
10115>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
10115>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
10115>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
10115>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
10115>>>>>
10115>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
10115>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
10115>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
10115>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
10115>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
10115>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
10115>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
10115>>>>>
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
10115>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
10115>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
10115>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
10115>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
10115>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
10115>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
10115>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
10115>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
10115>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
10115>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
10115>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
10115>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
10115>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
10115>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
10115>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
10115>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
10115>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
10115>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
10115>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
10115>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
10115>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
10115>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
10115>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
10115>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
10115>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
10115>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
10115>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
10115>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
10115>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
10115>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
10115>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
10115>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
10115>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
10115>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
10115>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
10115>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
10115>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
10115>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
10115>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
10115>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
10115>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
10115>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
10115>>>>>
10115>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
10115>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
10115>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
10115>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
10115>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
10115>>>>>
10115>>>>>
10115>>>>>// Replacement for logical column number that indicates all columns
10115>>>>>Define DF_ALL_COLUMNS for -1
10115>>>>>
10115>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
10115>>>>>Define RIM_NONE            for 0
10115>>>>>Define RIM_IDENTITY_COLUMN for 1
10115>>>>>Define RIM_DISPENSER_TABLE for 2
10115>>>>>Define RIM_EXTERNAL        for 3
10115>>>>>
10115>>>>>// Possible DF_FIELD_READ_ONLY values
10115>>>>>Define RO_NO            for 0
10115>>>>>Define RO_IGNORECHANGE  for 1
10115>>>>>Define RO_ACCEPTCHANGE  for 2
10115>>>>>Define RO_ERRORONCHANGE for 3
10115>>>>>
10115>>>>>
10115>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
10115>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
10115>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
10115>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
10115>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
10115>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
10115>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
10115>>>>>
10115>>>>>
10115>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
10115>>>>>
10115>>>>>// Possible SQL Column type values
10115>>>>>//      SQL Server specific types defined in mssqldrv.pkg
10115>>>>>//      DB2 specific typesm defined in db2_drv.pkg
10115>>>>>
10115>>>>>Define SQL_UNKNOWN_TYPE   for    0
10115>>>>>Define SQL_CHAR           for    1
10115>>>>>Define SQL_NUMERIC        for    2
10115>>>>>Define SQL_DECIMAL        for    3
10115>>>>>Define SQL_INTEGER        for    4
10115>>>>>Define SQL_SMALLINT       for    5
10115>>>>>Define SQL_FLOAT          for    6
10115>>>>>Define SQL_REAL           for    7
10115>>>>>Define SQL_DOUBLE         for    8
10115>>>>>Define SQL_DATETIME       for    9
10115>>>>>Define SQL_VARCHAR        for   12
10115>>>>>Define SQL_TYPE_DATE      for   91
10115>>>>>Define SQL_TYPE_TIME      for   92
10115>>>>>Define SQL_TYPE_TIMESTAMP for   93
10115>>>>>
10115>>>>>Define SQL_DATE           for    9
10115>>>>>Define SQL_INTERVAL       for   10
10115>>>>>Define SQL_TIME           for   10
10115>>>>>Define SQL_TIMESTAMP      for   11
10115>>>>>Define SQL_LONGVARCHAR    for  (-1)
10115>>>>>Define SQL_BINARY         for  (-2)
10115>>>>>Define SQL_VARBINARY      for  (-3)
10115>>>>>Define SQL_LONGVARBINARY  for  (-4)
10115>>>>>Define SQL_BIGINT         for  (-5)
10115>>>>>Define SQL_TINYINT        for  (-6)
10115>>>>>Define SQL_BIT            for  (-7)
10115>>>>>Define SQL_WCHAR          for  (-8)
10115>>>>>Define SQL_WVARCHAR       for  (-9)
10115>>>>>Define SQL_WLONGVARCHAR   for (-10)
10115>>>>>Define SQL_GUID           for (-11)
10115>>>>>
10115>>>>>// Possible DF_INDEX_SQL_TYPE values
10115>>>>>Define DF_INDEX_CLIENT      for  1
10115>>>>>Define DF_INDEX_SERVER      for  2
10115>>>>>Define DF_INDEX_SERVER_ONLY for  3
10115>>>>>Define DF_INDEX_TEMPORARY   for  4
10115>>>>>
10115>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
10115>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
10115>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
10115>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
10115>>>>>
10115>>>>>// Driver level attributes
10115>>>>>Define DRVR_TOKEN_BASE                       for 1000
10115>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
10115>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
10115>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
10115>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
10115>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
10115>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
10115>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
10115>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
10115>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
10115>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
10115>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
10115>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
10115>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
10115>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
10115>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
10115>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
10115>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
10115>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
10115>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
10115>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
10115>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
10115>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
10115>>>>>
10115>>>>>
10115>>>>>// Error Number constants
10115>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
10115>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
10115>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
10115>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
10115>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
10115>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
10115>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
10115>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
10115>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
10115>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
10115>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
10115>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
10115>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
10115>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
10115>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
10115>>>>>Define CLIERR_SQL_ERROR                           for 12304
10115>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
10115>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
10115>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
10115>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
10115>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
10115>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
10115>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
10115>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
10115>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
10115>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
10115>>>>>Define CLIERR_FIELDREADONLY                       for 12315
10115>>>>>Define CLIERR_DBPROPERROR                         for 12316
10115>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
10115>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
10115>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
10115>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
10115>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
10115>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
10115>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
10115>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
10115>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
10115>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
10115>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
10115>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
10115>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
10115>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
10115>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
10115>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
10115>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
10115>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
10115>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
10115>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
10115>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
10115>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
10115>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
10115>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
10115>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
10115>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
10115>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
10115>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
10115>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
10115>>>>>
10115>>>>>
10115>>>>>// Call driver Function identifiers
10115>>>>>Define CLI_CONSTRAINT             for 10000
10115>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
10115>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
10115>>>>>Define CLI_BROWSECONNECT          for 10003
10115>>>>>Define CLI_DATASOURCES            for 10004
10115>>>>>Define CLI_CKREVISION             for 10005
10115>>>>>Define CLI_INITDATASOURCES        for 10006
10115>>>>>Define CLI_ENUMERATE_TABLES       for 10007
10115>>>>>Define CLI_TABLENAME              for 10008
10115>>>>>Define CLI_TABLESCHEMA            for 10009
10115>>>>>Define CLI_TABLETYPE              for 10010
10115>>>>>Define CLI_TABLECOMMENT           for 10011
10115>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
10115>>>>>Define CLI_COLUMNNAME             for 10013
10115>>>>>Define CLI_DUMPSTATUS             for 10014
10115>>>>>Define CLI_READCONFIGURATION      for 10015
10115>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
10115>>>>>Define CLI_GETDBATTRIBUTE         for 10017
10115>>>>>Define CLI_GETREGNAME             for 10018
10115>>>>>Define CLI_GETSERIALNUM           for 10019
10115>>>>>Define CLI_GETMAXUSERS            for 10020
10115>>>>>Define CLI_BCP                    for 10021
10115>>>>>Define CLI_DROPINDICES            for 10022
10115>>>>>Define CLI_CREATEINDICES          for 10023
10115>>>>>Define CLI_REDIRECTCONNECTION     for 10024
10115>>>>>Define CLI_CREATECONNECTIONID     for 10025
10115>>>>>Define CLI_DELETECONNECTIONID     for 10026
10115>>>>>
10115>>>>>
10115>>>>>// Init data source types
10115>>>>>Define SQL_FETCH_ALL     for  2
10115>>>>>Define SQL_FETCH_USER    for 31
10115>>>>>Define SQL_FETCH_SYSTEM  for 32
10115>>>>>
10115>>>>>
10115>>>>>// Dummy strings used in the commands
10115>>>>>String  CLI$StrDummy 255
10115>>>>>Integer CLI$IntDummy
10115>>>>>
10115>>>>>
10115>>>>>//   Setup a constraint for a file.                                    
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>// Set or get an attribute at driver level. These attributes, when set,
10115>>>>>// will be set for the remainder of the session or until set again. To 
10115>>>>>// permanently set driver level attributes change the driver           
10115>>>>>// configuration file.                                                 
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>
10115>>>>>// An instance of this class can be used as a broker object to
10115>>>>>// call several CLI releated methods.                         
10115>>>>>
10115>>>>>//Class cCLIHandler is a cObject
10115>>>>>Class cCLIHandler is an Array
10116>>>>>    
10116>>>>>    Procedure Construct_Object 
10118>>>>>        Forward Send Construct_object 
10120>>>>>        
10120>>>>>        Property String  psDriverID        ""
10121>>>>>    End_Procedure
10122>>>>>    
10122>>>>>    
10122>>>>>    
10122>>>>>    // The revsion of a CLI Connectivity Kit
10122>>>>>    Function CKRevision Returns String
10124>>>>>        String  sDriverID
10124>>>>>        String  sRevision
10124>>>>>        String  sVoid
10124>>>>>        Integer iRetval
10124>>>>>        
10124>>>>>        Get psDriverID to sDriverID
10125>>>>>        If (sDRiverID <> "") Begin
10127>>>>>            Move (Repeat(" ", 255)) to sRevision
10128>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
10133>>>>>        End
10133>>>>>>
10133>>>>>        
10133>>>>>        Function_Return sRevision
10134>>>>>    End_Function
10135>>>>>    
10135>>>>>    
10135>>>>>    
10135>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
10135>>>>>    // Returns : The part version number or -1 if there is no such part number.
10135>>>>>    //
10135>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
10137>>>>>        Integer iPartRev
10137>>>>>        Integer iCurrentPart
10137>>>>>        Integer iSeparatorPos
10137>>>>>        
10137>>>>>        If (iPartNum > 4) ;            Function_Return -1
10140>>>>>        
10140>>>>>        Move 0 to iCurrentPart
10141>>>>>        Repeat
10141>>>>>>
10141>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
10142>>>>>            If (iSeparatorPos > 0) Begin
10144>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
10145>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
10146>>>>>                Increment iCurrentPart
10147>>>>>            End
10147>>>>>>
10147>>>>>            Else If (sRevision <> "") Begin
10150>>>>>                Move sRevision to iPartRev
10151>>>>>                Move "" to sRevision
10152>>>>>                Increment iCurrentPart
10153>>>>>            End
10153>>>>>>
10153>>>>>            Else ;                Move -1 to iPartRev
10155>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
10157>>>>>        
10157>>>>>        Function_Return iPartRev
10158>>>>>    End_Function
10159>>>>>    
10159>>>>>    
10159>>>>>    
10159>>>>>    // Returns the major revision of the CK
10159>>>>>    //
10159>>>>>    Function CKMajorRevision Returns Integer
10161>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
10162>>>>>    End_Function
10163>>>>>    
10163>>>>>    
10163>>>>>    
10163>>>>>    // Returns the minor revision of the CK
10163>>>>>    //
10163>>>>>    Function CKMinorRevision Returns Integer
10165>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
10166>>>>>    End_Function
10167>>>>>    
10167>>>>>    
10167>>>>>    
10167>>>>>    // Returns the release revision of the CK
10167>>>>>    //
10167>>>>>    Function CKReleaseRevision Returns Integer
10169>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
10170>>>>>    End_Function
10171>>>>>    
10171>>>>>    
10171>>>>>    
10171>>>>>    // Returns the major revision of the CK
10171>>>>>    //
10171>>>>>    Function CKBuildRevision Returns Integer
10173>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
10174>>>>>    End_Function
10175>>>>>    
10175>>>>>    
10175>>>>>    
10175>>>>>    // Determines if the CK conforms to a passed minimal revsion.
10175>>>>>    //
10175>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
10177>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
10180>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
10183>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
10186>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
10189>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
10192>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
10196>>>>>            End
10196>>>>>>
10196>>>>>        End
10196>>>>>>
10196>>>>>        
10196>>>>>        Function_Return (False)
10197>>>>>    End_Function
10198>>>>>    
10198>>>>>    
10198>>>>>    
10198>>>>>    // Returns the Connectiivty Kit registration name.
10198>>>>>    //
10198>>>>>    Function RegistrationName Returns String
10200>>>>>        String  sRegistration
10200>>>>>        String  sDRiverId
10200>>>>>        String  sVoid
10200>>>>>        Integer iRetval
10200>>>>>        
10200>>>>>        Get psDriverID to sDriverID
10201>>>>>        If (sDRiverID <> "") Begin
10203>>>>>            Move (Repeat(" ", 255)) to sRegistration
10204>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
10209>>>>>        End
10209>>>>>>
10209>>>>>        
10209>>>>>        Function_Return sRegistration
10210>>>>>    End_Function
10211>>>>>    
10211>>>>>    // Returns the Connectiivty Kit serial number.
10211>>>>>    //
10211>>>>>    Function SerialNumber Returns Integer
10213>>>>>        String  sDRiverId
10213>>>>>        String  sVoid
10213>>>>>        Integer iRetval
10213>>>>>        
10213>>>>>        Get psDriverID to sDriverID
10214>>>>>        If (sDRiverID <> "") Begin
10216>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
10221>>>>>        End
10221>>>>>>
10221>>>>>        
10221>>>>>        Function_Return iRetval
10222>>>>>    End_Function
10223>>>>>    
10223>>>>>    
10223>>>>>    // Returns the Connectiivty Kit maximum number of users.
10223>>>>>    //
10223>>>>>    Function MaxUsers Returns Integer
10225>>>>>        String  sDRiverId
10225>>>>>        String  sVoid
10225>>>>>        Integer iRetval
10225>>>>>        
10225>>>>>        Get psDriverID to sDriverID
10226>>>>>        If (sDRiverID <> "") Begin
10228>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
10233>>>>>        End
10233>>>>>>
10233>>>>>        
10233>>>>>        Function_Return iRetval
10234>>>>>    End_Function
10235>>>>>    
10235>>>>>    
10235>>>>>    
10235>>>>>    // Dump the current status of the drver in the passed disk file.
10235>>>>>    //
10235>>>>>    Procedure DumpStatus String sFileName
10237>>>>>        String  sVoid
10237>>>>>        String  sDriverID
10237>>>>>        Integer iVoid
10237>>>>>        
10237>>>>>        Get psDriverID to sDriverID
10238>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
10245>>>>>    End_Procedure
10246>>>>>    
10246>>>>>    
10246>>>>>    
10246>>>>>    // Reset all driver level configurable attributes to the
10246>>>>>    // default value and then reread the configuration.
10246>>>>>    //
10246>>>>>    Procedure ReadConfiguration
10248>>>>>        String  sVoid
10248>>>>>        String  sDriverID
10248>>>>>        Integer iVoid
10248>>>>>        
10248>>>>>        Get psDriverID to sDriverID
10249>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
10256>>>>>    End_Procedure
10257>>>>>    
10257>>>>>    
10257>>>>>    
10257>>>>>    // Convert a text to the corresponding
10257>>>>>    // Generate_Record_ID_Method attribute value
10257>>>>>    //
10257>>>>>    Function TextToRIMValue String sText Returns Integer
10259>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
10262>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
10266>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
10270>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
10274>>>>>    End_Function
10275>>>>>    
10275>>>>>    
10275>>>>>    
10275>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10275>>>>>    // corresponding text.
10275>>>>>    //
10275>>>>>    Function RIMValueToText Integer iAttrValue Returns String
10277>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
10280>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
10284>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
10288>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
10292>>>>>    End_Function
10293>>>>>    
10293>>>>>    
10293>>>>>    
10293>>>>>    // Convert a text to the corresponding
10293>>>>>    // Generate_Record_ID_Method attribute value
10293>>>>>    //
10293>>>>>    Function TextToROValue String sText Returns Integer
10295>>>>>        If (sText = "No") ;            Function_Return RO_NO
10298>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
10302>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
10306>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
10310>>>>>    End_Function
10311>>>>>    
10311>>>>>    
10311>>>>>    
10311>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10311>>>>>    // corresponding text.
10311>>>>>    //
10311>>>>>    Function ROValueToText Integer iAttrValue Returns String
10313>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
10316>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
10320>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
10324>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
10328>>>>>    End_Function
10329>>>>>    
10329>>>>>    
10329>>>>>    
10329>>>>>    // Return the text f the last error geneated by the driver.
10329>>>>>    //
10329>>>>>    Function LastDriverError Returns String
10331>>>>>        String  sDriverID
10331>>>>>        String  sLastError
10331>>>>>        String  sLastErrorLength
10331>>>>>        Integer iLastErrorLength
10331>>>>>        Integer iVoid
10331>>>>>        
10331>>>>>        // Initialize
10331>>>>>        Move "" to sLastError
10332>>>>>        
10332>>>>>        Get psDriverID to sDriverID
10333>>>>>        If (sDriverID <> "") Begin
10335>>>>>            // Get the text of the last error
10335>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
10336>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
10341>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
10342>>>>>            
10342>>>>>            If (iLastErrorLength > 0) Begin
10344>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
10345>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
10350>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
10351>>>>>            End
10351>>>>>>
10351>>>>>        End
10351>>>>>>
10351>>>>>        
10351>>>>>        Function_Return sLastError
10352>>>>>    End_Function
10353>>>>>    
10353>>>>>    
10353>>>>>    
10353>>>>>    // Enumerate the tables in a database
10353>>>>>    //
10353>>>>>    Function EnumerateTables String sLogin Returns Integer
10355>>>>>        String  sDriver
10355>>>>>        String  sVoid
10355>>>>>        Integer iNumTables
10355>>>>>        Integer iVoid
10355>>>>>        
10355>>>>>        Get psDriverID to sDriver
10356>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
10363>>>>>        
10363>>>>>        Function_Return iNumTables
10364>>>>>    End_Function
10365>>>>>    
10365>>>>>    
10365>>>>>    
10365>>>>>    // Returns the name of the table enumerated at the given position
10365>>>>>    //
10365>>>>>    Function TableName Integer iIndex Returns String
10367>>>>>        String  sDriver
10367>>>>>        String  sTableName
10367>>>>>        String  sVoid
10367>>>>>        Integer iVoid
10367>>>>>        
10367>>>>>        Get psDriverID to sDriver
10368>>>>>        If (sDriver <> "") Begin
10370>>>>>            Move (Repeat(" ", 255)) to sTableName
10371>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
10376>>>>>        End
10376>>>>>>
10376>>>>>        
10376>>>>>        Function_Return sTableName
10377>>>>>    End_Function
10378>>>>>    
10378>>>>>    
10378>>>>>    
10378>>>>>    // Returns the name of the schema of the table enumerated at the given position
10378>>>>>    //
10378>>>>>    Function SchemaName Integer iIndex Returns String
10380>>>>>        String  sDriver
10380>>>>>        String  sSchemaName
10380>>>>>        String  sVoid
10380>>>>>        Integer iVoid
10380>>>>>        
10380>>>>>        Get psDriverID to sDriver
10381>>>>>        If (sDriver <> "") Begin
10383>>>>>            Move (Repeat(" ", 255)) to sSchemaName
10384>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
10389>>>>>        End
10389>>>>>>
10389>>>>>        
10389>>>>>        Function_Return sSchemaName
10390>>>>>    End_Function
10391>>>>>    
10391>>>>>    // Returns the type of the table enumerated at the given position.
10391>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
10391>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
10391>>>>>    Function TableType Integer iIndex Returns String
10393>>>>>        String  sDriver
10393>>>>>        String  sTableType
10393>>>>>        String  sVoid
10393>>>>>        Integer iVoid
10393>>>>>        
10393>>>>>        Get psDriverID to sDriver
10394>>>>>        If (sDriver <> "") Begin
10396>>>>>            Move (Repeat(" ", 25)) to sTableType
10397>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
10402>>>>>        End
10402>>>>>>
10402>>>>>        
10402>>>>>        Function_Return sTableType
10403>>>>>    End_Function
10404>>>>>    
10404>>>>>    
10404>>>>>    // Returns the comment of the table enumerated at the given position
10404>>>>>    //
10404>>>>>    Function TableComment Integer iIndex Returns String
10406>>>>>        String  sDriver
10406>>>>>        String  sTableComment
10406>>>>>        String  sVoid
10406>>>>>        Integer iVoid
10406>>>>>        
10406>>>>>        Get psDriverID to sDriver
10407>>>>>        If (sDriver <> "") Begin
10409>>>>>            Move (Repeat(" ", 1024)) to sTableComment
10410>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
10415>>>>>        End
10415>>>>>>
10415>>>>>        
10415>>>>>        Function_Return sTableComment
10416>>>>>    End_Function
10417>>>>>    
10417>>>>>    // Enumerate the columns in a table
10417>>>>>    //
10417>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
10419>>>>>        String  sDriver
10419>>>>>        Integer iNumColumns
10419>>>>>        Integer iVoid
10419>>>>>        
10419>>>>>        Get psDriverID to sDriver
10420>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
10427>>>>>        
10427>>>>>        Function_Return iNumColumns
10428>>>>>    End_Function
10429>>>>>    
10429>>>>>    
10429>>>>>    
10429>>>>>    // Returns the name of the column enumerated at the given position
10429>>>>>    //
10429>>>>>    Function ColumnName Integer iIndex Returns String
10431>>>>>        String  sDriver
10431>>>>>        String  sColumnName
10431>>>>>        String  sVoid
10431>>>>>        Integer iVoid
10431>>>>>        
10431>>>>>        Get psDriverID to sDriver
10432>>>>>        If (sDriver <> "") Begin
10434>>>>>            Move (Repeat(" ", 255)) to sColumnName
10435>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
10440>>>>>        End
10440>>>>>>
10440>>>>>        
10440>>>>>        Function_Return sColumnName
10441>>>>>    End_Function
10442>>>>>    
10442>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
10442>>>>>    //
10442>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
10444>>>>>        
10444>>>>>        Integer iDriverIndex
10444>>>>>        
10444>>>>>        String sSQLDate
10444>>>>>        Integer iOrgDateFmt
10444>>>>>        Integer iOrgDateSep
10444>>>>>        
10444>>>>>        // Change date format to military, SQL dates are military dates
10444>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10447>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10450>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10453>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10456>>>>>        
10456>>>>>        If (Integer(dDFDate = 0)) Begin
10458>>>>>            // Return the dummy zero date
10458>>>>>            Get DriverIndex sDriver to iDriverIndex
10459>>>>>            If (iDriverIndex <> 0) Begin
10461>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
10464>>>>>            End
10464>>>>>>
10464>>>>>            Else Begin
10465>>>>>                Move '0001-01-01' to sSQLDate
10466>>>>>            End
10466>>>>>>
10466>>>>>        End
10466>>>>>>
10466>>>>>        Else Begin
10467>>>>>            Move dDFDate to sSQLDate
10468>>>>>        End
10468>>>>>>
10468>>>>>        
10468>>>>>        // Change date format back to original
10468>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10471>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10474>>>>>        
10474>>>>>        Function_Return sSQLDate
10475>>>>>    End_Function
10476>>>>>    
10476>>>>>    
10476>>>>>    
10476>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
10476>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
10478>>>>>        
10478>>>>>        Integer iDriverIndex
10478>>>>>        
10478>>>>>        Date dDFDate
10478>>>>>        String sDummyDateValue
10478>>>>>        Integer iOrgDateFmt
10478>>>>>        Integer iOrgDateSep
10478>>>>>        
10478>>>>>        // Change date format to military, SQL dates are military dates
10478>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10481>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10484>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10487>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10490>>>>>        
10490>>>>>        // We only need to convert if the date is the dummy zero date value
10490>>>>>        Get DriverIndex sDriver to iDriverIndex
10491>>>>>        If (iDriverIndex <> 0) Begin
10493>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
10496>>>>>        End
10496>>>>>>
10496>>>>>        Else Begin
10497>>>>>            Move '0001-01-01' to sDummyDateValue
10498>>>>>        End
10498>>>>>>
10498>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
10501>>>>>        Else ;            Move sSQLDate to dDFDate
10503>>>>>        
10503>>>>>        // Change date format back to original
10503>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10506>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10509>>>>>        
10509>>>>>        Function_Return dDFDate
10510>>>>>    End_Function
10511>>>>>    
10511>>>>>    Function DriverIndex String sDriver Returns Integer
10513>>>>>        
10513>>>>>        String  sCurrentDriver
10513>>>>>        Integer iNumberOfDrivers iDriver iCount
10513>>>>>        
10513>>>>>        Move 0 to iDriver
10514>>>>>        
10514>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
10517>>>>>        For iCount from 1 to iNumberOfDrivers
10523>>>>>>
10523>>>>>            
10523>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
10526>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
10528>>>>>                Move iCount to iDriver
10529>>>>>            End
10529>>>>>>
10529>>>>>        Loop
10530>>>>>>
10530>>>>>        
10530>>>>>        Function_Return iDriver
10531>>>>>        
10531>>>>>    End_Function
10532>>>>>    
10532>>>>>    
10532>>>>>    // Redirect an exisitng connection. The existing connection
10532>>>>>    // will point to another database but all tables will stay
10532>>>>>    // open!
10532>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
10534>>>>>        String  sDriver
10534>>>>>        String  sVoid
10534>>>>>        Integer iResult
10534>>>>>        Integer iVoid
10534>>>>>        
10534>>>>>        Get psDriverID to sDriver
10535>>>>>        If (sDriver <> "") Begin
10537>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
10542>>>>>        End
10542>>>>>>
10542>>>>>        Function_Return iResult
10543>>>>>    End_Function
10544>>>>>    
10544>>>>>    // Redirect a connection of a connection ID
10544>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
10544>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
10544>>>>>    //
10544>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
10544>>>>>    // to the new connection (Server/Database specified in sConnectString)
10544>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
10544>>>>>    //
10544>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
10544>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
10544>>>>>    //
10544>>>>>    // Returns:
10544>>>>>    //     0 when the redirection was successful.
10544>>>>>    //     1 if the connection ID does not exist or can not be found.
10544>>>>>    //     2 login into the new connection failed.
10544>>>>>    //
10544>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
10546>>>>>        String  sDriver
10546>>>>>        String  sVoid
10546>>>>>        Integer iResult
10546>>>>>        
10546>>>>>        Integer iOption
10546>>>>>        
10546>>>>>        // iOption
10546>>>>>        // 0 = RedirectConnection
10546>>>>>        // 1 = RedirectIdConnectString
10546>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
10546>>>>>        If (bKeepLoggedIn) Begin
10548>>>>>            Move 2 to iOption
10549>>>>>        End
10549>>>>>>
10549>>>>>        Else Begin
10550>>>>>            Move 1 to iOption
10551>>>>>        End
10551>>>>>>
10551>>>>>        
10551>>>>>        Get psDriverID to sDriver
10552>>>>>        If (sDriver <> "") Begin
10554>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
10559>>>>>        End
10559>>>>>>
10559>>>>>        Function_Return iResult
10560>>>>>    End_Function
10561>>>>>    
10561>>>>>    
10561>>>>>    // Create a DataFlex side connection id that can be used later on.
10561>>>>>    //
10561>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
10563>>>>>        String  sDriver
10563>>>>>        Integer iResult
10563>>>>>        Integer iOptions
10563>>>>>        
10563>>>>>        Get psDriverID to sDriver
10564>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
10567>>>>>        Else ;            Move iOpt to iOptions
10569>>>>>        If (sDriver <> "") Begin
10571>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
10576>>>>>        End
10576>>>>>>
10576>>>>>        Function_Return iResult
10577>>>>>    End_Function
10578>>>>>    
10578>>>>>    
10578>>>>>    
10578>>>>>    // Delete a DataFlex side connection id.
10578>>>>>    //
10578>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
10580>>>>>        String  sDriver
10580>>>>>        Integer iResult
10580>>>>>        String sVoid
10580>>>>>        
10580>>>>>        Get psDriverID to sDriver
10581>>>>>        If (sDriver <> "") Begin
10583>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
10588>>>>>        End
10588>>>>>>
10588>>>>>        Function_Return iResult
10589>>>>>    End_Function
10590>>>>>    
10590>>>>>End_Class
10591>>>
10591>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dferror.pkg)
10591>>>>>Use LanguageText.pkg
10591>>>>>Use Windows.pkg
10591>>>>>Use msgbox.pkg
10591>>>>>Use GlobalFunctionsProcedures.pkg
10591>>>>>
10591>>>>>// Include or define all useful symbols.
10591>>>>>Use errornum.inc
10591>>>>>// these are kept for compatibility. Don't use them
10591>>>>>
10591>>>>>// used by error handler and UserError to pull a caption out of the error string
10591>>>>>Define C_ErrorCaption for "*CAPTION*="
10591>>>>>
10591>>>>>// This array stores the set of trapped errors as toggled ranges starting
10591>>>>>// with the errors that are trapped. The array should always contain 0 and
10591>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10591>>>>>// following items...
10591>>>>>//
10591>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10591>>>>>//
10591>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10591>>>>>// 10 through the rest are trapped.
10591>>>>>//
10591>>>>>Class Trapped_Errors_Array is an array
10592>>>>>    
10592>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10592>>>>>    Function findErrorLE Integer targetError Returns Integer
10594>>>>>        
10594>>>>>        Integer lowIndex hiIndex midIndex currError
10594>>>>>        
10594>>>>>        // If error is outside of boudary conditions, use
10594>>>>>        // value of closest valid error# instead.
10594>>>>>        If (targetError <= 0);            Move 1 to targetError
10597>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10601>>>>>        
10601>>>>>        Move 0 to lowIndex
10602>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10603>>>>>        
10603>>>>>        // midIndex will contain the closest error LE to target upon exit.
10603>>>>>        Repeat
10603>>>>>>
10603>>>>>            
10603>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10604>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10605>>>>>            
10605>>>>>            // midIndex is targetIndex if a match occurs
10605>>>>>            If (currError = targetError) ;                Function_Return midIndex
10608>>>>>            
10608>>>>>            // We are either on it or just below it.
10608>>>>>            If ( lowIndex = midIndex ) Begin
10610>>>>>                
10610>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10613>>>>>                
10613>>>>>                Function_Return midIndex
10614>>>>>                
10614>>>>>            End
10614>>>>>>
10614>>>>>            
10614>>>>>            // No match, so move the boundaries.
10614>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10617>>>>>            Else ;                Move midIndex to lowIndex
10619>>>>>            
10619>>>>>        Until lowIndex gt hiIndex
10621>>>>>        
10621>>>>>        Function_Return midIndex
10622>>>>>        
10622>>>>>    End_Function
10623>>>>>    
10623>>>>>    // Boundaries of the table are assumed to hold error limits.
10623>>>>>    Procedure initArray
10625>>>>>        Send delete_data
10626>>>>>        Set array_value 0 to 0
10627>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
10628>>>>>    End_Procedure
10629>>>>>    
10629>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10629>>>>>    Function IsTrapped Integer Error# Returns Integer
10631>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10632>>>>>    End_Function
10633>>>>>    
10633>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10633>>>>>    // This routine leaves the array unsorted.
10633>>>>>    Procedure addError Integer Error#
10635>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
10638>>>>>    End_Procedure
10639>>>>>    
10639>>>>>    // Set error to flagged state.
10639>>>>>    Procedure handleError Integer Error# Integer trapFlag
10641>>>>>        
10641>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10641>>>>>        
10641>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10643>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10644>>>>>>
10644>>>>>            Procedure_Return
10645>>>>>        End
10645>>>>>>
10645>>>>>        
10645>>>>>        Get findErrorLE Error# to prevErrIndex
10646>>>>>        Get isTrapped   Error# to prevErrFlag
10647>>>>>        
10647>>>>>        // if eq, Error already handled in some range.
10647>>>>>        If (prevErrFlag <> trapFlag) Begin
10649>>>>>            
10649>>>>>            // This is kind of complicated. If we are adding an error,
10649>>>>>            // we have to account for the error already being in the
10649>>>>>            // array as well as rejoining ranges that have been previously
10649>>>>>            // split and splitting ranges when adding a new flag.
10649>>>>>            
10649>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
10650>>>>>            Get integer_value prevErrIndex         to prevErrValue
10651>>>>>            
10651>>>>>            // Do this first so prevErrIndex stays valid.
10651>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10654>>>>>            Else ;                Send addError ( Error# + 1 )
10656>>>>>            
10656>>>>>            If ( prevErrValue lt Error# ) ;                Send addError Error#
10659>>>>>            Else ;                Send delete_item prevErrIndex
10661>>>>>        End
10661>>>>>>
10661>>>>>        Send sort_items UPWARD_DIRECTION
10662>>>>>        
10662>>>>>    End_Procedure
10663>>>>>    
10663>>>>>    // Flag error as trappable
10663>>>>>    Procedure Trap_Error Integer Error#
10665>>>>>        Send handleError Error# 1
10666>>>>>    End_Procedure
10667>>>>>    
10667>>>>>    // Flag error as non-trappable
10667>>>>>    Procedure Ignore_Error Integer Error#
10669>>>>>        Send handleError Error# 0
10670>>>>>    End_Procedure
10671>>>>>    
10671>>>>>    // Flag all errors as trappable
10671>>>>>    Procedure Trap_All
10673>>>>>        Send initArray
10674>>>>>    End_Procedure
10675>>>>>    
10675>>>>>    // Flag all errors as non-trappable
10675>>>>>    Procedure Ignore_All
10677>>>>>        Send delete_data
10678>>>>>        Set array_value 0 to 0
10679>>>>>        Set array_value 1 to 1
10680>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10681>>>>>    End_Procedure
10682>>>>>    
10682>>>>>End_Class
10683>>>>>
10683>>>>>
10683>>>>>Class ErrorSystem is a cObject
10684>>>>>    
10684>>>>>    Procedure construct_object
10686>>>>>        Forward Send construct_object
10688>>>>>        
10688>>>>>        Set delegation_mode to no_delegate_or_error
10689>>>>>        
10689>>>>>        Property Integer Verbose_State            True
10690>>>>>        Property Integer Current_Error_Number     0
10691>>>>>        Property Integer Error_Line_Number        0
10692>>>>>        
10692>>>>>        // If set false, this makes the error handler work the old way which
10692>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10692>>>>>        Property Boolean pbUnhandledErrorSupport       True
10693>>>>>        
10693>>>>>        // shows error numbers with user errors. Only set this true if your
10693>>>>>        // application has meaningful numbers that helps the end user. Note that
10693>>>>>        // unhandled errors always show numbers.
10693>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10693>>>>>        Property Boolean pbShowErrorNumber        False
10694>>>>>        
10694>>>>>        
10694>>>>>        // This is the caption that appears for unhandled errors dialog box
10694>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10695>>>>>        
10695>>>>>        // This is the caption that appears for standard user errors
10695>>>>>        Property String psUserErrorCaption C_$Error
10696>>>>>        
10696>>>>>        // Flag which is sent when error is being processed. This
10696>>>>>        // stops error recursion.
10696>>>>>        Property Integer Error_Processing_State  False
10697>>>>>        
10697>>>>>        // array of errors that we consider User Errors
10697>>>>>        Property Integer[] pUserErrorsArray
10698>>>>>        
10698>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10698>>>>>        //  ring a bell when these occur.
10698>>>>>        //
10698>>>>>        Property Integer Bell_on_Find_Error_State True
10699>>>>>        
10699>>>>>        Object TrappedErrors is a Trapped_Errors_Array
10701>>>>>            Send initArray
10702>>>>>        End_Object
10703>>>>>        
10703>>>>>        Send Trap_All
10704>>>>>        
10704>>>>>        // define the standard user error numbers
10704>>>>>        Send AddUserError 0
10705>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
10706>>>>>        Send AddUserError DFERR_WINDOW_RANGE
10707>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
10708>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
10709>>>>>        Send AddUserError DFERR_BAD_ENTRY
10710>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
10711>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
10712>>>>>        Send AddUserError DFERR_DUPLICATE_REC
10713>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
10714>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
10715>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
10716>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
10717>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
10718>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
10719>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
10720>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
10721>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
10722>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
10723>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
10724>>>>>        Send AddUserError DFERR_OPERATOR
10725>>>>>        Send AddUserError DFERR_XML_HTTP
10726>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
10727>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
10728>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
10729>>>>>        Send AddUserError DFERR_WINPRINT
10730>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
10731>>>>>        Send AddUserError DFERR_MAPI
10732>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
10733>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
10734>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
10735>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
10736>>>>>        // number of DDs.
10736>>>>>        Move Self to Error_Object_Id
10737>>>>>    End_Procedure
10738>>>>>    
10738>>>>>    Function Help_Context Integer Context_Type Returns String
10740>>>>>        Function_Return (Current_Error_Number(Self))
10741>>>>>    End_Function
10742>>>>>    
10742>>>>>    // Catch and display error Error#.
10742>>>>>    Procedure Trap_Error Integer Error#
10744>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
10745>>>>>    End_Procedure
10746>>>>>    
10746>>>>>    // Pass error Error# on to the regular DataFlex error handler.
10746>>>>>    Procedure Ignore_Error Integer Error#
10748>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
10749>>>>>    End_Procedure
10750>>>>>    
10750>>>>>    // Catch and display all errors.
10750>>>>>    Procedure Trap_All
10752>>>>>        Send Trap_All to ( trappedErrors( Self ) )
10753>>>>>    End_Procedure
10754>>>>>    
10754>>>>>    // Forward all error to regular DataFlex error handler.
10754>>>>>    Procedure Ignore_All
10756>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
10757>>>>>    End_Procedure
10758>>>>>    
10758>>>>>    // Build complete error description from Flexerrs and user error message.
10758>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
10760>>>>>        String Full_Error_Text
10760>>>>>        
10760>>>>>        Move (Trim(ErrMsg)) to ErrMsg
10761>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
10762>>>>>        
10762>>>>>        If (ErrMsg<>"") Begin
10764>>>>>            
10764>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
10766>>>>>                // Make sure last character of error text is a separating symbol.
10766>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
10766>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
10769>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
10770>>>>>            End
10770>>>>>>
10770>>>>>            Else ;                Move ErrMsg to Full_Error_Text
10772>>>>>            
10772>>>>>        End
10772>>>>>>
10772>>>>>        
10772>>>>>        Function_Return Full_Error_Text
10773>>>>>    End_Function
10774>>>>>    
10774>>>>>    // return true if an error number is critical
10774>>>>>    Function Is_Critical Integer Error# Returns Integer
10776>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
10777>>>>>    End_Function
10778>>>>>    
10778>>>>>    // adds a user error to the array
10778>>>>>    Procedure AddUserError Integer iError
10780>>>>>        Integer[] UserErrors
10781>>>>>        Get pUserErrorsArray to UserErrors
10782>>>>>        // We assume that there are few enough user errors to worry about speed of finding
10782>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
10782>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
10784>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
10785>>>>>            Set pUserErrorsArray to UserErrors
10786>>>>>        End
10786>>>>>>
10786>>>>>    End_Procedure
10787>>>>>    
10787>>>>>    // removes an error from the user array
10787>>>>>    Procedure RemoveUserError Integer iError
10789>>>>>        Integer[] UserErrors
10790>>>>>        Integer iIndex iSize
10790>>>>>        Get pUserErrorsArray to UserErrors
10791>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
10792>>>>>        If (iIndex<>-1) Begin
10794>>>>>            // replace the removed error with the last error and resize the array
10794>>>>>            Move (SizeOfArray(UserErrors)) to iSize
10795>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
10796>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
10797>>>>>        End
10797>>>>>>
10797>>>>>    End_Procedure
10798>>>>>    
10798>>>>>    // removes all user errors
10798>>>>>    Procedure RemoveAllUserErrors
10800>>>>>        Integer[] UserErrors
10801>>>>>        Set pUserErrorsArray to UserErrors
10802>>>>>    End_Procedure
10803>>>>>    
10803>>>>>    // returns true if this is an unhandled error (i.e., not a user error
10803>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10805>>>>>        Integer[] UserErrors
10806>>>>>        Get pUserErrorsArray to UserErrors
10807>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10808>>>>>    End_Function
10809>>>>>    
10809>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10811>>>>>        String sCaption sCRLF
10811>>>>>        Move (Character(13)+Character(10)) to sCRLF
10812>>>>>        Get psUnhandledErrorCaption to sCaption
10813>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10814>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10815>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10816>>>>>    End_Procedure
10817>>>>>    
10817>>>>>    // Handle error event, displaying error info to user.
10817>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
10819>>>>>        Integer iReply iIcon
10819>>>>>        String  sErrorText sMess
10819>>>>>        String  sSource sCaption
10819>>>>>        Integer iSrcPos iSrc iTxtLen
10819>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10819>>>>>        
10819>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
10821>>>>>            Procedure_Return                     // recursion
10822>>>>>        End
10822>>>>>>
10822>>>>>        
10822>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
10823>>>>>        
10823>>>>>        Set Current_Error_Number to ErrNum
10824>>>>>        Set Error_Line_Number    to Err_Line
10825>>>>>        
10825>>>>>        // if this is false, this will work old-style -- all errors go through message box
10825>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10826>>>>>        
10826>>>>>        Get Is_Critical errnum to bCritical
10827>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
10828>>>>>        
10828>>>>>        
10828>>>>>        //
10828>>>>>        //   Changes made so find errors don't report - just beep
10828>>>>>        //
10828>>>>>        
10828>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
10830>>>>>            Send Bell
10831>>>>>        End
10831>>>>>>
10831>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
10834>>>>>            // if trapped do nothing
10834>>>>>            
10834>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
10834>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
10834>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
10834>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
10834>>>>>        End
10834>>>>>>
10834>>>>>        Else Begin
10835>>>>>            
10835>>>>>            // See if source information is provided (Source = module.function). If so remove
10835>>>>>            // as detail. Must find last instance of this in string
10835>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
10836>>>>>            If iSrc Begin
10838>>>>>                Move (iSrc-1) to iSrcPos
10839>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10840>>>>>                Move ErrMsg to sSource
10841>>>>>                Repeat // this makes sure we find last instance of this
10841>>>>>>
10841>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10842>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10843>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10846>>>>>                Until (iSrc=0)
10848>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
10849>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
10852>>>>>            End
10852>>>>>>
10852>>>>>            
10852>>>>>            // the caption normally used for handled user errors
10852>>>>>            Get psUserErrorCaption to sCaption
10853>>>>>            // if an operator error this may be a Procedure UserError situation where the
10853>>>>>            // caption is passed in the error text. If so, get the caption
10853>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
10855>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
10856>>>>>                If iSrc Begin
10858>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
10859>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
10860>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
10861>>>>>                End
10861>>>>>>
10861>>>>>            End
10861>>>>>>
10861>>>>>            
10861>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
10862>>>>>            
10862>>>>>            // if the error source is identified we can get extended error
10862>>>>>            // text for our error message
10862>>>>>            If ghoErrorSource Begin
10864>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10865>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
10868>>>>>            End
10868>>>>>>
10868>>>>>            
10868>>>>>            If (bUnhandledSupport) Begin
10870>>>>>                // as of 14.1, this is the preferred way to do errors
10870>>>>>                If ( bCritical or bIsUnhandled) Begin
10872>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10873>>>>>                    If (sSource<>"") Begin
10875>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10876>>>>>                    End
10876>>>>>>
10876>>>>>                End
10876>>>>>>
10876>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10879>>>>>                    // if a user error, we provide a way to see error numbers.
10879>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10880>>>>>                End
10880>>>>>>
10880>>>>>            End
10880>>>>>>
10880>>>>>            Else Begin
10881>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10881>>>>>                // only for backwards compatibility. All errors go through the message box
10881>>>>>                Get Verbose_State to bVerbose
10882>>>>>                If (bVerbose)  Begin
10884>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
10885>>>>>                    If (sSource<>"") Begin
10887>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10888>>>>>                    End
10888>>>>>>
10888>>>>>                End
10888>>>>>>
10888>>>>>            End
10888>>>>>>
10888>>>>>            
10888>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10890>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
10891>>>>>            End
10891>>>>>>
10891>>>>>            Else Begin
10892>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10893>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
10894>>>>>            End
10894>>>>>>
10894>>>>>            
10894>>>>>            // abort on critical errors
10894>>>>>            If bCritical ;                Abort
10897>>>>>            
10897>>>>>        End
10897>>>>>>
10897>>>>>        Move 0 to ghoErrorSource
10898>>>>>        Set Error_Processing_State to False // no longer reporting an error
10899>>>>>    End_Procedure
10900>>>>>    
10900>>>>>    
10900>>>>>    // The following functions are rarely or never used.
10900>>>>>    
10900>>>>>    // The functions below are used to construct a general help
10900>>>>>    // name for errors that are generated by the system.  If processing
10900>>>>>    // comes here, then there was no module specific help found.  These
10900>>>>>    // functions will provide a more general help name that appears in
10900>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10900>>>>>    // places in the help file under this application and module name.
10900>>>>>    
10900>>>>>    // Returns "ERROR:errornum" to supply error help.
10900>>>>>    Function Help_Name Returns String
10902>>>>>        Function_Return (Append("ERROR:",lastErr))
10903>>>>>    End_Function
10904>>>>>    
10904>>>>>    Function Application_Name Returns String
10906>>>>>        Function_Return 'SYSTEM'
10907>>>>>    End_Function
10908>>>>>    
10908>>>>>    Function Module_Name Returns String
10910>>>>>        Function_Return ''
10911>>>>>    End_Function
10912>>>>>End_Class
10913>>>>>
10913>>>>>Object Error_Info_Object is a ErrorSystem
10915>>>>>End_Object
10916>>>>>
10916>>>>>
10916>>>>>Procedure UserError Global String sMessage String sCaption
10918>>>>>    String sCapt
10918>>>>>    If (Error_Object_Id=0) Begin
10920>>>>>        Error DFERR_PROGRAM "No Error Handler"
10921>>>>>>
10921>>>>>        Procedure_Return
10922>>>>>    End
10922>>>>>>
10922>>>>>    
10922>>>>>    // Accept not passing a caption in which case the error handler's
10922>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10922>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10922>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10922>>>>>    If (num_arguments>1) Begin
10924>>>>>        Move sCaption to sCapt
10925>>>>>    End
10925>>>>>>
10925>>>>>    
10925>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10926>>>>>>
10926>>>>>    
10926>>>>>End_Procedure
10927>>>
10927>>>
10927>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 20.0\Pkg\sql.pkg)
10927>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
10927>>>>>// Connectivty Kits.                                              
10927>>>>>Use CLI.pkg
10927>>>>>
10927>>>>>// Global storage for results
10927>>>>>Integer SQLResult
10927>>>>>
10927>>>>>// Embedded SQL function constants
10927>>>>>Define FUNC_SQLCONNECT             for 1000000
10927>>>>>Define FUNC_SQLFILECONNECT         for 1000001
10927>>>>>Define FUNC_SQLDISCONNECT          for 1000002
10927>>>>>Define FUNC_SQLOPEN                for 1000003
10927>>>>>Define FUNC_SQLCLOSE               for 1000004
10927>>>>>Define FUNC_SQLPREPARE             for 1000005
10927>>>>>Define FUNC_SQLEXECUTE             for 1000006
10927>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
10927>>>>>Define FUNC_SQLFETCH               for 1000008
10927>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
10927>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
10927>>>>>Define FUNC_SQLBINDFILE            for 1000011
10927>>>>>Define FUNC_SQLGETDATA             for 1000012
10927>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
10927>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
10927>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
10927>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
10927>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
10927>>>>>Define FUNC_SQLSETPROCARG          for 1000018
10927>>>>>Define FUNC_SQLCALL                for 1000019
10927>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
10927>>>>>Define FUNC_SQLGETPROCARG          for 1000021
10927>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
10927>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
10927>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
10927>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
10927>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
10927>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
10927>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
10927>>>>>
10927>>>>>// Embedded SQL statement attribute constants
10927>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
10927>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
10927>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
10927>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
10927>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
10927>>>>>
10927>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
10927>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
10927>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
10927>>>>>Define SQL_CURSOR_DYNAMIC           for 2
10927>>>>>Define SQL_CURSOR_STATIC            for 3
10927>>>>>
10927>>>>>
10927>>>>>// Embedded SQL column attribute constants
10927>>>>>Define SQLCOLATTRIB_SIZE           for 1
10927>>>>>Define SQLCOLATTRIB_LENGTH         for 1
10927>>>>>Define SQLCOLATTRIB_PRECISION      for 2
10927>>>>>Define SQLCOLATTRIB_LABEL          for 3
10927>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
10927>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
10927>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
10927>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
10927>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
10927>>>>>
10927>>>>>
10927>>>>>// Types used for conversion with ConvertToXml
10927>>>>>Define esqlTime      for 8
10927>>>>>Define esqlDatetime  for 9
10927>>>>>
10927>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
10927>>>>>Integer giLastSQLhdbc
10927>>>>>Integer giLastSQLhstmt
10927>>>>>
10927>>>>>Move -1 to giLastSQLhdbc
10928>>>>>Move -1 to giLastSQLhstmt
10929>>>>>
10929>>>>>Struct tSQLColumn
10929>>>>>    Integer iSQLType
10929>>>>>    Integer iSQLSize
10929>>>>>    Integer iSQLPrecision
10929>>>>>    Integer iVariableDataType
10929>>>>>End_Struct
10929>>>>>
10929>>>>>// Statement object for embedded sql                           
10929>>>>>//   An object is created for each statement. These will be children    
10929>>>>>//   of cSQLConnection objects which manage the create and destruction  
10929>>>>>//   of these.                                                          
10929>>>>>
10929>>>>>Class cSQLStatement is a cObject
10930>>>>>    
10930>>>>>    Procedure Construct_object
10932>>>>>        Forward Send Construct_object
10934>>>>>        
10934>>>>>        Property Handle  phCLIStatementHandle   0
10935>>>>>        Property Handle  phCLIConnectionHandle  0
10936>>>>>        Property String  psDriverID             ""
10937>>>>>        
10937>>>>>        Property Integer piLastColumn      0
10938>>>>>        Property Integer piLastArgument    0
10939>>>>>        Property Integer piBindFile        0
10940>>>>>        Property Integer piColumnCount     0
10941>>>>>        
10941>>>>>        // True if there is at least 1 column with a variable length data type
10941>>>>>        Property Integer piHasVariableDataType  0
10942>>>>>        
10942>>>>>        // Max size of buffer for variable length data. Default 16000
10942>>>>>        Property Integer piMaxVariableBufferLength 16000
10943>>>>>        
10943>>>>>        // Allocated buffer for SQLGetData.
10943>>>>>        Property WString psVariableBuffer  ""
10944>>>>>        
10944>>>>>        // Allocated size of psVariableBuffer
10944>>>>>        Property Integer piVariableBufferLength 0
10945>>>>>        
10945>>>>>        // Stores column properties of a result set.
10945>>>>>        Property tSQLColumn[] paSQLColumns
10946>>>>>        
10946>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
10946>>>>>        //   0    = Fetch returned no data.
10946>>>>>        //   <> 0 = Row fetched
10946>>>>>        Property Integer piFetchResult     0
10947>>>>>        
10947>>>>>        
10947>>>>>        Property String psDummyZeroDate              '0001-01-01'
10948>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
10949>>>>>        
10949>>>>>    End_Procedure
10950>>>>>    
10950>>>>>    // Store basic information about the statement.
10950>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
10952>>>>>        
10952>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
10953>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
10954>>>>>        Set psDriverID             to sDrvrId
10955>>>>>        
10955>>>>>    End_Procedure
10956>>>>>    
10956>>>>>    
10956>>>>>    // Destroy the cSQLStatement object
10956>>>>>    Procedure DestroySQLStatement
10958>>>>>        Send Destroy
10959>>>>>    End_Procedure
10960>>>>>    
10960>>>>>    // Handle an error that has occurred while checking properties.
10960>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
10962>>>>>        Integer iErrHandle
10962>>>>>        Integer iErrNum
10962>>>>>        String  sLocationInfo
10962>>>>>        
10962>>>>>        // Get the DataFlex statement identifier
10962>>>>>        Move Self to iErrHandle
10963>>>>>        
10963>>>>>        // Determine error number
10963>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
10966>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
10970>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
10974>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
10976>>>>>        
10976>>>>>        // Create location ifnormation
10976>>>>>        Move "[" to sLocationInfo
10977>>>>>        If (sOriginMsg <> "") Begin
10979>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
10980>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
10981>>>>>        End
10981>>>>>>
10981>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
10982>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
10983>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
10984>>>>>        
10984>>>>>        // Generate the error
10984>>>>>        Error iErrNum sLocationInfo
10985>>>>>>
10985>>>>>    End_Procedure
10986>>>>>    
10986>>>>>    // Handle general error not related to the properties
10986>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
10988>>>>>        Integer iErrHandle
10988>>>>>        String  sLocationInfo
10988>>>>>        
10988>>>>>        // Get the DataFlex statement identifier
10988>>>>>        Move Self to iErrHandle
10989>>>>>        
10989>>>>>        // Create location information
10989>>>>>        Move "[" to sLocationInfo
10990>>>>>        If (sOriginMsg <> "") Begin
10992>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
10993>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
10994>>>>>        End
10994>>>>>>
10994>>>>>        If (sErrtext <> "") Begin
10996>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
10997>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
10998>>>>>        End
10998>>>>>>
10998>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
10999>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
11000>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
11001>>>>>        
11001>>>>>        // Generate the error
11001>>>>>        Error iErrNum sLocationInfo
11002>>>>>>
11002>>>>>    End_Procedure
11003>>>>>    
11003>>>>>    // Handle an illegal attribute error
11003>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
11005>>>>>        Integer bReport
11005>>>>>        
11005>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
11008>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
11011>>>>>    End_Procedure
11012>>>>>    
11012>>>>>    // Check if a column number is legal
11012>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
11014>>>>>        Integer bLegal
11014>>>>>        Integer iNumColumns
11014>>>>>        
11014>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11015>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
11018>>>>>        Else ;            Move DFFALSE to bLegal
11020>>>>>        
11020>>>>>        Function_Return bLegal
11021>>>>>    End_Function
11022>>>>>    
11022>>>>>    
11022>>>>>    
11022>>>>>    // Close a statement and free all alllocated resources
11022>>>>>    Procedure SQLClose
11024>>>>>        Integer ihdbc
11024>>>>>        Integer ihstmt
11024>>>>>        Integer iVoid
11024>>>>>        String  sDrvrId
11024>>>>>        String  sEmpty
11024>>>>>        
11024>>>>>        // Initialize
11024>>>>>        Move "" to sEmpty
11025>>>>>        
11025>>>>>        // Get the cli handles
11025>>>>>        Get phCLIStatementHandle  to ihstmt
11026>>>>>        Get phCLIConnectionHandle to ihdbc
11027>>>>>        Get psDriverId            to sDrvrId
11028>>>>>        
11028>>>>>        // Free the CLI handle
11028>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11030>>>>>            // Call the driver function to close
11030>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11035>>>>>            
11035>>>>>            Move -1 to giLastSQLhstmt
11036>>>>>            // Free the DataFlex handle
11036>>>>>            Send DestroySQLStatement
11037>>>>>        End
11037>>>>>>
11037>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
11039>>>>>    End_Procedure
11040>>>>>    
11040>>>>>    // Prepare a statement for execution
11040>>>>>    Procedure SQLPrepare String sStatement
11042>>>>>        Integer ihdbc
11042>>>>>        Integer ihstmt
11042>>>>>        Integer iVoid
11042>>>>>        String  sDrvrId
11042>>>>>        
11042>>>>>        // Get the cli handles
11042>>>>>        Get phCLIStatementHandle  to ihstmt
11043>>>>>        Get phCLIConnectionHandle to ihdbc
11044>>>>>        Get psDriverId            to sDrvrId
11045>>>>>        
11045>>>>>        // Prepare
11045>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11047>>>>>            // Call the driver function to prepare
11047>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11052>>>>>            Set piLastArgument to 0
11053>>>>>
11053>>>>>        End
11053>>>>>>
11053>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
11055>>>>>    End_Procedure
11056>>>>>    
11056>>>>>    Procedure SQLGetStatementAttributes
11058>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
11058>>>>>        String sMaxValue
11058>>>>>        tSQLColumn[] aSQLColumns
11058>>>>>        tSQLColumn[] aSQLColumns
11059>>>>>        
11059>>>>>        Integer iSqlType
11059>>>>>        Integer iSQLSize
11059>>>>>        Integer iSQLprecision
11059>>>>>        Integer iVariableDataType
11059>>>>>        
11059>>>>>        String  sDrvrId
11059>>>>>        
11059>>>>>        Integer iHasVariableDataType
11059>>>>>        
11059>>>>>        Move 0 to iHasVariableDataType
11060>>>>>        
11060>>>>>        
11060>>>>>        // Get the cli handles
11060>>>>>        Get phCLIStatementHandle  to ihstmt
11061>>>>>        Get phCLIConnectionHandle to ihdbc
11062>>>>>        Get psDriverId            to sDrvrId
11063>>>>>        
11063>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11064>>>>>        
11064>>>>>        Set piColumnCount to iNumColumns
11065>>>>>        
11065>>>>>        // Fill columns array
11065>>>>>        For iCol from 1 to iNumColumns
11071>>>>>>
11071>>>>>            Move 0 to iVariableDataType
11072>>>>>            
11072>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
11073>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
11074>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
11075>>>>>            
11075>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
11077>>>>>                // text type
11077>>>>>                Move 1 to iVariableDataType
11078>>>>>            End
11078>>>>>>
11078>>>>>            Else Begin
11079>>>>>                If (sDrvrId = "MSSQLDRV") Begin
11081>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
11081>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
11083>>>>>                        
11083>>>>>                        Move 1 to iVariableDataType
11084>>>>>                    End
11084>>>>>>
11084>>>>>                End
11084>>>>>>
11084>>>>>            End
11084>>>>>>
11084>>>>>            
11084>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
11085>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
11086>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
11087>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
11088>>>>>            
11088>>>>>            If (not(iVariableDataType)) Begin
11090>>>>>                If (iSQLSize > iMaxSize) Begin
11092>>>>>                    Move iSQLSize to iMaxSize
11093>>>>>                End
11093>>>>>>
11093>>>>>            End
11093>>>>>>
11093>>>>>            Else Begin
11094>>>>>                Move 1 to iHasVariableDataType
11095>>>>>            End
11095>>>>>>
11095>>>>>            
11095>>>>>        Loop
11096>>>>>>
11096>>>>>        
11096>>>>>        Set paSQLColumns   to aSQLColumns
11097>>>>>        Set piHasVariableDataType to iHasVariableDataType
11098>>>>>        
11098>>>>>    End_Procedure
11099>>>>>    
11099>>>>>    // Execute a prepared statement
11099>>>>>    Procedure SQLExecute
11101>>>>>        Integer ihdbc
11101>>>>>        Integer ihstmt
11101>>>>>        Integer iVoid
11101>>>>>        String  sDrvrId
11101>>>>>        String  sEmpty
11101>>>>>        
11101>>>>>        // Initialize
11101>>>>>        Move "" to sEmpty
11102>>>>>        
11102>>>>>        // Get the cli handles
11102>>>>>        Get phCLIStatementHandle  to ihstmt
11103>>>>>        Get phCLIConnectionHandle to ihdbc
11104>>>>>        Get psDriverId            to sDrvrId
11105>>>>>        
11105>>>>>        // Execute
11105>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11107>>>>>            // Call the driver function to execute
11107>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11112>>>>>            Send SQLGetStatementAttributes
11113>>>>>            Set piLastArgument to 0
11114>>>>>        End
11114>>>>>>
11114>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
11116>>>>>    End_Procedure
11117>>>>>    
11117>>>>>    
11117>>>>>    
11117>>>>>    // Prepare and execute a statement
11117>>>>>    Procedure SQLExecDirect String sStatement
11119>>>>>        Integer ihdbc
11119>>>>>        Integer ihstmt
11119>>>>>        Integer iVoid
11119>>>>>        String  sDrvrId
11119>>>>>        
11119>>>>>        // Get the cli handles
11119>>>>>        Get phCLIStatementHandle  to ihstmt
11120>>>>>        Get phCLIConnectionHandle to ihdbc
11121>>>>>        Get psDriverId            to sDrvrId
11122>>>>>        
11122>>>>>        // ExecDirect
11122>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11124>>>>>            // Call the driver function to execdirect
11124>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11129>>>>>            Send SQLGetStatementAttributes
11130>>>>>        End
11130>>>>>>
11130>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
11132>>>>>    End_Procedure
11133>>>>>    
11133>>>>>    // Fetch the next row
11133>>>>>    // Returns  : 0   = No more data
11133>>>>>    //<>0 = Success
11133>>>>>    Function SQLFetch Returns Integer
11135>>>>>        Integer ihdbc
11135>>>>>        Integer ihstmt
11135>>>>>        Integer iResult
11135>>>>>        String  sDrvrId
11135>>>>>        String  sEmpty
11135>>>>>        
11135>>>>>        // Initialize
11135>>>>>        Move "" to sEmpty
11136>>>>>        Move 0  to iResult
11137>>>>>        
11137>>>>>        // Get the cli handles
11137>>>>>        Get phCLIStatementHandle  to ihstmt
11138>>>>>        Get phCLIConnectionHandle to ihdbc
11139>>>>>        Get psDriverId            to sDrvrId
11140>>>>>        
11140>>>>>        // Fetch
11140>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11142>>>>>            Move False to Err
11143>>>>>            
11143>>>>>            // Call the driver function to fetch
11143>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11148>>>>>            
11148>>>>>            // If something went wrong, adjust the result
11148>>>>>            If (Err) ;                Move 0 to iResult
11151>>>>>            
11151>>>>>            Set piLastcolumn to 0
11152>>>>>        End
11152>>>>>>
11152>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
11154>>>>>        
11154>>>>>        Function_Return iResult
11155>>>>>    End_Function
11156>>>>>    
11156>>>>>    // Fetch the next row and return an array with all column values
11156>>>>>    // Returns  : Array of strings with all column values
11156>>>>>    // Sets piFetchResult property
11156>>>>>    //   0    = No more data
11156>>>>>    //   <> 0 = Success
11156>>>>>    Function SQLFetchRowValues Returns String[]
11158>>>>>        
11158>>>>>        String[] asValues
11159>>>>>        
11159>>>>>        tSQLColumn[] aSQLColumns
11159>>>>>        tSQLColumn[] aSQLColumns
11160>>>>>        
11160>>>>>        Integer ihdbc
11160>>>>>        Integer ihstmt
11160>>>>>        Integer iResult iVoid
11160>>>>>        Integer iColCount iCol
11160>>>>>        String  sDrvrId
11160>>>>>        String  sEmpty
11160>>>>>        Longptr pResultWStr
11160>>>>>        WString wVariableResult
11160>>>>>        Integer iHasVariableDataType
11160>>>>>        Integer iLen
11160>>>>>        Integer iVariableBufferLength
11160>>>>>        
11160>>>>>        // Initialize
11160>>>>>        Move "" to sEmpty
11161>>>>>        Move 0  to iResult
11162>>>>>        
11162>>>>>        // Get the cli handles
11162>>>>>        Get phCLIStatementHandle  to ihstmt
11163>>>>>        Get phCLIConnectionHandle to ihdbc
11164>>>>>        Get psDriverId            to sDrvrId
11165>>>>>        
11165>>>>>        Get paSQLColumns to aSQLColumns
11166>>>>>        Get piColumnCount to iColCount
11167>>>>>        Get piHasVariableDataType to iHasVariableDataType
11168>>>>>        
11168>>>>>        If (iHasVariableDataType) Begin
11170>>>>>            
11170>>>>>            Get piVariableBufferLength      to iVariableBufferLength
11171>>>>>            Get piMaxVariableBufferLength   to iLen
11172>>>>>            
11172>>>>>            If (iLen > iVariableBufferLength) Begin
11174>>>>>                // Allocate
11174>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
11175>>>>>                
11175>>>>>                Set piVariableBufferLength to iLen
11176>>>>>                Set psVariableBuffer       to wVariableResult
11177>>>>>                
11177>>>>>                Get piVariableBufferLength to iVariableBufferLength
11178>>>>>            End
11178>>>>>>
11178>>>>>        End
11178>>>>>>
11178>>>>>        
11178>>>>>        // Fetch
11178>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11180>>>>>            Move (False) to Err
11181>>>>>            
11181>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11181>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11181>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11181>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11183>>>>>                // Setup function arguments
11183>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11188>>>>>                Move ihstmt to giLastSQLhstmt
11189>>>>>                Move ihdbc to giLastSQLhdbc
11190>>>>>            End
11190>>>>>>
11190>>>>>            
11190>>>>>            // Call the driver function to fetch
11190>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
11195>>>>>            
11195>>>>>            // If something went wrong, adjust the result
11195>>>>>            If (Err) ;                Move 0 to iResult
11198>>>>>            
11198>>>>>            If (iResult) Begin
11200>>>>>                For iCol from 1 to iColCount
11206>>>>>>
11206>>>>>                    
11206>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11208>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
11213>>>>>                            
11213>>>>>                        If (pResultWStr) Begin
11215>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
11216>>>>>                        End
11216>>>>>>
11216>>>>>                        Else Begin
11217>>>>>                            Move "" to asValues[iCol - 1]
11218>>>>>                        End
11218>>>>>>
11218>>>>>                        
11218>>>>>                    End
11218>>>>>>
11218>>>>>                    Else Begin
11219>>>>>                        Get psVariableBuffer       to wVariableResult
11220>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
11225>>>>>                        
11225>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
11226>>>>>                    End
11226>>>>>>
11226>>>>>                    
11226>>>>>                Loop
11227>>>>>>
11227>>>>>            End
11227>>>>>>
11227>>>>>        End
11227>>>>>>
11227>>>>>        Else Begin
11228>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
11229>>>>>        End
11229>>>>>>
11229>>>>>        
11229>>>>>        Set piFetchResult to iResult
11230>>>>>        
11230>>>>>        Function_Return asValues
11231>>>>>        
11231>>>>>    End_Function
11232>>>>>    
11232>>>>>    // Fetch a complete result set.
11232>>>>>    // Returns  : 2-dimensional array of strings with result set
11232>>>>>    // Sets piFetchResult property
11232>>>>>    //   0    = No more data
11232>>>>>    //   <> 0 = Success
11232>>>>>    Function SQLFetchResultsetValues Returns String[][]
11234>>>>>        
11234>>>>>        String[][] asValues
11235>>>>>        
11235>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
11235>>>>>        String sDrvrId sEmpty sMax
11235>>>>>        Longptr pResultWStr
11235>>>>>        WString wResult
11235>>>>>        
11235>>>>>        tSQLColumn[] aSQLColumns
11235>>>>>        tSQLColumn[] aSQLColumns
11236>>>>>        WString  wVariableResult
11236>>>>>        Integer iHasVariableDataType
11236>>>>>        Integer iLen
11236>>>>>        Integer iVariableBufferLength
11236>>>>>        
11236>>>>>        // Initialize
11236>>>>>        Move "" to sEmpty
11237>>>>>        Move 0  to iResult
11238>>>>>        
11238>>>>>        // Get the cli handles
11238>>>>>        Get phCLIStatementHandle  to ihstmt
11239>>>>>        Get phCLIConnectionHandle to ihdbc
11240>>>>>        Get psDriverId            to sDrvrId
11241>>>>>        
11241>>>>>        // Fetch
11241>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11243>>>>>            Move False to Err
11244>>>>>            
11244>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11244>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11244>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11244>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11246>>>>>                // Setup function arguments
11246>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11251>>>>>                Move ihstmt to giLastSQLhstmt
11252>>>>>                Move ihdbc to giLastSQLhdbc
11253>>>>>            End
11253>>>>>>
11253>>>>>            
11253>>>>>            Get piColumnCount to iColCount
11254>>>>>            If (iColCount) Begin
11256>>>>>                Get paSQLColumns to aSQLColumns
11257>>>>>                Get piHasVariableDataType to iHasVariableDataType
11258>>>>>                If (iHasVariableDataType) Begin
11260>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
11261>>>>>                    Get piMaxVariableBufferLength   to iLen
11262>>>>>                    If (iLen > iVariableBufferLength) Begin
11264>>>>>                        // Allocate
11264>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
11265>>>>>                        
11265>>>>>                        Set piVariableBufferLength to iLen
11266>>>>>                        Set psVariableBuffer       to wVariableResult
11267>>>>>                        
11267>>>>>                        Get piVariableBufferLength to iVariableBufferLength
11268>>>>>                    End
11268>>>>>>
11268>>>>>                    Else Begin
11269>>>>>                        Set psVariableBuffer       to wVariableResult
11270>>>>>                    End
11270>>>>>>
11270>>>>>                End
11270>>>>>>
11270>>>>>                
11270>>>>>                // Call the driver function to fetch
11270>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11275>>>>>                If (Err) ;                    Move 0 to iResult
11278>>>>>                
11278>>>>>                While (iResult <> 0)
11282>>>>>                    
11282>>>>>                    For iCol from 1 to (iColCount)
11288>>>>>>
11288>>>>>                        
11288>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11290>>>>>                            
11290>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
11295>>>>>                            
11295>>>>>                            If (pResultWStr) Begin
11297>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
11298>>>>>                            End
11298>>>>>>
11298>>>>>                            Else Begin
11299>>>>>                                Move "" to asValues[iRow][iCol - 1]
11300>>>>>                            End
11300>>>>>>
11300>>>>>                        End
11300>>>>>>
11300>>>>>                        Else Begin
11301>>>>>                            //Variable data
11301>>>>>                            Move wVariableResult to wResult
11302>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
11307>>>>>                            
11307>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
11308>>>>>                        End
11308>>>>>>
11308>>>>>                    Loop
11309>>>>>>
11309>>>>>                    
11309>>>>>                    Increment iRow
11310>>>>>                    
11310>>>>>                    // Call the driver function to fetch
11310>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11315>>>>>                    If (Err) ;                        Move 0 to iResult
11318>>>>>                    
11318>>>>>                Loop
11319>>>>>>
11319>>>>>            End
11319>>>>>>
11319>>>>>        End
11319>>>>>>
11319>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
11321>>>>>        
11321>>>>>        Set piFetchResult to iResult
11322>>>>>        
11322>>>>>        Function_Return asValues
11323>>>>>    End_Function
11324>>>>>    
11324>>>>>    // Get the next column
11324>>>>>    Function SQLNextColumn Returns String
11326>>>>>        Integer iCol
11326>>>>>        String  sResult
11326>>>>>        
11326>>>>>        Get piLastColumn to iCol
11327>>>>>        Increment iCol
11328>>>>>        Get SQLColumnValue iCol to sResult
11329>>>>>        Set piLastColumn to iCol
11330>>>>>        
11330>>>>>        Function_Return sResult
11331>>>>>    End_Function
11332>>>>>    
11332>>>>>    
11332>>>>>    // Returns the native type of a column
11332>>>>>    Function SQLColumnType Integer iCol Returns Integer
11334>>>>>        Integer ihdbc
11334>>>>>        Integer ihstmt
11334>>>>>        String  sDrvrId
11334>>>>>        Integer iSQLType
11334>>>>>        Integer iColumns
11334>>>>>        
11334>>>>>        tSQLColumn[] aSQLColumns
11334>>>>>        tSQLColumn[] aSQLColumns
11335>>>>>        
11335>>>>>        // Get the cli handles
11335>>>>>        Get phCLIStatementHandle  to ihstmt
11336>>>>>        Get phCLIConnectionHandle to ihdbc
11337>>>>>        Get psDriverId            to sDrvrId
11338>>>>>        
11338>>>>>        // Get the value
11338>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11340>>>>>            
11340>>>>>            Get paSQLColumns   to aSQLColumns
11341>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11342>>>>>            
11342>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11344>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
11345>>>>>            End
11345>>>>>>
11345>>>>>            Else Begin
11346>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
11347>>>>>            End
11347>>>>>>
11347>>>>>        End
11347>>>>>>
11347>>>>>        Else Begin
11348>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
11349>>>>>        End
11349>>>>>>
11349>>>>>        
11349>>>>>        Function_Return iSQLType
11350>>>>>    End_Function
11351>>>>>    
11351>>>>>    // Returns the size (max length) of a column
11351>>>>>    Function SQLColumnSize Integer iCol Returns Integer
11353>>>>>        Integer ihdbc
11353>>>>>        Integer ihstmt
11353>>>>>        String  sDrvrId
11353>>>>>        Integer iSQLSize
11353>>>>>        Integer iColumns
11353>>>>>        
11353>>>>>        tSQLColumn[] aSQLColumns
11353>>>>>        tSQLColumn[] aSQLColumns
11354>>>>>        
11354>>>>>        // Get the cli handles
11354>>>>>        Get phCLIStatementHandle  to ihstmt
11355>>>>>        Get phCLIConnectionHandle to ihdbc
11356>>>>>        Get psDriverId            to sDrvrId
11357>>>>>        
11357>>>>>        // Get the value
11357>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11359>>>>>            
11359>>>>>            Get paSQLColumns   to aSQLColumns
11360>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11361>>>>>            
11361>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11363>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
11364>>>>>            End
11364>>>>>>
11364>>>>>            Else Begin
11365>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
11366>>>>>            End
11366>>>>>>
11366>>>>>        End
11366>>>>>>
11366>>>>>        Else Begin
11367>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
11368>>>>>        End
11368>>>>>>
11368>>>>>        
11368>>>>>        Function_Return iSQLSize
11369>>>>>    End_Function
11370>>>>>    
11370>>>>>    //  Returns 1 for variable length datatypes.
11370>>>>>    //  For example SQL Server varchar(max) or text type
11370>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
11370>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
11372>>>>>        Integer ihdbc
11372>>>>>        Integer ihstmt
11372>>>>>        String  sDrvrId
11372>>>>>        Integer iVariableDataType
11372>>>>>        Integer iColumns
11372>>>>>        
11372>>>>>        tSQLColumn[] aSQLColumns
11372>>>>>        tSQLColumn[] aSQLColumns
11373>>>>>        
11373>>>>>        // Get the cli handles
11373>>>>>        Get phCLIStatementHandle  to ihstmt
11374>>>>>        Get phCLIConnectionHandle to ihdbc
11375>>>>>        Get psDriverId            to sDrvrId
11376>>>>>        
11376>>>>>        // Get the value
11376>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11378>>>>>            
11378>>>>>            Get paSQLColumns   to aSQLColumns
11379>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11380>>>>>            
11380>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11382>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
11383>>>>>            End
11383>>>>>>
11383>>>>>            Else Begin
11384>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
11385>>>>>            End
11385>>>>>>
11385>>>>>        End
11385>>>>>>
11385>>>>>        Else Begin
11386>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
11387>>>>>        End
11387>>>>>>
11387>>>>>        
11387>>>>>        Function_Return iVariableDataType
11388>>>>>    End_Function
11389>>>>>    
11389>>>>>    
11389>>>>>    // Return the value of a column in a fetched row of a given
11389>>>>>    // statement.
11389>>>>>    Function SQLColumnValue Integer iCol Returns String
11391>>>>>        Integer ihdbc
11391>>>>>        Integer ihstmt
11391>>>>>        String  sDrvrId sResult
11391>>>>>        Longptr pResultWStr
11391>>>>>        
11391>>>>>        Integer iVoid
11391>>>>>        Integer iColSize
11391>>>>>        Integer iColPrecision
11391>>>>>        String  sEmpty
11391>>>>>        Integer bLegalColumn
11391>>>>>        
11391>>>>>        // Initialize
11391>>>>>        Move "" to sResult
11392>>>>>        
11392>>>>>        // Get the cli handles
11392>>>>>        Get phCLIStatementHandle  to ihstmt
11393>>>>>        Get phCLIConnectionHandle to ihdbc
11394>>>>>        Get psDriverId            to sDrvrId
11395>>>>>        
11395>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11395>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
11395>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
11395>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11397>>>>>            // Setup function arguments
11397>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
11402>>>>>            Move ihstmt to giLastSQLhstmt
11403>>>>>            Move ihdbc to giLastSQLhdbc
11404>>>>>        End
11404>>>>>>
11404>>>>>        
11404>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11406>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
11411>>>>>            
11411>>>>>            If (pResultWStr) Begin
11413>>>>>                Move (PointerToWString(pResultWStr)) to sResult
11414>>>>>            End
11414>>>>>>
11414>>>>>            Else Begin
11415>>>>>                Move "" to sResult
11416>>>>>            End
11416>>>>>>
11416>>>>>        End
11416>>>>>>
11416>>>>>        Else Begin
11417>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
11418>>>>>        End
11418>>>>>>
11418>>>>>        
11418>>>>>        Function_Return sResult
11419>>>>>        
11419>>>>>    End_Function
11420>>>>>    
11420>>>>>    // Add a file to the files used to place the statement result in.
11420>>>>>    Procedure SQLBindFile Integer iFileNum
11422>>>>>        Integer ihdbc
11422>>>>>        Integer ihstmt
11422>>>>>        Integer iVoid
11422>>>>>        String  sDrvrId
11422>>>>>        String  sFileType
11422>>>>>        Integer bIsOpen
11422>>>>>        
11422>>>>>        // Get the cli handles
11422>>>>>        Get phCLIStatementHandle  to ihstmt
11423>>>>>        Get phCLIConnectionHandle to ihdbc
11424>>>>>        Get psDriverId            to sDrvrId
11425>>>>>        
11425>>>>>        // If a file number is not passed see if we can use the statement's
11425>>>>>        // default file number which is usually set with SetFileConnection
11425>>>>>        If (iFileNum = 0) Begin
11427>>>>>            Get piBindFile to iFileNum
11428>>>>>            If (iFileNum = 0) Begin
11430>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
11430>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
11431>>>>>                
11431>>>>>                Move 0 to SQLResult
11432>>>>>                Procedure_Return
11433>>>>>            End
11433>>>>>>
11433>>>>>        End
11433>>>>>>
11433>>>>>        
11433>>>>>        // Bind the file
11433>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11435>>>>>            // Chek if the file is open
11435>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
11438>>>>>            If (bIsOpen) Begin
11440>>>>>                // Check if the file has the correct type
11440>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
11443>>>>>                If (sFileType = sDrvrId) Begin
11445>>>>>                    // Call the driver function to add a file to a statement
11445>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
11450>>>>>                End
11450>>>>>>
11450>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
11452>>>>>            End
11452>>>>>>
11452>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
11454>>>>>        End
11454>>>>>>
11454>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
11456>>>>>    End_Procedure
11457>>>>>    
11457>>>>>    
11457>>>>>    
11457>>>>>    // Get data of a column.                                  
11457>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
11459>>>>>        Integer ihdbc
11459>>>>>        Integer ihstmt
11459>>>>>        Integer iVoid
11459>>>>>        Integer iColSize
11459>>>>>        Integer iResult
11459>>>>>        String  sDrvrId
11459>>>>>        WString wResult
11459>>>>>        String  sEmpty
11459>>>>>        Integer bLegalColumn
11459>>>>>        
11459>>>>>        Integer iVariableBufferLength
11459>>>>>        
11459>>>>>        // Initialize
11459>>>>>        Move "" to sEmpty
11460>>>>>        Move 0 to iResult
11461>>>>>        
11461>>>>>        // Get the cli handles
11461>>>>>        Get phCLIStatementHandle  to ihstmt
11462>>>>>        Get phCLIConnectionHandle to ihdbc
11463>>>>>        Get psDriverId            to sDrvrId
11464>>>>>        
11464>>>>>        // Get the data
11464>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11466>>>>>            // Check if the column exists
11466>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11468>>>>>                If (iLen = 0) Begin
11470>>>>>                    Get SQLColumnValue iCol to wResult
11471>>>>>                End
11471>>>>>>
11471>>>>>                Else Begin
11472>>>>>                    // Add 1 for string terminator
11472>>>>>                    Move (iLen + 1) to iLen
11473>>>>>                    
11473>>>>>                    Get piVariableBufferLength to iVariableBufferLength
11474>>>>>                    If (iLen > iVariableBufferLength) Begin
11476>>>>>                        // Allocate
11476>>>>>                        Move (Repeat(' ', iLen)) to wResult
11477>>>>>                        
11477>>>>>                        Set piVariableBufferLength to iLen
11478>>>>>                        Set psVariableBuffer       to wResult
11479>>>>>                    End
11479>>>>>>
11479>>>>>                    Else Begin
11480>>>>>                        Get psVariableBuffer       to wResult
11481>>>>>                    End
11481>>>>>>
11481>>>>>                    
11481>>>>>                    
11481>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11481>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
11481>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
11481>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11483>>>>>                        // Setup function arguments
11483>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
11488>>>>>                        Move ihstmt to giLastSQLhstmt
11489>>>>>                        Move ihdbc to giLastSQLhdbc
11490>>>>>                    End
11490>>>>>>
11490>>>>>                    
11490>>>>>                    Move False to Err
11491>>>>>                    // Call the driver function to get the data
11491>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
11496>>>>>                    
11496>>>>>                    // If something went wrong, adjust the result
11496>>>>>                    If (Err) Begin
11498>>>>>                        Move 0 to iResult
11499>>>>>                    End
11499>>>>>>
11499>>>>>                    
11499>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11499>>>>>                    If (iResult = -4) Begin
11501>>>>>                        Move (SizeOfWString(wResult)) to iResult
11502>>>>>                    End
11502>>>>>>
11502>>>>>                End
11502>>>>>>
11502>>>>>            End
11502>>>>>>
11502>>>>>            Else Begin
11503>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11504>>>>>            End
11504>>>>>>
11504>>>>>        End
11504>>>>>>
11504>>>>>        Else Begin
11505>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11506>>>>>        End
11506>>>>>>
11506>>>>>        
11506>>>>>        // Fill global result
11506>>>>>        If (iResult > 0) Begin
11508>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11509>>>>>        End
11509>>>>>>
11509>>>>>        Else Begin
11510>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11511>>>>>        End
11511>>>>>>
11511>>>>>        
11511>>>>>        Function_Return (CString(wResult))
11512>>>>>    End_Function
11513>>>>>
11513>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
11513>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
11513>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
11515>>>>>        Integer ihdbc
11515>>>>>        Integer ihstmt
11515>>>>>        Integer iVoid
11515>>>>>        Integer iColSize
11515>>>>>        Integer iResult
11515>>>>>        String  sDrvrId
11515>>>>>        UChar[] uaResult
11516>>>>>        
11516>>>>>        Integer iSQLType
11516>>>>>        Integer iBinaryType
11516>>>>>        Integer iLenArray
11516>>>>>        Integer iResizeSize
11516>>>>>        
11516>>>>>        Move 0 to iResult
11517>>>>>        
11517>>>>>        // Get the cli handles
11517>>>>>        Get phCLIStatementHandle  to ihstmt
11518>>>>>        Get phCLIConnectionHandle to ihdbc
11519>>>>>        Get psDriverId            to sDrvrId
11520>>>>>        
11520>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11522>>>>>            // Check if the column exists
11522>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11524>>>>>                            
11524>>>>>                Get SQLColumnType iCol to iSQLType
11525>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
11527>>>>>                    Move 1 to iBinaryType
11528>>>>>                End
11528>>>>>>
11528>>>>>                Else Begin
11529>>>>>                    Move 0 to iBinaryType 
11530>>>>>                End
11530>>>>>>
11530>>>>>    
11530>>>>>                If (iBinaryType) Begin
11532>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
11533>>>>>                End
11533>>>>>>
11533>>>>>                Else Begin
11534>>>>>                    // Character type
11534>>>>>                    // returned as wstring (2 bytes per character)
11534>>>>>                    // Add 1 for string terminator
11534>>>>>                    Move (iLen + 1) to iLen
11535>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
11536>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
11537>>>>>                End
11537>>>>>>
11537>>>>>
11537>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11537>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
11537>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11539>>>>>                    // Setup function arguments
11539>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11544>>>>>                    Move ihstmt to giLastSQLhstmt
11545>>>>>                    Move ihdbc to giLastSQLhdbc
11546>>>>>                End
11546>>>>>>
11546>>>>>                
11546>>>>>                Move False to Err
11547>>>>>                
11547>>>>>                // Call the driver function to get the data
11547>>>>>                // iResult will be the length of the data in bytes 
11547>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
11552>>>>>                
11552>>>>>                // If something went wrong, adjust the result
11552>>>>>                If (Err) Begin
11554>>>>>                    Move 0 to iResult
11555>>>>>                End
11555>>>>>>
11555>>>>>                
11555>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11555>>>>>                If (iResult = -4) Begin
11557>>>>>                    Move (SizeOfArray(uaResult)) to iResult
11558>>>>>                End
11558>>>>>>
11558>>>>>                
11558>>>>>                If (iBinaryType) Begin
11560>>>>>                    If (iResult < iLen) Begin
11562>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
11563>>>>>                    End
11563>>>>>>
11563>>>>>                End
11563>>>>>>
11563>>>>>                Else Begin
11564>>>>>                    // Character data
11564>>>>>                    //   iResult has length of data in bytes (without zero terminator)
11564>>>>>                    //   uaResult will have data + zero terminator
11564>>>>>                    If (iResult < (iLenArray - 2) ) Begin
11566>>>>>                        // Received less than requested, strip off trailing zeroes.
11566>>>>>                        Move iResult to iResizeSize
11567>>>>>                    End
11567>>>>>>
11567>>>>>                    Else Begin
11568>>>>>                        // Strip off zero terminator
11568>>>>>                        Move (iLenArray - 2) to iResizeSize
11569>>>>>                    End
11569>>>>>>
11569>>>>>                    
11569>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
11570>>>>>                    
11570>>>>>                End
11570>>>>>>
11570>>>>>            End
11570>>>>>>
11570>>>>>            Else Begin
11571>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11572>>>>>            End
11572>>>>>>
11572>>>>>        End
11572>>>>>>
11572>>>>>        Else Begin
11573>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11574>>>>>        End
11574>>>>>>
11574>>>>>        
11574>>>>>        // Fill global result
11574>>>>>        If (iResult > 0) Begin
11576>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11577>>>>>        End
11577>>>>>>
11577>>>>>        Else Begin
11578>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11579>>>>>        End
11579>>>>>>
11579>>>>>        
11579>>>>>        Function_Return uaResult
11580>>>>>
11580>>>>>    End_Function
11581>>>>>    
11581>>>>>    
11581>>>>>    // Map a column name to a number, if the name id not found no
11581>>>>>    // error is generated the returned number will be 0 (zero) in
11581>>>>>    // that case
11581>>>>>    Function SQLColumnMap String sColname Returns Integer
11583>>>>>        Integer ihdbc
11583>>>>>        Integer ihstmt
11583>>>>>        Integer iNumColumns
11583>>>>>        Integer iColCount
11583>>>>>        Integer iColNum
11583>>>>>        String  sDrvrId
11583>>>>>        String  sCurColName
11583>>>>>        
11583>>>>>        // Get the cli handles
11583>>>>>        Get phCLIStatementHandle  to ihstmt
11584>>>>>        Get phCLIConnectionHandle to ihdbc
11585>>>>>        Get psDriverId            to sDrvrId
11586>>>>>        
11586>>>>>        // Get the number by looping through the column names
11586>>>>>        Move 0 to iColNum
11587>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11588>>>>>        For iColCount from 1 to iNumColumns
11594>>>>>>
11594>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
11595>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
11598>>>>>            
11598>>>>>            If (iColNum) ;                Break
11601>>>>>        Loop
11602>>>>>>
11602>>>>>        
11602>>>>>        Function_Return iColNum
11603>>>>>    End_Function
11604>>>>>    
11604>>>>>    
11604>>>>>    // SQLStmtAttribute
11604>>>>>    // Moved to SQLGetStatementAttribute. 
11604>>>>>    // This function is still here for backward compatibility.
11604>>>>>
11604>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
11606>>>>>        String  sResult
11606>>>>>
11606>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
11607>>>>>        
11607>>>>>        Function_Return sResult
11608>>>>>    End_Function
11609>>>>>
11609>>>>> 
11609>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
11611>>>>>        Integer ihdbc
11611>>>>>        Integer ihstmt
11611>>>>>        String  sResult
11611>>>>>        String  sDrvrId
11611>>>>>        
11611>>>>>        // Initialize
11611>>>>>        Move "" to sResult
11612>>>>>        
11612>>>>>        // Get the cli handles
11612>>>>>        Get phCLIStatementHandle  to ihstmt
11613>>>>>        Get phCLIConnectionHandle to ihdbc
11614>>>>>        Get psDriverId            to sDrvrId
11615>>>>>        
11615>>>>>        // Get the attribute
11615>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
11618>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
11620>>>>>        
11620>>>>>        Function_Return sResult
11621>>>>>    End_Function
11622>>>>>
11622>>>>>    
11622>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
11624>>>>>
11624>>>>>        Integer ihdbc
11624>>>>>        Integer ihstmt
11624>>>>>        String  sDrvrId
11624>>>>>        
11624>>>>>        Integer iLen
11624>>>>>        Integer bLegalAttrib
11624>>>>>        Integer iVoid
11624>>>>>        Integer iAttribValue
11624>>>>>
11624>>>>>        Get phCLIStatementHandle  to ihstmt
11625>>>>>        Get phCLIConnectionHandle to ihdbc
11626>>>>>        Get psDriverId            to sDrvrId
11627>>>>>        
11627>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11629>>>>>            Case Begin
11629>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11631>>>>>                    Move DFTRUE to bLegalAttrib
11632>>>>>                    Break
11633>>>>>                    
11633>>>>>                Case Else
11633>>>>>                    Move DFFALSE to bLegalAttrib
11634>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
11635>>>>>            Case End
11635>>>>>
11635>>>>>            If (bLegalAttrib) Begin
11637>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
11639>>>>>                    
11639>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
11640>>>>>                    Case Begin
11640>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
11642>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
11645>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
11648>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
11651>>>>>                            Break
11652>>>>>                            
11652>>>>>                        Case Else
11652>>>>>                            Move DFFALSE to bLegalAttrib
11653>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
11654>>>>>
11654>>>>>                    Case End
11654>>>>>                End
11654>>>>>>
11654>>>>>            End
11654>>>>>>
11654>>>>>
11654>>>>>            
11654>>>>>            If (bLegalAttrib) Begin
11656>>>>>                
11656>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
11661>>>>>                
11661>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
11666>>>>>            End
11666>>>>>>
11666>>>>>        End
11666>>>>>>
11666>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11668>>>>>        
11668>>>>>        
11668>>>>>        
11668>>>>>    End_Procedure
11669>>>>>    
11669>>>>>    
11669>>>>>    
11669>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11671>>>>>        String  sResult
11671>>>>>        Integer iLen
11671>>>>>        Integer bLegalAttrib
11671>>>>>        
11671>>>>>        // Initialize
11671>>>>>        Move ""     to sResult
11672>>>>>        
11672>>>>>        // Get the attribute
11672>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11674>>>>>            Case Begin
11674>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
11676>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
11679>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
11682>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
11685>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11688>>>>>                    Move DFTRUE to bLegalAttrib
11689>>>>>                    Break
11690>>>>>                    
11690>>>>>                Case Else
11690>>>>>                    Move DFFALSE to bLegalAttrib
11691>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
11692>>>>>            Case End
11692>>>>>            
11692>>>>>            If (bLegalAttrib) Begin
11694>>>>>                // Setup function arguments
11694>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
11699>>>>>            End
11699>>>>>>
11699>>>>>        End
11699>>>>>>
11699>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11701>>>>>        
11701>>>>>        Function_Return sResult
11702>>>>>    End_Function
11703>>>>>    
11703>>>>>    
11703>>>>>    
11703>>>>>    // Get a column's attribute
11703>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
11705>>>>>        Integer ihdbc
11705>>>>>        Integer ihstmt
11705>>>>>        String  sResult
11705>>>>>        String  sDrvrId
11705>>>>>        
11705>>>>>        // Initialize
11705>>>>>        Move "" to sResult
11706>>>>>        
11706>>>>>        // Get the cli handles
11706>>>>>        Get phCLIStatementHandle  to ihstmt
11707>>>>>        Get phCLIConnectionHandle to ihdbc
11708>>>>>        Get psDriverId            to sDrvrId
11709>>>>>        
11709>>>>>        // Get the attribute
11709>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
11712>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
11714>>>>>        
11714>>>>>        Function_Return sResult
11715>>>>>    End_Function
11716>>>>>    
11716>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11718>>>>>        String  sResult
11718>>>>>        String  sEmpty
11718>>>>>        Integer bIsStringAttribute
11718>>>>>        Integer iLen
11718>>>>>        Integer iVoid
11718>>>>>        Integer bLegalAttrib
11718>>>>>        Integer bLegalColumn
11718>>>>>        
11718>>>>>        // Initialize
11718>>>>>        Move "" to sResult
11719>>>>>        Move "" to sEmpty
11720>>>>>        Move 0  to iLen
11721>>>>>        
11721>>>>>        // Get the attribute
11721>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11723>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
11724>>>>>            If (bLegalColumn) Begin
11726>>>>>                // Determine the atributes type
11726>>>>>                Case Begin
11726>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
11728>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
11731>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
11734>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
11737>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
11740>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
11743>>>>>                        Move DFFALSE to bIsStringAttribute
11744>>>>>                        Move DFTRUE to bLegalAttrib
11745>>>>>                        Break
11746>>>>>                        
11746>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
11749>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
11752>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
11755>>>>>                        Move DFTRUE to bIsStringAttribute
11756>>>>>                        Move DFTRUE to bLegalAttrib
11757>>>>>                        Break
11758>>>>>                        
11758>>>>>                    Case Else
11758>>>>>                        Move DFFALSE to bLegalAttrib
11759>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
11760>>>>>                Case End
11760>>>>>                
11760>>>>>                If (bLegalAttrib) Begin
11762>>>>>                    // Setup function arguments
11762>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11767>>>>>                    
11767>>>>>                    If (bIsStringAttribute) Begin
11769>>>>>                        // Call the driver function to get the data length
11769>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
11774>>>>>                        
11774>>>>>                        If (iLen) Begin
11776>>>>>                            // Allocate
11776>>>>>                            Move (Repeat(' ', iLen)) to sResult
11777>>>>>                            
11777>>>>>                            // Call the driver function to get the name
11777>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
11782>>>>>                        End
11782>>>>>>
11782>>>>>                    End
11782>>>>>>
11782>>>>>                    Else Begin
11783>>>>>                        // get the attribute
11783>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
11788>>>>>                    End
11788>>>>>>
11788>>>>>                End
11788>>>>>>
11788>>>>>            End
11788>>>>>>
11788>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
11790>>>>>        End
11790>>>>>>
11790>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
11792>>>>>        
11792>>>>>        Function_Return sResult
11793>>>>>    End_Function
11794>>>>>    
11794>>>>>    
11794>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
11794>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
11796>>>>>        Integer ihdbc
11796>>>>>        Integer ihstmt
11796>>>>>        String  sDrvrId
11796>>>>>        Integer iVoid
11796>>>>>        String  sSchema
11796>>>>>        String  sEmpty
11796>>>>>        
11796>>>>>        // Initialize
11796>>>>>        Move "" to sEmpty
11797>>>>>        
11797>>>>>        // Get the cli handles
11797>>>>>        Get phCLIStatementHandle  to ihstmt
11798>>>>>        Get phCLIConnectionHandle to ihdbc
11799>>>>>        Get psDriverId            to sDrvrId
11800>>>>>        
11800>>>>>        // Call the procedure
11800>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11802>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
11805>>>>>            Else ;                Move "" to sSchema
11807>>>>>            
11807>>>>>            If (sSchema <> "") Begin
11809>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
11814>>>>>            End
11814>>>>>>
11814>>>>>            
11814>>>>>            // Call the procedure
11814>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
11819>>>>>            
11819>>>>>            Set piLastArgument to 0
11820>>>>>        End
11820>>>>>>
11820>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
11822>>>>>    End_Procedure
11823>>>>>    
11823>>>>>    // Pass the next argument
11823>>>>>    Procedure SQLSetNextArgument String sArgument
11825>>>>>        Integer iArgnum
11825>>>>>        
11825>>>>>        Get piLastArgument to iArgnum
11826>>>>>        Increment iArgnum
11827>>>>>        Send SQLSetArgument iArgnum sArgument
11828>>>>>        Set piLastArgument to iArgnum
11829>>>>>    End_Procedure
11830>>>>>    
11830>>>>>    
11830>>>>>    
11830>>>>>    // Set the next argument
11830>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
11832>>>>>        Integer ihdbc
11832>>>>>        Integer ihstmt
11832>>>>>        String  sDrvrId
11832>>>>>        Integer iVoid
11832>>>>>        String  sEmpty
11832>>>>>        
11832>>>>>        // Initialize
11832>>>>>        Move "" to sEmpty
11833>>>>>        
11833>>>>>        // Get the cli handles
11833>>>>>        Get phCLIStatementHandle  to ihstmt
11834>>>>>        Get phCLIConnectionHandle to ihdbc
11835>>>>>        Get psDriverId            to sDrvrId
11836>>>>>        
11836>>>>>        // Call the procedure
11836>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11838>>>>>            // Pass the information
11838>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
11843>>>>>            
11843>>>>>            // Pass the argument
11843>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
11848>>>>>        End
11848>>>>>>
11848>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
11850>>>>>    End_Procedure
11851>>>>>    
11851>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
11853>>>>>        Integer iParamNum 
11853>>>>>        Integer iType
11853>>>>>        
11853>>>>>        If (num_arguments < 2) Begin
11855>>>>>            Move typeString to iType
11856>>>>>        End
11856>>>>>>
11856>>>>>        Else Begin
11857>>>>>            Move iParamType to iType
11858>>>>>        End
11858>>>>>>
11858>>>>>        
11858>>>>>        Get piLastArgument to iParamNum
11859>>>>>        Increment iParamNum
11860>>>>>        Send SQLSetParameter iParamNum sParamValue iType
11861>>>>>        Set piLastArgument to iParamNum
11862>>>>>    End_Procedure
11863>>>>>
11863>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
11865>>>>>        
11865>>>>>        Integer ihdbc
11865>>>>>        Integer ihstmt
11865>>>>>        String  sDrvrId
11865>>>>>        Integer iVoid
11865>>>>>        String  sEmpty
11865>>>>>        Integer iType
11865>>>>>        
11865>>>>>        If (num_arguments < 3) Begin
11867>>>>>            Move typeString to iType
11868>>>>>        End
11868>>>>>>
11868>>>>>        Else Begin
11869>>>>>            Move iParamType to iType
11870>>>>>        End
11870>>>>>>
11870>>>>>        
11870>>>>>        Case Begin
11870>>>>>            Case (iType = typeDate )    
11872>>>>>
11872>>>>>                If (sParamValue <> "") Begin
11874>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
11875>>>>>                End
11875>>>>>>
11875>>>>>                
11875>>>>>                Break
11876>>>>>
11876>>>>>            Case (iType = typeDatetime )    
11879>>>>>
11879>>>>>                If (sParamValue <> "") Begin
11881>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
11882>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
11883>>>>>                End
11883>>>>>>
11883>>>>>
11883>>>>>                Break
11884>>>>>
11884>>>>>            Case (iType = typeNumber )    
11887>>>>>
11887>>>>>                If (sParamValue <> "") Begin
11889>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
11890>>>>>                End
11890>>>>>>
11890>>>>>                
11890>>>>>                Break
11891>>>>>            
11891>>>>>            Case (iType = typeTime )    
11894>>>>>
11894>>>>>                If (sParamValue <> "") Begin
11896>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
11897>>>>>                End
11897>>>>>>
11897>>>>>                
11897>>>>>                Break
11898>>>>>                
11898>>>>>            Case Else
11898>>>>>                    // sParamValue is a string type or a type that must be passed as a string
11898>>>>>                    Break
11899>>>>>                
11899>>>>>        Case End
11899>>>>>        
11899>>>>>        
11899>>>>>        // Initialize
11899>>>>>        Move "" to sEmpty
11900>>>>>        
11900>>>>>        // Get the cli handles
11900>>>>>        Get phCLIStatementHandle  to ihstmt
11901>>>>>        Get phCLIConnectionHandle to ihdbc
11902>>>>>        Get psDriverId            to sDrvrId
11903>>>>>        
11903>>>>>        // Call the procedure
11903>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11905>>>>>            // Pass the information
11905>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
11910>>>>>            
11910>>>>>            // Pass the argument
11910>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
11915>>>>>        End
11915>>>>>>
11915>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
11917>>>>>    End_Procedure
11918>>>>>    
11918>>>>>    
11918>>>>>    // Call a stored procedure
11918>>>>>    Procedure SQLCall
11920>>>>>        Integer ihdbc
11920>>>>>        Integer ihstmt
11920>>>>>        String  sDrvrId
11920>>>>>        Integer iVoid
11920>>>>>        String  sEmpty
11920>>>>>        
11920>>>>>        // Initialize
11920>>>>>        Move "" to sEmpty
11921>>>>>        
11921>>>>>        // Get the cli handles
11921>>>>>        Get phCLIStatementHandle  to ihstmt
11922>>>>>        Get phCLIConnectionHandle to ihdbc
11923>>>>>        Get psDriverId            to sDrvrId
11924>>>>>        
11924>>>>>        // Call the procedure
11924>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11926>>>>>            // Call the procedure
11926>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11931>>>>>            
11931>>>>>            Send SQLGetStatementAttributes
11932>>>>>            Set piLastArgument to 0
11933>>>>>        End
11933>>>>>>
11933>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
11935>>>>>    End_Procedure
11936>>>>>    
11936>>>>>    
11936>>>>>    // Get the next argument
11936>>>>>    Function SQLGetNextArgument Returns String
11938>>>>>        Integer iArgnum
11938>>>>>        String  sResult
11938>>>>>        
11938>>>>>        Get piLastArgument to iArgnum
11939>>>>>        Increment iArgnum
11940>>>>>        Get SQLGetArgument iArgnum to sResult
11941>>>>>        Set piLastArgument to iArgnum
11942>>>>>        
11942>>>>>        Function_Return sResult
11943>>>>>    End_Function
11944>>>>>    
11944>>>>>    
11944>>>>>    
11944>>>>>    // Get the specified argument from a procedure
11944>>>>>    Function SQLGetArgument Integer iArgnum Returns String
11946>>>>>        Integer ihdbc
11946>>>>>        Integer ihstmt
11946>>>>>        String  sDrvrId
11946>>>>>        Integer iVoid
11946>>>>>        String  sEmpty
11946>>>>>        String  sArgument
11946>>>>>        Integer iLen
11946>>>>>        
11946>>>>>        // Initialize
11946>>>>>        Move "" to sEmpty
11947>>>>>        Move "" to sArgument
11948>>>>>        
11948>>>>>        // Get the cli handles
11948>>>>>        Get phCLIStatementHandle  to ihstmt
11949>>>>>        Get phCLIConnectionHandle to ihdbc
11950>>>>>        Get psDriverId            to sDrvrId
11951>>>>>        
11951>>>>>        // Call the procedure
11951>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11953>>>>>            // Pass the information
11953>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
11958>>>>>            
11958>>>>>            // Get the length
11958>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
11963>>>>>            
11963>>>>>            If (iLen) Begin
11965>>>>>                // Allocate
11965>>>>>                Move (Repeat(' ', iLen)) to sArgument
11966>>>>>                
11966>>>>>                // Pass the argument
11966>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
11971>>>>>            End
11971>>>>>>
11971>>>>>        End
11971>>>>>>
11971>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
11973>>>>>        
11973>>>>>        Function_Return sArgument
11974>>>>>    End_Function
11975>>>>>    
11975>>>>>    
11975>>>>>    // Get the return value of a stored function
11975>>>>>    Function SQLReturnValue Returns String
11977>>>>>        Integer ihdbc
11977>>>>>        Integer ihstmt
11977>>>>>        String  sDrvrId
11977>>>>>        Integer iVoid
11977>>>>>        String  sEmpty
11977>>>>>        String  sRetval
11977>>>>>        Integer iLen
11977>>>>>        
11977>>>>>        // Initialize
11977>>>>>        Move "" to sEmpty
11978>>>>>        Move "" to sRetval
11979>>>>>        
11979>>>>>        // Get the cli handles
11979>>>>>        Get phCLIStatementHandle  to ihstmt
11980>>>>>        Get phCLIConnectionHandle to ihdbc
11981>>>>>        Get psDriverId            to sDrvrId
11982>>>>>        
11982>>>>>        // Call the procedure
11982>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11984>>>>>            // Get the length
11984>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
11989>>>>>            
11989>>>>>            If (iLen) Begin
11991>>>>>                // Allocate
11991>>>>>                Move (Repeat(' ', iLen)) to sRetval
11992>>>>>                
11992>>>>>                // Pass the argument
11992>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
11997>>>>>            End
11997>>>>>>
11997>>>>>        End
11997>>>>>>
11997>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
11999>>>>>        
11999>>>>>        Function_Return sRetval
12000>>>>>    End_Function
12001>>>>>    
12001>>>>>    
12001>>>>>    // Switch to the next set
12001>>>>>    // Returns : 0   = No more result sets
12001>>>>>    //     <>0 = Switched to next set
12001>>>>>    Function SQLNextResultSet Returns Integer
12003>>>>>        Integer ihdbc
12003>>>>>        Integer ihstmt
12003>>>>>        String  sDrvrId
12003>>>>>        Integer iResult
12003>>>>>        String  sEmpty
12003>>>>>        
12003>>>>>        // Initialize
12003>>>>>        Move "" to sEmpty
12004>>>>>        Move 0  to iResult
12005>>>>>        
12005>>>>>        // Get the cli handles
12005>>>>>        Get phCLIStatementHandle  to ihstmt
12006>>>>>        Get phCLIConnectionHandle to ihdbc
12007>>>>>        Get psDriverId            to sDrvrId
12008>>>>>        
12008>>>>>        // Call the procedure
12008>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12010>>>>>            // Get the length
12010>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
12015>>>>>            
12015>>>>>            Send SQLGetStatementAttributes
12016>>>>>            Set piLastArgument to 0
12017>>>>>        End
12017>>>>>>
12017>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
12019>>>>>        
12019>>>>>        Function_Return iResult
12020>>>>>    End_Function
12021>>>>>    
12021>>>>>    
12021>>>>>    // Setup a file that will be acivated after a succesfull
12021>>>>>    //fetch on the statement
12021>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
12023>>>>>        Integer ihdbc
12023>>>>>        Integer ihstmt
12023>>>>>        String  sDrvrId
12023>>>>>        Integer iResult
12023>>>>>        Integer bIsOpen
12023>>>>>        Integer iVoid
12023>>>>>        String  sFileType
12023>>>>>        
12023>>>>>        // Check if file is open
12023>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12026>>>>>        If (bIsOpen) Begin
12028>>>>>            // Get the cli handles
12028>>>>>            Get phCLIStatementHandle  to ihstmt
12029>>>>>            Get phCLIConnectionHandle to ihdbc
12030>>>>>            Get psDriverId            to sDrvrId
12031>>>>>            
12031>>>>>            // Call the procedure
12031>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12033>>>>>                // Check if the file has the correct type
12033>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
12036>>>>>                If (sFileType = sDrvrId) Begin
12038>>>>>                    // Setup the buffer
12038>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
12043>>>>>                End
12043>>>>>>
12043>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
12045>>>>>            End
12045>>>>>>
12045>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
12047>>>>>        End
12047>>>>>>
12047>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
12049>>>>>    End_Procedure
12050>>>>>    
12050>>>>>    
12050>>>>>    
12050>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
12052>>>>>        Integer ihdbc
12052>>>>>        Integer ihstmt
12052>>>>>        String  sDrvrId
12052>>>>>        String  sMessage
12052>>>>>        Integer iVoid
12052>>>>>        
12052>>>>>        // Initialize
12052>>>>>        Move "" to sMessage
12053>>>>>        
12053>>>>>        // Get the cli handles
12053>>>>>        Get phCLIStatementHandle  to ihstmt
12054>>>>>        Get phCLIConnectionHandle to ihdbc
12055>>>>>        Get psDriverId            to sDrvrId
12056>>>>>        
12056>>>>>        // Call the procedure
12056>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12058>>>>>            // Setup function arguments
12058>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
12063>>>>>            
12063>>>>>            Move (Repeat(' ', 1024)) to sMessage
12064>>>>>            // Get the length
12064>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
12069>>>>>        End
12069>>>>>>
12069>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
12071>>>>>        
12071>>>>>        Function_Return sMessage
12072>>>>>    End_Function
12073>>>>>    
12073>>>>>    
12073>>>>>    
12073>>>>>    // Remove the component identifier from a diagnostic message
12073>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
12075>>>>>        While (Left(sDiagMessage, 1) = "[")
12079>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
12080>>>>>        Loop
12081>>>>>>
12081>>>>>        
12081>>>>>        Function_Return sDiagMessage
12082>>>>>    End_Function
12083>>>>>    
12083>>>>>    
12083>>>>>    
12083>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
12083>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
12085>>>>>        
12085>>>>>        Integer iType
12085>>>>>        String  sSQLDate
12085>>>>>        Integer iOrgDateFmt
12085>>>>>        Integer iOrgDateSep
12085>>>>>        
12085>>>>>        String sDriverId
12085>>>>>        String sDummyZeroDate
12085>>>>>        String sDummyZeroDateMssqlDatetime
12085>>>>>        
12085>>>>>        // Change date format to military, SQL dates are military dates
12085>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12088>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12091>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12094>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12097>>>>>        
12097>>>>>        // We only need to convert if the date is 0
12097>>>>>        If (Integer(dDFDate = 0)) Begin
12099>>>>>            
12099>>>>>            If (num_arguments < 2) Begin
12101>>>>>                Move SQL_TYPE_TIMESTAMP to iType
12102>>>>>            End
12102>>>>>>
12102>>>>>            Else Begin
12103>>>>>                Move iSQLType to iType
12104>>>>>            End
12104>>>>>>
12104>>>>>            
12104>>>>>            
12104>>>>>            Get psDriverID to sDriverId
12105>>>>>            Get psDummyZeroDate to sDummyZeroDate
12106>>>>>            
12106>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
12108>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12109>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
12110>>>>>            End
12110>>>>>>
12110>>>>>            Else Begin
12111>>>>>                Move sDummyZeroDate to sSQLDate
12112>>>>>            End
12112>>>>>>
12112>>>>>            
12112>>>>>        End
12112>>>>>>
12112>>>>>        Else Begin
12113>>>>>            Move dDFDate to sSQLDate
12114>>>>>        End
12114>>>>>>
12114>>>>>        
12114>>>>>        // Change date format back to original
12114>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12117>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12120>>>>>        
12120>>>>>        Function_Return sSQLDate
12121>>>>>    End_Function
12122>>>>>    
12122>>>>>    
12122>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
12122>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
12124>>>>>        
12124>>>>>        Integer iType
12124>>>>>        Date    dDFDate
12124>>>>>        Integer iOrgDateFmt
12124>>>>>        Integer iOrgDateSep
12124>>>>>        
12124>>>>>        String  sDriverId
12124>>>>>        String  sDummyZeroDate
12124>>>>>        String  sDummyZeroDateMssqlDatetime
12124>>>>>        
12124>>>>>        Get psDriverID to sDriverId
12125>>>>>        
12125>>>>>        Get psDummyZeroDate to sDummyZeroDate
12126>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12127>>>>>        
12127>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12130>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12133>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12136>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12139>>>>>        
12139>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
12140>>>>>        
12140>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
12142>>>>>            Move 0 to dDFDate
12143>>>>>        End
12143>>>>>>
12143>>>>>        Else Begin
12144>>>>>            Move sSQLDate to dDFDate
12145>>>>>        End
12145>>>>>>
12145>>>>>        
12145>>>>>        // Change date format back to original
12145>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12148>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12151>>>>>        
12151>>>>>        Function_Return dDFDate
12152>>>>>    End_Function
12153>>>>>    
12153>>>>>End_Class
12154>>>>>
12154>>>>>
12154>>>>>// Connection object for embedded SQL                          
12154>>>>>// This provides the ability to create a connection for a driver.     
12154>>>>>// It will contain child statement objects                            
12154>>>>>
12154>>>>>Class cSQLConnection is a cObject
12155>>>>>    
12155>>>>>    Procedure Construct_object
12157>>>>>        Forward Send Construct_object
12159>>>>>        
12159>>>>>        Property Integer phCLIConnectionHandle       0
12160>>>>>        
12160>>>>>        Property String  psDriverID        ""
12161>>>>>        Property Integer piBindFile        0
12162>>>>>        
12162>>>>>        Property String psDummyZeroDate              '0001-01-01'
12163>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
12164>>>>>        
12164>>>>>    End_Procedure
12165>>>>>    
12165>>>>>    
12165>>>>>    
12165>>>>>    // Store basic information about the connection
12165>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
12167>>>>>        
12167>>>>>        String sDummyZeroDate
12167>>>>>        Integer iDriverIndex
12167>>>>>        
12167>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
12168>>>>>        Set psDriverID            to sDrvrId
12169>>>>>        
12169>>>>>        Case Begin
12169>>>>>            Case (sDrvrId = "MSSQLDRV")
12171>>>>>                Set psDummyZeroDate to '0001-01-01'
12172>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
12173>>>>>                Break
12174>>>>>            Case (sDrvrId = "DB2_DRV")
12177>>>>>                Set psDummyZeroDate to '0001-01-01'
12178>>>>>                Break
12179>>>>>            Case (sDrvrId = "ODBC_DRV")
12182>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
12183>>>>>                If (iDriverIndex <> 0) Begin
12185>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
12188>>>>>                End
12188>>>>>>
12188>>>>>                Else Begin
12189>>>>>                    Move '0001-01-01' to sDummyZeroDate
12190>>>>>                End
12190>>>>>>
12190>>>>>
12190>>>>>                Set psDummyZeroDate to sDummyZeroDate
12191>>>>>                Break
12192>>>>>                
12192>>>>>        Case End
12192>>>>>        
12192>>>>>    End_Procedure
12193>>>>>    
12193>>>>>    Function DriverIndex String sDriver Returns Integer
12195>>>>>        
12195>>>>>        String  sCurrentDriver
12195>>>>>        Integer iNumberOfDrivers iDriver iCount
12195>>>>>        
12195>>>>>        Move 0 to iDriver
12196>>>>>        
12196>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
12199>>>>>        For iCount from 1 to iNumberOfDrivers
12205>>>>>>
12205>>>>>            
12205>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
12208>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
12210>>>>>                Move iCount to iDriver
12211>>>>>            End
12211>>>>>>
12211>>>>>        Loop
12212>>>>>>
12212>>>>>        
12212>>>>>        Function_Return iDriver
12213>>>>>        
12213>>>>>    End_Function
12214>>>>>
12214>>>>>    
12214>>>>>    // Destroy the SQLConnection object
12214>>>>>    Procedure DestroySQLConnection
12216>>>>>        Send Destroy
12217>>>>>    End_Procedure
12218>>>>>    
12218>>>>>    
12218>>>>>    // Connect to a database server
12218>>>>>    // Returns : 1 Succesfully connected
12218>>>>>    //           0 Not connected
12218>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12220>>>>>        Integer ihdbc
12220>>>>>        String  sEmpty
12220>>>>>        
12220>>>>>        // Initialize
12220>>>>>        Move "" to sEmpty
12221>>>>>        Move 0  to ihdbc
12222>>>>>        
12222>>>>>        Move False to Err
12223>>>>>        
12223>>>>>        // Call the driver function to connect
12223>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
12228>>>>>        
12228>>>>>        // If there was an error, make result invalid
12228>>>>>        If (Err) ;            Move 0 to ihdbc
12231>>>>>        
12231>>>>>        // Check result and store it
12231>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12234>>>>>        
12234>>>>>        // Return success status
12234>>>>>        Function_Return (ihdbc <> 0)
12235>>>>>    End_Function
12236>>>>>    
12236>>>>>    
12236>>>>>    // Use a connection of an already open file
12236>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
12238>>>>>        Integer ihdbc
12238>>>>>        Integer bIsOpen
12238>>>>>        String  sDrvrId
12238>>>>>        String  sEmpty
12238>>>>>        
12238>>>>>        // Initialize
12238>>>>>        Move "" to sEmpty
12239>>>>>        Move 0  to ihdbc
12240>>>>>        
12240>>>>>        // Check if file is open
12240>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12243>>>>>        If (bIsOpen) Begin
12245>>>>>            // Fill the driver id, assume longest is 255 characters
12245>>>>>            Move (Repeat(' ', 255)) to sDrvrId
12246>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12249>>>>>            
12249>>>>>            Move False to Err
12250>>>>>            
12250>>>>>            // Call the driver function to connect
12250>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
12255>>>>>            
12255>>>>>            // If there was an error, make result invalid
12255>>>>>            If (Err) ;                Move 0 to ihdbc
12258>>>>>            
12258>>>>>            // Check result and store it
12258>>>>>            If (ihdbc <> 0) Begin
12260>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
12260>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12263>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
12264>>>>>                
12264>>>>>                // Set filenum so it can be used for fetching
12264>>>>>                Set piBindFile to iFileNum
12265>>>>>            End
12265>>>>>>
12265>>>>>        End
12265>>>>>>
12265>>>>>        
12265>>>>>        // Return success status
12265>>>>>        Function_Return (ihdbc <> 0)
12266>>>>>    End_Function
12267>>>>>    
12267>>>>>    
12267>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12267>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12267>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12267>>>>>    // The connectstring must be an exact match, but can be case insensitive
12267>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
12267>>>>>    // If no matching connectstring is found, this function will return 0
12267>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12267>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12269>>>>>        Integer ihdbc
12269>>>>>        String  sEmpty
12269>>>>>        Integer iFileNum
12269>>>>>        
12269>>>>>        // Initialize
12269>>>>>        Move "" to sEmpty
12270>>>>>        Move 0  to ihdbc
12271>>>>>        
12271>>>>>        Move False to Err
12272>>>>>        
12272>>>>>        // Call the driver function
12272>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
12272>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
12272>>>>>        Move 0 to iFileNum
12273>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
12278>>>>>        
12278>>>>>        // If there was an error, make result invalid
12278>>>>>        If (Err) ;            Move 0 to ihdbc
12281>>>>>        
12281>>>>>        // Check result and store it
12281>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12284>>>>>        
12284>>>>>        // Return success status
12284>>>>>        Function_Return (ihdbc <> 0)
12285>>>>>    End_Function
12286>>>>>    
12286>>>>>    
12286>>>>>    // Disconnect from an embedded SQL server and free allocated
12286>>>>>    // resources
12286>>>>>    Procedure SQLDisconnect
12288>>>>>        Integer ihdbc
12288>>>>>        Integer iVoid
12288>>>>>        String  sDrvrId
12288>>>>>        String  sEmpty
12288>>>>>        
12288>>>>>        // Initialize
12288>>>>>        Move "" to sEmpty
12289>>>>>        
12289>>>>>        // Get the cli handle
12289>>>>>        Get phCLIConnectionHandle to ihdbc
12290>>>>>        Get psDriverId to sDrvrId
12291>>>>>        
12291>>>>>        // Free the CLI handle
12291>>>>>        If (ihdbc <> 0) Begin
12293>>>>>            // Call the driver function to disconnect
12293>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
12298>>>>>            
12298>>>>>            Move -1 to giLastSQLhdbc
12299>>>>>            
12299>>>>>            // Free the DataFlex handle
12299>>>>>            Send DestroySQLConnection
12300>>>>>        End
12300>>>>>>
12300>>>>>    End_Procedure
12301>>>>>    
12301>>>>>    // Create a cSQLStatement object
12301>>>>>    Function CreateSQLStatement Returns Handle
12303>>>>>        
12303>>>>>        Handle hoSQLStatement
12303>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
12304>>>>>        
12304>>>>>        // If the connection has a default Bind File, assign it to the
12304>>>>>        // statement object. The default is set when you open a file with a
12304>>>>>        // SetFileConnection command.
12304>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
12305>>>>>        
12305>>>>>        Function_Return hoSQLStatement
12306>>>>>    End_Function
12307>>>>>    
12307>>>>>    
12307>>>>>    // Open a statement for use
12307>>>>>    Function SQLOpen Returns Handle
12309>>>>>        Handle  hoSQLStatement
12309>>>>>        Integer ihdbc
12309>>>>>        Integer ihstmt
12309>>>>>        Integer iVoid
12309>>>>>        String  sDrvrId
12309>>>>>        String  sEmpty
12309>>>>>        String  sDummyZeroDate
12309>>>>>        String  sDummyZeroDateMssqlDatetime
12309>>>>>        
12309>>>>>        // Initialize
12309>>>>>        Move "" to sEmpty
12310>>>>>        
12310>>>>>        // Get the cli handle to the connection
12310>>>>>        Get phCLIConnectionHandle to ihdbc
12311>>>>>        Get psDriverId  to sDrvrId
12312>>>>>        
12312>>>>>        // Allocate a new handle and populate it
12312>>>>>        If (ihdbc <> 0) Begin
12314>>>>>            // Create a new cSQLStatement object
12314>>>>>            Get CreateSQLStatement to hoSQLStatement
12315>>>>>            
12315>>>>>            // Call the driver function to allocate a cli statement handle
12315>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
12320>>>>>            
12320>>>>>            // If unsuccessful destroy hoSQLStatement
12320>>>>>            If (ihstmt = 0) Begin
12322>>>>>                Send DestroySQLStatement of hoSQLStatement
12323>>>>>                Move 0 to hoSQLStatement
12324>>>>>            End
12324>>>>>>
12324>>>>>            Else Begin
12325>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
12326>>>>>                
12326>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
12326>>>>>                Get psDummyZeroDate              to sDummyZeroDate
12327>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12328>>>>>                
12328>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
12329>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
12330>>>>>                
12330>>>>>            End
12330>>>>>>
12330>>>>>        End
12330>>>>>>
12330>>>>>        
12330>>>>>        Function_Return hoSQLStatement
12331>>>>>    End_Function
12332>>>>>    
12332>>>>>End_Class
12333>>>>>
12333>>>>>// Manager for embedded SQL handles.                           
12333>>>>>// We want to be able to use multiple drivers and multiple            
12333>>>>>// connections within a driver and multiple statements within a       
12333>>>>>// connection. To allow this we have placed our own handle logic on   
12333>>>>>// top of the driver handle logic. This way we can handle the         
12333>>>>>// situation where two driver handles may be equal.                   
12333>>>>>
12333>>>>>Class cSQLHandleManager is a cObject
12334>>>>>    
12334>>>>>    Procedure Construct_object
12336>>>>>        Forward Send Construct_object
12338>>>>>        
12338>>>>>        Property String  psDefaultDriver      ""
12339>>>>>        Property String  psDefaultConnection  ""
12340>>>>>        
12340>>>>>    End_Procedure
12341>>>>>    
12341>>>>>    // Create a cSQLConnection object
12341>>>>>    Function CreateSQLConnection Returns Handle
12343>>>>>        Handle hoSQLConnection
12343>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
12344>>>>>        Function_Return hoSQLConnection
12345>>>>>    End_Function
12346>>>>>    
12346>>>>>    
12346>>>>>    // Store default connection information
12346>>>>>    Procedure SQLSetConnect String sDriver String sConnect
12348>>>>>        Set psDefaultDriver      to sDriver
12349>>>>>        Set psDefaultConnection  to sConnect
12350>>>>>    End_Procedure
12351>>>>>    
12351>>>>>    
12351>>>>>    // Make a connection to an embedded SQL server
12351>>>>>    // Returns : The DataFlex handle to the connection
12351>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12353>>>>>        Handle hoSQLConnection
12353>>>>>        Integer bOK
12353>>>>>        
12353>>>>>        // Check arguments
12353>>>>>        If (sDrvrID = "" and sConnect = "") Begin
12355>>>>>            Get psDefaultDriver      to sDrvrId
12356>>>>>            Get psDefaultConnection  to sConnect
12357>>>>>        End
12357>>>>>>
12357>>>>>        
12357>>>>>        // Create a cSQLConnection object
12357>>>>>        Get CreateSQLConnection to hoSQLConnection
12358>>>>>        // Connect to the database
12358>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
12359>>>>>        
12359>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12359>>>>>        If (not(bOK)) Begin
12361>>>>>            Send DestroySQLConnection of hoSQLConnection
12362>>>>>            Move 0 to hoSQLConnection
12363>>>>>        End
12363>>>>>>
12363>>>>>        
12363>>>>>        Function_Return hoSQLConnection
12364>>>>>    End_Function
12365>>>>>    
12365>>>>>    
12365>>>>>    
12365>>>>>    // Make an existing connection available for use with Embedded SQL.
12365>>>>>    // The connection is identified by the number of a file
12365>>>>>    // that is open for that connection.
12365>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
12367>>>>>        Handle hoSQLConnection
12367>>>>>        Integer bOK
12367>>>>>        
12367>>>>>        // Create a cSQLConnection object
12367>>>>>        Get CreateSQLConnection to hoSQLConnection
12368>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
12369>>>>>        
12369>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12369>>>>>        If (not(bOK)) Begin
12371>>>>>            Send DestroySQLConnection of hoSQLConnection
12372>>>>>            Move 0 to hoSQLConnection
12373>>>>>        End
12373>>>>>>
12373>>>>>        
12373>>>>>        Function_Return hoSQLConnection
12374>>>>>    End_Function
12375>>>>>    
12375>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12375>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12375>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12375>>>>>    // The connectstrings must be an exact match, but can be case insensitive
12375>>>>>    // If no matching connectstring is found, this function will return 0
12375>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12375>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12377>>>>>        Handle hoSQLConnection
12377>>>>>        Integer bOK
12377>>>>>        
12377>>>>>        // Check arguments
12377>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
12379>>>>>            Get psDefaultDriver      to sDrvrId
12380>>>>>            Get psDefaultConnection  to sConnectString
12381>>>>>        End
12381>>>>>>
12381>>>>>        
12381>>>>>        // Create a cSQLConnection object
12381>>>>>        Get CreateSQLConnection to hoSQLConnection
12382>>>>>        // Connect to the database
12382>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
12383>>>>>        
12383>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12383>>>>>        If (not(bOK)) Begin
12385>>>>>            Send DestroySQLConnection of hoSQLConnection
12386>>>>>            Move 0 to hoSQLConnection
12387>>>>>        End
12387>>>>>>
12387>>>>>        
12387>>>>>        Function_Return hoSQLConnection
12388>>>>>    End_Function
12389>>>>>    
12389>>>>>    
12389>>>>>End_Class
12390>>>Use cApplication.pkg
12390>>>
12390>>>// constants
12390>>>Define C_ConnectionId for "DFCONNID=" // symbol used in INT/SERVER for connection Id
12390>>>Define C_ConnectionIdCmdLineName for "dfconnid=" // left side of name used in command line argument for dfconnid.ini file
12390>>>Define C_ConnectionIniFileName for "DFConnId.ini" // default name of connections INI file.
12390>>>Define C_ConnectionIniSectionBaseName for "connection" // normally assumes a suffix like connection1, conneciton 2, etc.
12390>>>Define C_ConnectionIniSectionId for "id" // Name of connection id
12390>>>Define C_ConnectionIniSectionDriver for "driver" // left side of [id] section for driver
12390>>>Define C_ConnectionIniSectionConnection for "connection" // left side of [id] section for connection
12390>>>Define C_ConnectionIniSectionUID for "UID"
12390>>>Define C_ConnectionIniSectionPWD for "PWD"
12390>>>Define C_ConnectionIniSectionTrusted for "trusted_connection"
12390>>>Define C_ConnectionIniSectionDisabled for "disabled"
12390>>>
12390>>>// connection ID information
12390>>>Struct tConnection
12390>>>    String sId                // connection id
12390>>>    String sString            // server-string as added via the ini file
12390>>>    String sUID               // User Id
12390>>>    String sPWD               // non-encrypted password
12390>>>    Boolean bTrustedConnection // Trusted connection
12390>>>    Integer iOptions          // connection ID options (don't use)
12390>>>    String sDriver            // name of driver
12390>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
12390>>>    String sConnectionString  // Full connection string assembled from various strings
12390>>>    String sSection           // this is usually the section name as it appears
12390>>>    // in the connections ini file (e.g., [Connection1])
12390>>>    Boolean bDisabled         // if set, this is not an active Id
12390>>>End_Struct
12390>>>
12390>>>// used to search loaded (registered) drivers to find CLI connection handle
12390>>>Struct tDriverCLIDictionary
12390>>>    String sDriver // registered driver name
12390>>>    Handle hoCLI   // CLI handle of object created when driver was loaded
12390>>>End_Struct
12390>>>
12390>>>// privately used to write INI sections
12390>>>Struct tConnectionIniSection
12390>>>    String sSection // section INI name. Should be unique
12390>>>    String[] Keys
12390>>>    String[] Values
12390>>>End_Struct
12390>>>
12390>>>// search tConnection by case insensitive ID
12390>>>Function ComparetConnectionById Desktop tConnection C1 tConnection C2 Returns Integer
12392>>>    String sId1 sId2
12392>>>    Move (Uppercase(C1.sId)) to sId1
12393>>>    Move (Uppercase(C2.sId)) to sId2
12394>>>    If (sId1>sId2) Begin
12396>>>        Function_Return (GT)
12397>>>    End
12397>>>>
12397>>>    Else If (sId1<sId2) Begin
12400>>>        Function_Return (LT)
12401>>>    End
12401>>>>
12401>>>    Function_Return (EQ)
12402>>>End_Function
12403>>>
12403>>>Class cConnection is a cObject
12404>>>    
12404>>>    Procedure Construct_Object
12406>>>        Forward Send Construct_Object
12408>>>        
12408>>>        // If you want to do this all manually set this False
12408>>>        Property Boolean pbUseConnectionIni True
12409>>>        
12409>>>        // When using managed logins, login again if already logged in?
12409>>>        Property Boolean pbSkipDuplicateLogin True
12410>>>        
12410>>>        // can be set to false, to require a login before an open. This gets
12410>>>        // set when the driver is registered.
12410>>>        Property Boolean private_pbLoginOnOpen True
12411>>>        
12411>>>        // name of connections ini file. Only set this if you want to override
12411>>>        // the normal mechanism of getting a name.
12411>>>        Property String psConnectionIni ""
12412>>>        
12412>>>        // as a scurity precaution this can be disabled so someone cannot run a
12412>>>        // cmdline option that redirects to a different database
12412>>>        Property Boolean pbCmdLineIniAllowed True
12413>>>        
12413>>>        // normally this is dfconnid="name" but it can be customized in the case where
12413>>>        // an application would have a conflict with this.
12413>>>        Property String psConnectionIdCmdLine C_ConnectionIdCmdLineName
12414>>>        
12414>>>        // Determines AutoConnect behavior (usually sent by cApplication after workspace
12414>>>        // is opened. Default is to RegisterAll and LoginAll and abort if error). If set
12414>>>        // false, nothing happens.
12414>>>        Property Boolean pbAutoConnect True
12415>>>        
12415>>>        // is a login dialog used? If so, it must be created and registered in ghoLoginConnectDialog
12415>>>        Property Boolean pbLoginDialogRequired True
12416>>>        
12416>>>        // is encryption used? If so, it must be created and registered in ghoLoginEncryption
12416>>>        Property Boolean pbEncryptPassword True
12417>>>        
12417>>>        // class to use for driver connection objects. Advanced use for sub-classing
12417>>>        Property Handle phcDriverConnection (RefClass(cCLIHandler))
12418>>>        
12418>>>        // can be used by error trapping / handling
12418>>>        Property Integer piErrorNumber
12419>>>        Property Integer piErrorLine
12420>>>        Property String psErrorText
12421>>>        Property Handle phoOldError
12422>>>        
12422>>>        Property tDriverCLIDictionary[] pRegisteredDriversDict
12423>>>        
12423>>>        Property tConnection[] pConnections
12424>>>        
12424>>>        Move Self to ghoConnection
12425>>>        
12425>>>    End_Procedure
12426>>>    
12426>>>    // error trapping for this object
12426>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
12428>>>        Set piErrorLine to iErrorLine
12429>>>        Set piErrorNumber to iErrorNumber
12430>>>        Set psErrorText to sErrorText
12431>>>    End_Procedure
12432>>>    
12432>>>    Procedure TrapErrors
12434>>>        If (Error_Object_Id = Self) Begin
12436>>>            Error DFERR_PROGRAM "ASSERT: cConnection: TrapErrors called twice!"
12437>>>>
12437>>>            Procedure_Return
12438>>>        End
12438>>>>
12438>>>        Set phoOldError to Error_Object_Id
12439>>>        Set piErrorNumber to 0
12440>>>        Move Self to Error_Object_Id
12441>>>    End_Procedure
12442>>>    
12442>>>    Procedure UnTrapErrors
12444>>>        Get phoOldError to Error_Object_Id
12445>>>    End_Procedure
12446>>>    
12446>>>    // Report a connections configuration error as a handled user error.
12446>>>    Procedure ConfigurationError Integer iError String sError
12448>>>        Send UserError sError C_$DriverConfigurationError
12449>>>    End_Procedure
12450>>>    
12450>>>    // Setting this property will change this new and all existing managed drivers
12450>>>    Procedure Set pbLoginOnOpen Boolean bLoginOnOpen
12452>>>        tDriverCLIDictionary[] DriverMap
12452>>>        tDriverCLIDictionary[] DriverMap
12453>>>        Integer i iDriver
12453>>>        Set private_pbLoginOnOpen to bLoginOnOpen
12454>>>        
12454>>>        // set any existing registered drivers
12454>>>        Get pRegisteredDriversDict to DriverMap
12455>>>        For i from 0 to (SizeOfArray(DriverMap)-1)
12461>>>>
12461>>>            Get DriverIndex DriverMap[i].sDriver to iDriver
12462>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bLoginOnOpen
12465>>>        Loop
12466>>>>
12466>>>        
12466>>>    End_Procedure
12467>>>    
12467>>>    Function pbLoginOnOpen Returns Boolean
12469>>>        Boolean bLogin
12469>>>        Get private_pbLoginOnOpen to bLogin
12470>>>        Function_Return bLogin
12471>>>    End_Function
12472>>>    
12472>>>    
12472>>>    // returns the Index from list of loaded drivers for sDriver. 0 if not found
12472>>>    // This searches all loaded drivers which may include drivers that were
12472>>>    // not registered.
12472>>>    Function DriverIndex String sDriver Returns Integer
12474>>>        Integer iDrivers i
12474>>>        String sADriver
12474>>>        Move (Uppercase(sDriver)) to sDriver
12475>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12478>>>        For i from 1 to iDrivers
12484>>>>
12484>>>            Get_Attribute DF_DRIVER_NAME of i to sADriver
12487>>>            If (sDriver=Uppercase(sADriver)) Begin
12489>>>                Function_Return i
12490>>>            End
12490>>>>
12490>>>        Loop
12491>>>>
12491>>>        Function_Return 0
12492>>>    End_Function
12493>>>    
12493>>>    // returns cConnectionCLIHandler object for this driver id.
12493>>>    // This must be a registered managed driver. If not found return 0
12493>>>    // This can be used to test if a driver is registered (and therefore loaded)
12493>>>    Function DriverCLIHandler String sDriver Returns Handle
12495>>>        Integer iIndex
12495>>>        tDriverCLIDictionary[] DriverMap
12495>>>        tDriverCLIDictionary[] DriverMap
12496>>>        tDriverCLIDictionary DriverItem
12496>>>        tDriverCLIDictionary DriverItem
12496>>>        Move (Trim(Uppercase(sDriver))) to sDriver
12497>>>        Move sDriver to DriverItem.sDriver
12498>>>        Get pRegisteredDriversDict to DriverMap
12499>>>        Move (SearchArray(DriverItem,DriverMap)) to iIndex
12500>>>        If (iIndex<>-1) Begin
12502>>>            Function_Return DriverMap[iIndex].hoCLI
12503>>>        End
12503>>>>
12503>>>        Function_Return 0
12504>>>    End_Function
12505>>>    
12505>>>    // low level load which does not register the driver - only loads
12505>>>    Function LoadDriver String sDriver Returns Boolean
12507>>>        Integer iErrorNumber
12507>>>        Send TrapErrors
12508>>>        Load_Driver sDriver
12509>>>        Send UnTrapErrors
12510>>>        Get piErrorNumber to iErrorNumber
12511>>>        Function_Return (iErrorNumber=0)
12512>>>    End_Function
12513>>>    
12513>>>    Function TestDriverConformance String sDriver Integer iDriver Handle hoCLI Returns Boolean
12515>>>        Integer iConformance
12515>>>        Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
12518>>>        If (not(iConformance iand 8)) Begin // bit 4 is managed driver conformance
12520>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverIsNotManaged,sDriver))
12521>>>            Function_Return False
12522>>>        End
12522>>>>
12522>>>        Function_Return True
12523>>>    End_Function
12524>>>    
12524>>>    // Register this driver. Load driver if not yet loaded
12524>>>    // return cConnectionCLIHandler handle for this driver
12524>>>    // If registered, just return the handle
12524>>>    // return 0 if driver cannot be loaded
12524>>>    // If newly registered here, sends OnDriverRegistered event
12524>>>    // raise error if driver cannot be loaded or does not conform
12524>>>    Function RegisterDriver String sDriver Returns Handle
12526>>>        Integer iIndex iDriver iConformance
12526>>>        Handle hoCLI hClass
12526>>>        Boolean bOk
12526>>>        Boolean bAutoLogin
12526>>>        tDriverCLIDictionary[] DriverMap
12526>>>        tDriverCLIDictionary[] DriverMap
12527>>>        Integer iIds iRet
12527>>>        String sId
12527>>>        Get DriverCLIHandler sDriver to hoCLI
12528>>>        If (hoCLI=0) Begin // driver not registered yet
12530>>>            Get pRegisteredDriversDict to DriverMap
12531>>>            Get phcDriverConnection to hClass
12532>>>            Get CreateNamed hClass ("oCLI_"+sDriver) to hoCLI
12533>>>            Move (SizeOfArray(DriverMap)) to iIndex
12534>>>            Move (Trim(Uppercase(sDriver)))  to DriverMap[iIndex].sDriver
12535>>>            Move hoCLI to DriverMap[iIndex].hoCLI
12536>>>            Set pRegisteredDriversDict to DriverMap
12537>>>            Set psDriverID of hoCLI to DriverMap[iIndex].sDriver
12538>>>            
12538>>>            Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12539>>>            Move (iDriver>0) to bOk // is driver already loaded (just not registered)
12540>>>            If not bOk Begin
12542>>>                Get LoadDriver DriverMap[iIndex].sDriver to bOk
12543>>>                If bOk Begin
12545>>>                    Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12546>>>                End
12546>>>>
12546>>>                Else Begin
12547>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverNotFound,sDriver))
12548>>>                End
12548>>>>
12548>>>            End
12548>>>>
12548>>>            
12548>>>            // finally make sure loaded driver supports managed connections and any other
12548>>>            // tests that might be applied by the developer
12548>>>            If bOk Begin
12550>>>                Get TestDriverConformance sDriver iDriver hoCLI to bOk
12551>>>            End
12551>>>>
12551>>>            
12551>>>            If not bOk Begin
12553>>>                Send Destroy of hoCLI
12554>>>                Move 0 to hoCLI
12555>>>                Move (RemoveFromArray(DriverMap,iIndex)) to DriverMap
12556>>>                Set pRegisteredDriversDict to DriverMap
12557>>>            End
12557>>>>
12557>>>            Else Begin
12558>>>                // driver is loaded and valid, complete registration
12558>>>                
12558>>>                // Is auto-login on open supported?
12558>>>                Get pbLoginOnOpen to bAutoLogin
12559>>>                Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bAutoLogin
12562>>>                
12562>>>                // remove existing connection IDs as defined in the driver.int file. If you are
12562>>>                // using registered connections, you are using registered drivers!
12562>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iIds
12565>>>                While (iIds>0)
12569>>>                    Decrement iIds
12570>>>                    Get DeleteConnectionID of hoCLI "" iIds to iRet
12571>>>                Loop
12572>>>>
12572>>>                
12572>>>                Send OnDriverRegistered sDriver iDriver hoCLI
12573>>>            End
12573>>>>
12573>>>        End
12573>>>>
12573>>>        Function_Return hoCLI
12574>>>    End_Function
12575>>>    
12575>>>    
12575>>>    
12575>>>    // returns a string array of loaded drivers (managed and unmanaged)
12575>>>    Function LoadedDrivers Returns String[]
12577>>>        Integer iDrivers i
12577>>>        String[] ArrayOfDrivers
12578>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12581>>>        For i from 1 to iDrivers
12587>>>>
12587>>>            Get_Attribute DF_DRIVER_NAME of i to ArrayOfDrivers[i-1]
12590>>>        Loop
12591>>>>
12591>>>        Function_Return ArrayOfDrivers
12592>>>    End_Function
12593>>>    
12593>>>    // List of all Server connection-strings logged into this driver.
12593>>>    // This includes managed/registered strings and strings used in non-managed ways (e.g., in int file)
12593>>>    Function DriverServerNames String sDriver Returns String[]
12595>>>        Integer iConnections i iDriver
12595>>>        String[] Connections
12596>>>        Get DriverIndex sDriver to iDriver
12597>>>        If (iDriver>0) Begin
12599>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iConnections
12602>>>            For i from 0 to (iConnections-1)
12608>>>>
12608>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver (i+1) to Connections[i]
12611>>>            Loop
12612>>>>
12612>>>        End
12612>>>>
12612>>>        Function_Return Connections
12613>>>    End_Function
12614>>>    
12614>>>    // this does a low level login, which basically wraps the login command with some error handling
12614>>>    // and the ability to make a login silent.
12614>>>    // This is essentially a Login command surrounded by error checking and trapping
12614>>>    Function BasicLogin String sDriver String sServer String sName String sPassword Returns Integer
12616>>>        Integer iError iIndex
12616>>>        Handle hoConnect
12616>>>        Get DriverIndex sDriver to iIndex
12617>>>        If (iIndex>0) Begin
12619>>>            Send TrapErrors
12620>>>            Login sServer sName sPassword sDriver
12622>>>            Send UnTrapErrors
12623>>>            Get piErrorNumber to iError
12624>>>        End
12624>>>>
12624>>>        Else Begin
12625>>>            Move DFERR_PROGRAM to iError
12626>>>            Error iError (SFormat(C_$DriverNotFound,  sDriver))
12627>>>>
12627>>>        End
12627>>>>
12627>>>        Function_Return iError
12628>>>    End_Function
12629>>>    
12629>>>    
12629>>>    // get array of managed connections across all drivers
12629>>>    // returns array of connections in tConnection.
12629>>>    Function ConnectionIDs Returns tConnection[]
12631>>>        tConnection[] Connections
12631>>>        tConnection[] Connections
12632>>>        Get pConnections to Connections
12633>>>        Function_Return Connections
12634>>>    End_Function
12635>>>    
12635>>>    // return index of Id from pConnections array. -1 if missing
12635>>>    Function ConnectionIdIndex String sId Returns Integer
12637>>>        tConnection[] Connections
12637>>>        tConnection[] Connections
12638>>>        tConnection Connection
12638>>>        tConnection Connection
12638>>>        Integer iIndex
12638>>>        Move (trim(sId)) to Connection.sId
12639>>>        Get pConnections to Connections
12640>>>        Move (SearchArray(Connection,Connections,Desktop,RefFunc(ComparetConnectionById))) to iIndex
12641>>>        Function_Return iIndex
12642>>>    End_Function
12643>>>    
12643>>>    // return handle of cConnectionCLIHandler object for this id. 0 if none
12643>>>    Function ConnectionIdCLIHandler String sId Returns Handle
12645>>>        tConnection[] Ids
12645>>>        tConnection[] Ids
12646>>>        Integer iIndex
12646>>>        Handle hoCLI
12646>>>        Get ConnectionIds to Ids
12647>>>        Get ConnectionIdIndex sId to iIndex
12648>>>        If (iIndex<>-1) Begin
12650>>>            Get DriverCLIHandler Ids[iIndex].sDriver to hoCLI
12651>>>            Function_Return hoCLI
12652>>>        End
12652>>>>
12652>>>        Function_Return 0
12653>>>    End_Function
12654>>>    
12654>>>    // return connection info for this id. Programming error if Id does not exist
12654>>>    Function ConnectionIdInfo String sId Returns tConnection
12656>>>        tConnection[] ConnIDs
12656>>>        tConnection[] ConnIDs
12657>>>        tConnection ConnId
12657>>>        tConnection ConnId
12657>>>        Integer iIndex i
12657>>>        Handle hoCLI
12657>>>        Get ConnectionIdCLIHandler sId to hoCLI
12658>>>        If (hoCLI) Begin
12660>>>            Get ConnectionIdIndex sId to iIndex
12661>>>            Get ConnectionIDs to ConnIDs
12662>>>            Move ConnIDs[iIndex] to ConnId
12663>>>        End
12663>>>>
12663>>>        Else Begin
12664>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12665>>>>
12665>>>        End
12665>>>>
12665>>>        Function_Return ConnId
12666>>>    End_Function
12667>>>    
12667>>>    
12667>>>    // add or upate connection to pConnections. Do not call directly
12667>>>    Function AddToConnections tConnection Connection Returns Integer
12669>>>        tConnection[] Connections
12669>>>        tConnection[] Connections
12670>>>        Integer iIndex
12670>>>        Get pConnections to Connections
12671>>>        Get ConnectionIdIndex Connection.sId to iIndex
12672>>>        If (iIndex=-1) Begin
12674>>>            Move (SizeOfArray(Connections)) to iIndex
12675>>>        End
12675>>>>
12675>>>        Move Connection to Connections[iIndex]
12676>>>        Set pConnections to Connections
12677>>>        Function_Return iIndex
12678>>>    End_Function
12679>>>    
12679>>>    // Remove connection ID from pConnection. Don't call directly
12679>>>    Function RemoveFromConnections String sId Returns Boolean
12681>>>        tConnection[] Connections
12681>>>        tConnection[] Connections
12682>>>        Integer iIndex
12682>>>        Get pConnections to Connections
12683>>>        Get ConnectionIdIndex sId to iIndex
12684>>>        If (iIndex<>-1) Begin
12686>>>            Move (RemoveFromArray(Connections,iIndex)) to Connections
12687>>>            Set pConnections to Connections
12688>>>        End
12688>>>>
12688>>>        Function_Return (iIndex<>-1)
12689>>>    End_Function
12690>>>    
12690>>>    // Return the connection ID syntax used for IDs in the INT file (e.g., DFCONNID=ID1)
12690>>>    // helper so you don't have to remember this syntax. Does not verify Id
12690>>>    Function ConnectionIDServerString String sId Returns String
12692>>>        Function_Return (C_ConnectionId - sId)
12693>>>    End_Function
12694>>>    
12694>>>    // Returns Connection.Ini file name if passed from the command line.
12694>>>    // requires cApplication object
12694>>>    // It's looking for something like dfconnid=myconnid.ini
12694>>>    Function ConnectionIniFromCmdLine Returns String
12696>>>        Handle hoCmdLine
12696>>>        Integer iCount iArg iPos
12696>>>        String sArg sFile sLeft
12696>>>        Get psConnectionIdCmdLine to sLeft
12697>>>        Get phoCommandLine of ghoApplication to hoCmdLine
12698>>>        Get CountOfArgs of hoCmdLine to iCount
12699>>>        For iArg from 1 to iCount
12705>>>>
12705>>>            Get Argument of hoCmdLine iArg to sArg
12706>>>            If (Pos(Lowercase(sLeft),Trim(Lowercase(sArg)))=1) Begin
12708>>>                Move (Trim(Remove(sArg,1,Length(C_ConnectionIdCmdLineName)))) to sFile
12709>>>                Function_Return sFile
12710>>>            End
12710>>>>
12710>>>        Loop
12711>>>>
12711>>>        Function_Return ""
12712>>>    End_Function
12713>>>    
12713>>>    // get qualified version of connections INI file using the rules for
12713>>>    // acquring this name. This file may not exist.
12713>>>    Function ConnectionIniFile Returns String
12715>>>        String sConnections sPath sPName
12715>>>        Boolean bCmdLineIniAllowed
12715>>>        Handle hoWorkspace
12715>>>        
12715>>>        Get pbCmdLineIniAllowed to bCmdLineIniAllowed
12716>>>        Get phoWorkspace of ghoApplication to hoWorkspace
12717>>>        
12717>>>        // order of naming precedence
12717>>>        // 1. If defined directly via a set, use that name
12717>>>        // 2. If command line allowed and exists use that name
12717>>>        // 3. If workspace has a definition (from config.ws) use that name
12717>>>        // 4. Else the default of data\dfconnid.ini
12717>>>        
12717>>>        Get psConnectionIni to sConnections
12718>>>        If (sConnections="" and bCmdLineIniAllowed) Begin
12720>>>            Get ConnectionIniFromCmdLine to sConnections
12721>>>        End
12721>>>>
12721>>>        If (sConnections="") Begin
12723>>>            Get psConnectionIni of hoWorkspace to sConnections
12724>>>        End
12724>>>>
12724>>>        If (sConnections="") Begin
12726>>>            Move C_ConnectionIniFileName to sConnections
12727>>>        End
12727>>>>
12727>>>        Move (Trim(sConnections)) to sConnections
12728>>>        
12728>>>        If (sConnections<>"") Begin
12730>>>            // first data path
12730>>>            If (Pos("<datapath>\",Lowercase(sConnections))) Begin
12732>>>                Get psDataPath of hoWorkspace to sPath
12733>>>                Move "<datapath>\" to sPName
12734>>>            End
12734>>>>
12734>>>            // first programs path
12734>>>            Else If (Pos("<apppath>\",Lowercase(sConnections))) Begin
12737>>>                Get GetApplicationPath of hoWorkspace to sPath
12738>>>                Move "<apppath>\" to sPName
12739>>>            End
12739>>>>
12739>>>            // first workspace home path
12739>>>            Else If (Pos("<homepath>\",Lowercase(sConnections))) Begin
12742>>>                Get psHome of hoWorkspace to sPath
12743>>>                Move "<homepath>\" to sPName
12744>>>            End
12744>>>>
12744>>>            // if no special path, use first data path
12744>>>            Else If (not(IsFilenameQualified(sConnections))) Begin
12747>>>                Get psDataPath of hoWorkspace to sPath
12748>>>                Move '' to sPName
12749>>>            End
12749>>>>
12749>>>            
12749>>>            If (sPath<>"") Begin
12751>>>                Get PathAtIndex of hoWorkspace sPath 1 to sPath
12752>>>                If (sPName<>"") Begin
12754>>>                    Move (Replace(sPName, sConnections, (sPath + "\"))) to sConnections
12755>>>                End
12755>>>>
12755>>>                Else Begin
12756>>>                    Move (sPath + "\" + sConnections) to sConnections
12757>>>                End
12757>>>>
12757>>>            End
12757>>>>
12757>>>        End
12757>>>>
12757>>>        Function_Return sConnections
12758>>>    End_Function
12759>>>    
12759>>>    Procedure OnReadCredentials String sSection String sId Handle hoIni String ByRef sUID String ByRef sPWDEncrypted Boolean ByRef bTrusted
12761>>>        String sTrusted
12761>>>        If (hoIni) Begin
12763>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionUID "" to sUID
12764>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionPWD "" to sPWDEncrypted
12765>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionTrusted "" to sTrusted
12766>>>            Move (lowercase(sTrusted)="yes") to bTrusted
12767>>>        End
12767>>>>
12767>>>    End_Procedure
12768>>>    
12768>>>    Procedure OnWriteCredentials String sSection String sId Handle hoIni String sUID String sPWDEncrypted Boolean bTrusted
12770>>>        If hoIni Begin
12772>>>            If (not(bTrusted) and  sUID<>"") Begin
12774>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionUID sUID
12775>>>            End
12775>>>>
12775>>>            Else Begin
12776>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionUID
12777>>>            End
12777>>>>
12777>>>            
12777>>>            If (not(bTrusted) and sUID<>"" and sPWDEncrypted<>"") Begin
12779>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionPWD sPWDEncrypted
12780>>>            End
12780>>>>
12780>>>            Else Begin
12781>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionPWD
12782>>>            End
12782>>>>
12782>>>            
12782>>>            If (bTrusted) Begin
12784>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionTrusted "yes"
12785>>>            End
12785>>>>
12785>>>            Else Begin
12786>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionTrusted
12787>>>            End
12787>>>>
12787>>>        End
12787>>>>
12787>>>    End_Procedure
12788>>>    
12788>>>    // returns a list of connection Ids from the connections.ini file.
12788>>>    // Driver does not have to be loaded (if not loaded, hoCLI=0)
12788>>>    // If pbUseConnectionIni is False, this does Nothing
12788>>>    // and must be augmented to do anything useful
12788>>>    Function LoadStoredConnections tConnection[] ByRef Connects Returns Boolean
12790>>>        String sConnectPath sId sConnect sDriver sUID sPWD sSection sDisabled
12790>>>        String[] Sections
12791>>>        Handle hoWorkspace hoArray hoIniFile
12791>>>        Integer i iConns iIndex
12791>>>        Boolean bUseConnectionIni bOk bTrusted bDisabled
12791>>>        tConnection ConnNew
12791>>>        tConnection ConnNew
12791>>>        
12791>>>        Get pbUseConnectionIni to bUseConnectionIni
12792>>>        
12792>>>        If bUseConnectionIni Begin
12794>>>            
12794>>>            Get ConnectionIniFile of ghoConnection to sConnectPath
12795>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
12797>>>                Function_Return True // if file does not exist, that's ok - no connections
12798>>>            End
12798>>>>
12798>>>            
12798>>>            Get Create (RefClass(cIniFile)) to hoIniFile
12799>>>            Get Create (RefClass(Array)) to hoArray
12800>>>            Set psFilename of hoIniFile to sConnectPath
12801>>>            
12801>>>            Send ReadSections of hoIniFile hoArray
12802>>>            
12802>>>            // create an array of all Connection sections.
12802>>>            For i from 0 to (Item_Count(hoArray) -1)
12808>>>>
12808>>>                Get Value of hoArray i to sSection
12809>>>                Move (Trim(sSection)) to sSection
12810>>>                If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
12812>>>                    // make sure id is not a duplicate
12812>>>                    Move sId to ConnNew.sId
12813>>>                    Move (SearchArray(sSection, Sections, Desktop,RefFunc(DFSTRICMP))) to iIndex
12814>>>                    If (iIndex<>-1) Begin
12816>>>                        Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniDupSection,sConnectPath,sSection))
12817>>>                        Function_Return False
12818>>>                    End
12818>>>>
12818>>>                    Move (trim(sSection)) to Sections[SizeOfArray(Sections)]
12819>>>                End
12819>>>>
12819>>>            Loop
12820>>>>
12820>>>            
12820>>>            For i from 0 to (SizeOfArray(Sections)-1)
12826>>>>
12826>>>                Move Sections[i] to sSection
12827>>>                
12827>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionId "" to sId
12828>>>                If (sId="") Begin
12830>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadId,sConnectPath,sSection))
12831>>>                    Function_Return False
12832>>>                End
12832>>>>
12832>>>                
12832>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDriver "" to sDriver
12833>>>                If (sDriver="") Begin
12835>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadDriver,sConnectPath,sSection))
12836>>>                    Function_Return False
12837>>>                End
12837>>>>
12837>>>                
12837>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionConnection "" to sConnect
12838>>>                If (sConnect="") Begin
12840>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadConnection,sConnectPath,sSection))
12841>>>                    Function_Return False
12842>>>                End
12842>>>>
12842>>>                
12842>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDisabled "" to sDisabled
12843>>>                Move (Lowercase(sDisabled)="yes") to bDisabled
12844>>>                
12844>>>                Send OnReadCredentials sSection sId hoIniFile (&sUID) (&sPWD) (&bTrusted)
12845>>>                
12845>>>                If (sPWD<>"") Begin
12847>>>                    Get DecryptPassword sPWD to sPWD
12848>>>                End
12848>>>>
12848>>>                
12848>>>                Move sSection to Connects[iConns].sSection
12849>>>                Move sDriver to Connects[iConns].sDriver
12850>>>                Move sId to Connects[iConns].sId
12851>>>                Move sConnect to Connects[iConns].sString
12852>>>                Move bDisabled to Connects[iConns].bDisabled
12853>>>                Move sPWD to Connects[iConns].sPWD
12854>>>                Move bTrusted to Connects[iConns].bTrustedConnection
12855>>>                Move sUID to Connects[iConns].sUID
12856>>>                
12856>>>                Increment iConns
12857>>>            Loop
12858>>>>
12858>>>            Send Destroy of hoArray
12859>>>            Send Destroy of hoIniFile
12860>>>        End
12860>>>>
12860>>>        
12860>>>        Function_Return True
12861>>>    End_Function
12862>>>    
12862>>>    Function DecryptPassword String sPWD Returns String
12864>>>        Handle hoLoginEncrypt
12864>>>        Boolean bEncryptPassword
12864>>>        Get pbEncryptPassword to bEncryptPassword
12865>>>        If (bEncryptPassword) Begin
12867>>>            Move ghoLoginEncryption to hoLoginEncrypt
12868>>>            // if not registered an error will occur - programming error
12868>>>            Get DecryptPassword of hoLoginEncrypt sPWD to sPWD
12869>>>        End
12869>>>>
12869>>>        Function_Return sPWD
12870>>>    End_Function
12871>>>    
12871>>>    Function EncryptPassword String sPWD Returns String
12873>>>        Handle hoLoginEncrypt
12873>>>        Boolean bEncryptPassword
12873>>>        Get pbEncryptPassword to bEncryptPassword
12874>>>        If (bEncryptPassword) Begin
12876>>>            Move ghoLoginEncryption to hoLoginEncrypt
12877>>>            // if not registered an error will occur - programming error
12877>>>            Get EncryptPassword of hoLoginEncrypt sPWD to sPWD
12878>>>        End
12878>>>>
12878>>>        Function_Return sPWD
12879>>>    End_Function
12880>>>    
12880>>>    // Assemble connect string based on connect string, user id, password and trusted connection
12880>>>    // If connect string already contains user id, etc. it is still appended which is consistent
12880>>>    // with odbc connection strings. The last one wins.
12880>>>    // sConnect should contain the SERVER= or DSN= information.
12880>>>    Function AssembleConnectionString String sConnect String sUID String sPWD Boolean bTrusted Returns String
12882>>>        String sConnectString
12882>>>        Move sConnect to sConnectString
12883>>>        If (bTrusted) Begin
12885>>>            Move (sConnectString+";trusted_connection=yes") to sConnectString
12886>>>        End
12886>>>>
12886>>>        Else Begin
12887>>>            If (sUID<>"") Begin
12889>>>                Move (sConnectString+";UID="+sUID) to sConnectString
12890>>>            End
12890>>>>
12890>>>            If (sPWD<>"") Begin
12892>>>                Move (sConnectString+";PWD="+sPWD) to sConnectString
12893>>>            End
12893>>>>
12893>>>        End
12893>>>>
12893>>>        Function_Return sConnectString
12894>>>    End_Function
12895>>>    
12895>>>    Function AddConnectionToDriverCLI Handle hoCLI tConnection Connection Returns Integer
12897>>>        Integer iResult iIndex
12897>>>        Get ConnectionIdIndex Connection.sId to iIndex
12898>>>        If (iIndex<>-1) Begin
12900>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIdAlreadyExists,Connection.sId))
12901>>>            Function_Return 1
12902>>>        End
12902>>>>
12902>>>        Get CreateConnectionID of hoCLI Connection.sId Connection.sConnectionString Connection.iOptions to iResult
12903>>>        If (iResult=0) Begin
12905>>>            Get AddToConnections Connection to iIndex
12906>>>        End
12906>>>>
12906>>>        Function_Return iResult
12907>>>    End_Function
12908>>>    
12908>>>    
12908>>>    // add a connection id for this driver.
12908>>>    // pass server string, user id, password and trusted connection info. The
12908>>>    // server string that gets added will combine all of these. The password
12908>>>    // may require decoding by calling decode password.
12908>>>    Function AddConnection String sDriver String sId String sString String sUID String sPWD Boolean bTrusted String sSection Returns Integer
12910>>>        Handle hoCLI
12910>>>        Integer iResult
12910>>>        tConnection Connection
12910>>>        tConnection Connection
12910>>>        String sConnectString
12910>>>        Get RegisterDriver sDriver to hoCLI
12911>>>        If (hoCLI=0) Begin
12913>>>            // will have raised an error
12913>>>            Function_Return False
12914>>>        End
12914>>>>
12914>>>        Get DriverIndex sDriver to Connection.iDriverIndex
12915>>>        Move sDriver to Connection.sDriver
12916>>>        Get AssembleConnectionString sString sUID sPWD bTrusted to sConnectString
12917>>>        
12917>>>        // assemble the connection struct variable.
12917>>>        Move (Trim(sSection)) to Connection.sSection
12918>>>        Move (Trim(sId)) to Connection.sId
12919>>>        Move sString to Connection.sString
12920>>>        Move sUID to Connection.sUID
12921>>>        Move sPWD to Connection.sPWD
12922>>>        Move bTrusted to Connection.bTrustedConnection
12923>>>        Move True to Connection.iOptions // login always silent.
12924>>>        Move sConnectString to Connection.sConnectionString
12925>>>        Send OnAddConnection (&Connection) // further customize connection
12926>>>        Get AddConnectionToDriverCLI hoCLI Connection to iResult
12927>>>        Function_Return (iResult=0)
12928>>>    End_Function
12929>>>    
12929>>>    // add connectionIds for all registered drivers
12929>>>    // if driver not loaded/registered, do so first
12929>>>    // If any error occurs, stop process and return false, else true
12929>>>    Function AddAllConnections Returns Boolean
12931>>>        tConnection[] Connects
12931>>>        tConnection[] Connects
12932>>>        Integer i iResult
12932>>>        Boolean bOk
12932>>>        Handle hoCLI
12932>>>        Get LoadStoredConnections (&Connects) to bOk
12933>>>        If not bOk Begin
12935>>>            Function_Return False
12936>>>        End
12936>>>>
12936>>>        
12936>>>        For i from 0 to (SizeOfArray(Connects)-1)
12942>>>>
12942>>>            If (not(Connects[i].bDisabled)) Begin
12944>>>                Get AddConnection Connects[i].sDriver Connects[i].sId Connects[i].sString Connects[i].sUID Connects[i].sPWD Connects[i].bTrustedConnection Connects[i].sSection to bOk
12945>>>                If not bOk Begin
12947>>>                    Function_Return False
12948>>>                End
12948>>>>
12948>>>            End
12948>>>>
12948>>>        Loop
12949>>>>
12949>>>        Function_Return True
12950>>>    End_Function
12951>>>    
12951>>>    // returns the DF_DATABASE_ID handle for the passed connection
12951>>>    // should only be called with data obtained from ConnectionIdInfo
12951>>>    // of ConnectionIds and not LoadStoredConnections
12951>>>    // If this returns 0, the connection is not logged in
12951>>>    Function ConnectionDatabaseIdHandle tConnection Conn Returns Handle
12953>>>        Handle hConnectionHandle
12953>>>        String sServerString
12953>>>        Get ConnectionIDServerString Conn.sId to sServerString
12954>>>        Get ServerDatabaseIdHandle Conn.sDriver Conn.iDriverIndex sServerString to hConnectionHandle
12955>>>        Function_Return hConnectionHandle
12956>>>    End_Function
12957>>>    
12957>>>    Function ServerDatabaseIdHandle String sDriver Integer iDriver String sServerString Returns Handle
12959>>>        Integer i
12959>>>        String[] ServerNames
12960>>>        Handle hConnectionHandle
12960>>>        Get DriverServerNames sDriver to ServerNames
12961>>>        Move (SearchArray(sServerString,ServerNames,Desktop,RefFunc(DFSTRICMP))) to i
12962>>>        If (i<>-1) Begin
12964>>>            Get_Attribute DF_DATABASE_ID of iDriver (i+1) to hConnectionHandle
12967>>>        End
12967>>>>
12967>>>        Function_Return hConnectionHandle
12968>>>    End_Function
12969>>>    
12969>>>    // Is connection ID logged in. Pass just the id (e.g. ID1)
12969>>>    // If connection ID is not registered, raise an error
12969>>>    Function IsConnectionIdLoggedIn String sId Returns Boolean
12971>>>        tConnection Connect
12971>>>        tConnection Connect
12971>>>        Handle hConnectionHandle
12971>>>        Get ConnectionIdInfo sId to Connect
12972>>>        Get ConnectionDatabaseIdHandle Connect to hConnectionHandle
12973>>>        Function_Return (hConnectionHandle<>0)
12974>>>    End_Function
12975>>>    
12975>>>    // login to this managed connection via connection id. return 0 if ok
12975>>>    // If ID not found, raise a program error
12975>>>    // Login by connect Id - main interface.
12975>>>    Function LoginConnectionId String sId Returns Integer
12977>>>        Integer iResult
12977>>>        Handle hoCli
12977>>>        Boolean bSkipDup bConnected
12977>>>        String sDriver sServer sError sDesc
12977>>>        tConnection Connect
12977>>>        tConnection Connect
12977>>>        Get ConnectionIdCLIHandler sId to hoCLI
12978>>>        
12978>>>        If hoCli Begin
12980>>>            Get pbSkipDuplicateLogin to bSkipDup
12981>>>            If (bSkipDup) Begin
12983>>>                Get IsConnectionIdLoggedIn sId to bConnected
12984>>>            End
12984>>>>
12984>>>            If not bConnected Begin
12986>>>                Get LoginConnectIdBase sId False to iResult
12987>>>                If (iResult) Begin
12989>>>                    Get psErrorText to sError
12990>>>                    Get ConnectionIdInfo sId to Connect
12991>>>                    Move (sDesc + sFormat("Connection Id=%1.\n\n",sId) + sError) to sError
12992>>>                    Set psErrorText to sError
12993>>>                End
12993>>>>
12993>>>            End
12993>>>>
12993>>>        End
12993>>>>
12993>>>        Else Begin
12994>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12995>>>>
12995>>>            Move 1 to iResult
12996>>>        End
12996>>>>
12996>>>        Function_Return iResult
12997>>>    End_Function
12998>>>    
12998>>>    // does unconditional login for connection Id. This
12998>>>    // can be customized.
12998>>>    Function LoginConnectIdBase String sId Boolean bSilent Returns Integer
13000>>>        Integer iError
13000>>>        Boolean bOk bSkipDialog
13000>>>        String sConn
13000>>>        tConnection Connect
13000>>>        tConnection Connect
13000>>>        Get ConnectionIdInfo sId to Connect
13001>>>        Get ConnectionIDServerString Connect.sId to sConn
13002>>>        // first try a silent login. If it works we are done
13002>>>        Get BasicLogin Connect.sDriver sConn "" "" to iError
13003>>>        If (iError=0) Begin
13005>>>            Function_Return 0
13006>>>        End
13006>>>>
13006>>>        
13006>>>        // If login failed because of incorrect client, skip the login dialog.
13006>>>        // This is the first place this version test occurs.
13006>>>        If (iError=CLIERR_NOCLIENTSERVERVERSIONMATCH or iError=CLIERR_MINIMUMCLIENTVERSIONNOTFOUND) Begin
13008>>>            Function_Return 1
13009>>>        End
13009>>>>
13009>>>        
13009>>>        // If we have a compliant login dialog, try that.
13009>>>        If (not(bSilent)) Begin
13011>>>            Get LoginConnectIdDialog Connect.sId to bOk
13012>>>        End
13012>>>>
13012>>>        Function_Return (If(bOk,0,1))
13013>>>    End_Function
13014>>>    
13014>>>    
13014>>>    Function LoginConnectIdDialog String sId Returns Boolean
13016>>>        Handle hoLoginConnectDialog bLoginDialogRequired
13016>>>        Boolean bOk
13016>>>        
13016>>>// web applications don't use an embedded database login
13016>>>        Get pbLoginDialogRequired to bLoginDialogRequired
13017>>>        If (bLoginDialogRequired) Begin
13019>>>            Move ghoLoginConnectDialog to hoLoginConnectDialog
13020>>>            // if object missing an error is raised - programming error
13020>>>            Get LoginConnectIdDialog of hoLoginConnectDialog sId to bOk
13021>>>        End
13021>>>>
13021>>>        
13021>>>        Function_Return bOk
13022>>>    End_Function
13023>>>    
13023>>>    // Change Connect string based on passed credentials
13023>>>    // Update the driver's map of connect Id/Connect strings.
13023>>>    // If there is no change in the connection string, this does nothing.
13023>>>    // This will log out and disconnect from the existing connection and connect (but
13023>>>    // not login) to the new one.
13023>>>    // The Id must exist or errors
13023>>>    Function ChangeConnectIdCredentials String sId String sUser String sPwd Boolean bTrust Returns tConnection
13025>>>        tConnection Connect
13025>>>        tConnection Connect
13025>>>        Integer iError
13025>>>        String sConnStr
13025>>>        Get ConnectionIdInfo sId to Connect
13026>>>        Get AssembleConnectionString Connect.sString sUser sPwd bTrust to Connect.sConnectionString
13027>>>        If (Connect.sConnectionString<>sConnStr) Begin
13029>>>            Send LogoutConnectionId Connect.sId
13030>>>            Send DeleteConnectionId Connect.sId
13031>>>            
13031>>>            Move bTrust to Connect.bTrustedConnection
13032>>>            Move (If(bTrust,"",sUser))  to Connect.sUID
13033>>>            Move (If(bTrust,"",sPwd)) to Connect.sPWD
13034>>>            
13034>>>            Get AddConnection Connect.sDriver Connect.sId Connect.sString Connect.sUID Connect.sPWD Connect.bTrustedConnection Connect.sSection to iError
13035>>>        End
13035>>>>
13035>>>        Function_Return Connect
13036>>>    End_Function
13037>>>    
13037>>>    // attempt connection Id login using ID with passed credentials.
13037>>>    // These credentials will update the driver's map of connect Id/Connect strings.
13037>>>    // The Id must exist or errors
13037>>>    Function LoginConnectIdNewCredentials String sId String sUser String sPwd Boolean bTrust Returns Integer
13039>>>        Integer iError
13039>>>        tConnection Connect
13039>>>        tConnection Connect
13039>>>        Get ChangeConnectIdCredentials sId sUser sPwd bTrust to Connect
13040>>>        Get LoginConnectIdBase sId True to iError // silent
13041>>>        Function_Return iError
13042>>>    End_Function
13043>>>    
13043>>>    // Store credentials for Id. By default store in connections INI file, if used.
13043>>>    // Can be augmented or overridden
13043>>>    Function StoreConnectionIdCredentials String sId String sUID String sPWD Boolean bTrusted Returns Boolean
13045>>>        String sConnectPath
13045>>>        Handle hoIniFile
13045>>>        Boolean bUseConnectionIni
13045>>>        tConnection Connect
13045>>>        tConnection Connect
13045>>>        
13045>>>        Get pbUseConnectionIni to bUseConnectionIni
13046>>>        
13046>>>        If bUseConnectionIni Begin
13048>>>            
13048>>>            Get ConnectionIniFile to sConnectPath
13049>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
13051>>>                Function_Return True // empty is ok
13052>>>            End
13052>>>>
13052>>>            
13052>>>            Get ConnectionIdInfo sId to Connect
13053>>>            Get Create (RefClass(cIniFile)) to hoIniFile
13054>>>            Set psFilename of hoIniFile to sConnectPath
13055>>>            
13055>>>            If (sPWD<>"") Begin
13057>>>                Get EncryptPassword sPWD to sPWD
13058>>>            End
13058>>>>
13058>>>            
13058>>>            Send OnWriteCredentials Connect.sSection sId hoIniFile sUid sPWD bTrusted
13059>>>            
13059>>>            Send Destroy of hoIniFile
13060>>>        End
13060>>>>
13060>>>        Function_Return True
13061>>>    End_Function
13062>>>    
13062>>>    // logout of this managed connection id. If Id does not exist, do nothing
13062>>>    // note that logging out closes all tables for this connection
13062>>>    Procedure LogoutConnectionId String sId
13064>>>        Handle hoCli
13064>>>        String sDriver sServer
13064>>>        Get ConnectionIdCLIHandler sId to hoCLI
13065>>>        If hoCLI Begin
13067>>>            Get psDriverID of hoCli to sDriver
13068>>>            Get ConnectionIDServerString sId to sServer
13069>>>            Logout sDriver sServer
13070>>>        End
13070>>>>
13070>>>    End_Procedure
13071>>>    
13071>>>    // delete this managed connection id. If Id does not exist, do nothing
13071>>>    // if logged in raise a programming error.
13071>>>    Procedure DeleteConnectionId String sId
13073>>>        Handle hoCli
13073>>>        Integer iResult
13073>>>        Boolean bOk bLoggedIn
13073>>>        Get ConnectionIdCLIHandler sId to hoCli
13074>>>        If hoCLI Begin
13076>>>            // if the connection is logged in, this is an error. Precede this call with
13076>>>            // LogoutConnectionId. This is not done automatically so it is clear to the
13076>>>            // developer that they are logging out of existing connections, which closes
13076>>>            // open tables.
13076>>>            Get IsConnectionIdLoggedIn sId to bLoggedIn
13077>>>            If bLoggedIn Begin
13079>>>                Error DFERR_PROGRAM (SFormat("Connection ID '%1' is still logged-in and cannot be deleted",sId))
13080>>>>
13080>>>                Procedure_Return
13081>>>            End
13081>>>>
13081>>>            Get DeleteConnectionID of hoCli sId -1 to iResult
13082>>>            Get RemoveFromConnections sId to bOk
13083>>>        End
13083>>>>
13083>>>    End_Procedure
13084>>>    
13084>>>    
13084>>>    // login to all managed connection Ids for all drivers
13084>>>    // if error return false on first failure
13084>>>    Function LoginAllConnections Returns Boolean
13086>>>        tConnection[] ConnIds
13086>>>        tConnection[] ConnIds
13087>>>        Integer i iResult
13087>>>        Get ConnectionIDs to ConnIds
13088>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13094>>>>
13094>>>            Get LoginConnectionId ConnIds[i].sId to iResult
13095>>>            If (iResult) Begin
13097>>>                Function_Return False
13098>>>            End
13098>>>>
13098>>>        Loop
13099>>>>
13099>>>        Function_Return True
13100>>>    End_Function
13101>>>    
13101>>>    // logout of all managed connections for all drivers
13101>>>    Procedure LogoutAllConnections
13103>>>        tConnection[] ConnIds
13103>>>        tConnection[] ConnIds
13104>>>        Integer i
13104>>>        Get ConnectionIDs to ConnIds
13105>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13111>>>>
13111>>>            Send LogoutConnectionId ConnIds[i].sId
13112>>>        Loop
13113>>>>
13113>>>    End_Procedure
13114>>>    
13114>>>    // "unregister" all managed connections for all drivers
13114>>>    // Logout and then delete the connection. Note there is no DeleteAllConnections
13114>>>    // because you will always want to logout and delete in a single step.
13114>>>    Procedure UnRegisterAllConnections
13116>>>        tConnection[] ConnIds
13116>>>        tConnection[] ConnIds
13117>>>        Integer i
13117>>>        Get ConnectionIDs to ConnIds
13118>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13124>>>>
13124>>>            Send LogoutConnectionId ConnIds[i].sId
13125>>>            Send DeleteConnectionId ConnIds[i].sId
13126>>>        Loop
13127>>>>
13127>>>    End_Procedure
13128>>>    
13128>>>    // you can redefine a connection-string for a logged in server and all open tables will get
13128>>>    // redirected to the new connection. You can choose to leave the old connection open so if you switch back
13128>>>    // it can be done quickly.
13128>>>    // This assumes that two servers contain the same tables with the same definitions. If they don't things
13128>>>    // will not work. It is the developer's responsibility to make sure this is the case.
13128>>>    // Use with care.
13128>>>    Function RedirectConnectionId String sId String sServer String sUID String sPWD Boolean bTrusted Boolean bKeepOpen Returns Boolean
13130>>>        Handle hoCli
13130>>>        Integer iIndex iRet
13130>>>        tConnection[] Connections
13130>>>        tConnection[] Connections
13131>>>        tConnection Connection
13131>>>        tConnection Connection
13131>>>        String sConnectString
13131>>>        
13131>>>        Get ConnectionIdIndex sId to iIndex
13132>>>        If (iIndex=-1) Begin
13134>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13135>>>>
13135>>>            Function_Return 1
13136>>>        End
13136>>>>
13136>>>        
13136>>>        Get ConnectionIdCLIHandler sId to hoCli
13137>>>        Get pConnections to Connections
13138>>>        Move Connections[iIndex] to Connection
13139>>>        
13139>>>        Get AssembleConnectionString sServer sUID sPWD bTrusted to sConnectString
13140>>>        Move sServer to Connection.sString
13141>>>        Move sUID to Connection.sUID
13142>>>        Move sPWD to Connection.sPWD
13143>>>        Move bTrusted to Connection.bTrustedConnection
13144>>>        Move sConnectString to Connection.sConnectionString
13145>>>        Get ConnectionIDServerString sId to sId
13146>>>        
13146>>>        Send TrapErrors
13147>>>        Get RedirectIdConnectString of hoCli sId sConnectString bKeepOpen to iRet
13148>>>        Send UnTrapErrors
13149>>>        // if 1, we have the ID but it must not be not logged-in. We can still
13149>>>        // switch to the non-logged in connection
13149>>>        If (iRet=0 or iRet=1) Begin
13151>>>            // if all is ok, update the connection info
13151>>>            Move Connection to Connections[iIndex]
13152>>>            Set pConnections to Connections
13153>>>            Move 0 to iRet
13154>>>            Set piErrorNumber to 0
13155>>>        End
13155>>>>
13155>>>        Function_Return (iRet=0)
13156>>>    End_Function
13157>>>    
13157>>>    // This gets sent when a mangaged driver is registerd (it might already be loaded).
13157>>>    // Can be used to set CLI driver settings like use-cache etc.
13157>>>    Procedure OnDriverRegistered String sDriver Integer iDriver Handle hoCLIHandler
13159>>>    End_Procedure
13160>>>    
13160>>>    
13160>>>    // this can be used to do whatever you want to the various connection
13160>>>    // info. You might use this to handle your own default UID/PWD enoding logic
13160>>>    // etc.
13160>>>    Procedure OnAddConnection tConnection ByRef Connection
13162>>>    End_Procedure
13163>>>    
13163>>>    Function WriteConnectionsIniString Handle hoIniFile String sSection String sKey String sValue Returns Integer
13165>>>        Integer iErrorNumber
13165>>>        Send TrapErrors
13166>>>        Send WriteString of hoIniFile sSection sKey sValue
13167>>>        Send UnTrapErrors
13168>>>        Get piErrorNumber to iErrorNumber
13169>>>        Function_Return iErrorNumber
13170>>>    End_Function
13171>>>    
13171>>>    // update the connections ini file with passed Ids. Note that the section name
13171>>>    // for each ID is not the name that will be written. It exists if this was the
13171>>>    // initial section name.
13171>>>    Function WriteConnectionsIni String sQFile tConnection[] Ids Returns Boolean
13173>>>        Integer i iErrorNumber iIndex iSec iSections
13173>>>        String  sDriver sValue sPWD sSection
13173>>>        Handle hoIniFile hoArray hoSection
13173>>>        Boolean bOk bExists
13173>>>        String[] Keys Values
13175>>>        tConnectionIniSection[] Sections
13175>>>        tConnectionIniSection[] Sections
13176>>>        tConnectionIniSection SectionTarget
13176>>>        tConnectionIniSection SectionTarget
13176>>>        
13176>>>        // if filename not passed, use the default
13176>>>        If (sQFile="") Begin
13178>>>            Get ConnectionIniFile of ghoConnection to sQFile
13179>>>        End
13179>>>>
13179>>>        
13179>>>        Get Create (RefClass(cIniFile)) to hoIniFile
13180>>>        Get Create (RefClass(Array)) to hoArray
13181>>>        Get Create (RefClass(Array)) to hoSection
13182>>>        Set psFilename of hoIniFile to sQFile
13183>>>        
13183>>>        // first save off all info from an existing section name. This section may get
13183>>>        // renamed but we want to write it out later under that new section name. Hence
13183>>>        // we must store all values.
13183>>>        For i from 0 to (SizeOfArray(Ids)-1)
13189>>>>
13189>>>            If (Ids[i].sSection<>"") Begin
13191>>>                Get SectionExists of hoIniFile Ids[i].sSection to bExists
13192>>>                If bExists Begin
13194>>>                    Move (Lowercase(Ids[i].sSection)) to sSection
13195>>>                    Move sSection to Sections[iSections].sSection
13196>>>                    Send Delete_Data of hoSection
13197>>>                    Send ReadSection of hoIniFile sSection hoSection
13198>>>                    For iSec from 0 to (Item_Count(hoSection)-1)
13204>>>>
13204>>>                        Get Value of hoSection iSec to Sections[iSections].Keys[iSec]
13205>>>                        Get ReadString of hoIniFile sSection Sections[iSections].Keys[iSec] "" to Sections[iSections].Values[iSec]
13206>>>                    Loop
13207>>>>
13207>>>                    Increment iSections
13208>>>                End
13208>>>>
13208>>>            End
13208>>>>
13208>>>        Loop
13209>>>>
13209>>>        
13209>>>        // Now remove all existing connection sections
13209>>>        Send ReadSections of hoIniFile hoArray
13210>>>        For i from 0 to (Item_Count(hoArray) -1)
13216>>>>
13216>>>            Get Value of hoArray i to sSection
13217>>>            Move (Trim(sSection)) to sSection
13218>>>            If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
13220>>>                Send DeleteSection of hoIniFile sSection
13221>>>            End
13221>>>>
13221>>>            If (iErrorNumber<>0) ;                Break
13224>>>        Loop
13225>>>>
13225>>>        
13225>>>        // now write the new connections, with each connection renamed.
13225>>>        For i from 0 to (SizeOfArray(Ids)-1)
13231>>>>
13231>>>            Move (C_ConnectionIniSectionBaseName+String(i+1)) to sSection
13232>>>            
13232>>>            // if the section already existed, write all existing data back under what
13232>>>            // might be a new section name. Some of this may get overridden below
13232>>>            Move (Lowercase(Ids[i].sSection)) to SectionTarget.sSection
13233>>>            Move (SearchArray(SectionTarget,Sections)) to iIndex
13234>>>            If (iIndex<>-1) Begin
13236>>>                For iSec from 0 to (SizeOfArray(Sections[iIndex].Keys)-1)
13242>>>>
13242>>>                    Get WriteConnectionsIniString hoIniFile sSection Sections[iIndex].Keys[iSec] Sections[iIndex].Values[iSec] to iErrorNumber
13243>>>                    If iErrorNumber ;                        Break
13246>>>                Loop
13247>>>>
13247>>>            End
13247>>>>
13247>>>            If iErrorNumber ;                Break
13250>>>            
13250>>>            // now write / overwrite new data
13250>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionId Ids[i].sId to iErrorNumber
13251>>>            If iErrorNumber ;                Break
13254>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDriver Ids[i].sDriver to iErrorNumber
13255>>>            If iErrorNumber ;                Break
13258>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionConnection Ids[i].sString to iErrorNumber
13259>>>            If iErrorNumber ;                Break
13262>>>
13262>>>            If (Ids[i].bDisabled) Begin
13264>>>                Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDisabled "yes" to iErrorNumber
13265>>>            End
13265>>>>
13265>>>            Else Begin
13266>>>                Send DeleteKey of hoIniFile sSection C_ConnectionIniSectionDisabled
13267>>>            End
13267>>>>
13267>>>            If iErrorNumber ;                Break
13270>>>
13270>>>            Move Ids[i].sPWD to sPWD
13271>>>            If (sPWD<>"") Begin
13273>>>                Get EncryptPassword sPWD to sPWD
13274>>>            End
13274>>>>
13274>>>            
13274>>>            Send OnWriteCredentials sSection Ids[i].sId hoIniFile Ids[i].sUID sPWD Ids[i].bTrustedConnection
13275>>>        Loop
13276>>>>
13276>>>        
13276>>>        Send Destroy of hoSection
13277>>>        Send Destroy of hoArray
13278>>>        Send Destroy of hoIniFile
13279>>>        Function_Return (iErrorNumber=0)
13280>>>    End_Function
13281>>>    
13281>>>    // creates an SQL Connection handler for SQL usage. It is up to you to destroy this
13281>>>    // by default it creates a cSQLConnection object. This can be augmented to create use
13281>>>    // a different class
13281>>>    Function CreateESQLConnectionHandler Returns Handle
13283>>>        Handle hoSQLConnection
13283>>>        Get CreateNamed (RefClass(cSQLConnection)) "oSQLConnectionHandler" to hoSQLConnection
13284>>>        Function_Return hoSQLConnection
13285>>>    End_Function
13286>>>    
13286>>>    // get a new ESQL connection handle for this connection Id.
13286>>>    // Programmer must destroy this handle when done
13286>>>    // Id must exist. Programming error if it does not
13286>>>    Function SQLConnectionId String sId Returns Handle
13288>>>        Handle hoSQLConnection hoCLI
13288>>>        Integer bOK
13288>>>        String sDrvrID sServer
13288>>>        
13288>>>        Get ConnectionIdCLIHandler sId to hoCLI
13289>>>        If hoCLI Begin
13291>>>            Get ConnectionIDServerString sId to sServer
13292>>>            Get psDriverID of hoCLI to sDrvrId
13293>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13294>>>            
13294>>>            // force it to use existing connection
13294>>>            Get SQLConnectionConnect of hoSQLConnection sDrvrID sServer to bOK
13295>>>            
13295>>>            If (not(bOK)) Begin
13297>>>                Send DestroySQLConnection of hoSQLConnection
13298>>>                Move 0 to hoSQLConnection
13299>>>            End
13299>>>>
13299>>>        End
13299>>>>
13299>>>        Else Begin
13300>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13301>>>>
13301>>>        End
13301>>>>
13301>>>        Function_Return hoSQLConnection
13302>>>    End_Function
13303>>>    
13303>>>    // these are interfaces that do not require connection Ids. You can pass a
13303>>>    // driver and a server connect string. Generally there are ID versions of these
13303>>>    // that should be used when possible.
13303>>>    
13303>>>    // is this connection to a server logged in. Pass driver and connect string
13303>>>    // connect string should be INT style. Either full string or DFCONNID=xx
13303>>>    // if driver not loaded, raise an error
13303>>>    Function IsDriverConnectionLoggedIn String sDriver String sConnect Returns Boolean
13305>>>        Handle hConnectionHandle hoCLI
13305>>>        Integer iDriver
13305>>>        Get DriverCLIHandler sDriver to hoCLI
13306>>>        If (hoCLI) Begin
13308>>>            Get DriverIndex sDriver to iDriver
13309>>>            Get ServerDatabaseIdHandle sDriver iDriver sConnect to hConnectionHandle
13310>>>        End
13310>>>>
13310>>>        Else Begin
13311>>>            Error DFERR_PROGRAM (SFormat(C_$DriverNotFound,sDriver))
13312>>>>
13312>>>        End
13312>>>>
13312>>>        Function_Return (hConnectionHandle<>0)
13313>>>    End_Function
13314>>>    
13314>>>    // login to this managed connection via driver and connection string.
13314>>>    // Normally you'd not use this and use LoginConnectionId
13314>>>    // If pbSkipDuplicateLogin=T it will skip the login if it is already connected
13314>>>    // If driver not loaded, attempt to load it.
13314>>>    // If it cannot be loaded, raise a configuration Error
13314>>>    // This is low level - use carefully
13314>>>    Function LoginServer String sDriver String sConnectString String sUID String sPWD Boolean bSilent Returns Integer
13316>>>        Integer iResult iDriver
13316>>>        Handle hoCli
13316>>>        Boolean bSkipDup bConnected bOldSilent
13316>>>        Get RegisterDriver sDriver to hoCLI
13317>>>        If hoCli Begin
13319>>>            Get pbSkipDuplicateLogin to bSkipDup
13320>>>            If (bSkipDup) Begin
13322>>>                Get IsDriverConnectionLoggedIn sDriver sConnectString to bConnected
13323>>>            End
13323>>>>
13323>>>            If not bConnected Begin
13325>>>                Get DriverIndex sDriver to iDriver
13326>>>                // note that passing the server as dfconnid=Id will not recognize bSilent
13326>>>                Get_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13329>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bSilent
13332>>>                Get BasicLogin sDriver sConnectString sUID sPWD to iResult
13333>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13336>>>            End
13336>>>>
13336>>>        End
13336>>>>
13336>>>        Else Begin
13337>>>            // if driver cannot be loaded, an error will be raised in RegisterDriver
13337>>>            Move 1 to iResult
13338>>>        End
13338>>>>
13338>>>        Function_Return iResult
13339>>>    End_Function
13340>>>    
13340>>>    // can connect using any server connect string for this driver
13340>>>    // returns new  ESQL connection handler, which the developer must destroy.
13340>>>    Function SQLConnection String sDriver String sConnect Returns Handle
13342>>>        Handle hoSQLConnection
13342>>>        String sDrvrID
13342>>>        Handle hoCLI
13342>>>        Boolean bOk
13342>>>        
13342>>>        // will raise configuration error if driver cannot be loaded
13342>>>        Get RegisterDriver sDriver to hoCLI
13343>>>        If hoCli Begin
13345>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13346>>>            
13346>>>            // force it to use existing connection
13346>>>            Get SQLConnectionConnect of hoSQLConnection sDriver sConnect to bOK
13347>>>            
13347>>>            If (not(bOK)) Begin
13349>>>                Send DestroySQLConnection of hoSQLConnection
13350>>>                Move 0 to hoSQLConnection
13351>>>            End
13351>>>>
13351>>>            
13351>>>        End
13351>>>>
13351>>>        Function_Return hoSQLConnection
13352>>>    End_Function
13353>>>    
13353>>>    // get a new ESQL connection handle for this open table. Programmer must
13353>>>    // destroy this handle when done
13353>>>    Function SQLConnectionByTable Handle hoTable Returns Handle
13355>>>        Handle hoSQLConnection
13355>>>        Boolean bOk
13355>>>        
13355>>>        Get CreateESQLConnectionHandler to hoSQLConnection
13356>>>        Get SQLFileConnect of hoSQLConnection hoTable to bOk
13357>>>        If (not(bOK)) Begin
13359>>>            Send DestroySQLConnection of hoSQLConnection
13360>>>            Move 0 to hoSQLConnection
13361>>>        End
13361>>>>
13361>>>        
13361>>>        Function_Return hoSQLConnection
13362>>>    End_Function
13363>>>    
13363>>>    // load all managed drivers and set up all managed connections. Abort if a failure
13363>>>    // if you don't want automatic abort, use RegisterAllDrivers and AddAllConnections
13363>>>    // This should succeed - if not it's a programming error
13363>>>    Procedure RegisterAllConnections
13365>>>        Boolean bOk
13365>>>        Get AddAllConnections to bOk
13366>>>        If not bOk Begin
13368>>>            Send UserError "Could not load and register managed drivers. The application cannot be run"
13369>>>            Abort
13370>>>>
13370>>>        End
13370>>>>
13370>>>    End_Procedure
13371>>>    
13371>>>    // Login to all managed connections in all managed drivers. Abort if any fail
13371>>>    // if you don't want automatic abort, use the function LoginAllConnections or
13371>>>    // LoginConnectionId
13371>>>    Procedure LoginAll
13373>>>        Boolean bOk
13373>>>        Integer iError
13373>>>        String sError
13373>>>        Get LoginAllConnections to bOk
13374>>>        If not bOk Begin
13376>>>            Get psErrorText to sError
13377>>>            Get piErrorNumber to iError
13378>>>            Send UserError (C_$LoginAllFailedWillAbort + "\n\n" + sError)
13379>>>            Abort
13380>>>>
13380>>>        End
13380>>>>
13380>>>    End_Procedure
13381>>>    
13381>>>    // Standard Auto-connect behavior.
13381>>>    // if pbAutoConnect is T it does a registerAll & LoginAll and aborts if an error occurs
13381>>>    // if pbAutoConnect is F, it does nothing.
13381>>>    // Note that RegisterAll and LoginIn don't do anything if managed connections are not used.
13381>>>    // This is called by cApplication when a workspace is opened.
13381>>>    Procedure AutoConnect
13383>>>        Boolean bAutoConnect
13383>>>        Get pbAutoConnect to bAutoConnect
13384>>>        If bAutoConnect Begin
13386>>>            Send RegisterAllConnections // might abort on failure
13387>>>            Send LoginAll // might abort on failure
13388>>>        End
13388>>>>
13388>>>    End_Procedure
13389>>>    
13389>>>    // This is called by cApplication when a workspace is opened.
13389>>>    Procedure AutoDisconnect
13391>>>        Boolean bAutoConnect
13391>>>        Get pbAutoConnect to bAutoConnect
13392>>>        If bAutoConnect Begin
13394>>>            Send UnRegisterAllConnections
13395>>>        End
13395>>>>
13395>>>    End_Procedure
13396>>>    
13396>>>    // EnumerateConnections:
13396>>>    // List the current registered connection ids.
13396>>>    //
13396>>>    Procedure EnumerateConnections Handle hoCallBack Handle hmGeneric
13398>>>        tConnection[] ConnIds
13398>>>        tConnection[] ConnIds
13399>>>        Integer i iConnIds
13399>>>        String sConnectionsIni
13399>>>        
13399>>>        Get ConnectionIniFile to sConnectionsIni
13400>>>        
13400>>>        Send hmGeneric of hoCallBack C_$ManagedConnections
13401>>>        Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIniFile, ConnectionIniFile(Self)))
13402>>>        
13402>>>        Get ConnectionIDs to ConnIds
13403>>>        Move (SizeOfArray(ConnIds)) to iConnIds
13404>>>        If (iConnIds=0) Begin
13406>>>            Send hmGeneric of hoCallBack C_$ManagedConnectionsNone
13407>>>        End
13407>>>>
13407>>>        Else Begin
13408>>>            For i from 0 to (iConnIds-1)
13414>>>>
13414>>>                Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIdLine, ConnIds[i].sId, ConnIds[i].sString, ConnIds[i].sDriver))
13415>>>            Loop
13416>>>>
13416>>>        End
13416>>>>
13416>>>    End_Procedure
13417>>>    
13417>>>End_Class
13418>
13418>Object oHtmlHelp is a cHtmlHelp
13420>End_Object
13421>
13421>Object oApplication is a cApplication
13423>
13423>    Object oConnection is a cConnection
13425>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\LoginEncryption.pkg)
13425>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLoginEncryption.pkg)
13425>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCryptographerEx.pkg)
13425>>>>>>>Use VdfBase.pkg
13425>>>>>>>
13425>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.0\Pkg\CryptographerConstants.pkg)
13425>>>>>>>>>//   Author  : Ulbe Stellema
13425>>>>>>>>>// Algorithm classes
13425>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
13425>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
13425>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
13425>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
13425>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
13425>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
13425>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
13425>>>>>>>>>
13425>>>>>>>>>// Algorithm types
13425>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
13425>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
13425>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
13425>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
13425>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
13425>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
13425>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
13425>>>>>>>>>
13425>>>>>>>>>// Generic sub-ids
13425>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
13425>>>>>>>>>
13425>>>>>>>>>// RSA sub-ids
13425>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
13425>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
13425>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
13425>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
13425>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
13425>>>>>>>>>
13425>>>>>>>>>// DSS sub-ids
13425>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
13425>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
13425>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
13425>>>>>>>>>
13425>>>>>>>>>// DES sub_ids
13425>>>>>>>>>Define ALG_SID_DES                      for 1
13425>>>>>>>>>Define ALG_SID_3DES                     for 3
13425>>>>>>>>>Define ALG_SID_DESX                     for 4
13425>>>>>>>>>Define ALG_SID_IDEA                     for 5
13425>>>>>>>>>Define ALG_SID_CAST                     for 6
13425>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
13425>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
13425>>>>>>>>>Define ALG_SID_3DES_112                 for 9
13425>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
13425>>>>>>>>>Define ALG_SID_RC5                      for 13
13425>>>>>>>>>Define ALG_SID_AES_128                  for 14
13425>>>>>>>>>Define ALG_SID_AES_192                  for 15
13425>>>>>>>>>Define ALG_SID_AES_256                  for 16
13425>>>>>>>>>Define ALG_SID_AES                      for 17
13425>>>>>>>>>
13425>>>>>>>>>// Fortezza sub-ids
13425>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
13425>>>>>>>>>Define ALG_SID_TEK                      for 11
13425>>>>>>>>>
13425>>>>>>>>>// RC2 sub-ids
13425>>>>>>>>>Define ALG_SID_RC2                      for 2
13425>>>>>>>>>
13425>>>>>>>>>// Stream cipher sub-ids
13425>>>>>>>>>Define ALG_SID_RC4                      for 1
13425>>>>>>>>>Define ALG_SID_SEAL                     for 2
13425>>>>>>>>>
13425>>>>>>>>>// Diffie-Hellman sub-ids
13425>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
13425>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
13425>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
13425>>>>>>>>>Define ALG_SID_KEA                      for 4
13425>>>>>>>>>
13425>>>>>>>>>// Hash sub ids
13425>>>>>>>>>Define ALG_SID_MD2                      for 1
13425>>>>>>>>>Define ALG_SID_MD4                      for 2
13425>>>>>>>>>Define ALG_SID_MD5                      for 3
13425>>>>>>>>>Define ALG_SID_SHA                      for 4
13425>>>>>>>>>Define ALG_SID_SHA1                     for 4
13425>>>>>>>>>Define ALG_SID_MAC                      for 5
13425>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
13425>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
13425>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
13425>>>>>>>>>Define ALG_SID_HMAC                     for 9
13425>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
13425>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
13425>>>>>>>>>Define ALG_SID_SHA_256                  for 12
13425>>>>>>>>>Define ALG_SID_SHA_384                  for 13
13425>>>>>>>>>Define ALG_SID_SHA_512                  for 14
13425>>>>>>>>>
13425>>>>>>>>>// secure channel sub ids
13425>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
13425>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
13425>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
13425>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
13425>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
13425>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
13425>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
13425>>>>>>>>>
13425>>>>>>>>>// algorithm identifier definitions
13425>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
13425>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
13425>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
13425>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
13425>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
13425>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
13425>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13425>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
13425>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
13425>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13425>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
13425>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
13425>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
13425>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
13425>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
13425>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
13425>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
13425>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
13425>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
13425>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
13425>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
13425>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
13425>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
13425>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
13425>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
13425>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
13425>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
13425>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
13425>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
13425>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
13425>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
13425>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
13425>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
13425>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
13425>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
13425>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
13425>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
13425>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
13425>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
13425>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
13425>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
13425>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
13425>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
13425>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
13425>>>>>>>>>
13425>>>>>>>>>// Providers
13425>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
13425>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
13425>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
13425>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
13425>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
13425>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
13425>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
13425>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
13425>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
13425>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
13425>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
13425>>>>>>>>>
13425>>>>>>>>>// dwFlags definitions for CryptAcquireContext
13425>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
13425>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
13425>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
13425>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
13425>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
13425>>>>>>>>>
13425>>>>>>>>>// dwFlag definitions for CryptGenKey
13425>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
13425>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
13425>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
13425>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
13425>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
13425>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
13425>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
13425>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
13425>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
13425>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
13425>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
13425>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
13425>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
13425>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
13425>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
13425>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
13425>>>>>>>>>
13425>>>>>>>>>// Provider types
13425>>>>>>>>>Define PROV_RSA_FULL                    for 1
13425>>>>>>>>>Define PROV_RSA_SIG                     for 2
13425>>>>>>>>>Define PROV_DSS                         for 3
13425>>>>>>>>>Define PROV_FORTEZZA                    for 4
13425>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
13425>>>>>>>>>Define PROV_SSL                         for 6
13425>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
13425>>>>>>>>>Define PROV_DSS_DH                      for 13
13425>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
13425>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
13425>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
13425>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
13425>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
13425>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
13425>>>>>>>>>Define PROV_RNG                         for 21
13425>>>>>>>>>Define PROV_INTEL_SEC                   for 22
13425>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
13425>>>>>>>>>Define PROV_RSA_AES                     for 24
13425>>>>>>>>>
13425>>>>>>>>>// KP_MODE
13425>>>>>>>>>// KP_MODE
13425>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
13425>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
13425>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
13425>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
13425>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
13425>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
13425>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
13425>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
13425>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
13425>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
13425>>>>>>>>>
13425>>>>>>>>>// dwParam definitions for CryptGetKeyParam
13425>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
13425>>>>>>>>>Define KP_SALT                          for 2       // Salt value
13425>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
13425>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
13425>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
13425>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
13425>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
13425>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
13425>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
13425>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
13425>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
13425>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
13425>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
13425>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
13425>>>>>>>>>Define KP_Y                             for 15      // Y value
13425>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
13425>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
13425>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
13425>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
13425>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
13425>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
13425>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
13425>>>>>>>>>Define KP_RP                            for 23
13425>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
13425>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
13425>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
13425>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
13425>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
13425>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
13425>>>>>>>>>Define KP_KEYVAL                        for 30
13425>>>>>>>>>Define KP_ADMIN_PIN                     for 31
13425>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
13425>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
13425>>>>>>>>>Define KP_PREHASH                       for 34
13425>>>>>>>>>Define KP_ROUNDS                        for 35
13425>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
13425>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
13425>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
13425>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
13425>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
13425>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
13425>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
13425>>>>>>>>>
13425>>>>>>>>>// dwParam definitions for CryptGetHashParam
13425>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
13425>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
13425>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
13425>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
13425>>>>>>>>>
13425>>>>>>>>>// key BLOB types
13425>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
13425>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
13425>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
13425>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
13425>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
13425>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
13425>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
13425>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
13425>>>>>>>>>
13425>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
13425>>>>>>>>>
13425>>>>>>>>>// KP_PADDING
13425>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
13425>>>>>>>>>Define RANDOM_PADDING                   for 2
13425>>>>>>>>>Define ZERO_PADDING                     for 3
13425>>>>>>>>>
13425>>>>>>>>>//  Structure cryptimportkey
13425>>>>>>>>>Struct PUBLICKEYSTRUC
13425>>>>>>>>>    UChar    bType
13425>>>>>>>>>    UChar    bVersion
13425>>>>>>>>>    UShort   reserved
13425>>>>>>>>>    UInteger aiKeyAlg
13425>>>>>>>>>End_Struct
13425>>>>>>>>>
13425>>>>>>>>>Struct tPLAINTEXTKEYBLOB
13425>>>>>>>>>    PUBLICKEYSTRUC hdr
13425>>>>>>>>>    PUBLICKEYSTRUC hdr
13425>>>>>>>>>    UInteger       dwKeySize
13425>>>>>>>>>//    UChar[]        rgbKeyData
13425>>>>>>>>>End_Struct
13425>>>>>>>>>
13425>>>>>>>>>
13425>>>>>>>>>
13425>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
13425>>>>>>>>>Struct HMAC_INFO
13425>>>>>>>>>    UInteger HashAlgid
13425>>>>>>>>>    Pointer pbInnerString
13425>>>>>>>>>    DWord cbInnerString
13425>>>>>>>>>    Pointer pbOuterString
13425>>>>>>>>>    DWord cbOuterString
13425>>>>>>>>>End_Struct
13425>>>>>>>>>
13425>>>>>>>>>Struct BLOBHEADER
13425>>>>>>>>>    UChar   bType
13425>>>>>>>>>    UChar   bVersion
13425>>>>>>>>>    Short   reserved
13425>>>>>>>>>    Integer aiKeyAlg
13425>>>>>>>>>End_Struct
13425>>>>>>>>>
13425>>>>>>>>>Struct CryptoBlob
13425>>>>>>>>>    BLOBHEADER  header
13425>>>>>>>>>    BLOBHEADER  header
13425>>>>>>>>>    Integer     cbKeySize
13425>>>>>>>>>    UChar[32]   rgbKeyData
13425>>>>>>>>>End_Struct
13425>>>>>>>>>
13425>>>>>>>>>
13425>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
13425>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13426>>>>>>>>>
13426>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
13426>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13428>>>>>>>>>    
13428>>>>>>>>>    Boolean bResult
13428>>>>>>>>>    UWide   uwContainer uwProvider
13428>>>>>>>>>    UWide   uwContainer uwProvider
13428>>>>>>>>>
13428>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
13429>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
13430>>>>>>>>>    
13430>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
13431>>>>>>>>>
13431>>>>>>>>>    Function_Return bResult
13432>>>>>>>>>End_Function
13433>>>>>>>>>
13433>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
13434>>>>>>>>>
13434>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
13435>>>>>>>>>
13435>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
13436>>>>>>>>>
13436>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
13437>>>>>>>>>
13437>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13438>>>>>>>>>
13438>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
13439>>>>>>>>>
13439>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
13440>>>>>>>>>
13440>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13441>>>>>>>>>
13441>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
13442>>>>>>>>>    
13442>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
13443>>>>>>>>>
13443>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
13444>>>>>>>>>
13444>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13445>>>>>>>>>
13445>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
13446>>>>>>>>>    
13446>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
13447>>>>>>>>>    
13447>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13448>>>>>>>>>    
13448>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13449>>>>>>>
13449>>>>>>>Class cCryptographerEx is a cObject
13450>>>>>>>    
13450>>>>>>>    Procedure Construct_Object
13452>>>>>>>        Forward Send Construct_Object
13454>>>>>>>        
13454>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
13455>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
13456>>>>>>>        Property Integer    piCipher    CALG_RC4
13457>>>>>>>        Property Integer    piHash      CALG_MD5
13458>>>>>>>        
13458>>>>>>>        // Private properties
13458>>>>>>>        Property Handle     Private_phProv
13459>>>>>>>        
13459>>>>>>>        // Block cipher properties
13459>>>>>>>        Property UChar[]    paKey
13460>>>>>>>        Property UChar[]    paIV
13461>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
13462>>>>>>>        Property Integer    piKeyType       CALG_AES_256
13463>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
13464>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
13465>>>>>>>        Property Integer    piBlockSize     16
13466>>>>>>>    End_Procedure
13467>>>>>>>    
13467>>>>>>>    
13467>>>>>>>    // Acquire key container handle
13467>>>>>>>    Function AcquireContext Returns Handle
13469>>>>>>>        Integer iProvider
13469>>>>>>>        WString wProvider
13469>>>>>>>        Handle hProv
13469>>>>>>>        Boolean bOk
13469>>>>>>>        Pointer pProv
13469>>>>>>>        
13469>>>>>>>        Move 0 to hProv
13470>>>>>>>        Get piProvider to iProvider
13471>>>>>>>        Get psProvider to wProvider
13472>>>>>>>        
13472>>>>>>>        //  Determine address to be passed as provider
13472>>>>>>>        If (Trim(wProvider) <> "") Begin
13474>>>>>>>            Move (AddressOf(wProvider)) to pProv
13475>>>>>>>        End
13475>>>>>>>>
13475>>>>>>>        Else Begin
13476>>>>>>>            Move 0 to pProv
13477>>>>>>>        End
13477>>>>>>>>
13477>>>>>>>        
13477>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
13477>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
13478>>>>>>>        If (not(bOk) or hProv = 0) Begin
13480>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
13481>>>>>>>        End
13481>>>>>>>>
13481>>>>>>>        
13481>>>>>>>        If (not(bOk) or hProv = 0) Begin
13483>>>>>>>            // Fallback to original
13483>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
13484>>>>>>>            
13484>>>>>>>            If (not(bOk) or hProv = 0) Begin
13486>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
13487>>>>>>>            End
13487>>>>>>>>
13487>>>>>>>        End
13487>>>>>>>>
13487>>>>>>>        Set Private_phProv to hProv
13488>>>>>>>        
13488>>>>>>>        Function_Return hProv
13489>>>>>>>    End_Function
13490>>>>>>>    
13490>>>>>>>    // Releases key container handle
13490>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
13492>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
13493>>>>>>>    End_Function
13494>>>>>>>    
13494>>>>>>>    // Creates hash object
13494>>>>>>>    Function CreateHash Handle hProv Returns Handle
13496>>>>>>>        Integer iAlgorithm
13496>>>>>>>        Handle hHash
13496>>>>>>>        Boolean bOk
13496>>>>>>>        
13496>>>>>>>        Move 0 to hHash
13497>>>>>>>        Get piHash to iAlgorithm
13498>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
13499>>>>>>>        
13499>>>>>>>        Function_Return hHash
13500>>>>>>>    End_Function
13501>>>>>>>    
13501>>>>>>>    // Destroys the hash object
13501>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
13503>>>>>>>        Function_Return (CryptDestroyHash(hHash))
13504>>>>>>>    End_Function
13505>>>>>>>    
13505>>>>>>>    // Adds data to hash object
13505>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
13507>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
13508>>>>>>>    End_Function
13509>>>>>>>    
13509>>>>>>>    // Generates session key
13509>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
13511>>>>>>>        Integer iAlgorithm
13511>>>>>>>        Handle hKey
13511>>>>>>>        Boolean bOk
13511>>>>>>>        
13511>>>>>>>        Move 0 to hKey
13512>>>>>>>        Get piCipher to iAlgorithm
13513>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
13514>>>>>>>        
13514>>>>>>>        Function_Return hKey
13515>>>>>>>    End_Function
13516>>>>>>>    
13516>>>>>>>    // Imports a plain text key
13516>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
13518>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13518>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13518>>>>>>>        Boolean   bSuccess
13518>>>>>>>        Handle    hKey
13518>>>>>>>        Integer   iHeadSize iKeySize
13518>>>>>>>        UChar[]   ucaKeyblob
13519>>>>>>>        Integer iVoid
13519>>>>>>>        
13519>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
13520>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
13521>>>>>>>        
13521>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
13522>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
13523>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
13524>>>>>>>        Move iKeySize           to blobhead.dwKeySize
13525>>>>>>>        
13525>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
13526>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
13527>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
13528>>>>>>>        
13528>>>>>>>        Move 0 to hKey
13529>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
13530>>>>>>>        If (not(bSuccess)) Begin
13532>>>>>>>            Move (ShowLastError()) to iVoid
13533>>>>>>>        End
13533>>>>>>>>
13533>>>>>>>        
13533>>>>>>>        Function_Return hKey
13534>>>>>>>    End_Function
13535>>>>>>>    
13535>>>>>>>    // Destroys the key
13535>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
13537>>>>>>>        Function_Return (CryptDestroyKey(hKey))
13538>>>>>>>    End_Function
13539>>>>>>>    
13539>>>>>>>    // Retrieves key data
13539>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
13541>>>>>>>        Integer iBuffer iLen
13541>>>>>>>        Boolean bOk
13541>>>>>>>        
13541>>>>>>>        Move (SizeOfType(Integer)) to iLen
13542>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
13543>>>>>>>        Function_Return iBuffer
13544>>>>>>>    End_Function
13545>>>>>>>    
13545>>>>>>>    // Retrieves a hash value
13545>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
13547>>>>>>>        UChar[] ucHash
13548>>>>>>>        Integer liResult
13548>>>>>>>        DWord   dwDataLen
13548>>>>>>>        
13548>>>>>>>        Move 0 to dwDataLen
13549>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
13550>>>>>>>        If (liResult = 0) ;            Function_Return ""
13553>>>>>>>        
13553>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
13554>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
13555>>>>>>>        If (liResult = 0) ;            Function_Return ""
13558>>>>>>>        
13558>>>>>>>        Function_Return ucHash
13559>>>>>>>    End_Function
13560>>>>>>>
13560>>>>>>>    // Encrypts data
13560>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13562>>>>>>>        Handle hProv hHash hKey
13562>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
13562>>>>>>>        Boolean bOk
13562>>>>>>>        
13562>>>>>>>        Get AcquireContext to hProv
13563>>>>>>>        If (hProv) Begin
13565>>>>>>>            Get CreateHash hProv to hHash
13566>>>>>>>            If (hHash) Begin
13568>>>>>>>                Get HashData hHash ucPassword to bOk
13569>>>>>>>                If (bOk) Begin
13571>>>>>>>                    Get piCipher to iAlgorithm
13572>>>>>>>                    Get DeriveKey hProv hHash to hKey
13573>>>>>>>                End
13573>>>>>>>>
13573>>>>>>>                Get DestroyHash hHash to bOk
13574>>>>>>>            End
13574>>>>>>>>
13574>>>>>>>            
13574>>>>>>>            If (hKey) Begin
13576>>>>>>>                //  First call to determine resulting data size
13576>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13577>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
13578>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
13579>>>>>>>                
13579>>>>>>>                //  Reserve space in string
13579>>>>>>>                If (iDataLen < iCipherLen) Begin
13581>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
13582>>>>>>>                End
13582>>>>>>>>
13582>>>>>>>                
13582>>>>>>>                //  Call to really decrypt
13582>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
13583>>>>>>>                //If (not(bOk)) Begin
13583>>>>>>>                //Move "" to sData
13583>>>>>>>                //Move (GetLastError()) to iErr
13583>>>>>>>                //End
13583>>>>>>>                
13583>>>>>>>                Get DestroyKey hKey to bOk
13584>>>>>>>            End 
13584>>>>>>>>
13584>>>>>>>            Get ReleaseContext hProv to bOk
13585>>>>>>>        End 
13585>>>>>>>>
13585>>>>>>>        Function_Return ucData
13586>>>>>>>    End_Function
13587>>>>>>>    
13587>>>>>>>    // Decrypts data
13587>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13589>>>>>>>        Handle hProv hHash hKey
13589>>>>>>>        Integer iAlgorithm iDataLen
13589>>>>>>>        Boolean bOk
13589>>>>>>>        
13589>>>>>>>        Get AcquireContext to hProv
13590>>>>>>>        If (hProv) Begin
13592>>>>>>>            Get CreateHash hProv to hHash
13593>>>>>>>            If (hHash) Begin
13595>>>>>>>                Get HashData hHash ucPassword to bOk
13596>>>>>>>                If (bOk) Begin
13598>>>>>>>                    Get piCipher to iAlgorithm
13599>>>>>>>                    Get DeriveKey hProv hHash to hKey
13600>>>>>>>                End
13600>>>>>>>>
13600>>>>>>>                Get DestroyHash hHash to bOk
13601>>>>>>>            End
13601>>>>>>>>
13601>>>>>>>            
13601>>>>>>>            If (hKey) Begin
13603>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13604>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
13605>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
13605>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
13607>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
13608>>>>>>>                End
13608>>>>>>>>
13608>>>>>>>                
13608>>>>>>>                Get DestroyKey hKey to bOk
13609>>>>>>>            End
13609>>>>>>>>
13609>>>>>>>            Get ReleaseContext hProv to bOk
13610>>>>>>>        End
13610>>>>>>>>
13610>>>>>>>        Function_Return ucData
13611>>>>>>>    End_Function
13612>>>>>>>    
13612>>>>>>>    // Creates a key
13612>>>>>>>    Function CreateKey Handle hProv Returns Handle
13614>>>>>>>        Integer iAlg iType iByte iLength iSize
13614>>>>>>>        CryptoBlob keyBlob
13614>>>>>>>        CryptoBlob keyBlob
13614>>>>>>>        Boolean bOk
13614>>>>>>>        Handle hKey
13614>>>>>>>        UChar[] aKey
13615>>>>>>>
13615>>>>>>>        Get paKey to aKey
13616>>>>>>>        Get piKeyAlg to iAlg
13617>>>>>>>        Get piKeyType to iType
13618>>>>>>>        Move iAlg                   to keyBlob.header.bType
13619>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
13620>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
13621>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
13622>>>>>>>        
13622>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
13623>>>>>>>        For iByte from 0 to iLength
13629>>>>>>>>
13629>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
13630>>>>>>>        Loop
13631>>>>>>>>
13631>>>>>>>        
13631>>>>>>>        Move 0 to hKey
13632>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
13633>>>>>>>        Function_Return hKey
13634>>>>>>>    End_Function
13635>>>>>>>    
13635>>>>>>>    // Sets the key parameters
13635>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
13637>>>>>>>        Integer iPadding iMode
13637>>>>>>>        Boolean bOk
13637>>>>>>>        UChar[] aIV
13638>>>>>>>        
13638>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
13638>>>>>>>        //For iByte from 0 to iLength
13638>>>>>>>        //    Move iByte to aIV[iByte]
13638>>>>>>>        //Loop
13638>>>>>>>
13638>>>>>>>        // Set initialization vector
13638>>>>>>>        Get paIV to aIV
13639>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
13640>>>>>>>        If (bOk) Begin
13642>>>>>>>            // Set padding
13642>>>>>>>            Get piKeyPadding to iPadding
13643>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
13644>>>>>>>            If (bOk) Begin
13646>>>>>>>                // Set move
13646>>>>>>>                Get piKeyMode to iMode
13647>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
13648>>>>>>>            End
13648>>>>>>>>
13648>>>>>>>        End
13648>>>>>>>>
13648>>>>>>>        Function_Return bOk        
13649>>>>>>>    End_Function
13650>>>>>>>    
13650>>>>>>>    // Encrypts using block cipher
13650>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
13652>>>>>>>        Handle hProv hKey
13652>>>>>>>        Integer iLen iSize iBlocks
13652>>>>>>>        Boolean bOk
13652>>>>>>>        
13652>>>>>>>        Get AcquireContext to hProv
13653>>>>>>>        If (hProv) Begin
13655>>>>>>>            // Create key
13655>>>>>>>            Get CreateKey hProv to hKey
13656>>>>>>>            If (hKey) Begin
13658>>>>>>>                Get SetKeyParameters hKey to bOk
13659>>>>>>>                If (bOk) Begin
13661>>>>>>>                    // Buffer for block ciphers can be up to block length larger
13661>>>>>>>                    Get piBlockSize to iSize
13662>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13663>>>>>>>                    
13663>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
13664>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
13665>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
13666>>>>>>>                End
13666>>>>>>>>
13666>>>>>>>                Get DestroyKey hKey to bOk
13667>>>>>>>            End
13667>>>>>>>>
13667>>>>>>>            Get ReleaseContext hProv to bOk
13668>>>>>>>        End
13668>>>>>>>>
13668>>>>>>>        Function_Return ucData
13669>>>>>>>    End_Function
13670>>>>>>>    
13670>>>>>>>    // Decrypts using block cipher
13670>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
13672>>>>>>>        Handle hProv hKey
13672>>>>>>>        Integer iLen
13672>>>>>>>        Boolean bOk
13672>>>>>>>        
13672>>>>>>>        Get AcquireContext to hProv
13673>>>>>>>        If (hProv) Begin
13675>>>>>>>            // Create key
13675>>>>>>>            Get CreateKey hProv to hKey
13676>>>>>>>            If (hKey) Begin
13678>>>>>>>                Get SetKeyParameters hKey to bOk
13679>>>>>>>                If (bOk) Begin
13681>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13682>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
13683>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
13684>>>>>>>                End
13684>>>>>>>>
13684>>>>>>>                Get DestroyKey hKey to bOk
13685>>>>>>>            End
13685>>>>>>>>
13685>>>>>>>            Get ReleaseContext hProv to bOk
13686>>>>>>>        End
13686>>>>>>>>
13686>>>>>>>        Function_Return ucData
13687>>>>>>>    End_Function
13688>>>>>>>    
13688>>>>>>>    
13688>>>>>>>    //  Generates random data.
13688>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
13690>>>>>>>        Handle hProv
13690>>>>>>>        UChar[] uaResult
13691>>>>>>>        Boolean bRes
13691>>>>>>>        
13691>>>>>>>        Get AcquireContext to hProv
13692>>>>>>>        
13692>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
13693>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
13694>>>>>>>        
13694>>>>>>>        Get ReleaseContext hProv to bRes
13695>>>>>>>        
13695>>>>>>>        Function_Return uaResult
13696>>>>>>>    End_Function
13697>>>>>>>    
13697>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
13697>>>>>>>    Function GenerateRandomString Integer iLength Returns String
13699>>>>>>>        String sResult
13699>>>>>>>        UChar[] ucData
13700>>>>>>>        Pointer pBase64
13700>>>>>>>        Integer iVoid
13700>>>>>>>        
13700>>>>>>>        Get GenerateRandom iLength to ucData
13701>>>>>>>        
13701>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
13702>>>>>>>        Move (PointerToString(pBase64)) to sResult
13703>>>>>>>        Move (Free(pBase64)) to iVoid
13704>>>>>>>        
13704>>>>>>>        Function_Return (Left(sResult, iLength))
13705>>>>>>>    End_Function
13706>>>>>>>    
13706>>>>>>>End_Class
13707>>>>>
13707>>>>>Class cLoginEncryption is a cObject
13708>>>>>    
13708>>>>>    Procedure Construct_Object
13710>>>>>        Forward Send Construct_Object
13712>>>>>        // this must be set to a multi (40ish) character random key
13712>>>>>        Property String psEncryptPassword ""
13713>>>>>        
13713>>>>>        Object oDataCrypter is a cCryptographerEx
13715>>>>>            Set piHash to CALG_SHA_256
13716>>>>>            Set piCipher to CALG_AES_256
13717>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
13718>>>>>            Set piProvider to PROV_RSA_AES
13719>>>>>        End_Object
13720>>>>>    End_Procedure
13721>>>>>    
13721>>>>>    // This can be augmented to return a password encryption key using any
13721>>>>>    // hidden mechanism desired.
13721>>>>>    Function GetEncryptionPassword Returns String
13723>>>>>        String sPassword
13723>>>>>        Get psEncryptPassword to sPassword
13724>>>>>        Function_Return sPassword
13725>>>>>    End_Function
13726>>>>>    
13726>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
13726>>>>>    //
13726>>>>>    // Params:
13726>>>>>    //   sPlainText     String to encrypt.
13726>>>>>    // Returns:
13726>>>>>    //   Base64 encoded hash.
13726>>>>>    Function EncryptPassword String sPlainText Returns String
13728>>>>>        String sEncryptPassword sBase64
13728>>>>>        UChar[] ucBinary
13729>>>>>        Pointer pBase64
13729>>>>>        Integer iVoid
13729>>>>>        
13729>>>>>        //  Encrypt Key
13729>>>>>        Get GetEncryptionPassword to sEncryptPassword
13730>>>>>        If (sEncryptPassword = "") Begin
13732>>>>>            Error DFERR_PROGRAM "No encryption password set"
13733>>>>>>
13733>>>>>        End
13733>>>>>>
13733>>>>>        
13733>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
13734>>>>>        
13734>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
13736>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
13737>>>>>>
13737>>>>>            Function_Return ""
13738>>>>>        End
13738>>>>>>
13738>>>>>        
13738>>>>>        //  Encode binary hash to Base64
13738>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
13739>>>>>        Move (PointerToString(pBase64)) to sBase64
13740>>>>>        Move (Free(pBase64)) to iVoid
13741>>>>>        
13741>>>>>        Function_Return sBase64
13742>>>>>    End_Function
13743>>>>>    
13743>>>>>    
13743>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
13743>>>>>    //
13743>>>>>    // Params:
13743>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
13743>>>>>    // Returns:
13743>>>>>    //   Readable plain text password
13743>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
13745>>>>>        String sEncryptPassword
13745>>>>>        UChar[] ucBinary ucPlain
13747>>>>>        Boolean bIsHex
13747>>>>>        Integer iLen iVoid
13747>>>>>        Pointer pBinary
13747>>>>>        
13747>>>>>        If (sBase64EncryptedPassword <> "") Begin
13749>>>>>            //  Decode from Base64
13749>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
13750>>>>>            
13750>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
13751>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
13752>>>>>                        
13752>>>>>            Move (Free(pBinary)) to iVoid
13753>>>>>            
13753>>>>>            //  Encrypted binary hash to string
13753>>>>>            Get GetEncryptionPassword to sEncryptPassword
13754>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
13755>>>>>        End
13755>>>>>>
13755>>>>>        
13755>>>>>        Function_Return (UCharArrayToString(ucPlain))
13756>>>>>    End_Function
13757>>>>>End_Class
13758>>>
13758>>>Object oLoginEncryption is a cLoginEncryption
13760>>>
13760>>>    // this must be created in your appsrc directory and must contain an encryption
13760>>>    // key that is set to psEncryptPassword. It will look something like this
13760>>>    //
13760>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
13760>>>    //  
Including file: LoginEncryptionKey.inc    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\AppSrc\LoginEncryptionKey.inc)
13760>>>>// Studio generated login encryption key
13760>>>>Set psEncryptPassword to "^EQaqq#xfhp>NK0gd8/^)Hfs(eSL%P^:?YqZY>Zj"
13761>>>>
13761>>>    
13761>>>    // use this to register this object to your cConnection Object. This object
13761>>>    // must be created after the cConnection object
13761>>>    Move Self to ghoLoginEncryption
13762>>>End_Object
13763>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.0\Pkg\DatabaseLoginDialog.dg)
13763>>>
13763>>>Use Windows.pkg
13763>>>Use cConnection.pkg
13763>>>Use dfLine.pkg
Including file: Dfline.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dfline.pkg)
13763>>>>>Use windows.pkg
13763>>>>>
13763>>>>>//
13763>>>>>// Line Styles
13763>>>>>//
13763>>>>>Enumeration_List
13763>>>>>    Define lnDIP        // grey (Shadow) top line, light bottom (highlight)
13763>>>>>    Define lnBUMP       // light top (highlight), grey (Shadow) bottom
13763>>>>>    Define lnSINGLE     // Single dark line
13763>>>>>    Define lnCUSTOM     // create your own with line_color1 & 2.
13763>>>>>End_Enumeration_List
13763>>>>>
13763>>>>>Class LineControl is a DFBaseLineControl
13764>>>>>    
13764>>>>>    Procedure Construct_Object
13766>>>>>        Forward Send Construct_Object
13768>>>>>        Property Integer Line_Color1  COLOR_BTNSHADOW
13769>>>>>        Property Integer Line_Color2  COLOR_BTNHIGHLIGHT
13770>>>>>        // we do not want control to participate in forward backwards object navigation
13770>>>>>        Set Skip_State to True
13771>>>>>    End_Procedure
13772>>>>>    
13772>>>>>    Procedure Notify Longptr wParam Longptr lParam
13774>>>>>    End_Procedure
13775>>>>>    
13775>>>>>    Procedure Set Line_Color1 Integer theColor
13777>>>>>        Set top_line_color to theColor
13778>>>>>    End_Procedure
13779>>>>>    
13779>>>>>    Procedure Set Line_Color2 Integer theColor
13781>>>>>        Set bottom_line_color to theColor
13782>>>>>    End_Procedure
13783>>>>>    
13783>>>>>    Function Line_Color1 Returns Integer
13785>>>>>        Function_Return (top_line_color(Self))
13786>>>>>    End_Function
13787>>>>>    
13787>>>>>    Function Line_Color2 Returns Integer
13789>>>>>        Function_Return (bottom_line_color(Self))
13790>>>>>    End_Function
13791>>>>>End_Class
13792>>>>>
13792>>>
13792>>>Object oDatabaseLoginDialog is a ModalPanel
13794>>>    Set Label to "Database Login"
13795>>>    Set Location to 2 2
13796>>>    Set Size to 110 211
13797>>>    
13797>>>    Property String psId
13799>>>    Property Boolean pbOk False
13801>>>    Property Boolean pbChanged False
13803>>>    Property Boolean pbAllowRemember True
13805>>>    
13805>>>    // this registers this object with the cConnection object.
13805>>>    Move Self to ghoLoginConnectDialog
13806>>>    
13806>>>    Object oUserIDForm is a Form
13808>>>        Set Label to "User Name"
13809>>>        Set Size to 12 85
13810>>>        Set Location to 34 79
13811>>>        Set Label_Col_Offset to 64
13812>>>        Set peAnchors to anTopLeftRight
13813>>>    End_Object
13814>>>    
13814>>>    Object oPwdForm is a Form
13816>>>        Set Size to 12 85
13817>>>        Set Location to 49 79
13818>>>        Set Label_Col_Offset to 64
13819>>>        Set Password_State to True
13820>>>        Set peAnchors to anTopLeftRight
13821>>>        Set Label to "Password"
13822>>>    End_Object
13823>>>    
13823>>>    Object oTrustedConnection is a CheckBox
13825>>>        Set Size to 10 50
13826>>>        Set Location to 65 79
13827>>>        Set Label to "Trusted Connection"
13828>>>    End_Object
13829>>>    
13829>>>    Object oRemember is a CheckBox
13831>>>        Set Size to 10 50
13832>>>        Set Location to 79 14
13833>>>        Set Label to "Remember and don't ask again"
13834>>>        Set Checked_State to True
13835>>>    End_Object
13836>>>    
13836>>>    Object oLogin_btn is a Button
13838>>>        Set Label to "&Login"
13839>>>        Set Location to 92 102
13840>>>        Set peAnchors to anBottomRight
13841>>>        Set Default_State to True
13842>>>        
13842>>>        Procedure OnClick
13845>>>            Boolean bTrust
13845>>>            String sUser sPwd sConn sErr sId
13845>>>            Integer iError
13845>>>            Get psId to sId
13846>>>            Get Value of oUserIDForm to sUser
13847>>>            Get Value of oPwdForm to sPwd
13848>>>            Get Checked_State of oTrustedConnection to bTrust
13849>>>            
13849>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
13850>>>            If (iError=0) Begin
13852>>>                Set pbOk to True
13853>>>                Set pbChanged to True
13854>>>                Send Close_Panel
13855>>>            End
13855>>>>
13855>>>            Else Begin
13856>>>                Get psErrorText of ghoConnection to sErr
13857>>>                Send UserError sErr "Login Error"
13858>>>            End
13858>>>>
13858>>>        End_Procedure
13859>>>    End_Object
13860>>>    
13860>>>    Object oCancel_btn is a Button
13862>>>        Set Label to "&Cancel"
13863>>>        Set Location to 92 157
13864>>>        Set peAnchors to anBottomRight
13865>>>        
13865>>>        Procedure OnClick
13868>>>            Send Close_Panel
13869>>>        End_Procedure
13870>>>    End_Object
13871>>>    
13871>>>    Object oConnectionIdInfo is a TextBox
13873>>>        Set Size to 10 50
13874>>>        Set Location to 4 14
13875>>>        Set Label to 'Connection Id='
13876>>>    End_Object
13877>>>    
13877>>>    Object oConnectionServerInfo is a TextBox
13879>>>        Set Size to 10 50
13880>>>        Set Location to 16 14
13881>>>        Set Label to 'Server'
13882>>>    End_Object
13883>>>    
13883>>>    Object oLineControl1 is a LineControl
13885>>>        Set Size to 2 202
13886>>>        Set Location to 29 5
13887>>>    End_Object
13888>>>    
13888>>>    Function LoginConnectIdDialog String sId Returns Boolean
13891>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
13891>>>        String sUser sPwd sDescription
13891>>>        tConnection Connect
13891>>>        tConnection Connect
13891>>>        
13891>>>        Get pbAllowRemember to bAllowRemember
13892>>>        
13892>>>        
13892>>>        If not bAllowRemember Begin
13894>>>            Set Enabled_State of oRemember to bRemember
13895>>>            Set Visible_State of oRemember to bRemember
13896>>>        End
13896>>>>
13896>>>        
13896>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
13897>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
13898>>>        Set Value of oConnectionServerInfo to Connect.sString
13899>>>        
13899>>>        Set psId to sId
13900>>>        Set pbOk to False
13901>>>        Set pbChanged to False
13902>>>        Set Value of oUserIDForm to Connect.sUID
13903>>>        Set Value of oPwdForm to ""
13904>>>        
13904>>>        Send Popup
13905>>>        
13905>>>        Get pbOk to bOk
13906>>>        Get pbChanged to bChanged
13907>>>        If (bChanged and bOk) Begin
13909>>>            If bAllowRemember Begin
13911>>>                Get Checked_State of oRemember to bRemember
13912>>>                If bRemember Begin
13914>>>                    Get Checked_State of oTrustedConnection to bTrusted
13915>>>                    If not (bTrusted) Begin
13917>>>                        Get Value of oUserIDForm to sUser
13918>>>                        Get Value of oPwdForm to sPwd
13919>>>                    End
13919>>>>
13919>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
13920>>>                End
13920>>>>
13920>>>            End
13920>>>>
13920>>>        End
13920>>>>
13920>>>        Function_Return bOk
13921>>>    End_Function
13922>>>    
13922>>>    
13922>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
13923>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
13924>>>End_Object
13925>>>
13925>    End_Object
13926>
13926>End_Object
13927>
13927>Use LocalBuffer.bp
Including file: LocalBuffer.bp    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\AppSrc\LocalBuffer.bp)
13927>>>Use Batchdd.pkg
Including file: Batchdd.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Batchdd.pkg)
13927>>>>>Use LanguageText.pkg
13927>>>>>
13927>>>>>Use Windows.pkg
13927>>>>>Use StatPnl.pkg    // creates object Status_Panel... only if non webapp
Including file: Statpnl.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Statpnl.pkg)
13927>>>>>>>// creates the standard status_panel object.
13927>>>>>>>//
13927>>>>>>>// This is the default Status Panel object used by any of the DataFlex classes that
13927>>>>>>>// invoke the standard status panel. The standard has always been that the package name
13927>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
13927>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
13927>>>>>>>// prior revisions has been replace with status panel that is part of the application.
13927>>>>>>>// This should work much better and faster than the old sentinel based solution.
13927>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
13927>>>>>>>// with most applications.
13927>>>>>>>//
13927>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
13927>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
13927>>>>>>>// a cleaner more robust interface.
13927>>>>>>>//
13927>>>>>>>//
13927>>>>>>>// Compatibility Note:
13927>>>>>>>//
13927>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
13927>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
13927>>>>>>>//
13927>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
13927>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
13927>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
13927>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
13927>>>>>>>//
13927>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
13927>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
13927>>>>>>>//
13927>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
13927>>>>>>>// can still access the new object via the ghoStatusPanel handle.
13927>>>>>>>//
13927>>>>>>>//
13927>>>>>>>// Creating your own Status Panel objects
13927>>>>>>>//
13927>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
13927>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
13927>>>>>>>// with a different file and object name and direct your status panel request to the new object.
13927>>>>>>>//
13927>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
13927>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
13927>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
13927>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
13927>>>>>>>// e.g.
13927>>>>>>>//       Procedure UpdateStatusBar
13927>>>>>>>//           Send DoAdvance of oProgressBar
13927>>>>>>>//           Send ProcessEvents
13927>>>>>>>//       End_Procedure
13927>>>>>>>//
13927>>>>>>>// Of course, if you use the standard interfaces in status bar and your forward send these
13927>>>>>>>// messages this will be done for you.
13927>>>>>>>//
13927>>>>>>>// the standard Interface for status panels are:
13927>>>>>>>//
13927>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
13927>>>>>>>// Send Start_StatusPanel      - start the status panel
13927>>>>>>>// Send Stop_StatusPanel       - stop the status panel
13927>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
13927>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
13927>>>>>>>//
13927>>>>>>>// Get/Set Caption_Text - updates the caption bar
13927>>>>>>>// Get/Set Title_Text   - updates the title area
13927>>>>>>>// Get/Set Message_Text - updates the Message area
13927>>>>>>>// Get/Set Action_Text  - updates the action area
13927>>>>>>>// Get/Set Button_Text  - updates the button area
13927>>>>>>>//
13927>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
13927>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
13927>>>>>>>//
13927>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
13927>>>>>>>
13927>>>>>>>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cProcessStatusPanel.pkg)
13927>>>>>>>>>// cProcessStatusPanel.pkg
13927>>>>>>>>>//
13927>>>>>>>>>// Class used to create StatusPanels.
13927>>>>>>>>>//
13927>>>>>>>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
13927>>>>>>>>>// interface is provided that is used to update the various areas of status panel. At this level,
13927>>>>>>>>>// those areas (title area, message area, action area, button area) are logical. You create the
13927>>>>>>>>>// physical objects at the object level and then bind these objects to the interface.
13927>>>>>>>>>// Take a look at StatPnl.pkg to see how this is used.
13927>>>>>>>>>//
13927>>>>>>>>>// the standard Interface for status panels are:
13927>>>>>>>>>//
13927>>>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
13927>>>>>>>>>// Send Start_StatusPanel      - start the status panel
13927>>>>>>>>>// Send Stop_StatusPanel       - stop the status panel
13927>>>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
13927>>>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
13927>>>>>>>>>//
13927>>>>>>>>>// Get/Set Caption_Text - updates the caption bar
13927>>>>>>>>>// Get/Set Title_Text   - updates the title area
13927>>>>>>>>>// Get/Set Message_Text - updates the Message area
13927>>>>>>>>>// Get/Set Action_Text  - updates the action area
13927>>>>>>>>>// Get/Set Button_Text  - updates the button area
13927>>>>>>>>>//
13927>>>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
13927>>>>>>>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
13927>>>>>>>>>//
13927>>>>>>>>>
13927>>>>>>>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cStatusPanel.pkg)
13927>>>>>>>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
13927>>>>>>>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
13927>>>>>>>>>>>//
13927>>>>>>>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
13927>>>>>>>>>>>
13927>>>>>>>>>>>Use Windows.pkg
13927>>>>>>>>>>>
13927>>>>>>>>>>>
13927>>>>>>>>>>>
13927>>>>>>>>>>>
13927>>>>>>>>>>>Class cStatusPanel is a FloatingPanel
13928>>>>>>>>>>>    
13928>>>>>>>>>>>    Procedure Construct_Object
13930>>>>>>>>>>>        Forward Send Construct_object
13932>>>>>>>>>>>        
13932>>>>>>>>>>>        Property Boolean pbCancel False
13933>>>>>>>>>>>        
13933>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
13934>>>>>>>>>>>        Set Icon to '' // this must be cleared so there will be no icon
13935>>>>>>>>>>>        Set locate_mode to CENTER_ON_PANEL
13936>>>>>>>>>>>        Set Border_Style  to Border_Dialog
13937>>>>>>>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
13937>>>>>>>>>>>        Set Scope_State to True
13938>>>>>>>>>>>        
13938>>>>>>>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
13939>>>>>>>>>>>    End_Procedure
13940>>>>>>>>>>>    
13940>>>>>>>>>>>    // this is private and required. Never send this.
13940>>>>>>>>>>>    Procedure Deactivate_Group
13942>>>>>>>>>>>        If (Active_State(Self)) Begin
13944>>>>>>>>>>>            Send SuspendGUI of Desktop False
13945>>>>>>>>>>>        End
13945>>>>>>>>>>>>
13945>>>>>>>>>>>        Forward Send Deactivate_Group
13947>>>>>>>>>>>    End_Procedure
13948>>>>>>>>>>>    
13948>>>>>>>>>>>    // Send this message to stop the panel
13948>>>>>>>>>>>    Procedure Deactivate
13950>>>>>>>>>>>        If (Active_State(Self)) Begin
13952>>>>>>>>>>>            Send SuspendGUI of Desktop False
13953>>>>>>>>>>>        End
13953>>>>>>>>>>>>
13953>>>>>>>>>>>        Forward Send Deactivate
13955>>>>>>>>>>>    End_Procedure
13956>>>>>>>>>>>    
13956>>>>>>>>>>>    // Send this message to start the panel
13956>>>>>>>>>>>    Procedure Activate
13958>>>>>>>>>>>        If not (Active_State(Self)) Begin
13960>>>>>>>>>>>            Set pbCancel to False
13961>>>>>>>>>>>            Send SuspendGUI of Desktop True
13962>>>>>>>>>>>        End
13962>>>>>>>>>>>>
13962>>>>>>>>>>>        Forward Send Activate
13964>>>>>>>>>>>    End_Procedure
13965>>>>>>>>>>>    
13965>>>>>>>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
13965>>>>>>>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
13965>>>>>>>>>>>    Procedure ProcessEvents
13967>>>>>>>>>>>        If (Active_State(Self)) Begin
13969>>>>>>>>>>>            Send PumpMsgQueue of Desktop
13970>>>>>>>>>>>        End
13970>>>>>>>>>>>>
13970>>>>>>>>>>>    End_Procedure
13971>>>>>>>>>>>    
13971>>>>>>>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
13971>>>>>>>>>>>    // process using this that it wants to close. It is then up the process close the panel.
13971>>>>>>>>>>>    Procedure Close_Panel
13973>>>>>>>>>>>        Set pbCancel to True
13974>>>>>>>>>>>    End_Procedure
13975>>>>>>>>>>>    
13975>>>>>>>>>>>End_Class
13976>>>>>>>>>
13976>>>>>>>>>
13976>>>>>>>>>
13976>>>>>>>>>Class cProcessStatusPanel is a cStatusPanel
13977>>>>>>>>>    
13977>>>>>>>>>    Procedure Construct_Object
13979>>>>>>>>>        Forward Send Construct_object
13981>>>>>>>>>        // determines if panel can be canceled
13981>>>>>>>>>        Property Boolean Allow_Cancel_State True
13982>>>>>>>>>    End_Procedure
13983>>>>>>>>>    
13983>>>>>>>>>    // Any of the properties that change the text of a status panel must also send
13983>>>>>>>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
13983>>>>>>>>>    // is essential when using status panels within a tight loop
13983>>>>>>>>>    
13983>>>>>>>>>    Procedure Set Caption_text String sText
13985>>>>>>>>>        Set Label to sText
13986>>>>>>>>>        Send ProcessEvents
13987>>>>>>>>>    End_Procedure
13988>>>>>>>>>    
13988>>>>>>>>>    Function Caption_Text Returns String
13990>>>>>>>>>        Function_Return (Label(Self))
13991>>>>>>>>>    End_Function
13992>>>>>>>>>    
13992>>>>>>>>>    Procedure Set Message_Text String sText
13994>>>>>>>>>        Send ProcessEvents
13995>>>>>>>>>    End_Procedure
13996>>>>>>>>>    
13996>>>>>>>>>    Function Message_Text Returns String
13998>>>>>>>>>    End_Function
13999>>>>>>>>>    
13999>>>>>>>>>    Procedure Set Action_Text String sText
14001>>>>>>>>>        Send ProcessEvents
14002>>>>>>>>>    End_Procedure
14003>>>>>>>>>    
14003>>>>>>>>>    Function Action_Text Returns String
14005>>>>>>>>>    End_Function
14006>>>>>>>>>    
14006>>>>>>>>>    Procedure Set Button_Text String sText
14008>>>>>>>>>        Send ProcessEvents
14009>>>>>>>>>    End_Procedure
14010>>>>>>>>>    
14010>>>>>>>>>    Function Button_Text Returns String
14012>>>>>>>>>    End_Function
14013>>>>>>>>>    
14013>>>>>>>>>    Procedure Set Title_Text String sText
14015>>>>>>>>>        Send ProcessEvents
14016>>>>>>>>>    End_Procedure
14017>>>>>>>>>    
14017>>>>>>>>>    Function Title_Text Returns String
14019>>>>>>>>>    End_Function
14020>>>>>>>>>    
14020>>>>>>>>>    // initializes values for caption, title & message
14020>>>>>>>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
14022>>>>>>>>>        Set Caption_text to sCaption
14023>>>>>>>>>        Set Title_Text   to sTitle
14024>>>>>>>>>        Set Message_Text to sMessage
14025>>>>>>>>>    End_Procedure
14026>>>>>>>>>    
14026>>>>>>>>>    // update the status panel's action area
14026>>>>>>>>>    Procedure Update_StatusPanel String sAction
14028>>>>>>>>>        Set Action_Text to sAction
14029>>>>>>>>>    End_Procedure
14030>>>>>>>>>    
14030>>>>>>>>>    // stop the status panel
14030>>>>>>>>>    Procedure Close_Panel
14032>>>>>>>>>        If (Allow_cancel_state(Self)) Begin
14034>>>>>>>>>            Forward Send Close_Panel
14036>>>>>>>>>        End
14036>>>>>>>>>>
14036>>>>>>>>>    End_Procedure
14037>>>>>>>>>    
14037>>>>>>>>>    // Code must be provided in the cancel button object to enable/disable cancel button
14037>>>>>>>>>    Procedure EnableCancelButton Boolean bEnable
14039>>>>>>>>>    End_Procedure
14040>>>>>>>>>    
14040>>>>>>>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
14040>>>>>>>>>    Function Check_StatusPanel Returns Integer
14042>>>>>>>>>        Boolean bCancel
14042>>>>>>>>>        If (Active_state(Self)) Begin
14044>>>>>>>>>            Send ProcessEvents
14045>>>>>>>>>            Get pbCancel to bCancel
14046>>>>>>>>>            If bCancel Begin
14048>>>>>>>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
14049>>>>>>>>>            End
14049>>>>>>>>>>
14049>>>>>>>>>        End
14049>>>>>>>>>>
14049>>>>>>>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
14050>>>>>>>>>    End_Function
14051>>>>>>>>>    
14051>>>>>>>>>    // start the status panel
14051>>>>>>>>>    Procedure Start_StatusPanel
14053>>>>>>>>>        If not (Active_state(Self)) Begin
14055>>>>>>>>>            Send EnableCancelButton (Allow_cancel_state(Self))
14056>>>>>>>>>            Send Activate
14057>>>>>>>>>        End
14057>>>>>>>>>>
14057>>>>>>>>>    End_Procedure
14058>>>>>>>>>    
14058>>>>>>>>>    // stop the status panel
14058>>>>>>>>>    Procedure Stop_StatusPanel
14060>>>>>>>>>        If (Active_state(Self)) Begin
14062>>>>>>>>>            Send Deactivate
14063>>>>>>>>>        End
14063>>>>>>>>>>
14063>>>>>>>>>    End_Procedure
14064>>>>>>>>>    
14064>>>>>>>>>End_Class
14065>>>>>>>
14065>>>>>>>
14065>>>>>>>Global_Variable Handle ghoStatusPanel // will contain the ID of the global StatusPanel object
14065>>>>>>>
14065>>>>>>>
14065>>>>>>>Object Status_Panel is a cProcessStatusPanel
14067>>>>>>>    
14067>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout your applicaton to access this object
14068>>>>>>>    
14068>>>>>>>    Set Size to 80 166
14069>>>>>>>    
14069>>>>>>>    Object oTitleTxt is a TextBox
14071>>>>>>>        Set location to 10 10
14072>>>>>>>        Set Auto_Size_State to False
14073>>>>>>>        Set size to 20 150
14074>>>>>>>        Set Justification_Mode to JMode_Center
14075>>>>>>>    End_Object
14076>>>>>>>    
14076>>>>>>>    Object oMessageTxt is a TextBox
14078>>>>>>>        Set location to 25 10
14079>>>>>>>        Set Auto_Size_State to False
14080>>>>>>>        Set size to 20 150
14081>>>>>>>    End_Object
14082>>>>>>>    
14082>>>>>>>    Object oActionTxt is a TextBox
14084>>>>>>>        Set location to 45 10
14085>>>>>>>    End_Object
14086>>>>>>>    
14086>>>>>>>    Object oStopButton is a Button
14088>>>>>>>        Set Location to 60 58
14089>>>>>>>        Set Label to C_$Cancel
14090>>>>>>>        
14090>>>>>>>        Procedure OnClick
14093>>>>>>>            Send Close_panel
14094>>>>>>>        End_Procedure
14095>>>>>>>        
14095>>>>>>>    End_Object
14096>>>>>>>    
14096>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
14096>>>>>>>    // objects defined within this instance of the status panel.
14096>>>>>>>    
14096>>>>>>>    // note: all of the messages that change text should be forwarded
14096>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
14096>>>>>>>    
14096>>>>>>>    Procedure Set Message_Text String sText
14099>>>>>>>        Set Label of oMessageTxt to sText
14100>>>>>>>        Forward Set Message_Text to sText
14102>>>>>>>    End_Procedure
14103>>>>>>>    
14103>>>>>>>    Function Message_Text Returns String
14106>>>>>>>        Function_Return (Label(oMessageTxt))
14107>>>>>>>    End_Function
14108>>>>>>>    
14108>>>>>>>    Procedure Set Action_Text String sText
14111>>>>>>>        Set Label of oActionTxt to sText
14112>>>>>>>        Forward Set Action_Text to sText
14114>>>>>>>    End_Procedure
14115>>>>>>>    
14115>>>>>>>    Function Action_Text Returns String
14118>>>>>>>        Function_Return (Label(oActionTxt))
14119>>>>>>>    End_Function
14120>>>>>>>    
14120>>>>>>>    Procedure Set Button_Text String sText
14123>>>>>>>        Set Label of oStopButton to sText
14124>>>>>>>        Forward Set Button_Text to sText
14126>>>>>>>    End_Procedure
14127>>>>>>>    
14127>>>>>>>    Function Button_Text Returns String
14130>>>>>>>        Function_Return (Label(oStopButton))
14131>>>>>>>    End_Function
14132>>>>>>>    
14132>>>>>>>    Procedure Set Title_Text String sText
14135>>>>>>>        Set Label of oTitleTxt to sText
14136>>>>>>>        Forward Set Title_Text to sText
14138>>>>>>>    End_Procedure
14139>>>>>>>    
14139>>>>>>>    Function Title_Text Returns String
14142>>>>>>>        Function_Return (Label(oTitleTxt))
14143>>>>>>>    End_Function
14144>>>>>>>    
14144>>>>>>>    // gets called when status panel is activated passing whether a button
14144>>>>>>>    // should appear
14144>>>>>>>    Procedure EnableCancelButton Boolean bEnable
14147>>>>>>>        Set Enabled_State of oStopButton to bEnable
14148>>>>>>>    End_Procedure
14149>>>>>>>    
14149>>>>>>>End_Object
14150>>>>>>>
14150>>>>>
14150>>>>>Use MsgBox.pkg
14150>>>>>Use GlobalFunctionsProcedures.pkg
14150>>>>>
14150>>>>>// Do this so the metadata is correct for windows apps, which
14150>>>>>// means it will be wrong for WebApps.
14150>>>>>Class BusinessProcess is a cObject
14151>>>>>    
14151>>>>>    Procedure Construct_Object
14153>>>>>        Forward Send Construct_Object
14155>>>>>        
14155>>>>>        // Status Panel related properties
14155>>>>>        Property Integer Status_Panel_State        True
14156>>>>>        Property Integer Allow_Cancel_State        False
14157>>>>>        Property String  Process_Caption           C_$RunningProcess
14158>>>>>        Property String  Process_Title             ""
14159>>>>>        Property String  Process_Message           ""
14160>>>>>        
14160>>>>>        Property Integer Status_Panel_Id           0
14161>>>>>        Property String  Status_Params             ''
14162>>>>>        
14162>>>>>        // if not web app, we want a normal status_panel object
14162>>>>>        Set Status_Panel_Id    to (Status_Panel(Self))
14163>>>>>        // Error related properties
14163>>>>>        
14163>>>>>        // if set true, errors will be forwarded to the normal
14163>>>>>        // VDF error handler causing an error message to popup.
14163>>>>>        // Normally you would not want this during a batch process.
14163>>>>>        
14163>>>>>        Property Integer Display_Error_State       False
14164>>>>>        
14164>>>>>        Property Integer Error_Count               0      // number of errors
14165>>>>>        
14165>>>>>        Property Integer Old_Error_Object_Id       0
14166>>>>>        
14166>>>>>        Property Integer Error_Processing_State    False  // internal use
14167>>>>>        
14167>>>>>        Property Integer Error_Check_State         False  // internal
14168>>>>>        
14168>>>>>        // Logging
14168>>>>>        Property Integer Status_Log_State          False
14169>>>>>        
14169>>>>>        // If you are going to log information you must create a
14169>>>>>        // status log object and set this property to its ID. See
14169>>>>>        // Statlog.pkg for more information.
14169>>>>>        Property Integer Status_Log_Id             0
14170>>>>>        
14170>>>>>        // This is normally not used at runtime by BPOs but it is required
14170>>>>>        // by the IDE to figure out how to structure and relate DDOs
14170>>>>>        Property Handle Main_DD                    0
14171>>>>>        
14171>>>>>    End_Procedure
14172>>>>>    
14172>>>>>    Procedure Update_Status String Val
14174>>>>>        Integer StatPnl
14174>>>>>        Get Status_Panel_Id to StatPnl
14175>>>>>        If StatPnl ;            Send Update_StatusPanel to StatPnl Val
14178>>>>>    End_Procedure
14179>>>>>    
14179>>>>>    Procedure Start_Status
14181>>>>>        Integer StatPnl
14181>>>>>        Set Error_Check_State to False
14182>>>>>        If (Status_Panel_State(Self)) Begin
14184>>>>>            Get Status_Panel_Id to StatPnl
14185>>>>>            If StatPnl Begin
14187>>>>>                Send Initialize_StatusPanel to StatPnl ;                    (Process_Caption(Self)) ;                    (Process_Title(Self)) ;                    (Process_Message(Self)) ;                    (Status_Params(Self))
14188>>>>>                Set Allow_Cancel_State of StatPnl to (Allow_Cancel_State(Self))
14189>>>>>                Send Start_StatusPanel to StatPnl
14190>>>>>            End
14190>>>>>>
14190>>>>>        End
14190>>>>>>
14190>>>>>    End_Procedure
14191>>>>>    
14191>>>>>    Procedure Resume_Status
14193>>>>>        Integer StatPnl
14193>>>>>        Get Status_Panel_Id to StatPnl
14194>>>>>        If StatPnl ;            Send Start_StatusPanel to StatPnl
14197>>>>>    End_Procedure
14198>>>>>    
14198>>>>>    Procedure End_Status
14200>>>>>        Integer StatPnl
14200>>>>>        Get Status_Panel_Id to StatPnl
14201>>>>>        If StatPnl ;            Send Stop_StatusPanel to StatPnl
14204>>>>>    End_Procedure
14205>>>>>    
14205>>>>>    Procedure Start_Log
14207>>>>>        Send Log_Status (SFormat(C_$BeginProcess, Process_Title(Self)))
14208>>>>>    End_Procedure
14209>>>>>    
14209>>>>>    Procedure End_Log
14211>>>>>        Integer ErrCount
14211>>>>>        Get Error_Count to ErrCount
14212>>>>>        Send Log_Status (SFormat(C_$EndProcessNumberOfErrors, Process_Title(Self), ErrCount))
14213>>>>>    End_Procedure
14214>>>>>    
14214>>>>>    Procedure Error_Log_Status Integer Errnum Integer iErrLine String ErrMsg
14216>>>>>        Send Log_Status (SFormat(C_$ErrorNum, ErrNum, ErrMsg))
14217>>>>>    End_Procedure
14218>>>>>    
14218>>>>>    Procedure Log_Status String Mess
14220>>>>>        Integer StatId
14220>>>>>        Get Status_Log_Id to StatId
14221>>>>>        If StatId ;            Send Log_Status to StatId Mess
14224>>>>>    End_Procedure
14225>>>>>    
14225>>>>>    // This pops up a message asking if a process should
14225>>>>>    // be canceled. Returns non-zero if cancel. This could be
14225>>>>>    // augmented, should not be sent.
14225>>>>>    
14225>>>>>    Function Process_Interrupt Returns Integer
14227>>>>>        Integer rVal
14227>>>>>        String Mess
14227>>>>>        If (Error_Check_State(Self)) ;            Move C_$AnErrorWasEncountered to Mess
14230>>>>>        Else ;            Move  C_$DoYouWishToCancelThisProcess to Mess
14232>>>>>        Move (YesNo_Box( Mess, C_$ProcessInterrupt, MB_DEFBUTTON1)) to rVal
14233>>>>>        Function_Return (Rval=MBR_YES)
14234>>>>>    End_Function
14235>>>>>    
14235>>>>>    // Public way to tell if a process should be canceled.
14235>>>>>    // This should be sent but probably not augmented
14235>>>>>    // check for report interrupt
14235>>>>>    // Returns True to stop report, false to continue
14235>>>>>    
14235>>>>>    Function Cancel_Check Returns Integer
14237>>>>>        Integer StatPnl StopIt
14237>>>>>        Get Status_Panel_Id to StatPnl
14238>>>>>        If ( Error_Check_State(Self) or ;            ( Status_Panel_State(Self) and ;            StatPnl and Check_StatusPanel(StatPnl)))  Begin
14240>>>>>            Send End_Status
14241>>>>>            Get Process_Interrupt to StopIt
14242>>>>>            If not StopIt ;                Send Resume_Status
14245>>>>>            Set Error_Check_State to False
14246>>>>>        End
14246>>>>>>
14246>>>>>        Function_Return StopIt
14247>>>>>    End_Function
14248>>>>>    
14248>>>>>    // All errors are directed to the main report. By Default we
14248>>>>>    // shut off the status panel, report the error and notify the interrupt
14248>>>>>    // mechanism to ask if the report should be canceled. VERY IMPORTANT!
14248>>>>>    // If you augment this and you plan on doing ANY windows IO you should
14248>>>>>    // first shut of the status panel.
14248>>>>>    
14248>>>>>    Procedure Error_Report Integer ErrNum Integer iErrLine String ErrMsg
14250>>>>>        Integer id
14250>>>>>        If (error_processing_state(Self)=False) Begin
14252>>>>>            Set Error_processing_State to True // prevents recursion
14253>>>>>            Set Error_Check_State to True
14254>>>>>            Set Error_Count to (Error_Count(Self)+1)
14255>>>>>            If (Status_Log_State(Self)) ;                Send Error_Log_Status ErrNum iErrLine ErrMsg
14258>>>>>            If (Display_Error_State(Self)) Begin
14260>>>>>                Get Old_Error_Object_Id to ID
14261>>>>>                Send End_Status // YOU MUST DO THIS!!!!
14262>>>>>                If ID ;                    Send Error_Report to Id ErrNum iErrLine ErrMsg
14265>>>>>                Else ;                    Send Error_Report of desktop ErrNum iErrLine ErrMsg
14267>>>>>            End
14267>>>>>>
14267>>>>>            Send onError ErrNum iErrLine ErrMsg
14268>>>>>            Set Error_processing_State to False
14269>>>>>        End
14269>>>>>>
14269>>>>>    End_Procedure
14270>>>>>    
14270>>>>>    // Event called by Error_Report. For augmentation.
14270>>>>>    // If you are planning on doing any interactive IO and you are
14270>>>>>    // using the status panel you must first remove the panel
14270>>>>>    // (send End_Status).
14270>>>>>    
14270>>>>>    Procedure OnError Integer ErrNum Integer iErrLine String ErrMsg
14272>>>>>    End_Procedure
14273>>>>>    
14273>>>>>    Procedure Start_Process
14275>>>>>        Set Error_Count to 0
14276>>>>>        Set Old_Error_Object_id to Error_Object_id
14277>>>>>        Move Self to Error_Object_id
14278>>>>>        If (Status_Log_State(Self)) ;            Send Start_Log
14281>>>>>        Send Start_Status
14282>>>>>    End_Procedure
14283>>>>>    
14283>>>>>    Procedure End_Process
14285>>>>>        Send End_Status
14286>>>>>        If (Status_Log_State(Self)) ;            Send End_Log
14289>>>>>        Get Old_Error_Object_id to Error_Object_id // restore previous error object
14290>>>>>        Set Old_Error_Object_id to 0
14291>>>>>    End_Procedure
14292>>>>>    
14292>>>>>    // This runs the actual busiess process. It is expected that most
14292>>>>>    // if not all of the custom code to run a process will be provided
14292>>>>>    // here.
14292>>>>>    
14292>>>>>    Procedure OnProcess
14294>>>>>    End_Procedure
14295>>>>>    
14295>>>>>    // This procedure is the main public access method into this
14295>>>>>    // object. A process is run by sending this message. It will start
14295>>>>>    // the process, call a user defined Hook (event) to actually do
14295>>>>>    // the processing, and then end the process.
14295>>>>>    
14295>>>>>    Procedure DoProcess
14297>>>>>        Send Start_Process   // does all process init
14298>>>>>        Send OnProcess       // must be provided by the programmer
14299>>>>>        Send End_Process     // does all close down
14300>>>>>    End_Procedure
14301>>>>>    
14301>>>>>End_Class
14302>>>>>
14302>>>Use cRecipeDataDictionary.dd
Including file: cRecipeDataDictionary.dd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\cRecipeDataDictionary.dd)
14302>>>>>Use DataDict.pkg
Including file: Datadict.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Datadict.pkg)
14302>>>>>>>Use VDFBase.pkg
14302>>>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
14302>>>>>>>
14302>>>>>>>Register_Procedure File_Field_Value_Changed
14302>>>>>>>Register_Procedure File_Field_Mask_Changed
14302>>>>>>>Register_Procedure File_Field_Label_Changed
14302>>>>>>>Register_Procedure File_Field_Option_Changed
14302>>>>>>>Register_Function  Extended_DEO_State Returns Integer
14302>>>>>>>Register_Function  Entry_Refresh_State Returns Integer
14302>>>>>>>Register_Procedure Set Entry_Refresh_State Integer iState
14302>>>>>>>Register_Function  Allow_Foreign_New_Save_State Returns Integer
14302>>>>>>>Register_Function  Server Returns Integer
14302>>>>>>>
14302>>>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Data_set.pkg)
14302>>>>>>>>>Use VDFBase.pkg
14302>>>>>>>>>Use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files\DataFlex 20.0\Pkg\fndmodes.pkg)
14302>>>>>>>>>>>//
14302>>>>>>>>>>>// special find modes
14302>>>>>>>>>>>//
14302>>>>>>>>>>>Define NEXT_RECORD  for 5 // find-next
14302>>>>>>>>>>>Define FIRST_RECORD for 6 // find-first
14302>>>>>>>>>>>Define LAST_RECORD  for 7 // find-last 
14302>>>>>>>>>Use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files\DataFlex 20.0\Pkg\refmodes.pkg)
14302>>>>>>>>>>>//
14302>>>>>>>>>>>// constants for REFRESH message parameter values
14302>>>>>>>>>>>//
14302>>>>>>>>>>>Define MODE_CLEAR             for 1  //notification from origin of clear
14302>>>>>>>>>>>Define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
14302>>>>>>>>>>>Define MODE_CLEAR_ALL         for 3  //notification from clear-all
14302>>>>>>>>>>>Define MODE_DELETE            for 4  //notification after successful delete
14302>>>>>>>>>>>Define MODE_SAVE              for 5  //notification after successful save
14302>>>>>>>>>>>
14302>>>>>>>>>
14302>>>>>>>>>
14302>>>>>>>>>//
14302>>>>>>>>>//Global integer status values
14302>>>>>>>>>//
14302>>>>>>>>>Define OPERATION_MODE   for |VI99  //status of data-sets in application
14302>>>>>>>>>Define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
14302>>>>>>>>>
14302>>>>>>>>>//
14302>>>>>>>>>//Constants for Operation_Mode global int values
14302>>>>>>>>>//
14302>>>>>>>>>Define MODE_WAITING  for 0  //wait-mode
14302>>>>>>>>>Define MODE_FINDING  for 1  //find-mode
14302>>>>>>>>>Define MODE_CLEARING for 2  //clear-mode
14302>>>>>>>>>Define MODE_CREATING for 3  //create-mode
14302>>>>>>>>>Define MODE_SAVING   for 4  //save-mode
14302>>>>>>>>>Define MODE_DELETING for 5  //delete-mode
14302>>>>>>>>>Define MODE_ABORTING for 6  //abort-mode
14302>>>>>>>>>Define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
14302>>>>>>>>>Define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
14302>>>>>>>>>
14302>>>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
14302>>>>>>>>>//   a C language handler providing the majority of new behavior.  The
14302>>>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
14302>>>>>>>>>//   and a container for subordinate Data_Sets.
14302>>>>>>>>>//
14302>>>>>>>>>Use BaseData_Set.pkg
14302>>>>>>>>>
14302>>>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
14302>>>>>>>>>// to augment C-based (Constrain) procedure(s).)
14302>>>>>>>>>
14302>>>>>>>>>Class DataSet is a BaseData_Set
14303>>>>>>>>>    
14303>>>>>>>>>    
14303>>>>>>>>>    // maintain old name for the time being to maximize compatability
14303>>>>>>>>>    // between character mode and windows versions. Developers should be
14303>>>>>>>>>    // able to move DS classes back and forth without changes.
14303>>>>>>>>>    Replace_Class_Name Data_Set DataSet
14303>>>>>>>>>    
14303>>>>>>>>>    Procedure Construct_Object //Integer Img#
14305>>>>>>>>>        Forward Send Construct_Object No_Image //Img#
14307>>>>>>>>>        
14307>>>>>>>>>        Property Integer Constrain_File 0
14308>>>>>>>>>        Property Integer Auto_Fill_State False
14309>>>>>>>>>        Property Integer Change_Disabled_State  False
14310>>>>>>>>>        // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
14310>>>>>>>>>        Property Integer Component_State False
14311>>>>>>>>>        
14311>>>>>>>>>    End_Procedure
14312>>>>>>>>>    
14312>>>>>>>>>    
14312>>>>>>>>>    //
14312>>>>>>>>>    // This may be called by legacy DSO and DDO code
14312>>>>>>>>>    //
14312>>>>>>>>>    // IMPORTANT NOTE of change for 8.2:
14312>>>>>>>>>    //         DO NOT call or augment this anymore.
14312>>>>>>>>>    //
14312>>>>>>>>>    //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
14312>>>>>>>>>    //
14312>>>>>>>>>    //         for augmenting: In DSOs - replace Field_main_index with File_field_index
14312>>>>>>>>>    //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
14312>>>>>>>>>    //                                   the file parameter.
14312>>>>>>>>>    //                                   See DDOs Field_index and File_field_Index for more
14312>>>>>>>>>    //
14312>>>>>>>>>    Function Field_Main_Index Integer file Integer Field Returns Integer
14314>>>>>>>>>        Integer dataType fldNdx retval ordr
14314>>>>>>>>>        Move -1 to retval      //field has no main index (default)
14315>>>>>>>>>        If (file <> 0) Begin
14317>>>>>>>>>//      FIELD_DEF file field to dataType fldNdx
14317>>>>>>>>>            Get_Attribute DF_FIELD_INDEX of file Field to fldNdx // main index field
14320>>>>>>>>>            If (fldNdx > 0 or Field = 0) ;                Move fldNdx to retval //field has main index
14323>>>>>>>>>        End
14323>>>>>>>>>>
14323>>>>>>>>>        If (file = main_file(Self)) Begin
14325>>>>>>>>>            Get ordering to ordr
14326>>>>>>>>>            If (ordr >= 0) ;                Move ordr to retval  //ordering takes precedence over main index
14329>>>>>>>>>        End
14329>>>>>>>>>>
14329>>>>>>>>>        Function_Return retval
14330>>>>>>>>>    End_Function
14331>>>>>>>>>    
14331>>>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
14331>>>>>>>>>    // message syntax.
14331>>>>>>>>>    // Note that this will never get here if the DD class is used as
14331>>>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
14331>>>>>>>>>    // case it calls the old message field_main_index above.
14331>>>>>>>>>    // DDO based objects will NEVER call this code
14331>>>>>>>>>    //
14331>>>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
14333>>>>>>>>>        Function_Return (Field_main_Index(Self,iFile,iField))
14334>>>>>>>>>    End_Function
14335>>>>>>>>>    
14335>>>>>>>>>    
14335>>>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
14337>>>>>>>>>        
14337>>>>>>>>>        RowID   riRow
14337>>>>>>>>>        Integer iIndex
14337>>>>>>>>>        Handle  hoServer
14337>>>>>>>>>        Integer iSegments iSeg iSegFld iSegFldMainIndex
14337>>>>>>>>>        Boolean bChanged bDoCheck bOk
14337>>>>>>>>>        
14337>>>>>>>>>        //Get Field_Main_Index iFile iField to iIndex
14337>>>>>>>>>        Get File_Field_Index iFile iField to iIndex
14338>>>>>>>>>        If (iIndex<>-1) Begin
14340>>>>>>>>>            // get prior rowId before it get cleared
14340>>>>>>>>>            Move (GetRowID(iFile)) to riRow
14341>>>>>>>>>            //  'hold' buffer to prepare for entry_update
14341>>>>>>>>>            Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
14344>>>>>>>>>            If bDoEntryUpdate Begin
14346>>>>>>>>>                Send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
14347>>>>>>>>>                
14347>>>>>>>>>                // If the buffer is cleared (no record and no changed data) then we want
14347>>>>>>>>>                // to do a constrained_clear which will force the buffer to get cleared
14347>>>>>>>>>                // according to the rules of the current constraints.
14347>>>>>>>>>                //Get_field_value iFile 0 to iRec
14347>>>>>>>>>                //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
14347>>>>>>>>>                
14347>>>>>>>>>                // If there was an active record to begin with we consider this changed (not cleared)
14347>>>>>>>>>                If (not(IsNullRowId(riRow))) Begin
14349>>>>>>>>>                    Move True to bChanged
14350>>>>>>>>>                End
14350>>>>>>>>>>
14350>>>>>>>>>                Else Begin
14351>>>>>>>>>                    // or, if the record was already changed or the entry_update created a change
14351>>>>>>>>>                    // we consider this changed
14351>>>>>>>>>                    Get_Attribute DF_FILE_CHANGED of iFile to bChanged
14354>>>>>>>>>                End
14354>>>>>>>>>>
14354>>>>>>>>>                
14354>>>>>>>>>                If not bChanged Begin
14356>>>>>>>>>                    // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
14356>>>>>>>>>                    // active record, the record was unchanged, and the update didn't change anything.
14356>>>>>>>>>                    Constrained_Clear eFindMode iFile by iIndex
14359>>>>>>>>>                End
14359>>>>>>>>>>
14359>>>>>>>>>                Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
14362>>>>>>>>>                    
14362>>>>>>>>>                    // If mode is GE or LE we need to do some extra processing. We want to clear
14362>>>>>>>>>                    // all index segemnt fields that occur after this field in the index. This way
14362>>>>>>>>>                    // dbList searches and find ge searches (f9) will always find the first record
14362>>>>>>>>>                    // that matches the data in the field being searched. This was if an index like
14362>>>>>>>>>                    // customer.name x customer.number where you had 10 identical names "john" typing
14362>>>>>>>>>                    // john will find the first record, because customer.number will get cleared.
14362>>>>>>>>>                    // Note we can no do this with GT or LT or you'd get stuck in fields
14362>>>>>>>>>                    
14362>>>>>>>>>                    // check all fields for index. Once you find the iField field, clear all
14362>>>>>>>>>                    // fields that follow it. Only do this if the other fields do not use the
14362>>>>>>>>>                    // same index as its primary index (in which case we assume the data is intentional).
14362>>>>>>>>>                    // This should handle most cases.
14362>>>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
14365>>>>>>>>>                    For iSeg from 1 to iSegments
14371>>>>>>>>>>
14371>>>>>>>>>                        Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
14374>>>>>>>>>                        If not bDoCheck Begin
14376>>>>>>>>>                            If (iSegFld=iField) ;                                Move True to bDoCheck // marked after we find the find field in the index
14379>>>>>>>>>                        End
14379>>>>>>>>>>
14379>>>>>>>>>                        Else Begin // we get here after we've found the main field segment
14380>>>>>>>>>                            // if main index if this segment is same as our find index, do nothing
14380>>>>>>>>>                            Get File_Field_Index iFile iSegFld to iSegFldMainIndex
14381>>>>>>>>>                            If (iSegFldMainIndex<>iIndex) ;                                Set_Field_Value iFile iSegFld to ''
14386>>>>>>>>>                        End
14386>>>>>>>>>>
14386>>>>>>>>>                    Loop
14387>>>>>>>>>>
14387>>>>>>>>>                End
14387>>>>>>>>>>
14387>>>>>>>>>                
14387>>>>>>>>>                Get Which_Data_Set iFile to hoServer
14388>>>>>>>>>                If (hoServer and iFile=main_file(hoServer)) ;                    Send Attach_Main_File to hoServer
14391>>>>>>>>>                Else ;                    Attach iFile
14393>>>>>>>>>            End
14393>>>>>>>>>>
14393>>>>>>>>>            
14393>>>>>>>>>            Move False to Err
14394>>>>>>>>>            
14394>>>>>>>>>            If (Is_SuperFind_Required(Self,iFile)) ;                Send Request_SuperFind eFindMode iFile iField
14397>>>>>>>>>            Else If bDeferred ;                Send Request_Read eFindMode iFile iIndex
14401>>>>>>>>>            Else ;                Send Request_Find eFindMode iFile iIndex
14403>>>>>>>>>            
14403>>>>>>>>>            If (not(Found) and not(err)) Begin
14405>>>>>>>>>                // refind original record (or leave it cleared if not record)
14405>>>>>>>>>                Move (FindByRowId(iFile,riRow)) to bOk
14406>>>>>>>>>                
14406>>>>>>>>>                If bShowFindErr ;                    Error (If(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
14409>>>>>>>>>                Move False to Found
14410>>>>>>>>>            End
14410>>>>>>>>>>
14410>>>>>>>>>        End
14410>>>>>>>>>>
14410>>>>>>>>>        Else ;            If bShowFindErr ;                Error DFERR_FIELD_NOT_INDEXED
14414>>>>>>>>>    End_Procedure
14415>>>>>>>>>    
14415>>>>>>>>>    
14415>>>>>>>>>    // We only care about should_saves of DEOs and not DSOs when
14415>>>>>>>>>    // exiting the app. Create a handler for data set class. We still
14415>>>>>>>>>    // broadcast in case we've got nested deos in the dso (hopefully not).
14415>>>>>>>>>    //
14415>>>>>>>>>    Function Exit_Application_Check Returns Integer
14417>>>>>>>>>        Integer rVal
14417>>>>>>>>>        Broadcast Get Exit_Application_Check to Rval // check w/ kids
14419>>>>>>>>>        Function_Return rVal
14420>>>>>>>>>    End_Function
14421>>>>>>>>>    
14421>>>>>>>>>    Procedure Constrain
14423>>>>>>>>>        Integer iFile
14423>>>>>>>>>        Send OnConstrain
14424>>>>>>>>>        Forward Send Constrain
14426>>>>>>>>>        Get Constrain_File to iFile
14427>>>>>>>>>        If iFile ;            Constrain (Main_file(Self)) relates to iFile
14430>>>>>>>>>    End_Procedure
14431>>>>>>>>>    
14431>>>>>>>>>    Procedure OnConstrain
14433>>>>>>>>>    End_Procedure
14434>>>>>>>>>    
14434>>>>>>>>>    // Less confusing Message for adding Updating servers
14434>>>>>>>>>    //
14434>>>>>>>>>    Procedure Set DDO_Server Handle ObjId
14436>>>>>>>>>        Send Attach_Server ObjId
14437>>>>>>>>>    End_Procedure
14438>>>>>>>>>    
14438>>>>>>>>>    // This is called when a view takes or retakes the
14438>>>>>>>>>    // focus. If DD not in use, do nothing.
14438>>>>>>>>>    //
14438>>>>>>>>>    Procedure Refind_DD_Records
14440>>>>>>>>>        If (in_use_state(Self)) ;            Send refind_records
14443>>>>>>>>>    End_Procedure
14444>>>>>>>>>    
14444>>>>>>>>>    // this returns true if the data-set is changed AND there are attached
14444>>>>>>>>>    // DEO objects. Without this you can get "changes exist" condition reported
14444>>>>>>>>>    // that the user will have no way of saving.
14444>>>>>>>>>    //
14444>>>>>>>>>    Function Data_Set_Should_Save Returns Integer
14446>>>>>>>>>        Function_Return (Should_Save(Self) and ;            Data_Set_User_interface_count(Self))
14447>>>>>>>>>    End_Function
14448>>>>>>>>>    
14448>>>>>>>>>    // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
14448>>>>>>>>>    // Add DSOs and DDOs must understand this message
14448>>>>>>>>>    
14448>>>>>>>>>    Function Extended_DSO_State Returns Integer
14450>>>>>>>>>        Function_Return 0
14451>>>>>>>>>    End_Function
14452>>>>>>>>>    
14452>>>>>>>>>    
14452>>>>>>>>>End_Class
14453>>>>>>>>>
14453>>>>>>>>>
14453>>>>>>>>>
14453>>>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Ddvaltbl.pkg)
14453>>>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may
14453>>>>>>>>>//  attached to validation tables which can then be used for
14453>>>>>>>>>//  validation (if Validate_state is true) or list loading.
14453>>>>>>>>>//  Developers can create their own validation tables as long as they
14453>>>>>>>>>//  conform to the following external interface:
14453>>>>>>>>>//
14453>>>>>>>>>// Properties
14453>>>>>>>>>//   Static_State       - if list must be rebuilt each validation, load
14453>>>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response
14453>>>>>>>>>//   Validate_State     - should table be used for validation
14453>>>>>>>>>//   Table_Loaded_State - is the validation table initialized?
14453>>>>>>>>>//
14453>>>>>>>>>// Methods
14453>>>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal
14453>>>>>>>>>//  Send Fill_list                    - fills a static list
14453>>>>>>>>>//  Send Request_Fill_From_List iObject iMessage
14453>>>>>>>>>//        This is a callback that will fill an external list by sending
14453>>>>>>>>>//        the passed message (iMessage) back to the requesting object
14453>>>>>>>>>//        (iObject). It will send this message for each item in the
14453>>>>>>>>>//        validation table. It always passes back four params. Those are:
14453>>>>>>>>>//                     iItem - Item count being passed back
14453>>>>>>>>>//                     sData - The Database value of the item
14453>>>>>>>>>//                     sDesc - The Value's description, "" if none
14453>>>>>>>>>//                     iFile - File number associated with the item (if any)
14453>>>>>>>>>//                     iRec  - Record associated with the item (if any)
14453>>>>>>>>>// Developers can create classes of any complexity to support validation
14453>>>>>>>>>// tables. We have provided the following four classes.
14453>>>>>>>>>//
14453>>>>>>>>>//  ValidationTable is an Array
14453>>>>>>>>>//           Provides simple one dimensional table support. The table must be
14453>>>>>>>>>//           loaded manually by creating fill_list and sending the message
14453>>>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static
14453>>>>>>>>>//           it is filled once. If non-static it is filled each time it is
14453>>>>>>>>>//           requested to validate or fill a foreign lis.
14453>>>>>>>>>//
14453>>>>>>>>>//  DescriptionValidationTable is a ValidationTable
14453>>>>>>>>>//           Provides a more complex three dimension array allowing the
14453>>>>>>>>>//           object to store a data value, description value and a record
14453>>>>>>>>>//           number. The developer must fill this list using the Add_table_
14453>>>>>>>>>//           value message passing up to three values (data, desc, record).
14453>>>>>>>>>//
14453>>>>>>>>>//  FileValidationTable is a DescriptionValidationTable
14453>>>>>>>>>//           Provides a data aware table. This can be used to load data from
14453>>>>>>>>>//           data-files, from data-sets. If you use data-sets you can place
14453>>>>>>>>>//           constraints within the data-set. You must define the file-number,
14453>>>>>>>>>//           data-set (if any), the file index, the file's data field, and
14453>>>>>>>>>//           the file's description field. You can also define an optional
14453>>>>>>>>>//           "Type". All records are constrained to this type (with or with-
14453>>>>>>>>>//           data-sets). If is assumed that this file has an optimized finding
14453>>>>>>>>>//           index.
14453>>>>>>>>>//
14453>>>>>>>>>//  CodeValidationTable is a FileValidationTable
14453>>>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"
14453>>>>>>>>>//
14453>>>>>>>>>Use VDFBase.pkg
14453>>>>>>>>>
14453>>>>>>>>>
14453>>>>>>>>>Class ValidationTable is an Array
14454>>>>>>>>>    
14454>>>>>>>>>    Procedure Construct_Object
14456>>>>>>>>>        Forward Send Construct_Object
14458>>>>>>>>>        Property Integer Static_State        True
14459>>>>>>>>>        
14459>>>>>>>>>        Property Integer Table_Loaded_State  False
14460>>>>>>>>>        
14460>>>>>>>>>        Property Integer Validate_State      True
14461>>>>>>>>>        Property Integer Allow_Blank_State   False
14462>>>>>>>>>        Property Integer Main_File           0
14463>>>>>>>>>        Property String  Table_Title         DD_VALIDATION_LIST_TITLE
14464>>>>>>>>>        
14464>>>>>>>>>        Property Integer Number_Elements     1
14465>>>>>>>>>        
14465>>>>>>>>>        // System maintained. Sub-classes use these
14465>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
14465>>>>>>>>>        
14465>>>>>>>>>        Property String  Current_Code            ''
14466>>>>>>>>>        
14466>>>>>>>>>        Property String  Current_Description     ''
14467>>>>>>>>>        
14467>>>>>>>>>        Property RowID Current_RowId
14468>>>>>>>>>    End_Procedure
14469>>>>>>>>>    
14469>>>>>>>>>    Function Data_Item_Count Returns Integer
14471>>>>>>>>>        Function_Return (Item_Count(Self))
14472>>>>>>>>>    End_Function
14473>>>>>>>>>    
14473>>>>>>>>>    Function Data_Value Integer iItem Returns String
14475>>>>>>>>>        Function_Return (Value(Self,iItem))
14476>>>>>>>>>    End_Function
14477>>>>>>>>>    
14477>>>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
14479>>>>>>>>>        Set Value  iItem to sValue
14480>>>>>>>>>    End_Procedure
14481>>>>>>>>>    
14481>>>>>>>>>    Function Data_Description Integer iItem Returns String
14483>>>>>>>>>        Function_Return ''
14484>>>>>>>>>    End_Function
14485>>>>>>>>>    
14485>>>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
14487>>>>>>>>>    End_Procedure
14488>>>>>>>>>    
14488>>>>>>>>>    Function Data_RowId Integer iItem Returns RowID
14490>>>>>>>>>        Function_Return (NullRowId())
14491>>>>>>>>>    End_Function
14492>>>>>>>>>    
14492>>>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
14494>>>>>>>>>    End_Procedure
14495>>>>>>>>>    
14495>>>>>>>>>    
14495>>>>>>>>>    Procedure Add_Table_Value String sValue
14497>>>>>>>>>        Set Data_Value  (Data_Item_Count(Self)) to sValue
14498>>>>>>>>>    End_Procedure
14499>>>>>>>>>    
14499>>>>>>>>>    Function Validate_Value String sCode Returns Integer
14501>>>>>>>>>        Integer iMax
14501>>>>>>>>>        Integer iCnt
14501>>>>>>>>>        If (sCode = '');            Function_Return (not(Allow_Blank_State(Self)))
14504>>>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
14506>>>>>>>>>            Send Delete_Data
14507>>>>>>>>>            Send Fill_list
14508>>>>>>>>>            Set Table_Loaded_State to True
14509>>>>>>>>>        End
14509>>>>>>>>>>
14509>>>>>>>>>        Get Data_Item_Count to iMax
14510>>>>>>>>>        Decrement iMax
14511>>>>>>>>>        For iCnt from 0 to iMax
14517>>>>>>>>>>
14517>>>>>>>>>            If (sCode=Data_Value(Self,iCnt)) Begin
14519>>>>>>>>>                Set Current_Code        to sCode
14520>>>>>>>>>                Set Current_Description to (Data_Description(Self,iCnt))
14521>>>>>>>>>                Set Current_RowId       to (Data_RowId(Self,iCnt))
14522>>>>>>>>>                Function_Return 0
14523>>>>>>>>>            End
14523>>>>>>>>>>
14523>>>>>>>>>        Loop
14524>>>>>>>>>>
14524>>>>>>>>>        Function_Return 1 // 0=OK
14525>>>>>>>>>    End_Function
14526>>>>>>>>>    
14526>>>>>>>>>    Function Find_Code_Description String sCode Returns String
14528>>>>>>>>>        If (sCode='' or ;            (sCode<>Current_Code(Self) and ;            Validate_Value(Self,sCode) ) );            Function_Return ''
14531>>>>>>>>>        Function_Return (Current_Description(Self))
14532>>>>>>>>>    End_Function
14533>>>>>>>>>    
14533>>>>>>>>>    
14533>>>>>>>>>    //  The deveveloper (or a sub-class) must fill this list. It is done
14533>>>>>>>>>    //  by finding the item and sending the Message:
14533>>>>>>>>>    //    Send Add_Table_Value sValue {sDescr}
14533>>>>>>>>>    //
14533>>>>>>>>>    Procedure Fill_List
14535>>>>>>>>>        Set Table_Loaded_State to True
14536>>>>>>>>>    End_Procedure
14537>>>>>>>>>    
14537>>>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
14539>>>>>>>>>        Integer iMax
14539>>>>>>>>>        Integer iCnt
14539>>>>>>>>>        Integer iFile
14539>>>>>>>>>        
14539>>>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
14542>>>>>>>>>        
14542>>>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
14544>>>>>>>>>            Send Delete_Data
14545>>>>>>>>>            Send Fill_list
14546>>>>>>>>>            Set Table_Loaded_State to True
14547>>>>>>>>>        End
14547>>>>>>>>>>
14547>>>>>>>>>        Get Main_File to iFile
14548>>>>>>>>>        Get Data_Item_Count to iMax
14549>>>>>>>>>        Decrement iMax
14550>>>>>>>>>        For iCnt from 0 to iMax
14556>>>>>>>>>>
14556>>>>>>>>>            Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                (Data_Description(Self,iCnt)) iFile ;                (Data_RowId(Self,iCnt))
14557>>>>>>>>>        Loop
14558>>>>>>>>>>
14558>>>>>>>>>    End_Procedure
14559>>>>>>>>>    
14559>>>>>>>>>    
14559>>>>>>>>>    // returns all data in a two dimension variant array.
14559>>>>>>>>>    // [i][0] = data
14559>>>>>>>>>    // [i][1] = description
14559>>>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
14559>>>>>>>>>    Function TableData Returns Variant[][]
14561>>>>>>>>>        Variant[][2] vData
14562>>>>>>>>>        Integer iMax i
14562>>>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
14564>>>>>>>>>            Send Delete_Data
14565>>>>>>>>>            Send Fill_list
14566>>>>>>>>>            Set Table_Loaded_State to True
14567>>>>>>>>>        End
14567>>>>>>>>>>
14567>>>>>>>>>        Get Data_Item_Count to iMax
14568>>>>>>>>>        For i from 0 to (iMax-1)
14574>>>>>>>>>>
14574>>>>>>>>>            Get Data_Value       i to vData[i][0]
14575>>>>>>>>>            Get Data_Description i to vData[i][1]
14576>>>>>>>>>        Loop
14577>>>>>>>>>>
14577>>>>>>>>>        Function_Return vData
14578>>>>>>>>>    End_Function
14579>>>>>>>>>    
14579>>>>>>>>>End_Class
14580>>>>>>>>>
14580>>>>>>>>>
14580>>>>>>>>>
14580>>>>>>>>>Class DescriptionValidationTable is an ValidationTable
14581>>>>>>>>>    
14581>>>>>>>>>    Procedure Construct_Object
14583>>>>>>>>>        Forward Send Construct_Object
14585>>>>>>>>>        Set Number_Elements to 2
14586>>>>>>>>>    End_Procedure
14587>>>>>>>>>    
14587>>>>>>>>>    Function Data_Item_Count Returns Integer
14589>>>>>>>>>        Function_Return (item_count(Self)/3)
14590>>>>>>>>>    End_Function
14591>>>>>>>>>    
14591>>>>>>>>>    Function Data_Value Integer iItem Returns String
14593>>>>>>>>>        Function_Return (Value(Self,iItem*3))
14594>>>>>>>>>    End_Function
14595>>>>>>>>>    
14595>>>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
14597>>>>>>>>>        Set Value  (iItem*3) to sValue
14598>>>>>>>>>    End_Procedure
14599>>>>>>>>>    
14599>>>>>>>>>    Function Data_Description Integer iItem Returns String
14601>>>>>>>>>        Function_Return (Value(Self,iItem*3+1))
14602>>>>>>>>>    End_Function
14603>>>>>>>>>    
14603>>>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
14605>>>>>>>>>        Set Value  (iItem*3+1) to sValue
14606>>>>>>>>>    End_Procedure
14607>>>>>>>>>    
14607>>>>>>>>>    Function Data_RowId Integer iItem Returns RowID
14609>>>>>>>>>        String sRowId
14609>>>>>>>>>        Get Value (iItem*3+2) to sRowId
14610>>>>>>>>>        Function_Return (DeSerializeRowId(sRowId))
14611>>>>>>>>>    End_Function
14612>>>>>>>>>    
14612>>>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
14614>>>>>>>>>        Set Value  (iItem*3+2) to (SerializeRowId(riValue))
14615>>>>>>>>>    End_Procedure
14616>>>>>>>>>    
14616>>>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowID riRec
14618>>>>>>>>>        String  sVal
14618>>>>>>>>>        RowID   riRecVal
14618>>>>>>>>>        Integer iCnt
14618>>>>>>>>>        Get Data_Item_Count to iCnt
14619>>>>>>>>>        Set Data_Value iCnt to sData
14620>>>>>>>>>        
14620>>>>>>>>>        // If one param passed use it for both display and database values
14620>>>>>>>>>        If (num_arguments <= 1);            Move sData  to sVal
14623>>>>>>>>>        Else ;            Move sDescr to sVal
14625>>>>>>>>>        Set Data_Description iCnt to sVal
14626>>>>>>>>>        
14626>>>>>>>>>        If (num_arguments <= 2) ;            Move (NullRowId()) to riRecVal
14629>>>>>>>>>        Else ;            Move riRec        to riRecVal
14631>>>>>>>>>        Set Data_RowId iCnt to riRecVal
14632>>>>>>>>>    End_Procedure
14633>>>>>>>>>End_Class
14634>>>>>>>>>
14634>>>>>>>>>
14634>>>>>>>>>Class FileValidationTable is an DescriptionValidationTable
14635>>>>>>>>>    
14635>>>>>>>>>    Procedure Construct_Object
14637>>>>>>>>>        Forward Send Construct_Object
14639>>>>>>>>>        Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
14640>>>>>>>>>        Property Integer Ordering          1   // Indx1 is a good guess.
14641>>>>>>>>>        Property String  Type_Value        ''  // default these two to
14642>>>>>>>>>        Property Integer Type_Field        0   // Undefined (none).
14643>>>>>>>>>        Property Integer Code_Field        1   // Fld 1=code, 2=descr
14644>>>>>>>>>        Property Integer Description_Field 2   // are good guesses.
14645>>>>>>>>>        
14645>>>>>>>>>        Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
14646>>>>>>>>>    End_Procedure
14647>>>>>>>>>    
14647>>>>>>>>>    Function Table_Loaded_State Returns Integer
14649>>>>>>>>>        Integer iRVal
14649>>>>>>>>>        Get No_fill_State to iRVal // if true, table always is loaded
14650>>>>>>>>>        If not iRval ;            Forward Get table_loaded_State to iRVal
14654>>>>>>>>>        Function_Return iRval
14655>>>>>>>>>    End_Function
14656>>>>>>>>>    
14656>>>>>>>>>    Function Validate_Value String sCode Returns Integer
14658>>>>>>>>>        Integer iRVal
14658>>>>>>>>>        Integer iDSO
14658>>>>>>>>>        Get Code_Load_Object  to iDSO
14659>>>>>>>>>        // we use standard validate, if code is blank, OR if
14659>>>>>>>>>        //   1. if no code DSO or the code DSO exists but is not busy.
14659>>>>>>>>>        //   2. AND it is not no-fill
14659>>>>>>>>>        //   3. AND it is static
14659>>>>>>>>>        // Else we find the record directly
14659>>>>>>>>>        // Note that the operation mode is busy during request_validate (the
14659>>>>>>>>>        // ddo does this). WHen operation mode is busy we must not use
14659>>>>>>>>>        // the code dso (must find manually).
14659>>>>>>>>>        If (sCode='' or ;            ( (iDSO=0 or Operation_Mode=0)    and ; // if no code DSO or DSO not busy            No_Fill_State(Self)=0 and ;            Static_State(Self) ) ) ;            Forward Get Validate_Value sCode to iRVal
14663>>>>>>>>>        Else If (sCode<>Current_Code(Self)) ;            Get Find_Value sCode to iRVal
14667>>>>>>>>>        Function_Return iRVal // OK
14668>>>>>>>>>    End_Function
14669>>>>>>>>>    
14669>>>>>>>>>    Procedure Initialize_File
14671>>>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
14671>>>>>>>>>        Get Code_Load_Object  to iDSO
14672>>>>>>>>>        Get Main_File         to iFile
14673>>>>>>>>>        Get Code_Field        to iCodeField
14674>>>>>>>>>        Get Description_Field to iDescField
14675>>>>>>>>>        Get Ordering          to iIndex
14676>>>>>>>>>        Get Type_Field        to iTypeField
14677>>>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Initialize_File to iDSO ;            iFile iIndex iCodeField iDescField ;            iTypeField (Type_Value(Self))
14680>>>>>>>>>        Else Begin
14681>>>>>>>>>            Clear iFile
14682>>>>>>>>>            // if Type exists, seed the type value
14682>>>>>>>>>            If iTypeField ;                Set_Field_Value iFile iTypeField to (Type_Value(Self))
14687>>>>>>>>>        End
14687>>>>>>>>>>
14687>>>>>>>>>    End_Procedure
14688>>>>>>>>>    
14688>>>>>>>>>    Function Find_Value String Code Returns Integer
14690>>>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
14690>>>>>>>>>        Get Code_Load_Object  to iDSO
14691>>>>>>>>>        Get Main_File         to iFile
14692>>>>>>>>>        Get Ordering          to iIndex
14693>>>>>>>>>        Get Code_Field        to iCodeField
14694>>>>>>>>>        Get Description_Field to iDescField
14695>>>>>>>>>        Get Type_Field        to iTypeField
14696>>>>>>>>>        Send Initialize_File
14697>>>>>>>>>        //
14697>>>>>>>>>        Set_Field_Value iFile iCodeField to Code
14700>>>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Request_Find to iDSO EQ iFile iIndex
14703>>>>>>>>>        Else ;            Vfind iFile iIndex EQ
14706>>>>>>>>>        If not (Found) ;            Function_Return 1
14709>>>>>>>>>        // Set properties Current_code and Current_Description
14709>>>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
14710>>>>>>>>>        Function_Return 0
14711>>>>>>>>>    End_Function
14712>>>>>>>>>    
14712>>>>>>>>>    // internal
14712>>>>>>>>>    Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
14714>>>>>>>>>        String sVal
14714>>>>>>>>>        Get_Field_Value iFile iCodeField to sVal
14717>>>>>>>>>        Set Current_Code to (trim(sVal))
14718>>>>>>>>>        If iDescField Begin
14720>>>>>>>>>            Get_Field_Value iFile iDescField to sVal
14723>>>>>>>>>            Set Current_Description to (trim(sVal))
14724>>>>>>>>>        End
14724>>>>>>>>>>
14724>>>>>>>>>        Set Current_RowId to (GetRowId(iFile))
14725>>>>>>>>>    End_Procedure
14726>>>>>>>>>    
14726>>>>>>>>>    Function Next_Code_Record Returns Boolean
14728>>>>>>>>>        Integer iFile iCodeField iDescField iIndex
14728>>>>>>>>>        Integer iTypeField
14728>>>>>>>>>        String sTypeValue sFoundTypeValue
14728>>>>>>>>>        Boolean bFound
14728>>>>>>>>>        Handle hoDSO
14728>>>>>>>>>        Get Code_Load_Object  to hoDSO
14729>>>>>>>>>        Get Description_Field to iDescField
14730>>>>>>>>>        Get Code_Field        to iCodeField
14731>>>>>>>>>        Get Main_File         to iFile
14732>>>>>>>>>        
14732>>>>>>>>>        If hoDSO Begin
14734>>>>>>>>>            Get Next_Code_record of hoDSO to bFound
14735>>>>>>>>>        End
14735>>>>>>>>>>
14735>>>>>>>>>        Else Begin
14736>>>>>>>>>            Get Ordering to iIndex
14737>>>>>>>>>            Vfind iFile iIndex GT
14739>>>>>>>>>            Move (Found) to bFound
14740>>>>>>>>>            If bFound Begin
14742>>>>>>>>>                // if found see if we are at the end of the valid list of types
14742>>>>>>>>>                Get Type_Field to iTypeField
14743>>>>>>>>>                Get Type_Value to sTypeValue
14744>>>>>>>>>                If ((iTypeField<>0) and (sTypeValue<>"")) Begin
14746>>>>>>>>>                    Get_Field_Value iFile iTypeField to sFoundTypeValue
14749>>>>>>>>>                    Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) to bFound
14750>>>>>>>>>                End
14750>>>>>>>>>>
14750>>>>>>>>>            End
14750>>>>>>>>>>
14750>>>>>>>>>        End
14750>>>>>>>>>>
14750>>>>>>>>>        If bFound Begin
14752>>>>>>>>>            Send Store_Current_Data iFile iCodeField iDescField
14753>>>>>>>>>        End
14753>>>>>>>>>>
14753>>>>>>>>>        Function_Return bFound
14754>>>>>>>>>    End_Function
14755>>>>>>>>>    
14755>>>>>>>>>    Procedure Fill_List
14757>>>>>>>>>        RowID riId
14757>>>>>>>>>        Boolean bFound
14757>>>>>>>>>        String sCode sDesc
14757>>>>>>>>>        If (Static_State(Self)=0 or No_Fill_State(Self)) ;            Procedure_Return
14760>>>>>>>>>        //
14760>>>>>>>>>        Send Delete_Data
14761>>>>>>>>>        Send Initialize_File
14762>>>>>>>>>        Get Next_Code_Record to bFound
14763>>>>>>>>>        While bFound
14767>>>>>>>>>            Get Current_Code        to sCode
14768>>>>>>>>>            Get Current_Description to sDesc
14769>>>>>>>>>            Get Current_RowId       to riId
14770>>>>>>>>>            Send Add_Table_Value sCode sDesc riId
14771>>>>>>>>>            Get Next_Code_Record to bFound
14772>>>>>>>>>        Loop
14773>>>>>>>>>>
14773>>>>>>>>>        Set Table_Loaded_State to True
14774>>>>>>>>>    End_Procedure
14775>>>>>>>>>    
14775>>>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
14777>>>>>>>>>        Integer iItem
14777>>>>>>>>>        Integer iFile
14777>>>>>>>>>        RowID   riId
14777>>>>>>>>>        Boolean bFound
14777>>>>>>>>>        String sCode sDesc
14777>>>>>>>>>        
14777>>>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
14780>>>>>>>>>        
14780>>>>>>>>>        If (Static_State(Self) and No_Fill_State(Self)=0 ) ;            Forward Send Request_Fill_From_List iObj iMsg
14784>>>>>>>>>        Else Begin
14785>>>>>>>>>            Get Main_File to iFile
14786>>>>>>>>>            Send Initialize_File
14787>>>>>>>>>            Get Next_Code_Record to bFound
14788>>>>>>>>>            While bFound
14792>>>>>>>>>                Get Current_Code        to sCode
14793>>>>>>>>>                Get Current_Description to sDesc
14794>>>>>>>>>                Get Current_RowId       to riId
14795>>>>>>>>>                Send iMSG to iObj iItem sCode sDesc iFile riId
14796>>>>>>>>>                Increment iItem
14797>>>>>>>>>                Get Next_Code_Record to bFound
14798>>>>>>>>>            Loop
14799>>>>>>>>>>
14799>>>>>>>>>        End
14799>>>>>>>>>>
14799>>>>>>>>>    End_Procedure
14800>>>>>>>>>End_Class
14801>>>>>>>>>
14801>>>>>>>>>Use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files\DataFlex 20.0\Pkg\codeload.pkg)
14801>>>>>>>>>>>// Interface:
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
14801>>>>>>>>>>>//                            Integer Desc# Integer Type# String Type
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
14801>>>>>>>>>>>//      parameters here. They are:
14801>>>>>>>>>>>//          File#  -  main file to use
14801>>>>>>>>>>>//         Index#  - Index to use for finding
14801>>>>>>>>>>>//          Code#  - field number of the code
14801>>>>>>>>>>>//          Desc#  - field number of the code's description
14801>>>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
14801>>>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//      You MUST send this message before finding records. Alternately,
14801>>>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
14801>>>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//    Get Next_Code_record to ret_Int
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
14801>>>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//    Get Current_Code to Ret_String
14801>>>>>>>>>>>//    Get Crnt_Description to Ret_String
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//      Returns the code and description of the last valid record found
14801>>>>>>>>>>>//      with the Next_Code_Record Message
14801>>>>>>>>>>>//
14801>>>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
14801>>>>>>>>>>>//                  radio-entry-form classes. In particular those using
14801>>>>>>>>>>>//                  the "code" look up file. Look at those packages if
14801>>>>>>>>>>>//                  you wish to use them yourself.
14801>>>>>>>>>>>//
14801>>>>>>>>>>>Use Data_Set.pkg
14801>>>>>>>>>>>
14801>>>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
14802>>>>>>>>>>>    
14802>>>>>>>>>>>    Procedure Construct_Object Integer Img#
14804>>>>>>>>>>>        Forward Send Construct_Object Img#
14806>>>>>>>>>>>        // These should be set by the Initialize_File message
14806>>>>>>>>>>>        Property String  Type_Value           '' // assume no defaults.
14807>>>>>>>>>>>        Property Integer Type_Field           0  // These values should be
14808>>>>>>>>>>>        Property Integer Code_Field           0  // set by initialize_file
14809>>>>>>>>>>>        Property Integer Description_Field    0  //
14810>>>>>>>>>>>        
14810>>>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
14810>>>>>>>>>>>        Property String  Current_Code         ''
14811>>>>>>>>>>>        Property String  Current_Description  ''
14812>>>>>>>>>>>    End_Procedure
14813>>>>>>>>>>>    
14813>>>>>>>>>>>    // If a Type exists (not a '') and there is a type field and a
14813>>>>>>>>>>>    // main_file constrain to the type. Else no constraints
14813>>>>>>>>>>>    Procedure OnConstrain
14815>>>>>>>>>>>        String sType
14815>>>>>>>>>>>        Integer iFile iField
14815>>>>>>>>>>>        Get Type_Value to sType
14816>>>>>>>>>>>        Get Main_File  to iFile
14817>>>>>>>>>>>        Get Type_Field to iField
14818>>>>>>>>>>>        If (sType<>'' and iFile<>0 and iField<>0) ;            Vconstrain iFile iField eq sType
14823>>>>>>>>>>>    End_Procedure
14824>>>>>>>>>>>    
14824>>>>>>>>>>>    //  This initializes the data-set for finding. You MUST pass all five
14824>>>>>>>>>>>    //  parameters here. They are:
14824>>>>>>>>>>>    //     File#  -  main file to use
14824>>>>>>>>>>>    //    Index#  - Index to use for finding
14824>>>>>>>>>>>    //     Code#  - field number of the code
14824>>>>>>>>>>>    //     Desc#  - field number of the code's description
14824>>>>>>>>>>>    //     Type#  - field number of the constraining Type (0 if none)
14824>>>>>>>>>>>    //      Type  - the constrain type value ('' = allow all records)
14824>>>>>>>>>>>    //
14824>>>>>>>>>>>    Procedure Initialize_File Integer File# Integer Index# Integer Code# ;            Integer Desc# Integer Type# String Type
14826>>>>>>>>>>>        // note: all params are required!
14826>>>>>>>>>>>        Set Main_File         to File#
14827>>>>>>>>>>>        Set Ordering          to Index#
14828>>>>>>>>>>>        Set Code_Field        to Code#
14829>>>>>>>>>>>        Set Description_Field to Desc#
14830>>>>>>>>>>>        Set Type_Field        to Type#
14831>>>>>>>>>>>        Set Type_Value        to Type
14832>>>>>>>>>>>        //
14832>>>>>>>>>>>        Send Rebuild_Constraints // set up constraints
14833>>>>>>>>>>>        Send Clear               // initialize the file
14834>>>>>>>>>>>    End_Procedure
14835>>>>>>>>>>>    
14835>>>>>>>>>>>    //  Find the next record: Return 0 if no record, 1 if record exists
14835>>>>>>>>>>>    //   if record exists set Current_Code and Current_Description
14835>>>>>>>>>>>    //
14835>>>>>>>>>>>    Function Next_Code_Record Returns Boolean
14837>>>>>>>>>>>        Integer iFile iField
14837>>>>>>>>>>>        String sValue
14837>>>>>>>>>>>        Send Request_Find GT (Main_File(Self)) (Ordering(Self))
14838>>>>>>>>>>>        If not (Found) ;            Function_Return False
14841>>>>>>>>>>>        // Set properties Current_code and Current_Description
14841>>>>>>>>>>>        Get Main_File to iFile
14842>>>>>>>>>>>        
14842>>>>>>>>>>>        Get Code_Field to iField
14843>>>>>>>>>>>        Get_Field_Value iFile iField to sValue
14846>>>>>>>>>>>        Set Current_Code to sValue
14847>>>>>>>>>>>        
14847>>>>>>>>>>>        Get Description_Field to iField
14848>>>>>>>>>>>        Get_Field_Value iFile iField to sValue
14851>>>>>>>>>>>        Set Current_Description to sValue
14852>>>>>>>>>>>        Function_Return True
14853>>>>>>>>>>>    End_Function
14854>>>>>>>>>>>    
14854>>>>>>>>>>>End_Class
14855>>>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCodeMaintOpen_Mixin.pkg)
14855>>>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
14855>>>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
14855>>>>>>>>>>>// were always opened with "open as"
14855>>>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
14855>>>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
14855>>>>>>>>>>>// open as - thus keeping this backwards compatible.
14855>>>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
14855>>>>>>>>>>>Use VDFBase.pkg
14855>>>>>>>>>>>
14855>>>>>>>>>>>Declare_Datafile CodeType
Including file: CodeType.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\CodeType.fd)
14855>>>>>>>>>>>Declare_Datafile CodeMast
Including file: CodeMast.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\CodeMast.fd)
14855>>>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
14855>>>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
14855>>>>>>>>>>>
14855>>>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
14856>>>>>>>>>>>    
14856>>>>>>>>>>>    Procedure OpenCodeMast
14858>>>>>>>>>>>        String sName
14858>>>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) Begin
14860>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
14863>>>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") Begin
14865>>>>>>>>>>>                Open CodeMast
14867>>>>>>>>>>>                Procedure_Return
14868>>>>>>>>>>>            End
14868>>>>>>>>>>>>
14868>>>>>>>>>>>        End
14868>>>>>>>>>>>>
14868>>>>>>>>>>>        Open "CodeMast" as Codemast.File_number
14870>>>>>>>>>>>    End_Procedure
14871>>>>>>>>>>>    
14871>>>>>>>>>>>    Procedure OpenCodeType
14873>>>>>>>>>>>        String sName
14873>>>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) Begin
14875>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
14878>>>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") Begin
14880>>>>>>>>>>>                Open CodeType
14882>>>>>>>>>>>                Procedure_Return
14883>>>>>>>>>>>            End
14883>>>>>>>>>>>>
14883>>>>>>>>>>>        End
14883>>>>>>>>>>>>
14883>>>>>>>>>>>        Open "CodeType" as CodeType.File_number
14885>>>>>>>>>>>    End_Procedure
14886>>>>>>>>>>>    
14886>>>>>>>>>>>End_Class
14887>>>>>>>>>
14887>>>>>>>>>//
14887>>>>>>>>>//  This is the object we need for loading files.
14887>>>>>>>>>//
14887>>>>>>>>>Object Code_loader is a Code_loader_Data_Set no_Image
14889>>>>>>>>>End_Object
14890>>>>>>>>>
14890>>>>>>>>>
14890>>>>>>>>>Class CodeValidationTable is an FileValidationTable
14891>>>>>>>>>    
14891>>>>>>>>>    // supports opening of file in reserved filelist area.
14891>>>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
14892>>>>>>>>>    
14892>>>>>>>>>    Procedure Construct_Object
14894>>>>>>>>>        Forward Send Construct_Object
14896>>>>>>>>>        
14896>>>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
14897>>>>>>>>>        
14897>>>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
14898>>>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
14899>>>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
14900>>>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
14901>>>>>>>>>        Set Description_Field to 3              // Fld 3: Description
14902>>>>>>>>>        Set Code_load_Object to (Code_Loader(Self))
14903>>>>>>>>>    End_Procedure
14904>>>>>>>>>    
14904>>>>>>>>>End_Class
14905>>>>>>>
14905>>>>>>>// Used to by DDOConstraintFindMeta to return constraint expression info in a friendlier fashion
14905>>>>>>>Struct tDDOConstraintFindMeta
14905>>>>>>>    Integer iJumpInSegments
14905>>>>>>>    Boolean bJumpOut
14905>>>>>>>    Boolean bPreRelate
14905>>>>>>>    Boolean bPostRelate
14905>>>>>>>End_Struct
14905>>>>>>>
14905>>>>>>>// used by webapp resynchs
14905>>>>>>>Struct tDDChangedParentInfo
14905>>>>>>>    Integer iTable
14905>>>>>>>    Boolean bSwitched
14905>>>>>>>End_Struct
14905>>>>>>>
14905>>>>>>>// used by webapp resynchs
14905>>>>>>>Struct tDDChangedInfo
14905>>>>>>>    Boolean bChanged
14905>>>>>>>    tDDChangedParentInfo[] ParentChanged
14905>>>>>>>    tDDChangedParentInfo[] ParentChanged
14905>>>>>>>End_Struct
14905>>>>>>>
14905>>>>>>>Enum_List
14905>>>>>>>    Define CONST_EXP_JUMPOUT     for 1
14905>>>>>>>    Define CONST_EXP_PRE_RELATE  for 2
14905>>>>>>>    Define CONST_EXP_POST_RELATE for 4
14905>>>>>>>End_Enum_List
14905>>>>>>>
14905>>>>>>>// Constraint Find Types
14905>>>>>>>Enum_List
14905>>>>>>>    Define CONST_VALUE for 0    // Constrain File.Field eq sValue
14905>>>>>>>    Define CONST_CHILD          // Constrain File Relates to iOtherFile
14905>>>>>>>    Define CONST_FIELD          // Constrain File.field eq OtherFile.OtherField
14905>>>>>>>    Define CONST_EXP            // Constrain File as (Expression) - expression is internal
14905>>>>>>>    Define CONST_RELATES        // Sames a CONST_CHILD - should never be used
14905>>>>>>>End_Enum_List
14905>>>>>>>
14905>>>>>>>// Constraint Find Modes
14905>>>>>>>Enum_List
14905>>>>>>>    Define CONST_LT for 0
14905>>>>>>>    Define CONST_LE for 1
14905>>>>>>>    Define CONST_EQ for 2
14905>>>>>>>    Define CONST_GE for 3
14905>>>>>>>    Define CONST_GT for 4
14905>>>>>>>    Define CONST_NE for 5
14905>>>>>>>    Define CONST_Matches for 6       // a matches not capable of a jump in e.g., "?A*"
14905>>>>>>>    Define CONST_Contains for 7      // a contains
14905>>>>>>>    Define CONST_MatchesJumpIn for 9 // a matches which is capable of a jump in e.g., "A*"
14905>>>>>>>    // note that BETWEEN is actually two constraints a GE and LE
14905>>>>>>>End_Enum_List
14905>>>>>>>
14905>>>>>>>// Struct used to DDOConstraints to return current constraints in an array
14905>>>>>>>Struct tConstraintDef
14905>>>>>>>    Integer eType // constraint Find type
14905>>>>>>>    Integer eMode // constrain file mode
14905>>>>>>>    Integer iFile
14905>>>>>>>    Integer iField
14905>>>>>>>    String sValue
14905>>>>>>>    Integer iOtherFile
14905>>>>>>>    Integer iOtherField
14905>>>>>>>End_Struct
14905>>>>>>>
14905>>>>>>>// values passed to OnPre/PostFind to indicate the operation type
14905>>>>>>>Enum_List
14905>>>>>>>    Define DDFindRequestFind    // request_find
14905>>>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
14905>>>>>>>    Define DDFindRequestAssign  // Request_assign
14905>>>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
14905>>>>>>>End_Enum_List
14905>>>>>>>
14905>>>>>>>
14905>>>>>>>// these are private
14905>>>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
14905>>>>>>>Use tDDRemembered.pkg
Including file: tDDRemembered.pkg    (C:\Program Files\DataFlex 20.0\Pkg\tDDRemembered.pkg)
14905>>>>>>>>>// DDRemember Struct used for DataDictionary Class
14905>>>>>>>>>
14905>>>>>>>>>// private
14905>>>>>>>>>
14905>>>>>>>>>Struct tDDRemembered
14905>>>>>>>>>    Integer iField // searches are performed on this segement - it must be first
14905>>>>>>>>>    String sDefault
14905>>>>>>>>>    String sLastValue
14905>>>>>>>>>End_Struct
14905>>>>>>>>>
14905>>>>>>>
14905>>>>>>>// Used to assign a global validation_object. This can be used for
14905>>>>>>>// automatic prompt object on non-relational validations (checks, validation_
14905>>>>>>>// tables, etc.)
14905>>>>>>>Integer DD_Global_Validation_Prompt_Object
14905>>>>>>>Move 0 to DD_Global_Validation_Prompt_Object
14906>>>>>>>
14906>>>>>>>// Used for Dso traversal marking - Private (do not use)
14906>>>>>>>Integer   DD_Current_Mark_Id
14906>>>>>>>Move 0 to DD_Current_Mark_Id
14907>>>>>>>
14907>>>>>>>// Used to validate DSO structures during Save and deletes
14907>>>>>>>Enumeration_List
14907>>>>>>>    Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
14907>>>>>>>    Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
14907>>>>>>>    Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
14907>>>>>>>End_Enumeration_List
14907>>>>>>>
14907>>>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
14907>>>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
14907>>>>>>>Enumeration_List
14907>>>>>>>    Define DD_ERROR_REPORT              // Report Error on screen
14907>>>>>>>    Define DD_ERROR_NO_REPORT           // Show no Error..
14907>>>>>>>End_Enumeration_List
14907>>>>>>>
14907>>>>>>>Enumeration_List
14907>>>>>>>    Define DD_Lock_on_All             for  7  // 111
14907>>>>>>>    Define DD_Lock_on_New_Save_Delete for  5  // 101
14907>>>>>>>    Define DD_Lock_on_Delete          for  4  // 100
14907>>>>>>>    Define DD_Lock_on_Save            for  2  // 010
14907>>>>>>>    Define DD_Lock_on_New_Save        for  1  // 001
14907>>>>>>>End_Enumeration_List
14907>>>>>>>
14907>>>>>>>
14907>>>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
14907>>>>>>>
14907>>>>>>>
14907>>>>>>>
14907>>>>>>>
14907>>>>>>>// The next replaces will be used to indicate default item-options
14907>>>>>>>// instead of a fieldnumber which is normally used.
14907>>>>>>>
14907>>>>>>>// these are the DD bits that pertain to DEO Item options.
14907>>>>>>>Define DD_DEO_MASK for (DD_NOENTER ior DD_SKIPFOUND ior DD_CAPSLOCK ior DD_ZERO_SUPPRESS ior DD_AUTORETURN ior DD_AUTOBACK ior DD_AUTOCLEAR)
14907>>>>>>>
14907>>>>>>>
14907>>>>>>>// Special parameter options that can get passed to Set Field_Options. The
14907>>>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
14907>>>>>>>// these are not used so it does not matter if their interface is a bit odd.
14907>>>>>>>Enumeration_List
14907>>>>>>>    Define DD_CLEAR_FIELD_OPTIONS      for -1
14907>>>>>>>    Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
14907>>>>>>>End_Enumeration_List
14907>>>>>>>
14907>>>>>>>// used to keep track of extra server file information.
14907>>>>>>>Struct tDDServerInformation
14907>>>>>>>    Integer iParent             // parent file number
14907>>>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
14907>>>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
14907>>>>>>>    Boolean bNoCascadeDelete           // when a child record exists should cascade delete stop the action
14907>>>>>>>    Boolean bCascadeDeleteNullTheParent // when a child record exists that is null parent allowed, should we delete or null the parent
14907>>>>>>>End_Struct
14907>>>>>>>
14907>>>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files\DataFlex 20.0\Pkg\DDExtFld.pkg)
14907>>>>>>>>>// This is used by the DataDictionary class and provides a method for
14907>>>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
14907>>>>>>>>>// Field objects are created within the DD by sending the message:
14907>>>>>>>>>// The DD interface is:
14907>>>>>>>>>//
14907>>>>>>>>>//      Get  Field_Object iField to hExtFieldObject
14907>>>>>>>>>//      Send DefineExtendedField iField
14907>>>>>>>>>//      Send DefineAllExtendedFields
14907>>>>>>>>>//      Send ExtendedFieldsUpdate bSave
14907>>>>>>>>>//      Send ExtendedFieldsRefresh bCleared
14907>>>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
14907>>>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
14907>>>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
14907>>>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
14907>>>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
14907>>>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
14907>>>>>>>>>//
14907>>>>>>>>>// Once object is identified, the following interface can be used
14907>>>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
14907>>>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
14907>>>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
14907>>>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
14907>>>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
14907>>>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
14907>>>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
14907>>>>>>>>>//
14907>>>>>>>>>
14907>>>>>>>>>//
14907>>>>>>>>>//  DD structure:
14907>>>>>>>>>//       DD Object           (property Field_objects points to child)
14907>>>>>>>>>//           FieldObjects    (array of field#s and field objs)
14907>>>>>>>>>//              FieldObject1 (heap alloc for each field)
14907>>>>>>>>>//              FieldObjectn
14907>>>>>>>>>//
14907>>>>>>>>>
14907>>>>>>>>>//
14907>>>>>>>>>// This is used to create a single extended field object.
14907>>>>>>>>>//
14907>>>>>>>>>// Interface
14907>>>>>>>>>//      Get FieldPointer to iMemoryPointer
14907>>>>>>>>>//      Get FieldLength  to iLen
14907>>>>>>>>>//      Get File_Number  to iFile
14907>>>>>>>>>//      Get Field_Number to iFile
14907>>>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
14907>>>>>>>>>//      get/Set Update_Find_State to bState         // be careful
14907>>>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
14907>>>>>>>>>//      get/set FieldChangedState
14907>>>>>>>>>//      send defineField  iFile iField
14907>>>>>>>>>//      Send FieldUpdate  bSave
14907>>>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
14907>>>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
14907>>>>>>>>>//      Set  Field_pValue iLen to pValue
14907>>>>>>>>>//
14907>>>>>>>>>Use VDFBase.pkg
14907>>>>>>>>>
14907>>>>>>>>>Class FieldObject is a cObject
14908>>>>>>>>>    
14908>>>>>>>>>    Procedure Construct_Object
14910>>>>>>>>>        Forward Send construct_object
14912>>>>>>>>>        // these are all set by DefineField and should not be changed
14912>>>>>>>>>        Property Integer File_Number        0
14913>>>>>>>>>        Property Integer Field_Number       0
14914>>>>>>>>>        Property Integer FieldLength        0
14915>>>>>>>>>        
14915>>>>>>>>>        // maintained by object
14915>>>>>>>>>        Property UChar[] pFieldArray
14916>>>>>>>>>        
14916>>>>>>>>>        // these can be changed, with care, by the developer
14916>>>>>>>>>        Property Integer Update_Save_State  True
14917>>>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
14918>>>>>>>>>        Property Integer FieldRefresh_State True
14919>>>>>>>>>        
14919>>>>>>>>>        // hopefully never used
14919>>>>>>>>>        Property Pointer pLegacyFieldPointer       0
14920>>>>>>>>>        
14920>>>>>>>>>    End_Procedure
14921>>>>>>>>>    
14921>>>>>>>>>    Procedure Set FieldChangedState Integer bState
14923>>>>>>>>>        Integer iField
14923>>>>>>>>>        Get Field_Number to iField
14924>>>>>>>>>        Delegate Set Field_Changed_state iField to bState
14926>>>>>>>>>    End_Procedure
14927>>>>>>>>>    
14927>>>>>>>>>    Function FieldChangedState Returns Integer
14929>>>>>>>>>        Integer iField  bState
14929>>>>>>>>>        Get Field_Number to iField
14930>>>>>>>>>        Delegate Get Field_Changed_state iField to bState
14932>>>>>>>>>        Function_Return bState
14933>>>>>>>>>    End_Function
14934>>>>>>>>>    
14934>>>>>>>>>    // return the field option specified
14934>>>>>>>>>    Function IsSaveNoPut Returns Boolean
14936>>>>>>>>>        Integer iField
14936>>>>>>>>>        Boolean  bState
14936>>>>>>>>>        Get Field_Number to iField
14937>>>>>>>>>        Delegate Get FieldSaveNoPut iField to bState
14939>>>>>>>>>        Function_Return bState
14940>>>>>>>>>    End_Function
14941>>>>>>>>>    
14941>>>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
14941>>>>>>>>>    //             and set memory pointer
14941>>>>>>>>>    Procedure DefineField Integer iFile Integer iField
14943>>>>>>>>>        Integer iFldLen
14943>>>>>>>>>        Set File_Number  to iFile
14944>>>>>>>>>        Set Field_Number to iField
14945>>>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
14948>>>>>>>>>        Set FieldLength  to iFldLen
14949>>>>>>>>>    End_Procedure
14950>>>>>>>>>    
14950>>>>>>>>>    // Move from the DD Buffer to the file buffer
14950>>>>>>>>>    Procedure FieldUpdate Integer bSave
14952>>>>>>>>>        Integer iFile iField iFieldLen
14952>>>>>>>>>        UChar[] FieldArray
14953>>>>>>>>>        Integer iType
14953>>>>>>>>>        Boolean bNoPut
14953>>>>>>>>>        
14953>>>>>>>>>        // if bSave, part of save which means only update if changed
14953>>>>>>>>>        // if not bsave, part of find. You usually would not update this. You
14953>>>>>>>>>        // don't index on these types of fields
14953>>>>>>>>>        If ( (bSave and Update_Save_State(Self) and FieldChangedState(Self)) or ;            (not(bSave) and Update_Find_state(Self) ) ) Begin
14955>>>>>>>>>            // if save, we must respect DD_NoPut
14955>>>>>>>>>            If (bSave) Begin
14957>>>>>>>>>                // we are looking at the DD's field buffer itemoptions for, which
14957>>>>>>>>>                // should be set appropriately before a save. This setting has any
14957>>>>>>>>>                // changes made to support dd_commit
14957>>>>>>>>>                Get IsSaveNoPut to bNoPut
14958>>>>>>>>>                If bNoPut Begin
14960>>>>>>>>>                    Procedure_Return
14961>>>>>>>>>                End
14961>>>>>>>>>>
14961>>>>>>>>>            End
14961>>>>>>>>>>
14961>>>>>>>>>            Get pFieldArray to FieldArray
14962>>>>>>>>>            Get File_Number to iFile
14963>>>>>>>>>            Get Field_Number to iField
14964>>>>>>>>>            If iFile Begin
14966>>>>>>>>>                Set_Field_Value iFile iField to FieldArray // LENGTH iFieldLen
14969>>>>>>>>>            End
14969>>>>>>>>>>
14969>>>>>>>>>        End
14969>>>>>>>>>>
14969>>>>>>>>>    End_Procedure
14970>>>>>>>>>    
14970>>>>>>>>>    // Move from File buffer to local DD Buffer
14970>>>>>>>>>    // bCleared determines if this is a find or a clear.
14970>>>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
14970>>>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
14972>>>>>>>>>        Integer iFile iField
14972>>>>>>>>>        Integer bOk
14972>>>>>>>>>        UChar[] FieldArray
14973>>>>>>>>>        If (FieldRefresh_state(Self)) Begin
14975>>>>>>>>>            //Get FieldPointer to pField
14975>>>>>>>>>            Get File_Number to iFile
14976>>>>>>>>>            Get Field_Number to iField
14977>>>>>>>>>            // move from file buffer to memory pointed to by pField
14977>>>>>>>>>            If (iFile) Begin
14979>>>>>>>>>                If not bCleared Begin
14981>>>>>>>>>                    Get_Field_Value iFile iField to FieldArray
14984>>>>>>>>>                End
14984>>>>>>>>>>
14984>>>>>>>>>                Set Field_UCValue to FieldArray
14985>>>>>>>>>            End
14985>>>>>>>>>>
14985>>>>>>>>>        End
14985>>>>>>>>>>
14985>>>>>>>>>        If bClearFieldChange Begin
14987>>>>>>>>>            Set FieldChangedstate to False
14988>>>>>>>>>        End
14988>>>>>>>>>>
14988>>>>>>>>>    End_Procedure
14989>>>>>>>>>    
14989>>>>>>>>>    Procedure Set Field_pEntry Integer iOpts Integer iLen Integer bShowErr Pointer pValue
14991>>>>>>>>>        Integer iFile iField iFldLen iMemLen
14991>>>>>>>>>        Integer bChanged
14991>>>>>>>>>        UChar[] FieldArray
14992>>>>>>>>>        
14992>>>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
14992>>>>>>>>>        
14992>>>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
14992>>>>>>>>>        // let NoPut through, since a user might need it for finding.
14992>>>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
14995>>>>>>>>>        
14995>>>>>>>>>        // maybe in the future
14995>>>>>>>>>        // Force a caplsock if required
14995>>>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
14995>>>>>>>>>        
14995>>>>>>>>>        Get File_Number  to iFile
14996>>>>>>>>>        Get Field_Number to iField
14997>>>>>>>>>        If (iFile) Begin
14999>>>>>>>>>            Get Is_pValueChanged iLen pValue to bChanged
15000>>>>>>>>>            If ( bChanged or (iOpts iand DD_FORCEPUT) ) Begin
15002>>>>>>>>>                Set Field_pValue iLen to pValue
15003>>>>>>>>>            End
15003>>>>>>>>>>
15003>>>>>>>>>            
15003>>>>>>>>>            
15003>>>>>>>>>            // Set changed state if changed and it is not No_put. This
15003>>>>>>>>>            // is an improvement on DEOs which would set changed-state for
15003>>>>>>>>>            // a no-put. This way, finds use the changed value but saves will
15003>>>>>>>>>            // not trigger a phony data loss
15003>>>>>>>>>            //If ( bChanged ) ;
15003>>>>>>>>>            If ( bChanged and not(iOpts iand DD_NOPUT) ) ;                Set FieldChangedState to True
15006>>>>>>>>>            
15006>>>>>>>>>            // The following is really highly unlikely!!!
15006>>>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
15006>>>>>>>>>            // part of validation.
15006>>>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
15006>>>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
15006>>>>>>>>>            // when a parent record is already loaded.
15006>>>>>>>>>            If (bChanged or FieldChangedState(Self)) Begin
15008>>>>>>>>>                If (iOpts iand DD_AUTOFIND) ;                    Delegate Send File_Field_AutoFind iFile iField EQ
15012>>>>>>>>>                Else If (iOpts iand DD_AUTOFIND_GE) ;                    Delegate Send File_Field_AutoFind iFile iField GE
15017>>>>>>>>>            End
15017>>>>>>>>>>
15017>>>>>>>>>        End
15017>>>>>>>>>>
15017>>>>>>>>>        
15017>>>>>>>>>    End_Procedure
15018>>>>>>>>>    
15018>>>>>>>>>    // convert pointer to UChar[]
15018>>>>>>>>>    Function PointerToUCharArray Pointer pValue Integer iLen Returns UChar[]
15020>>>>>>>>>        UChar[] FieldArray
15021>>>>>>>>>        Boolean bOk
15021>>>>>>>>>        Move (ResizeArray(FieldArray,iLen)) to FieldArray
15022>>>>>>>>>        Move (MemCopy(AddressOf(FieldArray),pValue,iLen)) to bOK
15023>>>>>>>>>        Function_Return FieldArray
15024>>>>>>>>>    End_Function
15025>>>>>>>>>    
15025>>>>>>>>>    // Raw update of pValue
15025>>>>>>>>>    Procedure Set Field_UCValue UChar[] FieldArray
15027>>>>>>>>>        Set pFieldArray to FieldArray
15028>>>>>>>>>        Send DestroyLegacyFieldHeap
15029>>>>>>>>>    End_Procedure
15030>>>>>>>>>    
15030>>>>>>>>>    // Raw update of pValue
15030>>>>>>>>>    Procedure Set Field_pValue Integer iLen Pointer pValue
15032>>>>>>>>>        UChar[] FieldArray
15033>>>>>>>>>        Get PointerToUCharArray pValue iLen to FieldArray
15034>>>>>>>>>        Set Field_UCValue to FieldArray
15035>>>>>>>>>    End_Procedure
15036>>>>>>>>>    
15036>>>>>>>>>    Function Is_pValueChanged Integer iLen Pointer pValue Returns Boolean
15038>>>>>>>>>        Boolean bChanged
15038>>>>>>>>>        UChar[] FieldArray
15039>>>>>>>>>        Integer iFldLen
15039>>>>>>>>>        Get pFieldArray to FieldArray
15040>>>>>>>>>        Move (SizeOfArray(FieldArray)) to iFldLen
15041>>>>>>>>>        If (iLen <> SizeOfArray(FieldArray)) Begin
15043>>>>>>>>>            Move True to bChanged
15044>>>>>>>>>        End
15044>>>>>>>>>>
15044>>>>>>>>>        Else If (iLen) Begin // check for empty pointer
15047>>>>>>>>>            Move (MemCompare(AddressOf(FieldArray),pValue,iLen)) to bChanged
15048>>>>>>>>>        End
15048>>>>>>>>>>
15048>>>>>>>>>        Function_Return bChanged
15049>>>>>>>>>    End_Function
15050>>>>>>>>>    
15050>>>>>>>>>    // returns data as UChar array - best way to access the data
15050>>>>>>>>>    Function FieldArray Returns UChar[]
15052>>>>>>>>>        UChar[] FieldArray
15053>>>>>>>>>        Get pFieldArray to FieldArray
15054>>>>>>>>>        Function_Return FieldArray
15055>>>>>>>>>    End_Function
15056>>>>>>>>>    
15056>>>>>>>>>    // legacy method. Hopefully this is never called.
15056>>>>>>>>>    Function FieldPointer Returns Pointer
15058>>>>>>>>>        Pointer pValue pOldValue
15058>>>>>>>>>        Integer iLen
15058>>>>>>>>>        UChar[] FieldArray
15059>>>>>>>>>        Boolean bOk
15059>>>>>>>>>        Get pFieldArray to FieldArray
15060>>>>>>>>>        Move (SizeOfArray(FieldArray)) to iLen
15061>>>>>>>>>        Move (Alloc(iLen)) to pValue
15062>>>>>>>>>        Move (MemCopy(pValue,AddressOf(FieldArray),iLen)) to bOk
15063>>>>>>>>>        Send DestroyLegacyFieldHeap
15064>>>>>>>>>        Set pLegacyFieldPointer to pValue
15065>>>>>>>>>        Function_Return pValue
15066>>>>>>>>>    End_Function
15067>>>>>>>>>    
15067>>>>>>>>>    Procedure DestroyLegacyFieldHeap
15069>>>>>>>>>        Integer bOK
15069>>>>>>>>>        Pointer pField
15069>>>>>>>>>        Get pLegacyFieldPointer to pField
15070>>>>>>>>>        If (pField ) Begin
15072>>>>>>>>>            Move (Free(pField)) to bOk
15073>>>>>>>>>            Set pLegacyFieldPointer to 0
15074>>>>>>>>>        End
15074>>>>>>>>>>
15074>>>>>>>>>    End_Procedure
15075>>>>>>>>>    
15075>>>>>>>>>    // augment to release heap allocation
15075>>>>>>>>>    Procedure Destroy_Object
15077>>>>>>>>>        Send DestroyLegacyFieldHeap
15078>>>>>>>>>        Forward Send Destroy_object
15080>>>>>>>>>    End_Procedure
15081>>>>>>>>>    
15081>>>>>>>>>End_Class
15082>>>>>>>>>
15082>>>>>>>>>// This contains all extended field objects.
15082>>>>>>>>>// The array contains a list of all objects where item=field#
15082>>>>>>>>>// and item+1=field object.
15082>>>>>>>>>//
15082>>>>>>>>>// Interface is:
15082>>>>>>>>>//     Get Field_object iField to hFldObj
15082>>>>>>>>>//     Send DefineFieldObject iField
15082>>>>>>>>>//     Send ExtendedFieldsUpdate bSave
15082>>>>>>>>>//     Send ExtendedFieldsRefresh bCleared
15082>>>>>>>>>//
15082>>>>>>>>>Class FieldObjects is an Array
15083>>>>>>>>>    
15083>>>>>>>>>    // return object Id for iField. 0 if none.
15083>>>>>>>>>    Function Field_Object Integer iField Returns Integer
15085>>>>>>>>>        Integer iItm iCnt
15085>>>>>>>>>        Get Item_Count to iCnt
15086>>>>>>>>>        Move 0 to iItm
15087>>>>>>>>>        While iItm lt iCnt
15091>>>>>>>>>            If (Value(Self,iItm)=iField) ;                Function_Return (Value(Self,iItm+1))
15094>>>>>>>>>            Increment iItm
15095>>>>>>>>>            Increment iItm
15096>>>>>>>>>        Loop
15097>>>>>>>>>>
15097>>>>>>>>>        Function_Return 0
15098>>>>>>>>>    End_Function
15099>>>>>>>>>    
15099>>>>>>>>>    // define an extended object for field
15099>>>>>>>>>    Procedure DefineFieldObject Integer iField
15101>>>>>>>>>        Integer hFld
15101>>>>>>>>>        Integer iCnt  iFile
15101>>>>>>>>>        Boolean bInUse
15101>>>>>>>>>        Boolean bHasRecord
15101>>>>>>>>>        Delegate Get Main_File to iFile
15103>>>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
15104>>>>>>>>>        If not hFld Begin
15106>>>>>>>>>            Get Create U_FieldObject to hFld
15107>>>>>>>>>            Send DefineField to hFld iFile iField
15108>>>>>>>>>            Get Item_Count to iCnt          // add to array
15109>>>>>>>>>            Set Value  iCnt to iField   // Pos   = field#
15110>>>>>>>>>            Set Value  (iCnt+1) to hFld // Pos+1 = field object
15111>>>>>>>>>            Delegate Get In_Use_State to bInUse
15113>>>>>>>>>            If bInUse Begin
15115>>>>>>>>>                Delegate Send Refind_Records
15117>>>>>>>>>                Delegate Get HasRecord to bHasRecord
15119>>>>>>>>>                // updating the newly created field with the file buffer contents we don't
15119>>>>>>>>>                // want to change the field's changed state, which might have been set already.
15119>>>>>>>>>                Send FieldRefresh of hFld (not(bHasRecord)) False
15120>>>>>>>>>            End
15120>>>>>>>>>>
15120>>>>>>>>>        End
15120>>>>>>>>>>
15120>>>>>>>>>    End_Procedure
15121>>>>>>>>>    
15121>>>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
15121>>>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
15123>>>>>>>>>        Integer iItm iCnt
15123>>>>>>>>>        Get Item_Count to iCnt
15124>>>>>>>>>        Move 0 to iItm
15125>>>>>>>>>        While iItm lt iCnt
15129>>>>>>>>>            Increment iItm
15130>>>>>>>>>            Send FieldUpdate to (Value(Self,iItm)) bSave
15131>>>>>>>>>            Increment iItm
15132>>>>>>>>>        Loop
15133>>>>>>>>>>
15133>>>>>>>>>    End_Procedure
15134>>>>>>>>>    
15134>>>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
15134>>>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
15136>>>>>>>>>        Integer iItm iCnt
15136>>>>>>>>>        Get Item_Count to iCnt
15137>>>>>>>>>        Move 0 to iItm
15138>>>>>>>>>        While iItm lt iCnt
15142>>>>>>>>>            Increment iItm
15143>>>>>>>>>            Send FieldRefresh to (Value(Self,iItm)) bCleared True
15144>>>>>>>>>            Increment iItm
15145>>>>>>>>>        Loop
15146>>>>>>>>>>
15146>>>>>>>>>    End_Procedure
15147>>>>>>>>>    
15147>>>>>>>>>    //
15147>>>>>>>>>    // these are sent from the child field object. We need to direct them
15147>>>>>>>>>    // to the DDO (the parent).
15147>>>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer bState
15149>>>>>>>>>        Delegate Set Field_Changed_state iField to bState
15151>>>>>>>>>    End_Procedure
15152>>>>>>>>>    
15152>>>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
15154>>>>>>>>>        Integer bState
15154>>>>>>>>>        Delegate Get Field_Changed_state iField to bState
15156>>>>>>>>>        Function_Return bState
15157>>>>>>>>>    End_Function
15158>>>>>>>>>    
15158>>>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iMode
15160>>>>>>>>>        Delegate Send File_field_AutoFind iFile iField iMode
15162>>>>>>>>>    End_Procedure
15163>>>>>>>>>    
15163>>>>>>>>>    Function FieldSaveNoPut Integer iField Returns Boolean
15165>>>>>>>>>        Boolean bIsCommited bNoPut
15165>>>>>>>>>        Delegate Get IsCommitted to bIsCommited
15167>>>>>>>>>        // we don't know if this is foreign or not (DDOs never do by themselves). We
15167>>>>>>>>>        // will test for regular. This should never be an issue as the DEO itself
15167>>>>>>>>>        // will be DisplayOnly as needed (we don't have indexed NoEnter=T/Noput=F issues)
15167>>>>>>>>>        Delegate Get FieldNoPut iField bIsCommited False to bNoPut
15169>>>>>>>>>        Function_Return bNoPut
15170>>>>>>>>>    End_Function
15171>>>>>>>>>    
15171>>>>>>>>>    Procedure Destroy_Object
15173>>>>>>>>>        Delegate Set Field_Objects to 0
15175>>>>>>>>>        Forward Send Destroy_object
15177>>>>>>>>>    End_Procedure
15178>>>>>>>>>    
15178>>>>>>>>>    
15178>>>>>>>>>End_Class
15179>>>>>>>// for text and binary. Must support Address Type
15179>>>>>>>
15179>>>>>>>
15179>>>>>>>// we need these from CLI.pkg for DAW drivers. These values must match what is defined
15179>>>>>>>// in cli.pkg
15179>>>>>>>Define DF_FILE_SQL_FILTER for 611
15179>>>>>>>Define DF_FILE_SQL_FILTER_ACTIVE for 624
15179>>>>>>>Define DF_FILE_SQL_FILTER_EQ for 636
15179>>>>>>>// same a CLI.pkg DF_FILE_TABLE_NAME but with a different name
15179>>>>>>>// used to avoid naming conflict. Must match cli.pkg df_file_table_name
15179>>>>>>>Define DF_FILE_SQL_TABLE_NAME for 609
15179>>>>>>>
15179>>>>>>>
15179>>>>>>>// Class helper for SQL/driver assistance.
15179>>>>>>>// This can only be used within a DataDictionary Class as it expects that
15179>>>>>>>// certain properties can be Get and Set via delegation.
15179>>>>>>>Class cDAWSQLDriverHelper is a cObject
15180>>>>>>>    
15180>>>>>>>    Function DriverIndex String sDriver Returns Integer
15182>>>>>>>        String  sCurrentDriver
15182>>>>>>>        Integer iNumberOfDrivers iDriver iCount
15182>>>>>>>        Move 0 to iDriver
15183>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
15186>>>>>>>        For iCount from 1 to iNumberOfDrivers
15192>>>>>>>>
15192>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
15195>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
15197>>>>>>>                Function_Return iCount
15198>>>>>>>            End
15198>>>>>>>>
15198>>>>>>>        Loop
15199>>>>>>>>
15199>>>>>>>        Function_Return 0
15200>>>>>>>    End_Function
15201>>>>>>>    
15201>>>>>>>    
15201>>>>>>>    // returns true if this table supports SQL filter interface
15201>>>>>>>    Function SupportsSQLFilters Returns Boolean
15203>>>>>>>        String sDriver
15203>>>>>>>        Integer iFile iDriver iConformance
15203>>>>>>>        Delegate Get Main_File to iFile
15205>>>>>>>        Get_Attribute DF_FILE_DRIVER of iFile to sDriver
15208>>>>>>>        Get DriverIndex sDriver to iDriver
15209>>>>>>>        If (iDriver) Begin
15211>>>>>>>            Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
15214>>>>>>>        End
15214>>>>>>>>
15214>>>>>>>        Function_Return (iConformance iand 4)
15215>>>>>>>    End_Function
15216>>>>>>>    
15216>>>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
15216>>>>>>>    
15216>>>>>>>    // Escape character to escape LIKE wildcards
15216>>>>>>>    
15216>>>>>>>    
15216>>>>>>>    Function SQLEscapedStr String sSQL Returns String
15218>>>>>>>        String sEscapedSQL
15218>>>>>>>        // Replace one single quote by 2 single quotes
15218>>>>>>>        Move (Replaces("'",sSQL,"''")) to sEscapedSQL
15219>>>>>>>        Function_Return sEscapedSQL
15220>>>>>>>    End_Function
15221>>>>>>>    
15221>>>>>>>    
15221>>>>>>>    Function SQLEscapeLikeWildcards String sSQL Returns String
15223>>>>>>>        
15223>>>>>>>        // Escape the wildcard characters than can be used in a LIKE
15223>>>>>>>        If (Pos("%",sSQL)) ;            Move (Replaces("%",sSQL,(SQL_LIKE_ESC + "%"))) to sSQL
15226>>>>>>>        If (Pos("_",sSQL)) ;            Move (Replaces("_",sSQL,(SQL_LIKE_ESC + "_"))) to sSQL
15229>>>>>>>        
15229>>>>>>>        Function_Return sSQL
15230>>>>>>>    End_Function
15231>>>>>>>    
15231>>>>>>>    
15231>>>>>>>    
15231>>>>>>>    // Creates an SQL Like Filter for this field and search target
15231>>>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
15233>>>>>>>        String sFilter sOrigFilter sField
15233>>>>>>>        Integer iFile
15233>>>>>>>        Integer iHasLikeEscape
15233>>>>>>>        String  sPrefix
15233>>>>>>>        
15233>>>>>>>        Delegate Get Main_File to iFile
15235>>>>>>>        Delegate Get psSQLFilter to sOrigFilter
15237>>>>>>>        Get SQLStrFieldName iField to sField
15238>>>>>>>        Get SQLEscapedStr sSearch to sSearch
15239>>>>>>>        
15239>>>>>>>        Move (Pos(SQL_LIKE_ESC,sSearch)) to iHasLikeEscape
15240>>>>>>>        If (not(iHasLikeEscape)) Begin
15242>>>>>>>            Get SQLEscapeLikeWildcards sSearch to sSearch
15243>>>>>>>        End
15243>>>>>>>>
15243>>>>>>>        
15243>>>>>>>        // Add the N prefix to properly handle Unicode data
15243>>>>>>>        Move 'N' to sPrefix
15244>>>>>>>        Move (sField + " LIKE " + sPrefix + "'%" + sSearch + "%'") to sFilter
15245>>>>>>>        
15245>>>>>>>        If (not(iHasLikeEscape)) Begin
15247>>>>>>>            If (Pos(SQL_LIKE_ESC,sFilter)) Begin
15249>>>>>>>                Move (sFilter + " ESCAPE '" + SQL_LIKE_ESC + "' "  ) to sFilter
15250>>>>>>>            End
15250>>>>>>>>
15250>>>>>>>        End
15250>>>>>>>>
15250>>>>>>>        
15250>>>>>>>        Function_Return sFilter
15251>>>>>>>    End_Function
15252>>>>>>>    
15252>>>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15252>>>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
15254>>>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
15256>>>>>>>            Move ( "(" + sOrigFilter + ") AND " + sFilter) to sFilter
15257>>>>>>>        End
15257>>>>>>>>
15257>>>>>>>        Else If (sFilter="") Begin
15260>>>>>>>            Move sOrigFilter to sFilter
15261>>>>>>>        End
15261>>>>>>>>
15261>>>>>>>        Function_Return sFilter
15262>>>>>>>    End_Function
15263>>>>>>>    
15263>>>>>>>    // Appends two filters with an or clause. Both or either can be empty.
15263>>>>>>>    // This may be used in OnConstrain methods when building SQL WHERE clauses in string values.
15263>>>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
15265>>>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
15267>>>>>>>            Move ("(" + sOrigFilter + ") OR (" + sFilter + ")") to sFilter
15268>>>>>>>        End
15268>>>>>>>>
15268>>>>>>>        Else If (sFilter="") Begin
15271>>>>>>>            Move sOrigFilter to sFilter
15272>>>>>>>        End
15272>>>>>>>>
15272>>>>>>>          Function_Return sFilter 
15273>>>>>>>    End_Function
15274>>>>>>>
15274>>>>>>>    // returns the name of the File and Field suitable for an SQL where statement ("Table"."Column")
15274>>>>>>>    Function SQLStrFileFieldName Integer iField Returns String
15276>>>>>>>        String sFile sField
15276>>>>>>>        Integer iFile
15276>>>>>>>        Get Main_File to iFile
15277>>>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
15280>>>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
15283>>>>>>>        Function_Return ('"' + sFile + '"' + '.' + '"' + sField + '"' ) 
15284>>>>>>>    End_Function
15285>>>>>>>
15285>>>>>>>    // returns the name of the Field suitable for an SQL where statement ("Column")
15285>>>>>>>    Function SQLStrFieldName Integer iField Returns String
15287>>>>>>>        String sField 
15287>>>>>>>        Integer iFile
15287>>>>>>>        Get Main_File to iFile
15288>>>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
15291>>>>>>>        
15291>>>>>>>        Function_Return ('"' + sField + '"' ) 
15292>>>>>>>    End_Function
15293>>>>>>>
15293>>>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement ("Schema"."Table"."Column")
15293>>>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
15295>>>>>>>        String sFile sField sSchema
15295>>>>>>>        Integer iFile
15295>>>>>>>        Get Main_File to iFile
15296>>>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
15299>>>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
15302>>>>>>>        Get_Attribute DF_FILE_OWNER of iFile to sSchema
15305>>>>>>>        
15305>>>>>>>        If (Trim(sSchema) <> "") ;            Function_Return ('"' + sSchema + '"' + '.' + '"' + sFile + '"' + '.' + '"' + sField + '"' ) 
15308>>>>>>>        Else ;            Function_Return ('"' + sFile + '"' + '.' + '"' + sField + '"' ) 
15310>>>>>>>    End_Function
15311>>>>>>>    
15311>>>>>>>    //  returns the name of a file suitable for a SQL statement
15311>>>>>>>    Function SQLStrFileName Integer iField Returns String
15313>>>>>>>        String sFile
15313>>>>>>>        Integer iFile
15313>>>>>>>        Get Main_File to iFile
15314>>>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
15317>>>>>>>        
15317>>>>>>>        Function_Return ('"' + sFile + '"')
15318>>>>>>>    End_Function
15319>>>>>>>
15319>>>>>>>
15319>>>>>>>    
15319>>>>>>>    // called before an SQL Filter find. Make sure that any global and table attributes are
15319>>>>>>>    // stored.
15319>>>>>>>    Procedure StoreDefaultSQLFilters
15321>>>>>>>        String sOldFilter
15321>>>>>>>        Boolean bOldFilterActive bOldFilterEQ
15321>>>>>>>        Integer iMain
15321>>>>>>>        Get Main_File to iMain
15322>>>>>>>        Get_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
15325>>>>>>>        Get_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
15328>>>>>>>        Get_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
15331>>>>>>>        Delegate Set psOldFilter to sOldFilter
15333>>>>>>>        Delegate Set pbOldFilterActive to bOldFilterActive
15335>>>>>>>        Delegate Set pbOldFilterEq to bOldFilterEQ
15337>>>>>>>    End_Procedure
15338>>>>>>>    
15338>>>>>>>    // called after an SQL find. Must restore the global and table SQL filter attributes
15338>>>>>>>    Procedure RestoreDefaultSQLFilters
15340>>>>>>>        String sOldFilter
15340>>>>>>>        Boolean bOldFilterActive bOldFilterEQ
15340>>>>>>>        Integer iMain
15340>>>>>>>        Delegate Get Main_File to iMain
15342>>>>>>>        Delegate Get psOldFilter to sOldFilter
15344>>>>>>>        Delegate Get pbOldFilterActive to bOldFilterActive
15346>>>>>>>        Delegate Get pbOldFilterEq to bOldFilterEQ
15348>>>>>>>        Set_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
15351>>>>>>>        Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
15354>>>>>>>        Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
15357>>>>>>>    End_Procedure
15358>>>>>>>    
15358>>>>>>>    // applies the passed SQL filter. If empty, it should make sure that no filter
15358>>>>>>>    // is applied. If non-empty it should set the filter active, set the filter string
15358>>>>>>>    // and make sure this is applied to all finds (including find EQ)
15358>>>>>>>    Procedure ApplySQLFilterStr String sFilter
15360>>>>>>>        Integer iMain
15360>>>>>>>        Delegate Get Main_File to iMain
15362>>>>>>>        If (sFilter<>"") Begin
15364>>>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to True
15367>>>>>>>            Set_Attribute DF_FILE_SQL_FILTER of iMain to sFilter
15370>>>>>>>            Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to True
15373>>>>>>>        End
15373>>>>>>>>
15373>>>>>>>        Else Begin
15374>>>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to False
15377>>>>>>>        End
15377>>>>>>>>
15377>>>>>>>    End_Procedure
15378>>>>>>>    
15378>>>>>>>End_Class
15379>>>>>>>
15379>>>>>>>// Every data_set will have a object based on this class. It will hold
15379>>>>>>>// the values for the fields, the entry_options and the messages IDs of the
15379>>>>>>>// iEntry, iExit and iValidate messages for each field.
15379>>>>>>>// It is assumed that an object of this class will always be used as a
15379>>>>>>>// child object of a Data_Set object.
15379>>>>>>>//
15379>>>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.
15379>>>>>>>//
15379>>>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION
15379>>>>>>>//
15379>>>>>>>// Value           The value of the field. Will be updated whenever the
15379>>>>>>>//                 value of a field changes due to data-entry or a found
15379>>>>>>>//                 record.
15379>>>>>>>// Data_File       Contains the filenumber. Is the same for every item.
15379>>>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the
15379>>>>>>>//                 items' itemnumber.
15379>>>>>>>// Item_Options    Used to store the standard item-options of a field.
15379>>>>>>>// Aux_Value       Used to store the foreign-item-options of a field.
15379>>>>>>>Class cRecordBuffer is an cDDBuffer
15380>>>>>>>    
15380>>>>>>>    // This procedure will be called from the Data_Set when the Main_File is
15380>>>>>>>    // being set. It will create an item for each field of the file in this
15380>>>>>>>    // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are
15380>>>>>>>    // currently not added.
15380>>>>>>>    Procedure Create_Items Integer iFile
15382>>>>>>>        Integer iField_Count iField
15382>>>>>>>        
15382>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
15385>>>>>>>        Set Main_File to iFile
15386>>>>>>>        Send Delete_Data
15387>>>>>>>        Set Item_Count to (iField_Count+1)
15388>>>>>>>        For iField from 0 to iField_Count
15394>>>>>>>>
15394>>>>>>>            // will skip recnum (field 0) if non-recnum table
15394>>>>>>>            // will set to skip if binary, text or overlap
15394>>>>>>>            Set Data_Field iField to iField
15395>>>>>>>        Loop
15396>>>>>>>>
15396>>>>>>>    End_Procedure
15397>>>>>>>    
15397>>>>>>>    // when an alias is created, we want to clear any values that will not be applied to
15397>>>>>>>    // this alias DD such as prompt and zoom objects (which would point to the superclass master)
15397>>>>>>>    Procedure ReDefineAliasItems Integer iFile
15399>>>>>>>        Integer i iItems
15399>>>>>>>        
15399>>>>>>>        Set Main_File to iFile
15400>>>>>>>        Get item_count to iItems
15401>>>>>>>        For i from 0 to (iItems-1)
15407>>>>>>>>
15407>>>>>>>            Set Prompt_Object i to 0
15408>>>>>>>            Set Zoom_Object i to 0
15409>>>>>>>        Loop
15410>>>>>>>>
15410>>>>>>>    End_Procedure
15411>>>>>>>    
15411>>>>>>>    
15411>>>>>>>    // This procedure will be called from the parent Data_Set whenever the
15411>>>>>>>    // Data_Set changes its Current_Record property, or after a Save, Delete
15411>>>>>>>    // or Clear operation.
15411>>>>>>>    // We use this event to store the values of the fields in our local
15411>>>>>>>    // record buffer.
15411>>>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
15413>>>>>>>        Integer iMain_File
15413>>>>>>>        Integer iOldState
15413>>>>>>>        tDDRemembered[] DefaultValues
15413>>>>>>>        tDDRemembered[] DefaultValues
15414>>>>>>>        Boolean bRetain bInReSync
15414>>>>>>>        Integer iFld iFlds iIndex
15414>>>>>>>        Handle hoDD
15414>>>>>>>        
15414>>>>>>>        Get Parent to hoDD
15415>>>>>>>        Delegate Get Main_File to iMain_File
15417>>>>>>>        
15417>>>>>>>        If not (IsNullRowId(riNew)) ;            Send Entry_Display
15420>>>>>>>        Else Begin
15421>>>>>>>            
15421>>>>>>>            If (OPERATION_ORIGIN) Begin
15423>>>>>>>                // this gets set by webapp during a resync. During resyncs you don't want to rely
15423>>>>>>>                // on the values in the buffers (as they may not be yours) so you cannot do retain
15423>>>>>>>                // of rememberlast. Fortunately, you don't need to as this information is not
15423>>>>>>>                // needed during a resync.
15423>>>>>>>                Get pbInResync of operation_origin to bInResync
15424>>>>>>>            End
15424>>>>>>>>
15424>>>>>>>            
15424>>>>>>>            // if we have any 17.0 Remember last value items, we must add those items to our array
15424>>>>>>>            // only do this if this is the operation origin or a parent (i.e., skip if a child DDO)
15424>>>>>>>            // Also skip if a resync. See above
15424>>>>>>>            If ( not(bInReSync) and ;                ( (Operation_Origin=hoDD) or ;                ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
15426>>>>>>>                Delegate Get pDDDefaults to DefaultValues
15428>>>>>>>                Move (SizeOfArray(DefaultValues)) to iFlds
15429>>>>>>>                For iFld from 0 to (iFlds-1)
15435>>>>>>>>
15435>>>>>>>                    Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
15436>>>>>>>// I don't think this test is needed
15436>>>>>>>//              // if a parent DD and not allow-foreign we want to ignore this if this is not an indexed field (for autofind)
15436>>>>>>>//              If ( bRetain and (Operation_Origin<>hoDD) and not(Allow_Foreign_New_Save_State(hoDD))) Begin
15436>>>>>>>//                 Get_Attribute DF_FIELD_INDEX of iMain_File DefaultValues[iFld].iField to iIndex
15436>>>>>>>//                 Move (iIndex<>0) to bRetain
15436>>>>>>>//              End
15436>>>>>>>                    If bRetain Begin
15438>>>>>>>                        Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
15439>>>>>>>                    End
15439>>>>>>>>
15439>>>>>>>                    Else Begin
15440>>>>>>>                        Move '' to DefaultValues[iFld].sLastValue
15441>>>>>>>                    End
15441>>>>>>>>
15441>>>>>>>                Loop
15442>>>>>>>>
15442>>>>>>>                Delegate Set pDDDefaults to DefaultValues
15444>>>>>>>            End
15444>>>>>>>>
15444>>>>>>>            
15444>>>>>>>            // we must do this to make retains not set changed_state
15444>>>>>>>            Delegate Get Change_Disabled_State to iOldState
15446>>>>>>>            Delegate Set Change_Disabled_State to True
15448>>>>>>>            // if mode is anything other than clear we do a clear all (clear keeps retains, clear all does not)
15448>>>>>>>            // also do clear-all if the DDO is foreign.
15448>>>>>>>            
15448>>>>>>>            // If bInReSync, we never use retains as the buffer is not ours yet.
15448>>>>>>>            // The Entry_Clear, Entry_Clear_All parameter is bIgnoreRetains.
15448>>>>>>>            // When True retain and retain_all states are ignored and cleared.
15448>>>>>>>            If (Operation_mode=MODE_CLEARING and ;                ( (Operation_Origin=parent(Self)) or ;                (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) Begin
15450>>>>>>>                Send Entry_Clear bInReSync
15451>>>>>>>            End
15451>>>>>>>>
15451>>>>>>>            Else Begin
15452>>>>>>>                Send Entry_Clear_all bInResync
15453>>>>>>>            End
15453>>>>>>>>
15453>>>>>>>            Delegate Set Change_Disabled_State to iOldState
15455>>>>>>>            Set Changed_State to False
15456>>>>>>>        End
15456>>>>>>>>
15456>>>>>>>    End_Procedure
15457>>>>>>>    
15457>>>>>>>    // Make sure to set the Changed_State of the Data_Set to TRUE when a
15457>>>>>>>    // field value changes and it's not during the Setting of the Defaults.
15457>>>>>>>    Procedure Set Changed_State Integer iState
15459>>>>>>>        Integer iNoChange
15459>>>>>>>        // Server.pkg in dso already knows this property
15459>>>>>>>        Delegate Get Change_disabled_State to iNoChange
15461>>>>>>>        If not iNoChange Begin
15463>>>>>>>            Forward Set Changed_State to iState
15465>>>>>>>            Delegate Set Changed_State to iState
15467>>>>>>>        End
15467>>>>>>>>
15467>>>>>>>    End_Procedure
15468>>>>>>>    
15468>>>>>>>End_Class
15469>>>>>>>
15469>>>>>>>
15469>>>>>>>// Objects of this class will be used to store all kinds of attributes
15469>>>>>>>// which belong to a field.
15469>>>>>>>//
15469>>>>>>>// FA_MIN_VALUE
15469>>>>>>>// Used to store the mininum value of field.
15469>>>>>>>//
15469>>>>>>>// FA_MAX_VALUE
15469>>>>>>>// Used to store the maximum value of a field.
15469>>>>>>>//
15469>>>>>>>// FA_CHECK_VALUE
15469>>>>>>>// Used to store a string which contains all possible values of a field.
15469>>>>>>>//
15469>>>>>>>// FA_CHECKBOX_TRUE
15469>>>>>>>// Used to store the TRUE value for a checkbox field
15469>>>>>>>//
15469>>>>>>>// FA_CHECKBOX_FALSE
15469>>>>>>>// Used to store the FALSE value of a checkbox field
15469>>>>>>>//
15469>>>>>>>// FA_TABLE_OBJECT
15469>>>>>>>// Stores object Id of a validation table.
15469>>>>>>>//
15469>>>>>>>// FA_ERROR_MESSAGE
15469>>>>>>>// Used to store a error text which will be shown to a user when a fields
15469>>>>>>>// value violates one of the rules defined for it.
15469>>>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When
15469>>>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE,
15469>>>>>>>// MAX_VALUE or CHECK_VALUE.
15469>>>>>>>//
15469>>>>>>>
15469>>>>>>>
15469>>>>>>>// Validation Types
15469>>>>>>>Enumeration_List
15469>>>>>>>    Define FA_VALIDATION_TYPE_NONE
15469>>>>>>>    Define FA_VALIDATION_TYPE_RANGE
15469>>>>>>>    Define FA_VALIDATION_TYPE_CHECK
15469>>>>>>>    Define FA_VALIDATION_TYPE_CHECKBOX
15469>>>>>>>    Define FA_VALIDATION_TYPE_TABLE
15469>>>>>>>End_Enumeration_List
15469>>>>>>>
15469>>>>>>>
15469>>>>>>>Class Field_Attributes is a Array
15470>>>>>>>    
15470>>>>>>>    Procedure Construct_Object
15472>>>>>>>        Forward Send Construct_Object
15474>>>>>>>        // Private: This replaces the use of arrays to get at this value. This
15474>>>>>>>        // allows us to find specific validation types (like checkboxes) more
15474>>>>>>>        // quickly than scanning an array
15474>>>>>>>        Property String Private.Validation_Types     ''
15475>>>>>>>    End_Procedure
15476>>>>>>>    
15476>>>>>>>    // Returns the extended validation type for the passed field.
15476>>>>>>>    Function Field_Validation_Type Integer iField Returns Integer
15478>>>>>>>        Integer iType
15478>>>>>>>        If iField ;            Move (mid(Private.Validation_Types(Self),1,iField)) to iType
15481>>>>>>>        Else ;            Move FA_VALIDATION_TYPE_NONE to iType
15483>>>>>>>        Function_Return iType
15484>>>>>>>    End_Function
15485>>>>>>>    
15485>>>>>>>    Procedure Set Field_Validation_Type Integer iField String sType
15487>>>>>>>        Integer iType
15487>>>>>>>        String sTypes
15487>>>>>>>        If iField Begin
15489>>>>>>>            Get Private.Validation_Types to sTypes
15490>>>>>>>            Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
15491>>>>>>>        End
15491>>>>>>>>
15491>>>>>>>    End_Procedure
15492>>>>>>>    
15492>>>>>>>    // Set any defaults required by this class when the main file is created.
15492>>>>>>>    // Create a string which contains all validation types. Set all to
15492>>>>>>>    // No extended validation type.
15492>>>>>>>    Procedure Create_Items
15494>>>>>>>        String  sType
15494>>>>>>>        Integer iCount
15494>>>>>>>        Delegate Get Field_Count to iCOunt
15496>>>>>>>        Move FA_VALIDATION_TYPE_NONE to sType
15497>>>>>>>        Set Private.Validation_Types to (Repeat(sType,iCount))
15498>>>>>>>    End_Procedure
15499>>>>>>>    
15499>>>>>>>    // Return field number of next field matching the passed validation type.
15499>>>>>>>    // Pass validation type and last position checked. Return 0 if no match
15499>>>>>>>    Function Next_Validation_Type String sType Integer iOffset Returns Integer
15501>>>>>>>        String sTypes
15501>>>>>>>        Integer iPos
15501>>>>>>>        Get Private.Validation_Types to sTypes
15502>>>>>>>        Move (Pos(sType, mid(sTypes,255,iOffset+1))) to iPos
15503>>>>>>>        If iPos ;            Add iOffset to iPos
15506>>>>>>>        Function_Return iPos
15507>>>>>>>    End_Function
15508>>>>>>>    
15508>>>>>>>    // This procedure will be called by the Extended_Data_Set to set the
15508>>>>>>>    // errornumber and message which will be triggered when it needs to.
15508>>>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
15510>>>>>>>        Integer iBase
15510>>>>>>>        Move (iField * FA_COUNT) to iBase
15511>>>>>>>        Set Value (iBase + FA_ERROR_NUMBER) to iErr
15512>>>>>>>        Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
15513>>>>>>>    End_Procedure
15514>>>>>>>    
15514>>>>>>>    // Used to retreive the error number and message for a particular field
15514>>>>>>>    Function Field_Error_Number Integer iField Returns Integer
15516>>>>>>>        Integer iErr
15516>>>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
15517>>>>>>>        Function_Return iErr
15518>>>>>>>    End_Function
15519>>>>>>>    
15519>>>>>>>    Function Field_Error_Message Integer iField Returns String
15521>>>>>>>        String sValue
15521>>>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
15522>>>>>>>        Function_Return sValue
15523>>>>>>>    End_Function
15524>>>>>>>    
15524>>>>>>>    
15524>>>>>>>    // This function manages the validation of a field against its extended
15524>>>>>>>    // validations.
15524>>>>>>>    Function Validate_Field Integer iField Returns Integer
15526>>>>>>>        Integer iType
15526>>>>>>>        Integer iResult
15526>>>>>>>        Get Field_Validation_Type iField to iType
15527>>>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Get Validate_Field_Range iField to iResult
15530>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Get Validate_Field_Check iField to iResult
15534>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Get Validate_Field_Checkbox iField to iResult
15538>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Validate_Field_Table iField to iResult
15542>>>>>>>        Function_Return iResult
15543>>>>>>>    End_Function
15544>>>>>>>    
15544>>>>>>>    // All extended validations know how to send callback messages (iMsg) to
15544>>>>>>>    // the calling object (iObj). This allows external lists to get filled w/
15544>>>>>>>    // the contents of a range. Used by combo boxes, spinners, etc.
15544>>>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
15546>>>>>>>        Integer iType
15546>>>>>>>        Integer iResult
15546>>>>>>>        Get Field_Validation_Type iField to iType
15547>>>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Send Field_Fill_List_Field_Range iField iObj iMsg
15550>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Send Field_Fill_List_Field_Check iField iObj iMsg
15554>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Send Field_Fill_List_Field_Checkbox iField iObj iMsg
15558>>>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Send Field_Fill_List_Field_Table iField iObj iMsg
15562>>>>>>>    End_Procedure
15563>>>>>>>    
15563>>>>>>>    // Return the id of the validation table if one exists. Otherwise return
15563>>>>>>>    // a zero.
15563>>>>>>>    Function Field_Table_Object Integer iField Returns Integer
15565>>>>>>>        Integer iType
15565>>>>>>>        Integer iObj
15565>>>>>>>        Integer iBase
15565>>>>>>>        Move (iField * FA_COUNT) to iBase
15566>>>>>>>        Get Field_Validation_Type iField to iType
15567>>>>>>>        If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Value (iBase + FA_TABLE_OBJECT) to iObj
15570>>>>>>>        Function_Return iObj
15571>>>>>>>    End_Function
15572>>>>>>>    
15572>>>>>>>    // Procedure to set the range for a field. It will automatically set the
15572>>>>>>>    // validation type of the field as well.
15572>>>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
15574>>>>>>>        Integer iBase
15574>>>>>>>        Move (iField * FA_COUNT) to iBase
15575>>>>>>>        Set Value (iBase + FA_MIN_VALUE) to sMin
15576>>>>>>>        Set Value (iBase + FA_MAX_VALUE) to sMax
15577>>>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
15578>>>>>>>    End_Procedure
15579>>>>>>>    
15579>>>>>>>    // Function to check a fields value agains a given check string.
15579>>>>>>>    Function Validate_Field_Range Integer iField Returns Integer
15581>>>>>>>        String  sMin
15581>>>>>>>        String  sMax
15581>>>>>>>        String  sValue
15581>>>>>>>        Integer iField_Type
15581>>>>>>>        Integer iResult
15581>>>>>>>        Integer iFile
15581>>>>>>>        Integer iBase
15581>>>>>>>        Move (iField * FA_COUNT) to iBase
15582>>>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
15583>>>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
15584>>>>>>>        Delegate Get Field_Current_Value iField to sValue
15586>>>>>>>        Delegate Get Main_File to iFile
15588>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
15591>>>>>>>        Move 0 to iResult
15592>>>>>>>        If (iField_Type=DF_ASCII) ;            Move (sValue < sMin or sValue > sMax) to iResult
15595>>>>>>>        Else If (iField_Type=DF_BCD) ;            Move (Number(sValue) < Number(sMin) or ;            Number(sValue) > Number(sMax)) to iResult
15599>>>>>>>        Else If (iField_Type=DF_DATE) ;            Move (Date(sValue) < Date(sMin) or Date(sValue) > Date(sMax)) to iResult
15603>>>>>>>        Else If (iField_Type=DF_DATETIME) ;            Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
15607>>>>>>>        If iResult Begin
15609>>>>>>>            Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
15611>>>>>>>            Function_Return 1
15612>>>>>>>        End
15612>>>>>>>>
15612>>>>>>>    End_Function
15613>>>>>>>    
15613>>>>>>>    // Callback to provide all valid value for this validation.
15613>>>>>>>    // Just call back with the two range values
15613>>>>>>>    Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
15615>>>>>>>        String  sMin
15615>>>>>>>        String  sMax
15615>>>>>>>        Integer iBase
15615>>>>>>>        Move (iField * FA_COUNT) to iBase
15616>>>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
15617>>>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
15618>>>>>>>        Send iMsg to iObj 0 sMin '' 0 (NullrowId())
15619>>>>>>>        Send iMsg to iObj 1 sMax '' 0 (NullrowId())
15620>>>>>>>    End_Procedure
15621>>>>>>>    
15621>>>>>>>    // Procedure to set the check for a field. It will automatically set the
15621>>>>>>>    // validation type of the field as well.
15621>>>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
15623>>>>>>>        Integer iBase
15623>>>>>>>        Move (iField * FA_COUNT) to iBase
15624>>>>>>>        Set Value (iBase + FA_CHECK_VALUE) to sCheck
15625>>>>>>>        //Set Value iBase to FA_VALIDATION_TYPE_CHECK
15625>>>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
15626>>>>>>>    End_Procedure
15627>>>>>>>    
15627>>>>>>>    // Function to check a fields value agains a given check string.
15627>>>>>>>    Function Validate_Field_Check Integer iField Returns Integer
15629>>>>>>>        String  sCheck
15629>>>>>>>        String  sValue
15629>>>>>>>        Integer iBase
15629>>>>>>>        Integer iPos
15629>>>>>>>        Integer iLength
15629>>>>>>>        Integer iResult
15629>>>>>>>        Integer iFile
15629>>>>>>>        Move (iField * FA_COUNT) to iBase
15630>>>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
15631>>>>>>>        Delegate Get Field_Current_Value iField to sValue
15633>>>>>>>        Delegate Get Main_File to iFile
15635>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
15638>>>>>>>        Move (Pad( sValue,iLength)) to sValue
15639>>>>>>>        // Replace the seperation characters with two of them so the user
15639>>>>>>>        // can't bypass the check by entering a seperation character.
15639>>>>>>>        Move (Replaces("|", sValue, "||")) to sValue
15640>>>>>>>        // Report an error if rules are violated.
15640>>>>>>>        Move (Pos( sValue, sCheck)) to iPos
15641>>>>>>>        If not iPos Begin
15643>>>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
15645>>>>>>>            Function_Return 1
15646>>>>>>>        End
15646>>>>>>>>
15646>>>>>>>    End_Function
15647>>>>>>>    
15647>>>>>>>    // Callback to provide all valid value for this validation.
15647>>>>>>>    // Call back with all valid check values
15647>>>>>>>    Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
15649>>>>>>>        String  sCheck
15649>>>>>>>        Integer iBase
15649>>>>>>>        Integer iPos
15649>>>>>>>        Integer iItem
15649>>>>>>>        Move (iField * FA_COUNT) to iBase
15650>>>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
15651>>>>>>>        Append sCheck "|"
15652>>>>>>>        Move (Pos( "|", sCheck)) to iPos
15653>>>>>>>        While iPos
15657>>>>>>>            If (iPos > 1) Begin
15659>>>>>>>                Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
15660>>>>>>>                Increment iItem
15661>>>>>>>            End
15661>>>>>>>>
15661>>>>>>>            Move (Mid( sCheck, 255, iPos+1))  to sCheck
15662>>>>>>>            Move (Pos( "|", sCheck)) to iPos
15663>>>>>>>        Loop
15664>>>>>>>>
15664>>>>>>>    End_Procedure
15665>>>>>>>    
15665>>>>>>>    // Procedure to set up a checkbox field. We will store the TRUE and FALSE
15665>>>>>>>    // Values in the extended array.
15665>>>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
15667>>>>>>>        Integer iBase
15667>>>>>>>        Move (iField * FA_COUNT) to iBase
15668>>>>>>>        Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
15669>>>>>>>        Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
15670>>>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
15671>>>>>>>    End_Procedure
15672>>>>>>>    
15672>>>>>>>    // Return the Value associated with the field and its select-state.
15672>>>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
15674>>>>>>>        Integer iBase
15674>>>>>>>        Integer iType
15674>>>>>>>        String sValue
15674>>>>>>>        Move (iField * FA_COUNT) to iBase
15675>>>>>>>        Get Field_Validation_Type iField to iType
15676>>>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move iState to sValue
15679>>>>>>>        Else ;            Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));            to sValue
15681>>>>>>>        Function_Return sValue
15682>>>>>>>    End_Function
15683>>>>>>>    
15683>>>>>>>    // Return the select_state based on the passed value and field
15683>>>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
15685>>>>>>>        Integer iBase
15685>>>>>>>        Integer iType
15685>>>>>>>        String  sTrue
15685>>>>>>>        Integer iState
15685>>>>>>>        Integer iFile
15685>>>>>>>        Integer iField_Type
15685>>>>>>>        Move (iField * FA_COUNT) to iBase
15686>>>>>>>        Get Field_Validation_Type iField to iType
15687>>>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
15688>>>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move (not(sValue=0 or sValue='')) to iState
15691>>>>>>>        Else Begin
15692>>>>>>>            Delegate Get Main_File to iFile
15694>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
15697>>>>>>>            If (iField_Type = DF_BCD) ;                Move (Number(sValue)=Number(sTrue)) to iState
15700>>>>>>>            Else ; // DF_ASCII                Move (sValue=sTrue) to iState
15702>>>>>>>        End
15702>>>>>>>>
15702>>>>>>>        Function_Return iState
15703>>>>>>>    End_Function
15704>>>>>>>    
15704>>>>>>>    
15704>>>>>>>    // Check that the buffer value is one of the two checkbox values.
15704>>>>>>>    Function Validate_Field_Checkbox Integer iField Returns Integer
15706>>>>>>>        String  sTrue
15706>>>>>>>        String  sFalse
15706>>>>>>>        String  sValue
15706>>>>>>>        Integer iField_Type
15706>>>>>>>        Integer iResult
15706>>>>>>>        Integer iFile
15706>>>>>>>        Integer iBase
15706>>>>>>>        Move (iField * FA_COUNT) to iBase
15707>>>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
15708>>>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
15709>>>>>>>        Delegate Get Field_Current_Value iField to sValue
15711>>>>>>>        Delegate Get Main_File to iFile
15713>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
15716>>>>>>>        Move 0 to iResult
15717>>>>>>>        If (iField_Type = DF_BCD) ;            Move (Number(sValue)=Number(sTrue) or ;            Number(sValue)=Number(sFalse)) to iResult
15720>>>>>>>        Else ; // DF_ASCII            Move (sValue=sTrue or sValue=sFalse) to iResult
15722>>>>>>>        If not iResult Begin
15724>>>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
15726>>>>>>>            Function_Return 1
15727>>>>>>>        End
15727>>>>>>>>
15727>>>>>>>    End_Function
15728>>>>>>>    
15728>>>>>>>    // Callback to provide all valid value for this validation.
15728>>>>>>>    // Just call back with the two true and false values
15728>>>>>>>    Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
15730>>>>>>>        String  sTrue
15730>>>>>>>        String  sFalse
15730>>>>>>>        Integer iBase
15730>>>>>>>        Move (iField * FA_COUNT) to iBase
15731>>>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
15732>>>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
15733>>>>>>>        Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
15734>>>>>>>        Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
15735>>>>>>>    End_Procedure
15736>>>>>>>    
15736>>>>>>>    // The object keeps track of a validation table object. This table object
15736>>>>>>>    // can be any type of object must at a minimum understand a small message
15736>>>>>>>    // protocol (see xvaltbl.pkg for info)
15736>>>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
15738>>>>>>>        Integer iBase
15738>>>>>>>        Move (iField * FA_COUNT) to iBase
15739>>>>>>>        Set Value (iBase + FA_TABLE_OBJECT) to iObj
15740>>>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
15741>>>>>>>    End_Procedure
15742>>>>>>>    
15742>>>>>>>    // This valdates against a validation table if appropriate (if a table
15742>>>>>>>    // exists and the table's validate_State is T). It validates by passing
15742>>>>>>>    // the message validate_value to the validation table object
15742>>>>>>>    Function Validate_Field_Table Integer iField Returns Integer
15744>>>>>>>        Integer iBase
15744>>>>>>>        Integer iTableObj
15744>>>>>>>        String  sValue
15744>>>>>>>        Integer iResult
15744>>>>>>>        Move (iField * FA_COUNT) to iBase
15745>>>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
15746>>>>>>>        If (iTableObj and Validate_State(iTableObj) ) Begin
15748>>>>>>>            Delegate Get Field_Current_Value iField to sValue
15750>>>>>>>            Get Validate_Value of iTableOBj sValue to iResult
15751>>>>>>>            If iResult ;                Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
15755>>>>>>>        End
15755>>>>>>>>
15755>>>>>>>        Function_Return iResult
15756>>>>>>>    End_Function
15757>>>>>>>    
15757>>>>>>>    // Callback to provide all valid value for this validation.
15757>>>>>>>    // Pass the request on to the validation table. This is the most common
15757>>>>>>>    // use of this.
15757>>>>>>>    Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
15759>>>>>>>        Integer iBase
15759>>>>>>>        Integer iTableObj
15759>>>>>>>        Move (iField * FA_COUNT) to iBase
15760>>>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
15761>>>>>>>        If iTableObj ;            Send Request_Fill_From_List to iTableObj iObj iMsg
15764>>>>>>>    End_Procedure
15765>>>>>>>    
15765>>>>>>>    // Often extended valditation types can provide automatic prompt
15765>>>>>>>    // objects. If the extended type supports a prompt object and there is
15765>>>>>>>    // a global validation_list object, we will use it
15765>>>>>>>    Function Prompt_Object Integer iField Returns Integer
15767>>>>>>>        Integer iType
15767>>>>>>>        Integer iObj
15767>>>>>>>        Get Field_Validation_Type iField to iType
15768>>>>>>>        If not (iType=FA_VALIDATION_TYPE_NONE or iType=FA_VALIDATION_TYPE_RANGE) ;            Move DD_Global_Validation_Prompt_Object to iObj
15771>>>>>>>        Function_Return iObj
15772>>>>>>>    End_Function
15773>>>>>>>    
15773>>>>>>>    
15773>>>>>>>End_Class
15774>>>>>>>
15774>>>>>>>
15774>>>>>>>
15774>>>>>>>// use to keep track of file field pairs such as system file file/field
15774>>>>>>>Struct tDDFileField
15774>>>>>>>    Integer iFile
15774>>>>>>>    Integer iField
15774>>>>>>>End_Struct
15774>>>>>>>
15774>>>>>>>Class Field_Mask_Array is an Array
15775>>>>>>>    
15775>>>>>>>    Function Array_Name Integer iField Integer iType Returns String
15777>>>>>>>        String sName
15777>>>>>>>        Move (iField*FMA_COUNT+iType) to iField
15778>>>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to sName
15781>>>>>>>        // sometimes an array value that is undefined returns a 0, we must change this to ''
15781>>>>>>>        If (sName = '0') ;            Move '' to sName
15784>>>>>>>        Function_Return sName
15785>>>>>>>    End_Function
15786>>>>>>>    
15786>>>>>>>    
15786>>>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
15788>>>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
15789>>>>>>>    End_Procedure
15790>>>>>>>    
15790>>>>>>>    Function Field_Mask_Type Integer iField Returns Integer
15792>>>>>>>        Integer iType
15792>>>>>>>        Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
15793>>>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iType
15796>>>>>>>        Function_Return iType
15797>>>>>>>    End_Function
15798>>>>>>>    
15798>>>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
15800>>>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
15801>>>>>>>    End_Procedure
15802>>>>>>>    
15802>>>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
15804>>>>>>>        Integer iState
15804>>>>>>>        Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
15805>>>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iState
15808>>>>>>>        Function_Return iState
15809>>>>>>>    End_Function
15810>>>>>>>    
15810>>>>>>>    Procedure Set Field_Mask Integer iField String sMask
15812>>>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
15813>>>>>>>    End_Procedure
15814>>>>>>>    
15814>>>>>>>    Function Field_Mask Integer iField Returns String
15816>>>>>>>        Function_Return (Array_Name(Self,iField,FMA_MASK))
15817>>>>>>>    End_Function
15818>>>>>>>    
15818>>>>>>>    Procedure Set Field_Label_Short Integer iField String sName
15820>>>>>>>        Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
15821>>>>>>>    End_Procedure
15822>>>>>>>    
15822>>>>>>>    Function Field_Label_Short Integer iField Returns String
15824>>>>>>>        Function_Return (Array_Name(Self,iField,FMA_SHORT_NAME))
15825>>>>>>>    End_Function
15826>>>>>>>    
15826>>>>>>>    Procedure Set Field_Label_Long Integer iField String sName
15828>>>>>>>        Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
15829>>>>>>>    End_Procedure
15830>>>>>>>    
15830>>>>>>>    Function Field_Label_Long Integer iField Returns String
15832>>>>>>>        Function_Return (Array_Name(Self,iField,FMA_LONG_NAME))
15833>>>>>>>    End_Function
15834>>>>>>>    
15834>>>>>>>    Procedure Set Field_Class_Name Integer iField String sName
15836>>>>>>>        Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
15837>>>>>>>    End_Procedure
15838>>>>>>>    
15838>>>>>>>    Function Field_Class_Name Integer iField Returns String
15840>>>>>>>        Function_Return (Array_Name(Self,iField,FMA_CLASS_NAME))
15841>>>>>>>    End_Function
15842>>>>>>>    
15842>>>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt
15844>>>>>>>        Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
15845>>>>>>>    End_Procedure
15846>>>>>>>    
15846>>>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
15848>>>>>>>        Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
15849>>>>>>>    End_Function
15850>>>>>>>    
15850>>>>>>>End_Class
15851>>>>>>>
15851>>>>>>>Class DataDictionary is a DataSet
15852>>>>>>>    
15852>>>>>>>    Procedure Construct_Object
15854>>>>>>>        Forward Send Construct_Object
15856>>>>>>>        
15856>>>>>>>        Property String  Existing_Key_Value                           ""
15857>>>>>>>        Property Integer Protect_Key_State                            True
15858>>>>>>>        
15858>>>>>>>        Property String  Key_Fields                                   ""
15859>>>>>>>        
15859>>>>>>>        // These are added to support the checking of DSO connections
15859>>>>>>>        // during deletes and saves. Only the first two properties are Public
15859>>>>>>>        Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
15860>>>>>>>        Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
15861>>>>>>>        Property Integer Save_Structure_Validated_State              False
15862>>>>>>>        Property Integer Cascade_Delete_Structure_Validated_State    False
15863>>>>>>>        Property Integer No_Cascade_Delete_Structure_Validated_State False
15864>>>>>>>        
15864>>>>>>>        Property Integer Last_Mark_Sequence_Id                       0
15865>>>>>>>        
15865>>>>>>>        // These are added for optimized traversal of
15865>>>>>>>        // entry-update and validation and maybe more
15865>>>>>>>        Property String  Visited_Fields          ""
15866>>>>>>>        Property Integer Visited_State           False
15867>>>>>>>        // means will be part of a downward delete (cascade deletable). This only has meaning
15867>>>>>>>        // when cascade_delete_state is True
15867>>>>>>>        Property Boolean DownDelete_State        False
15868>>>>>>>        
15868>>>>>>>        // these are set by the define_auto_increment, which is obsolete and has been replaced
15868>>>>>>>        // the Set Field_auto_increment method.
15868>>>>>>>        Property Integer Auto_Increment_Source_File  0
15869>>>>>>>        Property Integer Auto_Increment_Source_Field 0
15870>>>>>>>        Property Integer Auto_Increment_Dest_Field   0
15871>>>>>>>        
15871>>>>>>>        // used by the set Field_auto_increment method
15871>>>>>>>        // these are split into two arrays to make searching for the field easier
15871>>>>>>>        // the arrays should always be synched.
15871>>>>>>>        Property Integer[] pAutoIncrementFields
15872>>>>>>>        Property tDDFileField[] pAutoIncrementSysFileFields
15873>>>>>>>        
15873>>>>>>>        // Error Reporting Related
15873>>>>>>>        // If DD_Error_No_Report errors would be supressed (only ERR gets set)
15873>>>>>>>        Property Integer Error_Report_Mode           DD_Error_Report
15874>>>>>>>        
15874>>>>>>>        // During validation, this is the field being validated.
15874>>>>>>>        Property Integer Current_Validate_Field      0
15875>>>>>>>        
15875>>>>>>>        // when errors are redirected locally this maintains the original handler.
15875>>>>>>>        Property Integer Old_Error_Object_Id         0
15876>>>>>>>        
15876>>>>>>>        // Must be provided if local error handler is to be created
15876>>>>>>>        Property Integer Error_Processing_State      0
15877>>>>>>>        
15877>>>>>>>        // These should be changed most carefully and possible only and the
15877>>>>>>>        // DSO level. These allow you to defeat full field validation which
15877>>>>>>>        // makes it easier to corrupt data! Validate_DEO_Only_State limits
15877>>>>>>>        // save validation to DEOs (which is what data-sets have always done).
15877>>>>>>>        // Validate_foreign_File_State will skip validation under the following
15877>>>>>>>        // conditions: 1) DSO if for a parent (it did not originate the save).
15877>>>>>>>        //
15877>>>>>>>        Property Integer Validate_DEOs_Only_State    False
15878>>>>>>>        Property Integer Validate_Foreign_File_State True
15879>>>>>>>        // if set true, a field validation requested started with this
15879>>>>>>>        // DD will check all fields, even in an error is encountered
15879>>>>>>>        Property Integer Validate_All_Fields_State   False
15880>>>>>>>        
15880>>>>>>>        // If true, all entry updates will occur through the DD. Else
15880>>>>>>>        // saves occur through the DD and find occur through the DEOs
15880>>>>>>>        Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
15881>>>>>>>        
15881>>>>>>>        // can be used by Refind_records method (remote refind of recs). Obsolete. Use prFindRowId
15881>>>>>>>        Property Integer Find_Record_Id 0
15882>>>>>>>        
15882>>>>>>>        // can be used by Refind_records method (remote refind of recs)
15882>>>>>>>        Property RowID prFindRowId (NullRowId())
15883>>>>>>>        // can be used by Refind_records method (remote refind of recs)
15883>>>>>>>        Property tDDChangedInfo pDDChangedInfo
15884>>>>>>>        
15884>>>>>>>        // Private: Id of field_objects container. This is not created until needed
15884>>>>>>>        Property Integer Field_Objects 0
15885>>>>>>>        
15885>>>>>>>        // Public: If set the DDO will never be foreign, allowing
15885>>>>>>>        // you to create new parents when a child is saved. This would
15885>>>>>>>        // normally only be set within the DDO and not the class. This would be
15885>>>>>>>        // used where a child table wants to save the parent (header) when the
15885>>>>>>>        // first child is saved. It would disable the foreign key and index
15885>>>>>>>        // find_Req and required settings (as well as any displayonly).
15885>>>>>>>        Property Integer Allow_Foreign_New_Save_State False
15886>>>>>>>        
15886>>>>>>>        Set pbDDAttach to True // set false to get (very) old attach_main_file_behavior
15887>>>>>>>        Set pbSmartRelate to True // Only relate if parent is attached via a DDO
15888>>>>>>>        
15888>>>>>>>        // If this is an alias file, this is the master file it is based on
15888>>>>>>>        Property Handle piMasterTable 0
15889>>>>>>>        
15889>>>>>>>        Property tDDServerInformation[] pServerInformation
15890>>>>>>>        
15890>>>>>>>        Property tDDRemembered[] pDDDefaults
15891>>>>>>>        
15891>>>>>>>        Property Boolean pbInSuperFind False
15892>>>>>>>        
15892>>>>>>>        // Create the local buffer.
15892>>>>>>>        Object Record_Buffer is a cRecordBuffer
15894>>>>>>>        End_Object
15895>>>>>>>        
15895>>>>>>>        // Create the extended field attributes array.
15895>>>>>>>        Object Field_Attributes is a Field_Attributes
15897>>>>>>>        End_Object
15898>>>>>>>        
15898>>>>>>>        // Create an array to maintain Status help values for each field
15898>>>>>>>        Object Statushelp_Array is an array
15900>>>>>>>        End_Object
15901>>>>>>>        
15901>>>>>>>        Object FieldMask_Array is an Field_Mask_array
15903>>>>>>>        End_Object
15904>>>>>>>        
15904>>>>>>>        
15904>>>>>>>        // keep track of all system/unknown files that must be set to
15904>>>>>>>        // default for smart file mode to work right.
15904>>>>>>>        Object System_File_obj is an Array
15906>>>>>>>        End_Object
15907>>>>>>>        
15907>>>>>>>        // used during Request_Validate
15907>>>>>>>        Property Handle[] pDDsWithFindReqErrors
15908>>>>>>>        
15908>>>>>>>        // Apply SQL filters in constrained finds
15908>>>>>>>        Property Boolean pbUseDDSQLFilters False
15909>>>>>>>        // If pbUseDDSQLFilters is true, this determines if the table global filter should be applied as well
15909>>>>>>>        Property Boolean pbApplyGlobalSQLFilters False
15910>>>>>>>        // Filter which will get applied before each DDO constrained find. If "", no filter is applied
15910>>>>>>>        Property String psSQLFilter ""
15911>>>>>>>        
15911>>>>>>>        // Old values for SQL Filters which are pushed and popped by StoreSQLDefaultFilters and RestoreSQLDefaultFilters
15911>>>>>>>        Property String psOldFilter ""
15912>>>>>>>        Property Boolean pbOldFilterActive
15913>>>>>>>        Property Boolean pbOldFilterEq
15914>>>>>>>        
15914>>>>>>>        // used to point to the composite child object that provides the SQL
15914>>>>>>>        // interfaces for a driver. This can be used with DAW drivers. Other drivers may require
15914>>>>>>>        // that you sub-class your DD and create a different object based on a custom class
15914>>>>>>>        Property Handle phoSQLHelper (Create(Self,RefClass(cDAWSQLDriverHelper)))
15915>>>>>>>        
15915>>>>>>>        
15915>>>>>>>        Property Handle pbInResync False
15916>>>>>>>        
15916>>>>>>>        Property Integer piPrimaryIndex -1      // Indicates the unique index used by the webapp view state system (-1 defaults to the primary key or recnum for embedded).
15917>>>>>>>        
15917>>>>>>>        Set Smart_FileMode_State to True  // extended DSOs should default to true
15918>>>>>>>        
15918>>>>>>>        Send Define_Fields // Developer Hook - define all field rules
15919>>>>>>>    End_Procedure
15920>>>>>>>    
15920>>>>>>>    // Returns 1 to indicate that this is a DD class.
15920>>>>>>>    Function Extended_DSO_State Returns Integer
15922>>>>>>>        Function_Return 1
15923>>>>>>>    End_Function
15924>>>>>>>    
15924>>>>>>>    
15924>>>>>>>    // Used to set up all XDS functions and rules. Called by construct_object
15924>>>>>>>    // and considered a bit more user friendly.
15924>>>>>>>    Procedure Define_Fields
15926>>>>>>>    End_Procedure
15927>>>>>>>    
15927>>>>>>>    
15927>>>>>>>    
15927>>>>>>>    // This message has been augmented to create a local recordbuffer for a
15927>>>>>>>    // file. We cannot do this earlier because we need the file to count the
15927>>>>>>>    // number of necessary fields.
15927>>>>>>>    Procedure Set Main_File Integer iFile
15929>>>>>>>        Integer iCurrent_File iMaster
15929>>>>>>>        Get piMasterTable to iMaster
15930>>>>>>>        If iMaster Begin
15932>>>>>>>            // is an alias condition
15932>>>>>>>            Forward Set Main_File to iFile
15934>>>>>>>            Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
15935>>>>>>>        End
15935>>>>>>>>
15935>>>>>>>        Else If iFile Begin
15938>>>>>>>            Get Main_File to iCurrent_File
15939>>>>>>>            If (iCurrent_File and iCurrent_File <> iFile) Begin
15941>>>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
15942>>>>>>>                Procedure_Return
15943>>>>>>>            End
15943>>>>>>>>
15943>>>>>>>            Forward Set Main_File to iFile
15945>>>>>>>            Send Create_Items to (Record_Buffer(Self)) iFile
15946>>>>>>>            Send Create_Items to (Field_Attributes(Self))
15947>>>>>>>        End
15947>>>>>>>>
15947>>>>>>>    End_Procedure
15948>>>>>>>    
15948>>>>>>>    // This procedure will update the Key_Fields property to include or
15948>>>>>>>    // excluded the fieldnumber passed in the list of fieldnumbers which make
15948>>>>>>>    // up an keyvalue.
15948>>>>>>>    Procedure Set Key_Field_State Integer iField Integer iState
15950>>>>>>>        String  sKeys
15950>>>>>>>        Set Key_Field_State of Record_Buffer iField to iState
15951>>>>>>>        Get Key_Fields to sKeys
15952>>>>>>>        Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
15953>>>>>>>    End_Procedure
15954>>>>>>>    
15954>>>>>>>    // Will return TRUE if the field passed has been defined as a key.
15954>>>>>>>    Function Key_Field_State Integer iField Returns Integer
15956>>>>>>>        Integer iState
15956>>>>>>>        Get Key_Field_State of Record_Buffer iField to iState
15957>>>>>>>        Function_Return iState
15958>>>>>>>    End_Function
15959>>>>>>>    
15959>>>>>>>    // Returns complete key value.
15959>>>>>>>    Function Key_Value Returns String
15961>>>>>>>        String  sKeys
15961>>>>>>>        String  sKey_Value
15961>>>>>>>        String  sValue
15961>>>>>>>        Integer iField
15961>>>>>>>        Get Key_Fields to sKeys
15962>>>>>>>        Move "" to sKey_Value
15963>>>>>>>        Repeat
15963>>>>>>>>
15963>>>>>>>            Move (Pos( "X",sKeys)) to iField
15964>>>>>>>            If iField Begin
15966>>>>>>>                Get Field_Current_Value iField to sValue
15967>>>>>>>                Append sKey_Value sValue
15968>>>>>>>                Move (Overstrike(" ", sKeys, iField)) to sKeys
15969>>>>>>>            End
15969>>>>>>>>
15969>>>>>>>        Until not iField
15971>>>>>>>        Function_Return sKey_Value
15972>>>>>>>    End_Function
15973>>>>>>>    
15973>>>>>>>    // This procedure will be called whenever the Data_Set changes its
15973>>>>>>>    // Current_Record property, or after a Save, Delete or Clear operation.
15973>>>>>>>    // We send this message to the Record_Buffer object to update its values.
15973>>>>>>>    Procedure New_Current_Record Integer iOld Integer iNew
15975>>>>>>>        // does nothing, but exists if developer is using this for some purpose. Is called after
15975>>>>>>>        // OnNewCurrentRecord (if recnum based table)
15975>>>>>>>    End_Procedure
15976>>>>>>>    
15976>>>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
15978>>>>>>>        Integer iObj
15978>>>>>>>        Integer iOldst
15978>>>>>>>        Integer iFoc
15978>>>>>>>        Integer iIsExt
15978>>>>>>>        Forward Send OnNewCurrentRecord riOld riNew
15980>>>>>>>        Move (Record_Buffer(Self)) to iObj
15981>>>>>>>        If iObj Begin
15983>>>>>>>            Send OnNewCurrentRecord of iObj riOld riNew
15984>>>>>>>            // must also refresh all defined extended fields
15984>>>>>>>            Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
15985>>>>>>>            Get Focus of Desktop to iFoc
15986>>>>>>>            Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
15987>>>>>>>            If iIsExt Begin                               // disable the state so
15989>>>>>>>                Get Entry_Refresh_State of iFoc to iOldSt // value will come
15990>>>>>>>                Set Entry_Refresh_State of iFoc to True   // from Local buffer.
15991>>>>>>>            End
15991>>>>>>>>
15991>>>>>>>            Set Existing_Key_Value to (Key_Value(Self))
15992>>>>>>>            If iIsExt ;                Set Entry_Refresh_State of iFoc to iOldSt
15995>>>>>>>            // Only set defaults when the record is new
15995>>>>>>>            If (IsNullRowId(riNew)) ;                Send Prepare_Default_Values
15998>>>>>>>        End
15998>>>>>>>>
15998>>>>>>>    End_Procedure
15999>>>>>>>    
15999>>>>>>>    // Shuts off change mode and sends initialize_default_values which is
15999>>>>>>>    // a user hook routine.
15999>>>>>>>    Procedure Prepare_Default_Values
16001>>>>>>>        Integer iOldState
16001>>>>>>>        Get Change_disabled_State to iOldState
16002>>>>>>>        Set Change_disabled_State to True
16003>>>>>>>        Send Private_Field_Defaults
16004>>>>>>>        // set defaults if this is the main DDO or the DDO is
16004>>>>>>>        // flagged as supporting saving new records when foreign (a parent)
16004>>>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self)) ;            Send Field_Defaults
16007>>>>>>>        Send AssignDynamicDefaults
16008>>>>>>>        Set Change_disabled_State to iOldState
16009>>>>>>>    End_Procedure
16010>>>>>>>    
16010>>>>>>>    // Set all checkbox fields to default to False data value.
16010>>>>>>>    Procedure Private_Field_Defaults
16012>>>>>>>        Integer iField
16012>>>>>>>        Repeat
16012>>>>>>>>
16012>>>>>>>            Get Next_Validation_Type of (Field_Attributes(Self)) ;                FA_VALIDATION_TYPE_CHECKBOX iField to iField
16013>>>>>>>            If (iField = 0) ;                Procedure_Return
16016>>>>>>>            Set Field_Select_State  iField to False
16017>>>>>>>            Set Field_Changed_State iField to True
16018>>>>>>>        Loop
16019>>>>>>>>
16019>>>>>>>    End_Procedure
16020>>>>>>>    
16020>>>>>>>    // Will be called after a clear operation to let the application
16020>>>>>>>    // programmer set the default values for the record. This should be done
16020>>>>>>>    // by sending SET Field_Current_Value.
16020>>>>>>>    Procedure Field_Defaults
16022>>>>>>>    End_Procedure
16023>>>>>>>    
16023>>>>>>>    // Pass type and string value and see if this is valid data for this
16023>>>>>>>    // type. Currently we check for numbers and dates. Return non-zero
16023>>>>>>>    // if invalid.
16023>>>>>>>    Function IsDataInvalid Integer iType String sValue Returns Integer
16025>>>>>>>        Date    dVal
16025>>>>>>>        DateTime dtVal
16025>>>>>>>        Number  nVal
16025>>>>>>>        Integer bOK
16025>>>>>>>        Boolean bInvalid
16025>>>>>>>        
16025>>>>>>>        Move False to bInvalid
16026>>>>>>>        If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
16028>>>>>>>            If (iType=DF_DATE) Begin
16030>>>>>>>                MoveTrapErr sValue to dVal
16031>>>>>>>                Move (Err) to bInvalid
16032>>>>>>>            End
16032>>>>>>>>
16032>>>>>>>            Else If (iType=DF_DATETIME) Begin
16035>>>>>>>                MoveTrapErr sValue to dtVal
16036>>>>>>>                Move (Err) to bInvalid
16037>>>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
16037>>>>>>>            End
16037>>>>>>>>
16037>>>>>>>            Else Begin
16038>>>>>>>                MoveTrapErr sValue to nVal // this may gen an error.
16039>>>>>>>                Move (Err) to bInvalid
16040>>>>>>>            End
16040>>>>>>>>
16040>>>>>>>            Move False to Err
16041>>>>>>>        End
16041>>>>>>>>
16041>>>>>>>        Function_Return bInvalid
16042>>>>>>>    End_Function
16043>>>>>>>    
16043>>>>>>>    // Return 1 if the passed DEO is part of the DDs list of connected DEOs
16043>>>>>>>    // First check if server of DEO is this DD. If so, we are owned. If not
16043>>>>>>>    // we must check the DD's UI DEO list.
16043>>>>>>>    // The passed object MUST be a valid DEO or an error will occur.
16043>>>>>>>    Function IsDEOOwned Integer iDEO Returns Integer
16045>>>>>>>        Integer iMax iCount
16045>>>>>>>        // if DEOs server is same as current DD it is owned. This is the
16045>>>>>>>        // fast check
16045>>>>>>>        If (Server(iDEO)=Self) ;            Function_Return 1
16048>>>>>>>        // else see if the DEO is in the DD's DEO list
16048>>>>>>>        Get Data_Set_User_Interface_Count to iMax
16049>>>>>>>        Decrement iMax
16050>>>>>>>        For iCount from 0 to iMax
16056>>>>>>>>
16056>>>>>>>            If (Data_Set_User_Interface(Self,iCount)=iDEO) ;                Function_Return 1
16059>>>>>>>        Loop
16060>>>>>>>>
16060>>>>>>>        Function_Return 0
16061>>>>>>>    End_Function
16062>>>>>>>    
16062>>>>>>>    // This procedure changes the field value of the given field in the
16062>>>>>>>    // record-buffer object.
16062>>>>>>>    // It also sends Field_Value_Changed to notify every the attached DEOs.
16062>>>>>>>    // This has been optimized so this message is only sent when data is
16062>>>>>>>    // actually changed.
16062>>>>>>>    Procedure Set Field_Current_Value Integer iField String sValue
16064>>>>>>>        Integer iObj
16064>>>>>>>        String sOldVal
16064>>>>>>>        Integer iChanged
16064>>>>>>>        Integer iType
16064>>>>>>>        Integer iFile
16064>>>>>>>        Integer iFocObj
16064>>>>>>>        Integer iCrnt
16064>>>>>>>        Integer bInvalid
16064>>>>>>>        Integer iIdentity
16064>>>>>>>        Address pData
16064>>>>>>>        Integer iLen
16064>>>>>>>        
16064>>>>>>>        Get Main_File to iFile
16065>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16068>>>>>>>        
16068>>>>>>>        // Overlap fields are not supported directly in DDs. It is expected
16068>>>>>>>        // that you will use the underlying fields instead
16068>>>>>>>        If (iType = DF_OVERLAP) Begin
16070>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
16071>>>>>>>            Procedure_Return
16072>>>>>>>        End
16072>>>>>>>>
16072>>>>>>>        
16072>>>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
16074>>>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
16075>>>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
16076>>>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
16077>>>>>>>            // will gen error if ext. field does not exist
16077>>>>>>>            Set Field_Current_Pointer_Value iField iLen to pData
16078>>>>>>>            Procedure_Return
16079>>>>>>>        End
16079>>>>>>>>
16079>>>>>>>        
16079>>>>>>>        
16079>>>>>>>        // If date or number, force conversion so any error is detected before
16079>>>>>>>        // the buffer is updated. We don't want the record buffer to contain
16079>>>>>>>        // invalid data
16079>>>>>>>        Get IsDataInvalid iType sValue to bInvalid
16080>>>>>>>        If bInvalid ;         // If an error occurred we have            Procedure_Return  // a bad number or a bad date. Do no more!
16083>>>>>>>        
16083>>>>>>>        Move (Record_Buffer(Self)) to iObj
16084>>>>>>>        Get Value of iObj iField to sOldVal
16085>>>>>>>        
16085>>>>>>>        Set Value of iObj iField to sValue
16086>>>>>>>        
16086>>>>>>>        // Augmented to handle non DF databases JJT
16086>>>>>>>        // Some tables may use some field other then recnum for their record identity.
16086>>>>>>>        // This will be dfrecnum or some other numeric field. When this happens the DD have
16086>>>>>>>        // to field buffers for the same value. When an update occurs from the DD to the DB buffer
16086>>>>>>>        // an update can occur twice. If the values are the same, this does not matter. Else the highest
16086>>>>>>>        // field value will get the update (not recnum). So if someone changes recnum but not its real field
16086>>>>>>>        // finding may not work right. The DD is updated when a record is found and the API keeps the two values
16086>>>>>>>        // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
16086>>>>>>>        // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
16086>>>>>>>        // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
16086>>>>>>>        //
16086>>>>>>>        // if field is recnum and record identity is not 0, we must also update the other field.
16086>>>>>>>        If (iField=0) Begin
16088>>>>>>>            Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
16091>>>>>>>            If (iIdentity>0) ;                Set Value of iObj iIdentity to sValue
16094>>>>>>>        End
16094>>>>>>>>
16094>>>>>>>        
16094>>>>>>>        // When data-sets are working they should not update the
16094>>>>>>>        // DEOs.
16094>>>>>>>        
16094>>>>>>>        // prior to vdf7, we stopped all operation modes of non-zero. We now allow
16094>>>>>>>        // validates to pass through and we have a new operation mode for this. This
16094>>>>>>>        // should be ok, since we already allowed navigation validation through - we just
16094>>>>>>>        // stopped request_validate validations.
16094>>>>>>>        If (Operation_Mode=0 or Operation_Mode=MODE_VALIDATING) Begin
16096>>>>>>>            If (iType=DF_BCD) ;                Move (Number(sValue)<>Number(sOldVal)) to iChanged
16099>>>>>>>            Else If (iType=DF_DATE) ;                Move (Date(sValue)<>Date(sOldVal)) to iChanged
16103>>>>>>>            Else If (iType=DF_DATETIME) ;                Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
16107>>>>>>>            Else ;                Move (sValue<>sOldVal) to iChanged
16109>>>>>>>            // if changed, notify all DEOs of this change
16109>>>>>>>            If iChanged ;                Send Field_Value_Changed iField sValue
16112>>>>>>>            Else Begin
16113>>>>>>>                // If here the set value did not change the contents of the DD.
16113>>>>>>>                // However, it is possible that the current focus DEO may contain
16113>>>>>>>                // a different value than the one we are setting. In such a case
16113>>>>>>>                // we must re-synchronize the DEO. Only the one DEO can be affected
16113>>>>>>>                // because it is the current focus deo/item that can contain a value
16113>>>>>>>                // that is not yet updated in the DD. This fixes a bug where the
16113>>>>>>>                // iexit was setting a value which was different from what was in
16113>>>>>>>                // the DEO but was the same as the old DD value (iExit is called
16113>>>>>>>                // before the DD is re-synched with the DEO). This could happen
16113>>>>>>>                // also by sending this message directly with a different value in
16113>>>>>>>                // the DEO focus item.
16113>>>>>>>                Get Focus of Desktop to iFocObj
16114>>>>>>>                // similar logic to Get Field_Current_Value. We check that the DEO
16114>>>>>>>                // is extended, that entry_refresh is not disabled and that the
16114>>>>>>>                // DEO's server is this DD.
16114>>>>>>>                If ( Extended_DEO_State(iFocObj) and ;                    (Entry_Refresh_State(iFocObj)=0)) Begin
16116>>>>>>>                    Get Current_item of iFocObj to iCrnt
16117>>>>>>>                    // If Focus DEO has same file and field and it is not checkbox
16117>>>>>>>                    // we must set its value. Set local value directly sets the value
16117>>>>>>>                    // in the DEO item. If we used value we'd get recursion!
16117>>>>>>>                    If ( Data_File(iFocObj,iCrnt)=iFile and ;                        Data_Field(iFocObj,iCrnt)=iField and ;                        IsDEOOwned(Self,iFocObj) and ;                        Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                        Send File_Field_Value_Changed to iFocObj iFile iField sValue True
16120>>>>>>>                    //Set Local_Value of iFocObj iCrnt to sValue
16120>>>>>>>                End
16120>>>>>>>>
16120>>>>>>>            End
16120>>>>>>>>
16120>>>>>>>        End
16120>>>>>>>>
16120>>>>>>>    End_Procedure
16121>>>>>>>    
16121>>>>>>>    // Sets Field_Current_Value and Sets Field_Changed_State for passed field.
16121>>>>>>>    Procedure Set Field_Changed_Value Integer iField String sValue
16123>>>>>>>        Set Field_Changed_State iField to True
16124>>>>>>>        Set Field_Current_Value iField to sValue
16125>>>>>>>    End_Procedure
16126>>>>>>>    
16126>>>>>>>    
16126>>>>>>>    // This should only be set by a DEO that is changing a NoPut value. This should only happen when NoEnter=F
16126>>>>>>>    // for indexed findable noput deos. With foreign-field noputs we may store the value and update them
16126>>>>>>>    // for finds but we don't want them for saves. The cDDBuffer class handles this but it needs to
16126>>>>>>>    // know if this was a DEO NoPut update. DDOs have always allowed you to directly update foreign NoPut
16126>>>>>>>    // fields when the change did not come from a DEO.
16126>>>>>>>    Procedure Set Field_NoPutValueChangedByDeo Integer iField Boolean bChange
16128>>>>>>>        Set Item_ChangedByDeo of Record_Buffer iField to bChange
16129>>>>>>>    End_Procedure
16130>>>>>>>    
16130>>>>>>>    Procedure Set File_Field_NoPutValueChangedByDeo Integer iFile Integer iField Boolean bChange
16132>>>>>>>        Integer iDSO
16132>>>>>>>        Get Data_set iFile to iDSO
16133>>>>>>>        If iDSO Begin
16135>>>>>>>            Set Field_NoPutValueChangedByDeo of iDSO iField to bChange
16136>>>>>>>        End
16136>>>>>>>>
16136>>>>>>>    End_Procedure
16137>>>>>>>    
16137>>>>>>>    // Returns the value from the record buffer for the field of which the
16137>>>>>>>    // fieldnumber has been passed.
16137>>>>>>>    // If the file/field requested is the focus file/field the use the DEO's
16137>>>>>>>    // value.
16137>>>>>>>    Function Field_Current_Value Integer iField Returns String
16139>>>>>>>        Integer iType
16139>>>>>>>        Integer iFile
16139>>>>>>>        String  sValue
16139>>>>>>>        Integer iFoc
16139>>>>>>>        Integer iCrnt
16139>>>>>>>        Integer iStrSize
16139>>>>>>>        Integer iFldSize iVoid
16139>>>>>>>        UChar[] UCData
16140>>>>>>>        
16140>>>>>>>        Get Focus of desktop to iFoc
16141>>>>>>>        Get Main_File to iFile
16142>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16145>>>>>>>        
16145>>>>>>>        // Overlap fields are not supported directly in DDs. It is expected
16145>>>>>>>        // that you will use the underlying fields instead
16145>>>>>>>        If (iType=DF_OVERLAP) Begin
16147>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
16148>>>>>>>            Function_Return ''
16149>>>>>>>        End
16149>>>>>>>>
16149>>>>>>>        
16149>>>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
16151>>>>>>>            Get Field_Current_UCAValue iField to UCData
16152>>>>>>>            
16152>>>>>>>            // we assume a string is passed here. If we return to a string the
16152>>>>>>>            // pointer message will convert this to a string. First check that max string
16152>>>>>>>            // length is ok for this field.
16152>>>>>>>            Get_Argument_Size to iStrSize
16153>>>>>>>            Move (SizeOfArray(UCData)) to iFldSize
16154>>>>>>>            // check that the string size is large enough to hold the value
16154>>>>>>>            If (iStrSize < iFldSize) Begin
16156>>>>>>>                Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_TOO_BIG
16157>>>>>>>            End
16157>>>>>>>>
16157>>>>>>>            Else Begin
16158>>>>>>>                Move (UCharArrayToString(UCData)) to sValue
16159>>>>>>>            End
16159>>>>>>>>
16159>>>>>>>            // This function has always returned the value as a 0 delimited string.
16159>>>>>>>            // Therefore trim at first zero. This means that you should not use this method
16159>>>>>>>            // with Binary types as embedded zeros will cause a truncation.
16159>>>>>>>            Move (CString(sValue)) to sValue
16160>>>>>>>            Function_Return sValue
16161>>>>>>>        End
16161>>>>>>>>
16161>>>>>>>        
16161>>>>>>>        // This was extended to also make sure that the focus's server
16161>>>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
16161>>>>>>>        // file/field being the right file/field but for a different view.
16161>>>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
16161>>>>>>>        // ddos have the information they need from the deos. During a refresh we don't
16161>>>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
16161>>>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
16161>>>>>>>        // DEO field, so the buffer is always correct.
16161>>>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
16163>>>>>>>            Get Current_item of iFoc to iCrnt
16164>>>>>>>            If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;                IsDEOOwned(Self,iFoc) and ;                (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
16166>>>>>>>                Get Data_Value of iFoc iCrnt to sValue
16167>>>>>>>            End
16167>>>>>>>>
16167>>>>>>>            Else Begin
16168>>>>>>>                Get Value of (Record_Buffer(Self)) iField to sValue
16169>>>>>>>            End
16169>>>>>>>>
16169>>>>>>>        End
16169>>>>>>>>
16169>>>>>>>        Else Begin
16170>>>>>>>            Get Value of (Record_Buffer(Self)) iField to sValue
16171>>>>>>>        End
16171>>>>>>>>
16171>>>>>>>        
16171>>>>>>>        // cast value to the proper datatype
16171>>>>>>>        If (iType=DF_BCD) Begin
16173>>>>>>>            Function_Return (Number(sValue))
16174>>>>>>>        End
16174>>>>>>>>
16174>>>>>>>        Else If (iType=DF_DATE) Begin
16177>>>>>>>            Function_Return (Date(sValue))
16178>>>>>>>        End
16178>>>>>>>>
16178>>>>>>>        Else If (iType=DF_DATETIME) Begin
16181>>>>>>>            Function_Return (Cast(sValue,DateTime))
16182>>>>>>>        End
16182>>>>>>>>
16182>>>>>>>        // else return as string
16182>>>>>>>        Function_Return sValue
16183>>>>>>>    End_Function
16184>>>>>>>    
16184>>>>>>>    // This sets a default value without setting the DSO's changed_State
16184>>>>>>>    Procedure Set Field_Default_Value Integer iField String sValue
16186>>>>>>>        Integer iOldState
16186>>>>>>>        Get Change_disabled_State to iOldState
16187>>>>>>>        Set Change_disabled_State to True
16188>>>>>>>        Set Field_Changed_Value iField to sValue
16189>>>>>>>        Set Change_disabled_State to iOldState
16190>>>>>>>    End_Procedure
16191>>>>>>>    
16191>>>>>>>    Procedure Set File_Field_default_Value Integer iFile Integer iField String sValue
16193>>>>>>>        Integer iDSO
16193>>>>>>>        Get Data_set iFile to iDSO
16194>>>>>>>        If iDSO ;            Set Field_default_Value of iDSO iField to sValue
16197>>>>>>>    End_Procedure
16198>>>>>>>    
16198>>>>>>>    // Methods to set and get the value of a field. When set all DSOs and
16198>>>>>>>    // DEOs are notified.
16198>>>>>>>    Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
16200>>>>>>>        Integer iDSO
16200>>>>>>>        Get Data_set iFile to iDSO
16201>>>>>>>        If iDSO ;            Set Field_Current_Value of iDSO iField to sValue
16204>>>>>>>    End_Procedure
16205>>>>>>>    
16205>>>>>>>    Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
16207>>>>>>>        Integer iDSO
16207>>>>>>>        Get Data_set iFile to iDSO
16208>>>>>>>        If iDSO ;            Set Field_Changed_Value of iDSO iField to sValue
16211>>>>>>>    End_Procedure
16212>>>>>>>    
16212>>>>>>>    Function File_Field_Current_Value Integer iFile Integer iField Returns String
16214>>>>>>>        Integer iDSO
16214>>>>>>>        String sValue
16214>>>>>>>        Get Data_set iFile to iDSO
16215>>>>>>>        If iDSO ;            Get Field_Current_Value of iDSO iField to sValue
16218>>>>>>>        Function_Return sValue
16219>>>>>>>    End_Function
16220>>>>>>>    
16220>>>>>>>    // This procedure will notify every attached DEO that the value of a
16220>>>>>>>    // field has been changed. Every DEO needs to update its value to reflect
16220>>>>>>>    // the new value.
16220>>>>>>>    Procedure Field_Value_Changed Integer iField String sValue
16222>>>>>>>        Integer iMax
16222>>>>>>>        Integer iCount
16222>>>>>>>        Integer iDEO
16222>>>>>>>        Integer iMain_File
16222>>>>>>>        Integer iNoChange
16222>>>>>>>        Get Change_Disabled_State to iNoChange
16223>>>>>>>        Get Main_File to iMain_File
16224>>>>>>>        Get Data_Set_User_Interface_Count to iMax
16225>>>>>>>        Decrement iMax
16226>>>>>>>        For iCount from 0 to iMax
16232>>>>>>>>
16232>>>>>>>            Get Data_Set_User_Interface iCount to iDEO
16233>>>>>>>            If (Extended_DEO_State(iDEO) ) Begin
16235>>>>>>>                Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
16236>>>>>>>            End
16236>>>>>>>>
16236>>>>>>>        Loop
16237>>>>>>>>
16237>>>>>>>    End_Procedure
16238>>>>>>>    
16238>>>>>>>    // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_
16238>>>>>>>    // state if appropriate (if change_disabled_state is false)
16238>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
16240>>>>>>>        Function_Return ;            (Item_Changed_State(Record_Buffer(Self), iField))
16241>>>>>>>    End_Function
16242>>>>>>>    
16242>>>>>>>    
16242>>>>>>>    // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
16242>>>>>>>    // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
16242>>>>>>>    // They set the field_Current_value and they set the field_changed_state. If noput they will
16242>>>>>>>    // not set changed_state. This now makes windows and web consistent.
16242>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer iState
16244>>>>>>>        Boolean bNoPut bOldSt bIsCommitted
16244>>>>>>>        
16244>>>>>>>        Get Field_Option iField DD_NOPUT to bNoPut
16245>>>>>>>        If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
16247>>>>>>>            Get IsCommitted iField to bIsCommitted
16248>>>>>>>            If bIsCommitted Begin
16250>>>>>>>                Get IsFieldCommitted iField to bNoPut
16251>>>>>>>            End
16251>>>>>>>>
16251>>>>>>>        End
16251>>>>>>>>
16251>>>>>>>        
16251>>>>>>>        If bNoPut Begin
16253>>>>>>>            Get Change_disabled_State to bOldSt
16254>>>>>>>            Set Change_disabled_State to True
16255>>>>>>>        End
16255>>>>>>>>
16255>>>>>>>        
16255>>>>>>>        Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
16256>>>>>>>        // the cDDBuffer class item_changed_state does not attempt to set
16256>>>>>>>        // changed_state, so we do it here. This will allow for future
16256>>>>>>>        // greater flexibilities.
16256>>>>>>>        If (iState) Begin
16258>>>>>>>            Set Changed_State of (Record_Buffer(Self)) to True
16259>>>>>>>        End
16259>>>>>>>>
16259>>>>>>>        If bNoPut Begin
16261>>>>>>>            Set Change_disabled_State to bOldSt
16262>>>>>>>        End
16262>>>>>>>>
16262>>>>>>>        
16262>>>>>>>    End_Procedure
16263>>>>>>>    
16263>>>>>>>    // As above, but passes both file and field
16263>>>>>>>    Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
16265>>>>>>>        Integer iDSO
16265>>>>>>>        Get Data_Set iFile to iDSO
16266>>>>>>>        If iDSO ;            Function_Return (Field_Changed_State(iDSO, iField))
16269>>>>>>>    End_Function
16270>>>>>>>    
16270>>>>>>>    Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
16272>>>>>>>        Integer iDSO
16272>>>>>>>        Get Data_Set iFile to iDSO
16273>>>>>>>        If iDSO ;            Set Field_Changed_State of iDSO iField to iState
16276>>>>>>>    End_Procedure
16277>>>>>>>    
16277>>>>>>>    // This simulates entering a value into a field from a keyboard. Pass the
16277>>>>>>>    // Field and DD Options and the value. It is up to you to pass the proper
16277>>>>>>>    // DD options. This is normally sent by File_Field_Entry and you are
16277>>>>>>>    // advised to use that message and not this one.
16277>>>>>>>    Procedure Set Field_Entry Integer iField Integer iOpts Integer bShowErr String sValue
16279>>>>>>>        Integer iFile
16279>>>>>>>        Integer iType
16279>>>>>>>        Integer bChanged
16279>>>>>>>        Integer bInvalid
16279>>>>>>>        Integer hObj
16279>>>>>>>        String sOldVal
16279>>>>>>>        Address pData
16279>>>>>>>        Integer iLen
16279>>>>>>>        
16279>>>>>>>        Get Main_File to iFile
16280>>>>>>>        
16280>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. We will
16280>>>>>>>        // let NoPut through, since a user might need it for finding.
16280>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
16283>>>>>>>        
16283>>>>>>>        // Force a caplsock if required
16283>>>>>>>        If (iOpts iand DD_CAPSLOCK) ;            Move (Uppercase(sValue)) to sValue
16286>>>>>>>        
16286>>>>>>>        // If date or number, force conversion so any error is detected before
16286>>>>>>>        // the buffer is updated. We don't want the record buffer to contain
16286>>>>>>>        // invalid data
16286>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16289>>>>>>>        
16289>>>>>>>        // Overlap fields are not supported directly in DDs. It is expected
16289>>>>>>>        // that you will use the underlying fields instead
16289>>>>>>>        If (iType = DF_OVERLAP) Begin
16291>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
16292>>>>>>>            Procedure_Return
16293>>>>>>>        End
16293>>>>>>>>
16293>>>>>>>        
16293>>>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
16295>>>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
16296>>>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
16297>>>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
16298>>>>>>>            // will gen error if ext. field does not exist
16298>>>>>>>            Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
16299>>>>>>>            Procedure_Return
16300>>>>>>>        End
16300>>>>>>>>
16300>>>>>>>        
16300>>>>>>>        Get IsDataInvalid iType sValue to bInvalid
16301>>>>>>>        If bInvalid Begin     // If an error occurred we have
16303>>>>>>>            If bShowErr ;                Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                (" ("-sValue-")")
16306>>>>>>>            Procedure_Return  // a bad number or a bad date. Do no more!
16307>>>>>>>        End
16307>>>>>>>>
16307>>>>>>>        // update the value only if the value is changed.
16307>>>>>>>        Move (Record_Buffer(Self)) to hObj
16308>>>>>>>        Get Value of hObj iField to sOldVal
16309>>>>>>>        If (iType=DF_BCD) ;            Move (Number(sValue)<>Number(sOldVal)) to bChanged
16312>>>>>>>        Else If (iType=DF_DATE) ;            Move (Date(sValue)<>Date(sOldVal)) to bChanged
16316>>>>>>>        Else If (iType=DF_DATETIME) ;            Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
16320>>>>>>>        Else ;            Move (sValue<>sOldVal) to bChanged
16322>>>>>>>        
16322>>>>>>>        // if changed or force put, update the value.
16322>>>>>>>        If ( bChanged or (iOpts iand DD_FORCEPUT) ) ;            Set Field_Current_Value iField to sValue
16325>>>>>>>        
16325>>>>>>>        // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
16325>>>>>>>        // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
16325>>>>>>>        If ( bChanged) Begin
16327>>>>>>>            Set Field_Changed_State iField to True
16328>>>>>>>            // if noput (but not noenter) we must tell the DDO that this should not be
16328>>>>>>>            // updated during a save.
16328>>>>>>>            If (iOpts iand DD_NOPUT) Begin
16330>>>>>>>                Set Field_NoPutValueChangedByDeo iField to True
16331>>>>>>>            End
16331>>>>>>>>
16331>>>>>>>        End
16331>>>>>>>>
16331>>>>>>>        
16331>>>>>>>        // perform autofinds if needed. Note that required checking will occur as
16331>>>>>>>        // part of validation.
16331>>>>>>>        // We will only autofind if the field value is changed. This is consistent with
16331>>>>>>>        // DEOs which do not autofind on unchanged values. This provides optimizations
16331>>>>>>>        // when a parent record is already loaded.
16331>>>>>>>        If (bChanged or Field_Changed_state(Self,iField)) Begin
16333>>>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
16333>>>>>>>            // testing is important and make sure we test for exact bit match. Must first
16333>>>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
16333>>>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Send File_Field_AutoFind iFile iField GE
16336>>>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) ;                Send File_Field_AutoFind iFile iField EQ
16340>>>>>>>        End
16340>>>>>>>>
16340>>>>>>>        
16340>>>>>>>    End_Procedure
16341>>>>>>>    
16341>>>>>>>    // This returns file-field options for a Field_Entry type of environment.
16341>>>>>>>    // It will strip autofind from main-file DDs but leave foreign field alone.
16341>>>>>>>    // This is needed for Field_entry. Otherwise adding a field value to an autofind
16341>>>>>>>    // for save or find causes an autofind to trigger first which either causes the
16341>>>>>>>    // wrong rec to save or for a double find.
16341>>>>>>>    Function File_Field_Entry_Options Integer iFile Integer iField Returns Integer
16343>>>>>>>        Integer iOpts
16343>>>>>>>        // this will get the appropriate field and foreign field opts
16343>>>>>>>        Get File_Field_Options iFile iField to iOpts
16344>>>>>>>        // If the main file (not foreign) we will strip autofind. Autofind should not
16344>>>>>>>        // be an automatic part of main file entry while it should with foreign fields.
16344>>>>>>>        If (iFile=Main_File(Self)) Begin
16346>>>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
16346>>>>>>>            // testing is important and make sure we test for exact bit match. Must first
16346>>>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
16346>>>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Move (iOpts - DD_AUTOFIND_GE) to iOpts
16349>>>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND)  ;                Move (iOpts - DD_AUTOFIND)    to iOpts
16353>>>>>>>        End
16353>>>>>>>>
16353>>>>>>>        Function_Return iOpts
16354>>>>>>>    End_Function
16355>>>>>>>    
16355>>>>>>>    // This simulates entering a value into a field from a keyboard. The DD
16355>>>>>>>    // receiving this message determines if it is Main or Foreign (just like
16355>>>>>>>    // server). It will do an uppercase, will respect No_Enter and DisplayOnly
16355>>>>>>>    // and will do a autofind if required. It does not do a field validation.
16355>>>>>>>    Procedure Set File_Field_Entry Integer iFile Integer iField Integer bShowErr String sValue
16357>>>>>>>        Integer iOpts
16357>>>>>>>        Integer hDD
16357>>>>>>>        Get Data_Set iFile to hDD
16358>>>>>>>        If hDD Begin
16360>>>>>>>            // this will get the appropriate field and foreign field opts
16360>>>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
16361>>>>>>>            Set Field_Entry of hDD iField iOpts bShowErr to sValue
16362>>>>>>>        End
16362>>>>>>>>
16362>>>>>>>    End_Procedure
16363>>>>>>>    
16363>>>>>>>    // return object ID of extended field, 0 if none
16363>>>>>>>    Function Field_Object Integer iField Returns Integer
16365>>>>>>>        Integer hoFlds hoField
16365>>>>>>>        Boolean bAutoAssign
16365>>>>>>>        Get Field_Objects to hoFlds
16366>>>>>>>        If hoFlds Begin
16368>>>>>>>            Get Field_Object of hoFlds iField to hoField
16369>>>>>>>        End
16369>>>>>>>>
16369>>>>>>>        If not hoField Begin
16371>>>>>>>            Send DefineExtendedField iField // will create field_objects and Field_Object as needed
16372>>>>>>>            Get Field_Objects to hoFlds
16373>>>>>>>            Get Field_Object of hoFlds iField to hoField
16374>>>>>>>        End
16374>>>>>>>>
16374>>>>>>>        Function_Return hoField
16375>>>>>>>    End_Function
16376>>>>>>>    
16376>>>>>>>    // This is the same as Field_entry except the value is passed via a
16376>>>>>>>    // pointer. If data-type is extended (text/binary) it will use and an
16376>>>>>>>    // extended field object to handle this. If date/number/string we will
16376>>>>>>>    // convert this to a string and use Field_Entry. It is the caller's
16376>>>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
16376>>>>>>>    // If an extended Field object is needed and not defined, an error is
16376>>>>>>>    // returned. If pointer is null, assume empty string passed (this is a
16376>>>>>>>    // change as of 8.3 - it used to ignore null pointers)
16376>>>>>>>    Procedure Set Field_Pointer_Entry Integer iField Integer iOpts Integer iLen Integer bShowErr Address pData
16378>>>>>>>        Integer hFld
16378>>>>>>>        String  sValue
16378>>>>>>>        Integer iFile
16378>>>>>>>        Integer iType
16378>>>>>>>        
16378>>>>>>>        Get Main_file to iFile
16379>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16382>>>>>>>        
16382>>>>>>>        // Overlap fields are not supported directly in DDs. It is expected
16382>>>>>>>        // that you will use the underlying fields instead
16382>>>>>>>        If (iType = DF_OVERLAP) ;            Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_OVERLAP_ERROR
16385>>>>>>>        Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
16388>>>>>>>            Get Field_Object iField to hFld // the object that handles this large text
16389>>>>>>>            If hFld ;                Set Field_pEntry of hFld iOpts iLen bShowErr to pData
16392>>>>>>>            Else ;                Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_FIELD_NOT_DEFINED
16394>>>>>>>        End
16394>>>>>>>>
16394>>>>>>>        Else Begin
16395>>>>>>>            // if number,date or string convert the pointer data to
16395>>>>>>>            // string data and do a normal entry with it.
16395>>>>>>>            Move (PointerToString(pData)) to sValue
16396>>>>>>>            Set Field_Entry iField iOpts bShowErr to sValue
16397>>>>>>>        End
16397>>>>>>>>
16397>>>>>>>    End_Procedure
16398>>>>>>>    
16398>>>>>>>    // This is the same as File_Field_entry except the value is passed via a
16398>>>>>>>    // pointer. See Field_Pointer_Entry for more on this
16398>>>>>>>    Procedure Set File_Field_Pointer_Entry Integer iFile Integer iField Integer iLen Integer bShowErr Address pData
16400>>>>>>>        Integer iOpts
16400>>>>>>>        Integer hDD
16400>>>>>>>        Get Data_Set iFile to hDD
16401>>>>>>>        If hDD Begin
16403>>>>>>>            // this will get the appropriate field and foreign field opts
16403>>>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
16404>>>>>>>            Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
16405>>>>>>>        End
16405>>>>>>>>
16405>>>>>>>    End_Procedure
16406>>>>>>>    
16406>>>>>>>    // This is the same as Field_Current_Value except the value is passed via
16406>>>>>>>    // a pointer. If data-type is extended (text/binary) it will use and an
16406>>>>>>>    // extended field object to handle this. If date/number/string we will
16406>>>>>>>    // convert this to a string and use Field_Entry. It is the caller's
16406>>>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
16406>>>>>>>    // If an extended Field object is needed and not defined, an error is
16406>>>>>>>    // returned. If pointer is null, assume empty string passed (this is a
16406>>>>>>>    // change as of 8.3 - it used to ignore null pointers)
16406>>>>>>>    Procedure Set Field_Current_Pointer_Value Integer iField Integer iLen Address pData
16408>>>>>>>        Integer hFld
16408>>>>>>>        String  sValue
16408>>>>>>>        Integer iFile iType iCrnt
16408>>>>>>>        Handle iFocObj
16408>>>>>>>        Boolean bChanged
16408>>>>>>>        
16408>>>>>>>        Get Main_file to iFile
16409>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16412>>>>>>>        
16412>>>>>>>        // Overlap fields are not supported directly in DDs. It is expected
16412>>>>>>>        // that you will use the underlying fields instead
16412>>>>>>>        If (iType = DF_OVERLAP) Begin
16414>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
16415>>>>>>>            Procedure_Return
16416>>>>>>>        End
16416>>>>>>>>
16416>>>>>>>        
16416>>>>>>>        If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
16418>>>>>>>            // if number,date or string convert the pointer data to
16418>>>>>>>            // string data and do a normal entry with it.
16418>>>>>>>            Move (PointerToString(pData)) to sValue  // create string from pointer data
16419>>>>>>>            Set Field_Current_Value iField to sValue
16420>>>>>>>            Procedure_Return
16421>>>>>>>        End
16421>>>>>>>>
16421>>>>>>>        
16421>>>>>>>        Get Field_Object iField to hFld // the object that handles this large text
16422>>>>>>>        If not hFld Begin
16424>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
16425>>>>>>>            Procedure_Return
16426>>>>>>>        End
16426>>>>>>>>
16426>>>>>>>        
16426>>>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
16427>>>>>>>        If bChanged Begin
16429>>>>>>>            Set Field_pValue of hFld iLen to pData
16430>>>>>>>            Send Field_Pointer_Value_Changed iField pData
16431>>>>>>>        End
16431>>>>>>>>
16431>>>>>>>        Else Begin
16432>>>>>>>            // If here the set value did not change the contents of the DD.
16432>>>>>>>            // However, it is possible that the current focus DEO may contain
16432>>>>>>>            // a different value than the one we are setting. In such a case
16432>>>>>>>            // we must re-synchronize the DEO. Only the one DEO can be affected
16432>>>>>>>            // because it is the current focus deo/item that can contain a value
16432>>>>>>>            // that is not yet updated in the DD. This fixes a bug where the
16432>>>>>>>            // iexit was setting a value which was different from what was in
16432>>>>>>>            // the DEO but was the same as the old DD value (iExit is called
16432>>>>>>>            // before the DD is re-synched with the DEO). This could happen
16432>>>>>>>            // also by sending this message directly with a different value in
16432>>>>>>>            // the DEO focus item.
16432>>>>>>>            Get Focus of Desktop to iFocObj
16433>>>>>>>            // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
16433>>>>>>>            // is extended, that entry_refresh is not disabled and that the
16433>>>>>>>            // DEO's server is this DD.
16433>>>>>>>            If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
16435>>>>>>>                // If Focus DEO has same file and field and it is not checkbox
16435>>>>>>>                // we must set its value. Set local value directly sets the value
16435>>>>>>>                // in the DEO item. If we used value we'd get recursion!
16435>>>>>>>                Get Current_item of iFocObj to iCrnt
16436>>>>>>>                If ( Data_File(iFocObj,iCrnt)=iFile and ;                    Data_Field(iFocObj,iCrnt)=iField and ;                    IsDEOOwned(Self,iFocObj) ) Begin
16438>>>>>>>                    Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
16439>>>>>>>                End
16439>>>>>>>>
16439>>>>>>>            End
16439>>>>>>>>
16439>>>>>>>        End
16439>>>>>>>>
16439>>>>>>>    End_Procedure
16440>>>>>>>    
16440>>>>>>>    // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
16440>>>>>>>    Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
16442>>>>>>>    End_Procedure
16443>>>>>>>    
16443>>>>>>>    Procedure Field_Pointer_Value_Changed Integer iField Address pValue
16445>>>>>>>        Integer iMax
16445>>>>>>>        Integer iCount
16445>>>>>>>        Integer iDEO
16445>>>>>>>        Integer iMain_File
16445>>>>>>>        Integer iNoChange
16445>>>>>>>        Get Change_Disabled_State to iNoChange
16446>>>>>>>        Get Main_File to iMain_File
16447>>>>>>>        Get Data_Set_User_Interface_Count to iMax
16448>>>>>>>        Decrement iMax
16449>>>>>>>        For iCount from 0 to iMax
16455>>>>>>>>
16455>>>>>>>            Get Data_Set_User_Interface iCount to iDEO
16456>>>>>>>            If (Extended_DEO_State(iDEO) ) Begin
16458>>>>>>>                Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
16459>>>>>>>            End
16459>>>>>>>>
16459>>>>>>>        Loop
16460>>>>>>>>
16460>>>>>>>    End_Procedure
16461>>>>>>>    
16461>>>>>>>    // This is the same as File_Field_Current_Value except the value is passed
16461>>>>>>>    // via a pointer. See Field_current_Pointer_Value for more on this
16461>>>>>>>    Procedure Set File_Field_Current_Pointer_Value Integer iFile Integer iField Integer iLen Address pData
16463>>>>>>>        Integer hDD
16463>>>>>>>        Get Data_Set iFile to hDD
16464>>>>>>>        If hDD ;            Set Field_Current_Pointer_Value of hDD iField iLen to pData
16467>>>>>>>    End_Procedure
16468>>>>>>>    
16468>>>>>>>    // This returns the data pointer to the extended field. At this point
16468>>>>>>>    // this is the data. Be careful if you change the data, be even more
16468>>>>>>>    // careful if you change the pointer (don't do it!!!!)
16468>>>>>>>    Function Field_Current_Pointer_Value Integer iField Returns Address
16470>>>>>>>        Integer hFld
16470>>>>>>>        Handle iFoc
16470>>>>>>>        
16470>>>>>>>        Get Field_Object iField to hFld // the object that handles this large text
16471>>>>>>>        If not hFld Begin
16473>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
16474>>>>>>>            Function_Return 0
16475>>>>>>>        End
16475>>>>>>>>
16475>>>>>>>        
16475>>>>>>>        
16475>>>>>>>        // This was extended to also make sure that the focus's server
16475>>>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
16475>>>>>>>        // file/field being the right file/field but for a different view.
16475>>>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
16475>>>>>>>        // ddos have the information they need from the deos. During a refresh we don't
16475>>>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
16475>>>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
16475>>>>>>>        // DEO field, so the buffer is always correct.
16475>>>>>>>        Get Focus of Desktop to iFoc
16476>>>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
16478>>>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
16480>>>>>>>                Send Update_Focus_Field
16481>>>>>>>            End
16481>>>>>>>>
16481>>>>>>>        End
16481>>>>>>>>
16481>>>>>>>        
16481>>>>>>>        Function_Return (FieldPointer(hFld))
16482>>>>>>>    End_Function
16483>>>>>>>    
16483>>>>>>>    
16483>>>>>>>    Function Field_Current_UCAValue Integer iField Returns UChar[]
16485>>>>>>>        Integer hFld
16485>>>>>>>        Handle iFoc
16485>>>>>>>        UChar[] Data
16486>>>>>>>        
16486>>>>>>>        Get Field_Object iField to hFld // the object that handles this large text
16487>>>>>>>        If not hFld Begin
16489>>>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
16490>>>>>>>            Function_Return 0
16491>>>>>>>        End
16491>>>>>>>>
16491>>>>>>>        
16491>>>>>>>        
16491>>>>>>>        // This was extended to also make sure that the focus's server
16491>>>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
16491>>>>>>>        // file/field being the right file/field but for a different view.
16491>>>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
16491>>>>>>>        // ddos have the information they need from the deos. During a refresh we don't
16491>>>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
16491>>>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
16491>>>>>>>        // DEO field, so the buffer is always correct.
16491>>>>>>>        Get Focus of Desktop to iFoc
16492>>>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
16494>>>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
16496>>>>>>>                Send Update_Focus_Field
16497>>>>>>>            End
16497>>>>>>>>
16497>>>>>>>        End
16497>>>>>>>>
16497>>>>>>>        Get FieldArray of hFld to Data
16498>>>>>>>        Function_Return Data
16499>>>>>>>    End_Function
16500>>>>>>>    
16500>>>>>>>    Function File_Field_Current_Pointer_Value Integer iFile Integer iField Returns Address
16502>>>>>>>        Address pValue
16502>>>>>>>        Integer hDD
16502>>>>>>>        Get Data_Set iFile to hDD
16503>>>>>>>        If hDD Begin
16505>>>>>>>            Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
16506>>>>>>>            Function_Return pValue                                  // data
16507>>>>>>>        End
16507>>>>>>>>
16507>>>>>>>    End_Function
16508>>>>>>>    
16508>>>>>>>    Procedure Set Field_Current_UCAValue Integer iField UChar[] Data
16510>>>>>>>        Set Field_Current_Pointer_Value iField (SizeOfArray(Data)) to (AddressOf(Data))
16511>>>>>>>    End_Procedure
16512>>>>>>>    
16512>>>>>>>    Procedure Set File_Field_Current_UCAValue Integer iFile Integer iField UChar[] Data
16514>>>>>>>        Integer hDD
16514>>>>>>>        Get Data_Set iFile to hDD
16515>>>>>>>        If hDD Begin
16517>>>>>>>            Set Field_Current_UCAValue of hDD iField to Data
16518>>>>>>>        End
16518>>>>>>>>
16518>>>>>>>    End_Procedure
16519>>>>>>>    
16519>>>>>>>    Function File_Field_Current_UCAValue Integer iFile Integer iField Returns UChar[]
16521>>>>>>>        UChar[] UCValue
16522>>>>>>>        Handle hDD
16522>>>>>>>        Get Data_Set iFile to hDD
16523>>>>>>>        If hDD Begin
16525>>>>>>>            Get Field_Current_UCAValue of hDD iField to UCValue // return pointer to first byte of
16526>>>>>>>            Function_Return UCValue                              // data
16527>>>>>>>        End
16527>>>>>>>>
16527>>>>>>>    End_Function
16528>>>>>>>    
16528>>>>>>>    // Create an extended field object for the passed field. .
16528>>>>>>>    // If field already exists, do nothing. This should only be used with
16528>>>>>>>    // text and binary fields.
16528>>>>>>>    Procedure DefineExtendedField Integer iField
16530>>>>>>>        Integer hFlds
16530>>>>>>>        Get Field_Objects to hFlds // this may not be created yet.
16531>>>>>>>        If not hFlds Begin         // if not created, create extended-fields wrapper
16533>>>>>>>            Object ExtendedFieldObjects is a FieldObjects
16535>>>>>>>                Move Self to hFlds
16536>>>>>>>            End_Object
16537>>>>>>>            Set Field_Objects to hFlds
16538>>>>>>>        End
16538>>>>>>>>
16538>>>>>>>        Send DefineFieldObject to hFlds iField
16539>>>>>>>    End_Procedure
16540>>>>>>>    
16540>>>>>>>    // create extended DD fields for all text and binary files
16540>>>>>>>    Procedure DefineAllExtendedFields
16542>>>>>>>        Integer iCount iType iField iFile
16542>>>>>>>        Get Main_file to iFile
16543>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
16546>>>>>>>        For iField from 1 to iCount
16552>>>>>>>>
16552>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
16555>>>>>>>            If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary                Send DefineExtendedField iField
16558>>>>>>>        Loop
16559>>>>>>>>
16559>>>>>>>    End_Procedure
16560>>>>>>>    
16560>>>>>>>    // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer
16560>>>>>>>    // Private
16560>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
16562>>>>>>>        Integer hFlds
16562>>>>>>>        Get Field_Objects to hFlds
16563>>>>>>>        If hFlds ;            Send ExtendedFieldsUpdate to hFlds bSave
16566>>>>>>>    End_Procedure
16567>>>>>>>    
16567>>>>>>>    // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer
16567>>>>>>>    // Private
16567>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
16569>>>>>>>        Integer hFlds
16569>>>>>>>        Get Field_Objects to hFlds
16570>>>>>>>        If hFlds ;            Send ExtendedFieldsRefresh to hFlds bCleared
16573>>>>>>>    End_Procedure
16574>>>>>>>    
16574>>>>>>>    // This procedure can be used to set the Item_Options of a field. This can
16574>>>>>>>    // be passed any number of arguments.
16574>>>>>>>    // Support the following special first parameters:
16574>>>>>>>    //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions
16574>>>>>>>    //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options
16574>>>>>>>    Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
16576>>>>>>>        Integer iObj
16576>>>>>>>        Integer iOptions
16576>>>>>>>        Integer iOption
16576>>>>>>>        Integer iArg
16576>>>>>>>        Integer iClear
16576>>>>>>>        Integer iType
16576>>>>>>>        Move (Record_Buffer(Self)) to iObj
16577>>>>>>>        Get Item_Options of iObj iField to iOptions
16578>>>>>>>        //
16578>>>>>>>        For iArg from 2 to Num_Arguments
16584>>>>>>>>
16584>>>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
16585>>>>>>>            
16585>>>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
16588>>>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
16592>>>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
16596>>>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
16598>>>>>>>        Loop
16599>>>>>>>>
16599>>>>>>>        //
16599>>>>>>>        //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
16599>>>>>>>        //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
16599>>>>>>>        //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
16599>>>>>>>        
16599>>>>>>>        Set Item_Options of iObj iField to iOptions
16600>>>>>>>    End_Procedure
16601>>>>>>>    
16601>>>>>>>    // This function returns all the item_options which have been set for
16601>>>>>>>    // a field. The value from the Record_Buffer object will be binary or'ed
16601>>>>>>>    // with constand Default_Item_Options and the DD_AUTOCLEAR constants when
16601>>>>>>>    // the Autoclear_State of the field has been set.
16601>>>>>>>    // Keep in mind that Autoclear is *not* kept in the Item_Options
16601>>>>>>>    // property.
16601>>>>>>>    Function Field_Options Integer iField Returns Integer
16603>>>>>>>        Function_Return (Item_Options(Record_Buffer(Self), iField))
16604>>>>>>>    End_Function
16605>>>>>>>    
16605>>>>>>>    Function Field_Option Integer iField Integer iOption Returns Integer
16607>>>>>>>        Integer iOptions
16607>>>>>>>        Integer iState
16607>>>>>>>        Get Item_Options of (Record_Buffer(Self)) iField to iOptions
16608>>>>>>>        // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
16608>>>>>>>        Move ((iOptions iand iOption)=iOption) to iState
16609>>>>>>>        Function_Return iState
16610>>>>>>>    End_Function
16611>>>>>>>    
16611>>>>>>>    
16611>>>>>>>    Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
16613>>>>>>>        Integer iObj
16613>>>>>>>        Integer iOptions
16613>>>>>>>        Integer iOption
16613>>>>>>>        Integer iArg
16613>>>>>>>        Integer iClear
16613>>>>>>>        
16613>>>>>>>        
16613>>>>>>>        Move (Record_Buffer(Self)) to iObj
16614>>>>>>>        Get Aux_Value of iObj iField to iOptions
16615>>>>>>>        //
16615>>>>>>>        For iArg from 2 to Num_Arguments
16621>>>>>>>>
16621>>>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
16622>>>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
16625>>>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
16629>>>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
16633>>>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
16635>>>>>>>        Loop
16636>>>>>>>>
16636>>>>>>>        //
16636>>>>>>>        Set Aux_Value of iObj iField to iOptions
16637>>>>>>>    End_Procedure
16638>>>>>>>    
16638>>>>>>>    Function Foreign_Field_Options Integer iField Returns Integer
16640>>>>>>>        Integer iOpts
16640>>>>>>>        Get ForeignFieldOptions of Record_Buffer iField to iOpts
16641>>>>>>>        Function_Return iOpts
16642>>>>>>>    End_Function
16643>>>>>>>    
16643>>>>>>>    Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
16645>>>>>>>        If bSet Begin
16647>>>>>>>            Set Foreign_Field_Options iField to iOption
16648>>>>>>>        End
16648>>>>>>>>
16648>>>>>>>        Else Begin
16649>>>>>>>            Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
16650>>>>>>>        End
16650>>>>>>>>
16650>>>>>>>    End_Procedure
16651>>>>>>>    
16651>>>>>>>    Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
16653>>>>>>>        Integer iOptions
16653>>>>>>>        Integer iState
16653>>>>>>>        Get Foreign_Field_Options iField to iOptions
16654>>>>>>>        Move ((iOptions iand iOption)=iOption) to iState
16655>>>>>>>        Function_Return iState
16656>>>>>>>    End_Function
16657>>>>>>>    
16657>>>>>>>    // This procedure is being used by DEOs when they need to copy the item-
16657>>>>>>>    // options from the Data_Set. When the filenumber being passed is not
16657>>>>>>>    // equal to the Main_File of this Data_Set, then the Foreign_Field_Options
16657>>>>>>>    // will be applied.
16657>>>>>>>    Function File_Field_Options Integer iFile Integer iField Returns Integer
16659>>>>>>>        Integer iDSO
16659>>>>>>>        Integer iMain_File
16659>>>>>>>        Integer iOpts
16659>>>>>>>        Integer iRB
16659>>>>>>>        Integer iType
16659>>>>>>>        Get Main_File to iMain_File
16660>>>>>>>        If (iFile <> iMain_File) ;            Get Data_Set iFile to iDSO
16663>>>>>>>        Else ;            Move Self to iDSO
16665>>>>>>>        If iDSO Begin
16667>>>>>>>            Get Field_Options of iDSO iField to iOpts
16668>>>>>>>            // we consider the item to be foreign if the DDO main file is different than the one
16668>>>>>>>            // passed and we do not allow foreign (parent) new records to be saved.
16668>>>>>>>            If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options                Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
16671>>>>>>>            Function_Return iOpts
16672>>>>>>>        End
16672>>>>>>>>
16672>>>>>>>    End_Function
16673>>>>>>>    
16673>>>>>>>    
16673>>>>>>>    // Procedure to set the message to be sent on item entry.
16673>>>>>>>    Procedure Set Field_Entry_msg Integer iField Integer iMsg
16675>>>>>>>        Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
16676>>>>>>>    End_Procedure
16677>>>>>>>    
16677>>>>>>>    // Function to return the message to be sent on item entry.
16677>>>>>>>    Function Field_Entry_msg Integer iField Returns Integer
16679>>>>>>>        Function_Return (Item_Entry_MSG(Record_Buffer(Self), iField))
16680>>>>>>>    End_Function
16681>>>>>>>    
16681>>>>>>>    
16681>>>>>>>    // Procedure to send the message to be sent on item exit.
16681>>>>>>>    Procedure Set Field_Exit_msg Integer iField Integer iMsg
16683>>>>>>>        Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
16684>>>>>>>    End_Procedure
16685>>>>>>>    
16685>>>>>>>    // Function to return the message to be set on item exit.
16685>>>>>>>    Function Field_Exit_msg Integer iField Returns Integer
16687>>>>>>>        Function_Return (Item_Exit_MSG(Record_Buffer(Self), iField))
16688>>>>>>>    End_Function
16689>>>>>>>    
16689>>>>>>>    // Procedure to set the message to be sent on item validation.
16689>>>>>>>    Procedure Set Field_Validate_msg Integer iField Integer iMsg
16691>>>>>>>        Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
16692>>>>>>>    End_Procedure
16693>>>>>>>    
16693>>>>>>>    // Function to return the message to be set on item validation.
16693>>>>>>>    Function Field_Validate_msg Integer iField Returns Integer
16695>>>>>>>        Function_Return (Item_Validate_MSG(Record_Buffer(Self), iField))
16696>>>>>>>    End_Function
16697>>>>>>>    
16697>>>>>>>    
16697>>>>>>>    // Used to Get/Set the Prompt_Object for a Field.
16697>>>>>>>    Procedure Set Field_Prompt_Object Integer iField Integer iObj
16699>>>>>>>        Set Prompt_Object of (Record_Buffer(Self)) iField to iObj
16700>>>>>>>    End_Procedure
16701>>>>>>>    
16701>>>>>>>    Function Field_Prompt_Object Integer iField Returns Integer
16703>>>>>>>        Integer iObj
16703>>>>>>>        Get Prompt_Object of (Record_Buffer(Self)) iField to iObj
16704>>>>>>>        If (iObj = 0) ;            Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
16707>>>>>>>        Function_Return iObj
16708>>>>>>>    End_Function
16709>>>>>>>    
16709>>>>>>>    Procedure Set Field_Zoom_Object Integer iField Integer iObj
16711>>>>>>>        Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
16712>>>>>>>    End_Procedure
16713>>>>>>>    
16713>>>>>>>    Function Field_Zoom_Object Integer iField Returns Integer
16715>>>>>>>        Function_Return (Zoom_Object(Record_Buffer(Self), iField))
16716>>>>>>>    End_Function
16717>>>>>>>    
16717>>>>>>>    
16717>>>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
16719>>>>>>>        Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
16720>>>>>>>    End_Procedure
16721>>>>>>>    
16721>>>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
16723>>>>>>>        Handle hoPrompt
16723>>>>>>>        Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
16724>>>>>>>        Function_Return hoPrompt
16725>>>>>>>    End_Function
16726>>>>>>>    
16726>>>>>>>    
16726>>>>>>>    // Used to Get/Set the Prompt_Object for a Field.
16726>>>>>>>    Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
16728>>>>>>>        Integer iObj
16728>>>>>>>        Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
16729>>>>>>>        Function_Return iObj
16730>>>>>>>    End_Function
16731>>>>>>>    
16731>>>>>>>    Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
16733>>>>>>>        Integer iObj
16733>>>>>>>        Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
16734>>>>>>>        Function_Return iObj
16735>>>>>>>    End_Function
16736>>>>>>>    
16736>>>>>>>    Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
16738>>>>>>>        Handle hoPrompt
16738>>>>>>>        Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
16739>>>>>>>        Function_Return hoPrompt
16740>>>>>>>    End_Function
16741>>>>>>>    
16741>>>>>>>    // Return the extended validation type for this field.
16741>>>>>>>    Function Field_Validation_Type Integer iField Returns Integer
16743>>>>>>>        Integer iType
16743>>>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField ;            to iType
16744>>>>>>>        Function_Return iType
16745>>>>>>>    End_Function
16746>>>>>>>    
16746>>>>>>>    // Procedure to define a valid value range for a field.
16746>>>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
16748>>>>>>>        Set Field_Value_Range of (Field_Attributes(Self)) iField ;            to sMin sMax
16749>>>>>>>    End_Procedure
16750>>>>>>>    
16750>>>>>>>    
16750>>>>>>>    // Procedure to define a validate table for a field.
16750>>>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
16752>>>>>>>        Set Field_Value_Table of (Field_Attributes(Self)) iField ;            to iObj
16753>>>>>>>    End_Procedure
16754>>>>>>>    
16754>>>>>>>    // This provides a callback to the calling object (iObj) by passing this
16754>>>>>>>    // object the message iMsg for each item in the table. Note this works for
16754>>>>>>>    // all extended validation types (range, check, etc.)
16754>>>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
16756>>>>>>>        Send Field_Fill_list to (Field_Attributes(Self)) ;            iField iObj iMsg
16757>>>>>>>    End_Procedure
16758>>>>>>>    
16758>>>>>>>    Procedure File_Field_Fill_List Integer iFile Integer iField ;            Integer iObj Integer iMsg
16760>>>>>>>        Integer iDSO
16760>>>>>>>        Get Data_set iFile to iDSO
16761>>>>>>>        If iDSO ;            Send Field_Fill_list to iDSO iField iObj iMsg
16764>>>>>>>    End_Procedure
16765>>>>>>>    
16765>>>>>>>    // Returns the ID if any of the validation table for this object.
16765>>>>>>>    Function Field_Table_Object Integer iField Returns Integer
16767>>>>>>>        Integer iRval
16767>>>>>>>        Get Field_Table_Object of (Field_Attributes(Self)) iField to iRVal
16768>>>>>>>        Function_Return iRVal
16769>>>>>>>    End_Function
16770>>>>>>>    
16770>>>>>>>    Function File_Field_Table_Object Integer iFile Integer iField Returns Integer
16772>>>>>>>        Integer iDSO
16772>>>>>>>        Get Data_set iFile to iDSO
16773>>>>>>>        If iDSO ;            Function_Return (Field_Table_Object(iDSO,iField))
16776>>>>>>>    End_Function
16777>>>>>>>    
16777>>>>>>>    // Returns code description value for the passed string for the
16777>>>>>>>    // passed validation table object. Normally use field_value_description
16777>>>>>>>    Function Validation_Table_Description Integer iObj String sVal Returns String
16779>>>>>>>        String sDesc
16779>>>>>>>        If iObj ;            Get Find_Code_Description of iObj sVal to sDesc
16782>>>>>>>        Function_Return sDesc
16783>>>>>>>    End_Function
16784>>>>>>>    
16784>>>>>>>    // Returns the description value for the field's code value. This only
16784>>>>>>>    // works if you have a validation table - else it returns the field value
16784>>>>>>>    Function Field_Current_Description Integer iField Returns String
16786>>>>>>>        String sDesc
16786>>>>>>>        String sVal
16786>>>>>>>        Integer iObj
16786>>>>>>>        Get Field_Current_Value iField to sVal
16787>>>>>>>        Get Field_Table_Object iField to iObj
16788>>>>>>>        If iObj Begin
16790>>>>>>>            Get Validation_Table_Description iObj sVal to sDesc
16791>>>>>>>            If (sDesc="") ;                Move sVal to sDesc // if desc is blank, use value
16794>>>>>>>        End
16794>>>>>>>>
16794>>>>>>>        Else ;            Move sVal to sDesc
16796>>>>>>>        Function_Return sDesc
16797>>>>>>>    End_Function
16798>>>>>>>    
16798>>>>>>>    Function File_Field_Current_Description Integer iFile Integer iField Returns String
16800>>>>>>>        Integer iDSO
16800>>>>>>>        Get Data_set iFile to iDSO
16801>>>>>>>        If iDSO ;            Function_Return (Field_Current_Description(iDSO,iField))
16804>>>>>>>    End_Function
16805>>>>>>>    
16805>>>>>>>    // Required Messaging to Support Checkbox items in DEOs
16805>>>>>>>    //  Defines a field as a two item field and defines True and False values
16805>>>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
16807>>>>>>>        Set Field_CheckBox_Values of (Field_Attributes(Self)) iField ;            to sTrue sFalse
16808>>>>>>>    End_Procedure
16809>>>>>>>    
16809>>>>>>>    //    Returns a field's select_State based on the pased value
16809>>>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
16811>>>>>>>        Function_Return (Field_Value_Select_State(Field_Attributes(Self),iField,sValue))
16812>>>>>>>    End_Function
16813>>>>>>>    
16813>>>>>>>    //    Returns a field's select_State based on the DD buffer contents
16813>>>>>>>    Function Field_Select_State Integer iField Returns Integer
16815>>>>>>>        String sValue
16815>>>>>>>        Get Field_Current_Value iField to sValue
16816>>>>>>>        Function_Return (Field_Value_Select_State(Self,iField,sValue))
16817>>>>>>>    End_Function
16818>>>>>>>    
16818>>>>>>>    //   Returns a file/field' select_State based on contents of DD buffer
16818>>>>>>>    Function File_Field_Select_State Integer iFile Integer iField Returns Integer
16820>>>>>>>        Integer iDSO
16820>>>>>>>        Get Data_set iFile to iDSO
16821>>>>>>>        If iDSO ;            Function_Return (Field_Select_State(iDSO,iField))
16824>>>>>>>    End_Function
16825>>>>>>>    
16825>>>>>>>    //   Returns a file/field' select_State based on passed value
16825>>>>>>>    Function File_Field_Value_Select_State Integer iFile Integer iField ;            String sValue Returns Integer
16827>>>>>>>        Integer iDSO
16827>>>>>>>        Get Data_set iFile to iDSO
16828>>>>>>>        If iDSO ;            Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
16831>>>>>>>    End_Function
16832>>>>>>>    
16832>>>>>>>    // get the actual database value that corresponds to the boolean value
16832>>>>>>>    // passed.
16832>>>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
16834>>>>>>>        Function_Return (Field_Checkbox_Value(Field_Attributes(Self),iField,iState))
16835>>>>>>>    End_Function
16836>>>>>>>    
16836>>>>>>>    Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState Returns String
16838>>>>>>>        Integer iDSO
16838>>>>>>>        Get Data_set iFile to iDSO
16839>>>>>>>        If iDSO ;            Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
16842>>>>>>>    End_Function
16843>>>>>>>    
16843>>>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
16843>>>>>>>    Procedure Set Field_Select_State Integer iField Integer iState
16845>>>>>>>        String sValue
16845>>>>>>>        Get Field_Checkbox_Value iField iState to sValue
16846>>>>>>>        Set Field_Current_Value iField to sValue
16847>>>>>>>    End_Procedure
16848>>>>>>>    
16848>>>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
16848>>>>>>>    // if needed (set Field_Current_Value does this). First finds proper file
16848>>>>>>>    // DSO
16848>>>>>>>    Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
16850>>>>>>>        Integer iDSO
16850>>>>>>>        Get Data_set iFile to iDSO
16851>>>>>>>        If iDSO ;            Set Field_Select_State of iDSO iField to iState
16854>>>>>>>    End_Procedure
16855>>>>>>>    
16855>>>>>>>    // Procedure to define a check string for a field.
16855>>>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
16857>>>>>>>        Set Field_Value_Check of (Field_Attributes(Self)) iField ;            to sCheck
16858>>>>>>>    End_Procedure
16859>>>>>>>    
16859>>>>>>>    // This function will be called indirectly by DEOs when an item is being
16859>>>>>>>    // entered, exited or needs validation. The first argument holds the
16859>>>>>>>    // fieldnumber for the field and the second holds the id of the message
16859>>>>>>>    // which can be send to retrieve the message which needs to be send for
16859>>>>>>>    // this Field/Event combination. The value of the second argument can be
16859>>>>>>>    // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.
16859>>>>>>>    Function Exec_Field_Message Integer iField Integer iMsg_ID Returns Integer
16861>>>>>>>        Integer iMsg
16861>>>>>>>        Integer iResult
16861>>>>>>>        String  sValue
16861>>>>>>>        Get iMsg_ID iField to iMsg
16862>>>>>>>        If iMsg Begin
16864>>>>>>>            Get Field_Current_Value iField to sValue
16865>>>>>>>            Get iMsg iField sValue to iResult
16866>>>>>>>        End
16866>>>>>>>>
16866>>>>>>>        Function_Return iResult
16867>>>>>>>    End_Function
16868>>>>>>>    
16868>>>>>>>    
16868>>>>>>>    // This function will be called from within DEOs when an item is being
16868>>>>>>>    // entered, exited or needs validation. The first argument holds the
16868>>>>>>>    // file number, the second argument holds the field and the third
16868>>>>>>>    // holds the id of the message  which can be send to retrieve the message
16868>>>>>>>    // which needs to be send for this File/Field/Event combination.
16868>>>>>>>    // The value of the second argument can be  GET_Field_Entry_MSG,
16868>>>>>>>    // GET_Field_Exit_MSG or GET_Field_Validate_MSG.
16868>>>>>>>    // This will redirect to the proper data-set object.
16868>>>>>>>    Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID Returns Integer
16870>>>>>>>        Integer iDSO
16870>>>>>>>        Integer iResult
16870>>>>>>>        Get Data_set iFile to iDSO
16871>>>>>>>        If iDSO ;            Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
16874>>>>>>>        Function_Return iResult
16875>>>>>>>    End_Function
16876>>>>>>>    
16876>>>>>>>    // Find the data-set whose main_file is the same as File#. The message
16876>>>>>>>    // Which_data_set includes updating parent files, we will throw those out.
16876>>>>>>>    // This has been augmented to search down the DDO tree if we do not find
16876>>>>>>>    // the DD with our quick C Which_Data_set search
16876>>>>>>>    Function Data_Set Integer iFile Returns Integer
16878>>>>>>>        Integer iTmp
16878>>>>>>>        Integer iDSO
16878>>>>>>>        Get Main_File to iTmp
16879>>>>>>>        If (iTmp = iFile) ;            Function_Return Self
16882>>>>>>>        Get Which_Data_Set iFile to iDSO
16883>>>>>>>        If iDSO Begin
16885>>>>>>>            // check that DS's main-file is the File (and not a parent file)
16885>>>>>>>            Get Main_File of iDSO to iTmp
16886>>>>>>>            If (iTmp = iFile) ;                Function_Return iDSO
16889>>>>>>>        End
16889>>>>>>>>
16889>>>>>>>        
16889>>>>>>>        // This really should have succeeded by now. If not we need to do a
16889>>>>>>>        // downward sweep looking for DD. This will be a slower process since it
16889>>>>>>>        // involves flex level DDO structure traversal. We should very rarely ever
16889>>>>>>>        // get to this point. If we do, it takes longer!
16889>>>>>>>        
16889>>>>>>>        // Unlike other traversals we will mark and check in a single
16889>>>>>>>        // step.
16889>>>>>>>        // This Mark_Id creates a sequence Id for this clear. This way
16889>>>>>>>        // DSOs only get cleared one time during this process.
16889>>>>>>>        Send IncrementCurrentMarkId
16890>>>>>>>        Get Private.Data_set iFile to iDSO // this does the recursive downward search
16891>>>>>>>        Function_Return iDSO
16892>>>>>>>    End_Function
16893>>>>>>>    
16893>>>>>>>    Function Private.Data_Set Integer iFile Returns Integer
16895>>>>>>>        Integer iMax
16895>>>>>>>        Integer iDSO hDD
16895>>>>>>>        Integer iCount
16895>>>>>>>        
16895>>>>>>>        If (iFile=Main_file(Self)) ;            Function_Return Self
16898>>>>>>>        
16898>>>>>>>        // We are only looking at sequence ID.
16898>>>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
16899>>>>>>>        
16899>>>>>>>        // recurse Down first, since we already tried upward direction.
16899>>>>>>>        Get Data_Set_Client_Count to iMax
16900>>>>>>>        Decrement iMax
16901>>>>>>>        For iCount from 0 to iMax
16907>>>>>>>>
16907>>>>>>>            Get Data_Set_Client iCount to iDSO
16908>>>>>>>            // If already cleared during this sequence...do nothing
16908>>>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
16910>>>>>>>                Get Private.Data_Set of iDSO iFile to hDD
16911>>>>>>>                If hDD ;                    Function_Return hDD // when found...get out
16914>>>>>>>            End
16914>>>>>>>>
16914>>>>>>>        Loop
16915>>>>>>>>
16915>>>>>>>        // recurse up server list next. We do this 2nd because it is
16915>>>>>>>        // the less likely path for success.
16915>>>>>>>        Get Data_Set_Server_Count to iMax
16916>>>>>>>        Decrement iMax
16917>>>>>>>        For iCount from 0 to iMax
16923>>>>>>>>
16923>>>>>>>            Get Data_Set_Server iCount to iDSO
16924>>>>>>>            // If already cleared during this sequence...do nothing
16924>>>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
16926>>>>>>>                Get Private.Data_Set of iDSO iFile to hDD
16927>>>>>>>                If hDD ;                    Function_Return hDD // when found...get out
16930>>>>>>>            End
16930>>>>>>>>
16930>>>>>>>        Loop
16931>>>>>>>>
16931>>>>>>>        Function_Return 0 // if here, our traversal has failed.
16932>>>>>>>    End_Function
16933>>>>>>>    
16933>>>>>>>    // These methods can be used to set/get a field property in a flexible
16933>>>>>>>    // way. The first two argument are the file- and fieldnumber followed by
16933>>>>>>>    // the ID of the message that should be send. The last argument should
16933>>>>>>>    // be the value to set or the variable to store the value in.
16933>>>>>>>    Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
16935>>>>>>>        Integer iDSO
16935>>>>>>>        Get Data_Set iFile to iDSO
16936>>>>>>>        If iDSO Begin
16938>>>>>>>            Set iMsg of iDSO iField to sValue
16939>>>>>>>            Procedure_Return sValue
16940>>>>>>>        End
16940>>>>>>>>
16940>>>>>>>    End_Procedure
16941>>>>>>>    
16941>>>>>>>    Function File_Field_Property Integer iFile Integer iField Integer iMsg Returns Integer
16943>>>>>>>        Integer iDSO
16943>>>>>>>        String  sValue
16943>>>>>>>        Get Data_Set iFile to iDSO
16944>>>>>>>        If iDSO Begin
16946>>>>>>>            Get iMsg of iDSO iField to sValue
16947>>>>>>>            Function_Return sValue
16948>>>>>>>        End
16948>>>>>>>>
16948>>>>>>>    End_Function
16949>>>>>>>    
16949>>>>>>>    // This procedure will return the number of fields in the object
16949>>>>>>>    Function Field_Count Returns Integer
16951>>>>>>>        Function_Return (Item_Count(Record_Buffer(Self)) - 1)
16952>>>>>>>    End_Function
16953>>>>>>>    
16953>>>>>>>    // This procedure will clear all flags in the visited_fields string so
16953>>>>>>>    // that all field will be validated on the next requests.
16953>>>>>>>    Procedure Clear_Visited_Fields
16955>>>>>>>        // this clears field visitation marks
16955>>>>>>>        Set Visited_Fields to (Repeat(" ", Field_Count(Self)))
16956>>>>>>>    End_Procedure
16957>>>>>>>    
16957>>>>>>>    // Private.Initialize_Visited
16957>>>>>>>    // This procedure will be called when validations (and perhaps other
16957>>>>>>>    // events) is requested. It clears the visited marks and then proceeds
16957>>>>>>>    // to clear the marks up the server tree.
16957>>>>>>>    // This is passed two parameters: Up_and_down, If true upward and downward
16957>>>>>>>    // initialize. If Clear_Fields also clear the field string
16957>>>>>>>    Procedure Private.Initialize_Visited Integer Up_and_Down Integer Clear_Fields
16959>>>>>>>        Integer iMax
16959>>>>>>>        Integer iDSO
16959>>>>>>>        Integer iCount
16959>>>>>>>        
16959>>>>>>>        // recurse up server list first. Only recurse up
16959>>>>>>>        Get Data_Set_Server_Count to iMax
16960>>>>>>>        Decrement iMax
16961>>>>>>>        For iCount from 0 to iMax
16967>>>>>>>>
16967>>>>>>>            Get Data_Set_Server iCount to iDSO
16968>>>>>>>            // If already cleared during this sequence...do nothing
16968>>>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                Send Private.Initialize_Visited to iDSO False Clear_Fields
16971>>>>>>>        Loop
16972>>>>>>>>
16972>>>>>>>        
16972>>>>>>>        If Clear_Fields ;            Send Clear_Visited_Fields // clear all markers in this object
16975>>>>>>>        // this clears the visited mark for the entire object
16975>>>>>>>        Set Visited_State to False
16976>>>>>>>        Set DownDelete_State to False
16977>>>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
16978>>>>>>>        
16978>>>>>>>        // If Up_and_Down recurse Down server list
16978>>>>>>>        If Up_and_Down Begin
16980>>>>>>>            Get Data_Set_Client_Count to iMax
16981>>>>>>>            Decrement iMax // **EK** This line was missing
16982>>>>>>>            For iCount from 0 to iMax
16988>>>>>>>>
16988>>>>>>>                Get Data_Set_Client iCount to iDSO
16989>>>>>>>                // If already cleared during this sequence...do nothing
16989>>>>>>>                If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                    Send Private.Initialize_Visited to iDSO True Clear_Fields
16992>>>>>>>            Loop
16993>>>>>>>>
16993>>>>>>>        End
16993>>>>>>>>
16993>>>>>>>    End_Procedure
16994>>>>>>>    
16994>>>>>>>    
16994>>>>>>>    // Clears Visited marks and (maybe) field visited marks in all required
16994>>>>>>>    // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)
16994>>>>>>>    // propagation. If False, DSOs are marked up (save style). This does not
16994>>>>>>>    // have a mode to mark ALL DSOs in a structure. (Not needed so far).
16994>>>>>>>    // If Clear_Fields is T the field string marker is also cleared.
16994>>>>>>>    // The method of using the global integer DD_Current_Mark_ID is an opt-
16994>>>>>>>    // imizer. This is private - do not tamper with it!
16994>>>>>>>    // Note that Intialize_Visited does not always Clear all DDOs in the structure. When
16994>>>>>>>    // Up_and_Down is true, it is marking all DDOs that will participate in a cascade delete
16994>>>>>>>    // which may not be all DDOs in the structure. If you want to initialize all DDOs use InitializeAllVisited
16994>>>>>>>    Procedure Initialize_Visited Integer Up_and_Down Integer Clear_Fields
16996>>>>>>>        Send IncrementCurrentMarkId
16997>>>>>>>        Send Private.Initialize_Visited Up_and_Down Clear_Fields
16998>>>>>>>    End_Procedure
16999>>>>>>>    
16999>>>>>>>    Procedure InitializeAllVisited2
17001>>>>>>>        Integer iMax iCount
17001>>>>>>>        Handle hoDSO
17001>>>>>>>        
17001>>>>>>>        Set Visited_State to False
17002>>>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id // marks this as visited
17003>>>>>>>        
17003>>>>>>>        // recurse up server list.
17003>>>>>>>        Get Data_Set_Server_Count to iMax
17004>>>>>>>        For iCount from 0 to (iMax-1)
17010>>>>>>>>
17010>>>>>>>            Get Data_Set_Server iCount to hoDSO
17011>>>>>>>            // If already cleared during this sequence...do nothing
17011>>>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 of hoDSO
17014>>>>>>>        Loop
17015>>>>>>>>
17015>>>>>>>        
17015>>>>>>>        // recurse down client list.
17015>>>>>>>        Get Data_Set_Client_Count to iMax
17016>>>>>>>        For iCount from 0 to (iMax-1)
17022>>>>>>>>
17022>>>>>>>            Get Data_Set_Client iCount to hoDSO
17023>>>>>>>            // If already cleared during this sequence...do nothing
17023>>>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 to hoDSO
17026>>>>>>>        Loop
17027>>>>>>>>
17027>>>>>>>    End_Procedure
17028>>>>>>>    
17028>>>>>>>    // clears visited flag for *all* ddos in the structure.
17028>>>>>>>    Procedure InitializeAllVisited
17030>>>>>>>        Send IncrementCurrentMarkId
17031>>>>>>>        Send InitializeAllVisited2
17032>>>>>>>    End_Procedure
17033>>>>>>>    
17033>>>>>>>    
17033>>>>>>>    // Internal recursive message to check file connections. Called from
17033>>>>>>>    // Valid_connections only. Private message
17033>>>>>>>    Function Private.Valid_Structure Integer Up_And_Down Returns Integer
17035>>>>>>>        Integer iRval iCount iMax
17035>>>>>>>        Handle iDSO iPDSO
17035>>>>>>>        Integer iPMax iPCount iPMain
17035>>>>>>>        Boolean bUpDown bNull bCascadeNull bDown
17035>>>>>>>        
17035>>>>>>>        // Check Current Connections
17035>>>>>>>        Get Valid_Servers to iRval           // always check servers
17036>>>>>>>        If (iRval=0 and Up_and_Down) ;       // check Clients if required            Get Valid_Clients to iRval
17039>>>>>>>        Set Visited_State to True
17040>>>>>>>        
17040>>>>>>>        // Ask Server data-sets to check their server connections
17040>>>>>>>        If not iRval Begin // check up
17042>>>>>>>            Get Data_Set_Server_Count to iMax
17043>>>>>>>            Decrement iMax
17044>>>>>>>            For iCount from 0 to iMax
17050>>>>>>>>
17050>>>>>>>                Get Data_Set_Server iCount to iDSO
17051>>>>>>>                If not (Visited_state(iDSO)) ;                    Get Private.Valid_Structure of iDSO False to iRVal
17054>>>>>>>            Until iRval
17056>>>>>>>        End
17056>>>>>>>>
17056>>>>>>>        
17056>>>>>>>        // If required, Ask Clients to check their server and client connections
17056>>>>>>>        //
17056>>>>>>>        If (iRval=0 and Up_and_Down) Begin // check down
17058>>>>>>>            Get Data_Set_Client_Count to iMax
17059>>>>>>>            Decrement iMax
17060>>>>>>>            For iCount from 0 to iMax
17066>>>>>>>>
17066>>>>>>>                Get Data_Set_Client iCount to iDSO
17067>>>>>>>                If not (Visited_state(iDSO)) Begin
17069>>>>>>>                    Get Data_Set_Server_Count of iDSO to iPMax
17070>>>>>>>                    // test if all deletable parents for a non parent null allowed/cascade delete null
17070>>>>>>>                    For iPCount from 0 to (iPMax-1)
17076>>>>>>>>
17076>>>>>>>                        Get Data_Set_Server of iDSO iPCount to iPDSO
17077>>>>>>>                        Get DownDelete_State of iPDSO to bDown
17078>>>>>>>                        If (bDown) Begin
17080>>>>>>>                            Get Main_File of iPDSO to iPMain
17081>>>>>>>                            Get IsNullParentAllowed of iDSO iPMain to bNull
17082>>>>>>>                            Get IsCascadeDeleteNull of iDSO iPMain to bCascadeNull
17083>>>>>>>                            Move (not(bNull) or not(bCascadeNull)) to bUpDown
17084>>>>>>>                        End
17084>>>>>>>>
17084>>>>>>>                    Until bUpDown
17086>>>>>>>                    Get Private.Valid_Structure of iDSO bUpDown to iRVal
17087>>>>>>>                End
17087>>>>>>>>
17087>>>>>>>            Until iRval
17089>>>>>>>        End
17089>>>>>>>>
17089>>>>>>>        
17089>>>>>>>        Function_Return iRVal
17090>>>>>>>        
17090>>>>>>>    End_Function
17091>>>>>>>    
17091>>>>>>>    // Validate data-set updating connections against required connections
17091>>>>>>>    // Pass: Up_and_down=T if we should check Server and Client connections
17091>>>>>>>    //                  =F is we only check servers
17091>>>>>>>    // Ret: 0 if ok, Missing File# if not ok.
17091>>>>>>>    // Up_And_Down should be true when testing for cascade delete structures and
17091>>>>>>>    // false when testing for save / delete-no-cascade structures
17091>>>>>>>    Function Valid_Structure Integer Up_And_Down Returns Integer
17093>>>>>>>        Send Initialize_Visited Up_and_Down False // False=don't clear field marks
17094>>>>>>>        If (Up_And_Down) Begin
17096>>>>>>>            Send MarkDDOsForCascadeDelete
17097>>>>>>>        End
17097>>>>>>>>
17097>>>>>>>        Function_Return (Private.Valid_Structure(Self,Up_and_Down))
17098>>>>>>>    End_Function
17099>>>>>>>    
17099>>>>>>>    // mark all DDOs which are part of this deletes cascade delete tree
17099>>>>>>>    // mark this and all clients as Downward deletable. This includes
17099>>>>>>>    // cacscade delete and cascade set to null (not for cascade_delete_state=F)
17099>>>>>>>    Procedure MarkDDOsForCascadeDelete
17101>>>>>>>        Integer iMax  iCount
17101>>>>>>>        Boolean bDown
17101>>>>>>>        Handle hoDDO
17101>>>>>>>        Set DownDelete_State to True
17102>>>>>>>        Get Data_Set_Client_Count to iMax
17103>>>>>>>        For iCount from 0 to (iMax-1)
17109>>>>>>>>
17109>>>>>>>            Get Data_Set_Client iCount to hoDDO
17110>>>>>>>            Get DownDelete_State of hoDDO to bDown
17111>>>>>>>            If not bDown Begin // circular DDO test - never do this
17113>>>>>>>                Send MarkDDOsForCascadeDelete of hoDDO
17114>>>>>>>            End
17114>>>>>>>>
17114>>>>>>>        Loop
17115>>>>>>>>
17115>>>>>>>    End_Procedure
17116>>>>>>>    
17116>>>>>>>    
17116>>>>>>>    // This function will execute the validation message for each field within
17116>>>>>>>    // this object. If DoAllFG is true all items are validated. If false
17116>>>>>>>    // only unvisited items are checked.
17116>>>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
17116>>>>>>>    // do something with the possible cascade of errors
17116>>>>>>>    // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue
17116>>>>>>>    // the validation (the other fields will be bad). This works best if the
17116>>>>>>>    // findreq appears as one of the first fields in the file (which is almost
17116>>>>>>>    // always the case
17116>>>>>>>    Function Validate_Fields Integer DoAllFg Integer bNoStop Returns Integer
17118>>>>>>>        Integer iRetval
17118>>>>>>>        Integer iMax
17118>>>>>>>        Integer iCount
17118>>>>>>>        Integer iFile
17118>>>>>>>        Integer iErr
17118>>>>>>>        String  sVS
17118>>>>>>>        Get Visited_Fields to sVS
17119>>>>>>>        Get Field_Count to iMax
17120>>>>>>>        Get Main_File to iFile
17121>>>>>>>        For iCount from 1 to iMax
17127>>>>>>>>
17127>>>>>>>            If (DoAllFG or Mid(sVS, 1, iCount)=" ") Begin
17129>>>>>>>                Get Validate_Field iCount to iErr
17130>>>>>>>                If iErr Begin
17132>>>>>>>                    Move iErr to iRetVal
17133>>>>>>>                    // error occurred. If not no-stop or the error is
17133>>>>>>>                    // a findreq error - we are done.
17133>>>>>>>                    If (not(bNoStop) or iRetVal=DFERR_ENTER_VALID_REC_ID) ;                        Function_Return iRetVal
17136>>>>>>>                End
17136>>>>>>>>
17136>>>>>>>            End
17136>>>>>>>>
17136>>>>>>>        Loop
17137>>>>>>>>
17137>>>>>>>        Function_Return iRetval
17138>>>>>>>    End_Function
17139>>>>>>>    
17139>>>>>>>    // 17.0 - added support for null-parents. If null parents allowed, req lets it through
17139>>>>>>>    Function Validate_Required Integer iField Returns Integer
17141>>>>>>>        Boolean bNull bErr
17141>>>>>>>        
17141>>>>>>>        Move (trim(Field_Current_Value(Self,iField))='') to bErr
17142>>>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
17145>>>>>>>        Function_Return bErr
17146>>>>>>>    End_Function
17147>>>>>>>    
17147>>>>>>>    // return true if we should skip validation for this field. This can happen with Null allowed parents.
17147>>>>>>>    // if this is foreign, new and has no changes and is null allowed we will skip.
17147>>>>>>>    Function SkipValidate Integer iField Returns Boolean
17149>>>>>>>        Boolean bSkip bFieldChanged bEmpty
17149>>>>>>>        String sValue
17149>>>>>>>        
17149>>>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
17151>>>>>>>            // We must also check field_changed_state and only skip if this is not changed.
17151>>>>>>>            Get Field_Changed_State iField to bFieldChanged
17152>>>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
17152>>>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
17152>>>>>>>            If bFieldChanged Begin
17154>>>>>>>                Get Field_Current_Value iField to sValue
17155>>>>>>>                Get IsEmptyField iField sValue to bEmpty
17156>>>>>>>                If bEmpty Begin
17158>>>>>>>                    Move False to bFieldChanged
17159>>>>>>>                End
17159>>>>>>>>
17159>>>>>>>            End
17159>>>>>>>>
17159>>>>>>>            If (not(bFieldChanged)) Begin
17161>>>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
17161>>>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
17161>>>>>>>                Get IsNullParentOrAncestor to bSkip
17162>>>>>>>            End
17162>>>>>>>>
17162>>>>>>>        End
17162>>>>>>>>
17162>>>>>>>        Function_Return bSkip
17163>>>>>>>    End_Function
17164>>>>>>>    
17164>>>>>>>    
17164>>>>>>>    // This will tell us if this DD can be treated as either a null parent
17164>>>>>>>    // or an ancestor of a null parent. This should only be called for a DD
17164>>>>>>>    // that is a candidate for this meaning that it does not have a change.
17164>>>>>>>    // We will test if its child allows this parent to be null or if this
17164>>>>>>>    // is in the path of an allowed null parent. We assume that parents of
17164>>>>>>>    // null parents will also be null. This is used to test if validations are
17164>>>>>>>    // needed.
17164>>>>>>>    Function IsNullParentOrAncestor Returns Boolean
17166>>>>>>>        Handle[] hoDDs
17167>>>>>>>        Integer i iSize iMain
17167>>>>>>>        Boolean bNullAllowed
17167>>>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
17167>>>>>>>        // last item is the operation_origin.
17167>>>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs)
17168>>>>>>>        Move (SizeOfArray(hoDDs)) to iSize
17169>>>>>>>        If (iSize) Begin
17171>>>>>>>            // see if the immediate child allows this to be null.
17171>>>>>>>            Get Main_File to iMain
17172>>>>>>>            Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
17173>>>>>>>            
17173>>>>>>>            // if null not allowed, see if this is an ancestor to a null allowed
17173>>>>>>>            // parent where all DDs in this path are unchanged. For example:
17173>>>>>>>            // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
17173>>>>>>>            // want to test if G.DD needs validation
17173>>>>>>>            Move 1 to i
17174>>>>>>>            While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
17178>>>>>>>                Get Main_File of hoDDs[i] to iMain
17179>>>>>>>                Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
17180>>>>>>>                Increment i
17181>>>>>>>            Loop
17182>>>>>>>>
17182>>>>>>>            
17182>>>>>>>        End
17182>>>>>>>>
17182>>>>>>>        Function_Return bNullAllowed
17183>>>>>>>    End_Function
17184>>>>>>>    
17184>>>>>>>    
17184>>>>>>>    Function Validate_FindReq Integer iField Returns Integer
17186>>>>>>>        Integer bErr iOpts
17186>>>>>>>        // if no current record, we have not found the required record.
17186>>>>>>>        Move (not(HasRecord(Self))) to bErr
17187>>>>>>>        // We also need to check if the field is changed. If the field is changed and this
17187>>>>>>>        // is an autofind field, this indicates that an autofind was attempted and failed. We
17187>>>>>>>        // can't jut rely on current_record because a failed autofind restores the old current
17187>>>>>>>        // record. For this to work, DEOs must set the DD field's changed_state to true on
17187>>>>>>>        // no-put fields (dd_deomx.pkg was changed to do this).
17187>>>>>>>        If (not(bErr) and field_changed_state(Self,iField)) Begin
17189>>>>>>>            Get Field_Options iField to iOpts
17190>>>>>>>            Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;                ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
17191>>>>>>>        End
17191>>>>>>>>
17191>>>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
17194>>>>>>>        Function_Return bErr
17195>>>>>>>    End_Function
17196>>>>>>>    
17196>>>>>>>    // This function will be called to validate a field.
17196>>>>>>>    // mark field currently being validated
17196>>>>>>>    // Altered to Check DD options (required, findreq)
17196>>>>>>>    Function Validate_Field Integer iField Returns Integer
17198>>>>>>>        Integer iResult
17198>>>>>>>        Integer iMsg
17198>>>>>>>        Integer iObj
17198>>>>>>>        String  sValue
17198>>>>>>>        Integer iFile
17198>>>>>>>        Integer iOpts iMain
17198>>>>>>>        Boolean bSkipValidate
17198>>>>>>>        Handle[] hoDDs
17199>>>>>>>        
17199>>>>>>>        Set Current_Validate_Field to iField
17200>>>>>>>        
17200>>>>>>>        // test if we should skip validation on this field
17200>>>>>>>        Get SkipValidate iField to bSkipValidate
17201>>>>>>>        
17201>>>>>>>        If (not(bSkipValidate)) Begin
17203>>>>>>>            
17203>>>>>>>            Move (Record_Buffer(Self)) to iObj
17204>>>>>>>            Get Main_File to iFile
17205>>>>>>>            
17205>>>>>>>            // Check for DD option failures: required, find_required
17205>>>>>>>            // "File_field" gets regular and foreign fields as needed
17205>>>>>>>            //Get File_Field_Options iFile iField to iOpts
17205>>>>>>>            Get Field_Options iField to iOpts  // get reg options
17206>>>>>>>            // if this is not the DDO that started the validation, we will assume that
17206>>>>>>>            // this is foreign. Operation_origin is set in Request_Validate
17206>>>>>>>            // If foreign (as defined above) and we do not allow new saves when
17206>>>>>>>            // foreign, we will consider this to be foreign and add foreign options
17206>>>>>>>            If (Operation_Origin<>Self and ;                Allow_Foreign_New_Save_State(Self)=0)  ;                Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
17209>>>>>>>            
17209>>>>>>>            
17209>>>>>>>            // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
17209>>>>>>>            // the calling function knows that a findreq failed. Always do this validation first
17209>>>>>>>            If (iOpts iand DD_FINDREQ) ;                Get Validate_FindReq  iField to iResult
17212>>>>>>>            If iResult Begin
17214>>>>>>>                Send AddDDHasFindReqError
17215>>>>>>>                Move DFERR_ENTER_VALID_REC_ID to iResult
17216>>>>>>>            End
17216>>>>>>>>
17216>>>>>>>            Else Begin
17217>>>>>>>                
17217>>>>>>>                If (iOpts iand DD_REQUIRED) ;                    Get Validate_Required iField to iResult
17220>>>>>>>                
17220>>>>>>>                If (iResult=0) Begin
17222>>>>>>>                    // First execute the user defined validation message
17222>>>>>>>                    Get Item_Validate_MSG of iObj iField to iMsg
17223>>>>>>>                    If iMsg Begin
17225>>>>>>>                        Get Field_Current_Value iField to sValue
17226>>>>>>>                        Get iMsg iField sValue to iResult
17227>>>>>>>                    End
17227>>>>>>>>
17227>>>>>>>                End
17227>>>>>>>>
17227>>>>>>>                
17227>>>>>>>                // Check for keys
17227>>>>>>>                If (iResult=0 and Key_Field_State(Self, iField)) ;                    Get Validate_Key_Field iField to iResult
17230>>>>>>>                
17230>>>>>>>                // Do extended validations
17230>>>>>>>                If (iResult=0) ;                    Get Validate_Field of (Field_Attributes(Self)) iField to iResult
17233>>>>>>>            End
17233>>>>>>>>
17233>>>>>>>        End
17233>>>>>>>>
17233>>>>>>>        
17233>>>>>>>        Set Current_Validate_Field to 0
17234>>>>>>>        // Mark this field being validated
17234>>>>>>>        Get Visited_Fields to sValue
17235>>>>>>>        Set Visited_Fields to (Overstrike("X", sValue, iField))
17236>>>>>>>        
17236>>>>>>>        Function_Return iResult
17237>>>>>>>        
17237>>>>>>>    End_Function
17238>>>>>>>    
17238>>>>>>>    
17238>>>>>>>    // This function will be called to validate a field.
17238>>>>>>>    Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
17240>>>>>>>        Integer iDSO
17240>>>>>>>        Integer iResult
17240>>>>>>>        Integer hOldOrigin
17240>>>>>>>        Get Data_Set iFile to iDSO
17241>>>>>>>        If not iDSO ;            Function_Return 0
17244>>>>>>>        
17244>>>>>>>        // This function is only called by the DEOs.
17244>>>>>>>        // It is possible for validate_item when called as part of
17244>>>>>>>        // request_validate to get called more than once
17244>>>>>>>        // when a field is foreign (it is attached to both its DDO and the
17244>>>>>>>        // child-main ddo). This makes sure the validation is only called once.
17244>>>>>>>        // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
17244>>>>>>>        // a mode just for request_validate).
17244>>>>>>>        If (Operation_Mode=MODE_VALIDATING and ;         // if from request_validate            Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked            Function_Return 0                         // skip it
17247>>>>>>>        
17247>>>>>>>        Move Operation_origin to hOldOrigin
17248>>>>>>>        
17248>>>>>>>        // if from request_validate operation_origin will be set and should not
17248>>>>>>>        // be reset here.
17248>>>>>>>        If (OPERATION_ORIGIN=0) Begin
17250>>>>>>>            Move Self to Operation_Origin
17251>>>>>>>        End
17251>>>>>>>>
17251>>>>>>>        
17251>>>>>>>        Get Validate_Field of iDSO iField to iResult
17252>>>>>>>        Move hOldOrigin to Operation_Origin
17253>>>>>>>        Function_Return iResult
17254>>>>>>>    End_Function
17255>>>>>>>    
17255>>>>>>>    // This function will be called to check if a key has been changed.
17255>>>>>>>    Function Validate_Key_Field Integer iField Returns Integer
17257>>>>>>>        String  sOld_Value
17257>>>>>>>        String  sNew_Value
17257>>>>>>>        String  sKeys
17257>>>>>>>        Integer iState
17257>>>>>>>        Boolean bMultiKeys
17257>>>>>>>        Get Protect_Key_State to iState
17258>>>>>>>        If iState Begin
17260>>>>>>>            Get Key_Value to sNew_Value
17261>>>>>>>            // Only check existing records.
17261>>>>>>>            If (HasRecord(Self)) Begin
17263>>>>>>>                Get Existing_Key_Value to sOld_Value
17264>>>>>>>                If (sNew_Value <> sOld_Value) Begin
17266>>>>>>>                    // we have an error. If there is only one key field we know
17266>>>>>>>                    // where the field is and we can report that field. If we have
17266>>>>>>>                    // multiple key fields, we don't really know where the offending key change
17266>>>>>>>                    // is, so we will not report a field.
17266>>>>>>>                    Get Key_Fields to sKeys
17267>>>>>>>                    Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
17268>>>>>>>                    Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
17269>>>>>>>                    Function_Return 1
17270>>>>>>>                End
17270>>>>>>>>
17270>>>>>>>            End
17270>>>>>>>>
17270>>>>>>>        End
17270>>>>>>>>
17270>>>>>>>    End_Function
17271>>>>>>>    
17271>>>>>>>    
17271>>>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
17271>>>>>>>    // is handled by the DD that originated the request_validate. Very private
17271>>>>>>>    Function DDHasFindReqError Returns Boolean
17273>>>>>>>        Handle[] DDsWithFindReqErrors
17274>>>>>>>        Integer iIndex
17274>>>>>>>        If (OPERATION_ORIGIN) Begin
17276>>>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
17277>>>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
17278>>>>>>>            Function_Return (iIndex<>-1)
17279>>>>>>>        End
17279>>>>>>>>
17279>>>>>>>    End_Function
17280>>>>>>>    
17280>>>>>>>    // During a request_validate a find_request error has occurred. Add this DD
17280>>>>>>>    // to list of DDs that have this error. This is handled by the DD that
17280>>>>>>>    // originated the request_validate.  Very private
17280>>>>>>>    Procedure AddDDHasFindReqError
17282>>>>>>>        Handle[] DDsWithFindReqErrors
17283>>>>>>>        If (OPERATION_ORIGIN) Begin
17285>>>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
17286>>>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
17287>>>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
17288>>>>>>>        End
17288>>>>>>>>
17288>>>>>>>    End_Procedure
17289>>>>>>>    
17289>>>>>>>    // This function will execute the validation message for each field of the
17289>>>>>>>    // data set and all of its parents in parent first order.
17289>>>>>>>    // Pass: DoALLFg bNoStop
17289>>>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
17289>>>>>>>    // do something with the possible cascade of errors
17289>>>>>>>    Function Validate_Data_Sets Integer DoAllFg Integer bNoStop Returns Integer
17291>>>>>>>        Integer iDSO
17291>>>>>>>        Integer iRetval
17291>>>>>>>        Integer iCount
17291>>>>>>>        Integer iMax
17291>>>>>>>        Integer bErr
17291>>>>>>>        Boolean bDDHasFindReqError
17291>>>>>>>        // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
17291>>>>>>>        // Validate if not foreign, or foreign new saves allowed, or
17291>>>>>>>        // foreign validation is supported (it normally is)
17291>>>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self) or ;            Validate_Foreign_File_State(Self)) Begin
17293>>>>>>>            
17293>>>>>>>            If (bNoStop) Begin
17295>>>>>>>                // if do all, it is possible that this DD as a find-req error. If so there is no
17295>>>>>>>                // need to look for more errors in this DD or its parents. This makes the do all checking
17295>>>>>>>                // a little more intelligent and doesn't return a bunch of errors when it is not needed
17295>>>>>>>                Get DDHasFindReqError to bDDHasFindReqError
17296>>>>>>>            End
17296>>>>>>>>
17296>>>>>>>            
17296>>>>>>>            If (not(bDDHasFindReqError)) Begin
17298>>>>>>>                Get Data_Set_Server_Count to iMax
17299>>>>>>>                Decrement iMax
17300>>>>>>>                For iCount from 0 to iMax
17306>>>>>>>>
17306>>>>>>>                    Get Data_Set_Server iCount to iDSO
17307>>>>>>>                    If not (Visited_state(iDSO)) Begin
17309>>>>>>>                        Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
17310>>>>>>>                        If bErr Begin
17312>>>>>>>                            Move bErr to iRetVal
17313>>>>>>>                            If bNoStop ;                                Move 0 to bErr
17316>>>>>>>                        End
17316>>>>>>>>
17316>>>>>>>                    End
17316>>>>>>>>
17316>>>>>>>                Until bErr
17318>>>>>>>                If not bErr Begin
17320>>>>>>>                    Get Validate_Fields DoAllFg bNoStop to bErr
17321>>>>>>>                    If bErr ;                        Move bErr to iRetVal
17324>>>>>>>                End
17324>>>>>>>>
17324>>>>>>>            End
17324>>>>>>>>
17324>>>>>>>        End
17324>>>>>>>>
17324>>>>>>>        Set Visited_State to True
17325>>>>>>>        Function_Return iRetval
17326>>>>>>>    End_Function
17327>>>>>>>    
17327>>>>>>>    // This tests the DDO and all "up" DDOs to see if a switched parent / commit test even needs to be
17327>>>>>>>    // tested. This is called by the top ValidateSwitchedCommittedParents to see if a switch parent test
17327>>>>>>>    // even needs to be applied before it has to refinds records.
17327>>>>>>>    // Return true is there is nothing to test (i.e., the shortcut worked).
17327>>>>>>>    Function IsCommittedRecursiveUpParentChangeAllowed Returns Boolean
17329>>>>>>>        Boolean bAllowed bCommitted bVisited bHasRecord
17329>>>>>>>        Integer iServers iSrvr iParent
17329>>>>>>>        Handle hoSrvr
17329>>>>>>>        
17329>>>>>>>        
17329>>>>>>>        // optimization. We only test committed parents if one parent does not allow changing committed records.
17329>>>>>>>        // This avoids extra finds and relates when not needed
17329>>>>>>>        Set Visited_State to True
17330>>>>>>>        Get Data_Set_Server_Count to iServers
17331>>>>>>>        Get IsCommitted to bCommitted
17332>>>>>>>        Move 0 to iSrvr
17333>>>>>>>        Move True to bAllowed
17334>>>>>>>        While (iSrvr<iServers and bAllowed)
17338>>>>>>>            Get Data_Set_Server iSrvr to hoSrvr
17339>>>>>>>            Get Main_File of hoSrvr to iParent
17340>>>>>>>            // if committed and parent change not allowed, we are done
17340>>>>>>>            If (bCommitted) Begin
17342>>>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
17343>>>>>>>            End
17343>>>>>>>>
17343>>>>>>>            // if still allowed, check all parents
17343>>>>>>>            If (bAllowed) Begin
17345>>>>>>>                Get Visited_State of hoSrvr to bVisited
17346>>>>>>>                If not bVisited Begin
17348>>>>>>>                    Get IsCommittedRecursiveUpParentChangeAllowed of hoSrvr to bAllowed
17349>>>>>>>                End
17349>>>>>>>>
17349>>>>>>>            End
17349>>>>>>>>
17349>>>>>>>            Increment iSrvr
17350>>>>>>>        Loop
17351>>>>>>>>
17351>>>>>>>        Function_Return bAllowed
17352>>>>>>>    End_Function
17353>>>>>>>    
17353>>>>>>>    
17353>>>>>>>    // special validate-save check for changed committed parent. If the record is committed
17353>>>>>>>    // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
17353>>>>>>>    // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
17353>>>>>>>    // When called from the we must refind the original record and all original parents. This way we can compare these parent
17353>>>>>>>    // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
17353>>>>>>>    // we only even do this if this is committed and there is a chance that there are changed parents
17353>>>>>>>    
17353>>>>>>>    Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
17355>>>>>>>        Integer iServers iSrvr iMain iParent iPMain
17355>>>>>>>        Handle hoSrvr
17355>>>>>>>        RowID riCrnt riParent riPCrnt
17355>>>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged bVisited
17355>>>>>>>        Boolean bHasRecord bPHasRecord bFound
17355>>>>>>>        
17355>>>>>>>        
17355>>>>>>>        // Shortcut optimization. This tests for any committed DDO with a parent that doesn't allow a switch
17355>>>>>>>        // return true if there is any reason to actually test any DDO up the tree for a parent change
17355>>>>>>>        If bTop Begin
17357>>>>>>>            // init visited nodes, these will be tested and set in IsCommittedRecursiveUpParentChangeAllowed
17357>>>>>>>            Send Initialize_Visited False False //false=up only, true=clear fields
17358>>>>>>>            Get IsCommittedRecursiveUpParentChangeAllowed to bAllowed
17359>>>>>>>            If bAllowed Begin
17361>>>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
17362>>>>>>>            End
17362>>>>>>>>
17362>>>>>>>        End
17362>>>>>>>>
17362>>>>>>>        
17362>>>>>>>        Get Main_File to iMain
17363>>>>>>>        Get CurrentRowId to riCrnt
17364>>>>>>>        Get Data_Set_Server_Count to iServers
17365>>>>>>>        Get HasRecord to bHasRecord
17366>>>>>>>        
17366>>>>>>>        If (bHasRecord and (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) ) Begin
17368>>>>>>>            // this refinds the main record and, most importantly, relates all original parents on up
17368>>>>>>>            // We now have the original parents which we can test to see if they are changed.
17368>>>>>>>            Get ReadByRowIdEx iMain riCrnt to bFound
17369>>>>>>>            If not bFound Begin
17371>>>>>>>                Error DFERR_CANT_REFIND_RECORD
17372>>>>>>>>
17372>>>>>>>                Function_Return True
17373>>>>>>>            End
17373>>>>>>>>
17373>>>>>>>        End
17373>>>>>>>>
17373>>>>>>>        
17373>>>>>>>        If (bTop) Begin
17375>>>>>>>            // If at start, init visited nodes, these will be tested and set during recursive calls to this function
17375>>>>>>>            Send Initialize_Visited False False // false=up only, true=clear fields
17376>>>>>>>        End
17376>>>>>>>>
17376>>>>>>>        
17376>>>>>>>        Set Visited_State to True
17377>>>>>>>        Get IsCommitted to bCommitted
17378>>>>>>>        If bCommitted Begin
17380>>>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
17380>>>>>>>            // First see any any of the parents are changed.
17380>>>>>>>            Get Parent_Changed_State to bChanged
17381>>>>>>>            If bChanged Begin
17383>>>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
17383>>>>>>>                Move 0 to iSrvr
17384>>>>>>>                While (iSrvr<iServers and not(bErr))
17388>>>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
17389>>>>>>>                    Get Main_File of hoSrvr to iParent
17390>>>>>>>                    Get CurrentRowId of hoSrvr to riParent
17391>>>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
17392>>>>>>>                    If bParentChanged Begin
17394>>>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
17395>>>>>>>                        If not bAllowed Begin
17397>>>>>>>                            Move True to bErr
17398>>>>>>>                            If bErr Begin
17400>>>>>>>                                Send Data_Set_Error of hoSrvr -1 0 DD_CANNOT_SWITCH_PARENT
17401>>>>>>>                            End
17401>>>>>>>>
17401>>>>>>>                        End
17401>>>>>>>>
17401>>>>>>>                    End
17401>>>>>>>>
17401>>>>>>>                    Increment iSrvr
17402>>>>>>>                Loop
17403>>>>>>>>
17403>>>>>>>            End
17403>>>>>>>>
17403>>>>>>>        End
17403>>>>>>>>
17403>>>>>>>        
17403>>>>>>>        // no error in immediate we must continue this check up the parent tree.
17403>>>>>>>        Move 0 to iSrvr
17404>>>>>>>        While (iSrvr<iServers and not(bErr))
17408>>>>>>>            Get Data_Set_Server iSrvr to hoSrvr
17409>>>>>>>            Get Visited_State of hoSrvr to bVisited
17410>>>>>>>            If (not(bVisited)) Begin
17412>>>>>>>                
17412>>>>>>>                // if new record, we need to refind parent records from here since you cannot
17412>>>>>>>                // have done a find/relate on a new record.
17412>>>>>>>                If (not(bHasRecord)) Begin
17414>>>>>>>                    Get HasRecord of hoSrvr to bPHasRecord
17415>>>>>>>                    If (bPHasRecord) Begin
17417>>>>>>>                        Get Main_File of hoSrvr to iPMain
17418>>>>>>>                        Get CurrentRowId of hoSrvr to riPCrnt
17419>>>>>>>                        If (not(IsNullRowID(riPCrnt))) Begin
17421>>>>>>>                            Get ReadByRowIdEx of hoSrvr iPMain riPCrnt to bFound
17422>>>>>>>                            If not bFound Begin
17424>>>>>>>                                Error DFERR_CANT_REFIND_RECORD
17425>>>>>>>>
17425>>>>>>>                                Function_Return True
17426>>>>>>>                            End
17426>>>>>>>>
17426>>>>>>>                        End
17426>>>>>>>>
17426>>>>>>>                    End
17426>>>>>>>>
17426>>>>>>>                End
17426>>>>>>>>
17426>>>>>>>                
17426>>>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
17427>>>>>>>            End
17427>>>>>>>>
17427>>>>>>>            Increment iSrvr
17428>>>>>>>        Loop
17429>>>>>>>>
17429>>>>>>>        
17429>>>>>>>        If bTop Begin // if back to the top, make sure our buffers are correct.
17431>>>>>>>            Send Refind_Records
17432>>>>>>>        End
17432>>>>>>>>
17432>>>>>>>        
17432>>>>>>>        Function_Return bErr
17433>>>>>>>    End_Function
17434>>>>>>>    
17434>>>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
17436>>>>>>>        
17436>>>>>>>        Handle hoBuff hoDSO
17436>>>>>>>        Boolean bCommit bIsFind bVisited bIsForeign
17436>>>>>>>        Integer iMax iCount iItems iOpts iChanges
17436>>>>>>>        
17436>>>>>>>        
17436>>>>>>>        Move record_buffer to hoBuff
17437>>>>>>>        Move (OPERATION_MODE<>MODE_SAVING) to bIsFind
17438>>>>>>>        
17438>>>>>>>        // first recurse to all parent ddos
17438>>>>>>>        Get Data_Set_Server_Count to iMax
17439>>>>>>>        Decrement iMax
17440>>>>>>>        For iCount from 0 to iMax
17446>>>>>>>>
17446>>>>>>>            Get Data_Set_Server iCount to hoDSO
17447>>>>>>>            Get Visited_State of hoDSO to bVisited
17448>>>>>>>            If not (bVisited) Begin
17450>>>>>>>                Send Entry_Update_Data_Sets to hoDSO iFile iAll
17451>>>>>>>            End
17451>>>>>>>>
17451>>>>>>>        Loop
17452>>>>>>>>
17452>>>>>>>        
17452>>>>>>>        // if find, we only do this if the main file is the same as the find file
17452>>>>>>>        If (not(bIsFind) or iFile=Main_File(Self)) Begin
17454>>>>>>>            If (not(bIsFind)) Begin
17456>>>>>>>                // if a save, we care if it is committed.
17456>>>>>>>                Get IsCommitted to bCommit
17457>>>>>>>            End
17457>>>>>>>>
17457>>>>>>>            
17457>>>>>>>            // pass if Find (True) or save (False). We only care about commit on saves
17457>>>>>>>            // The setting of bIsForeign is an approximation. Foreign is really a DEO and and not
17457>>>>>>>            // a DD concept - in fact, at this point we don't really know. For example, a save in a header/dtl
17457>>>>>>>            // detail DEO (ordrdtl grid)has header DEOs that are not really foreign. This test errs on the side
17457>>>>>>>            // of assuming it's foreign. This would cause problems with incorrect parent NoPuts except we also
17457>>>>>>>            // set a flag, Field_NoPutValueChangedByDeo, when a field is changed via a NoPut DEO. The DD will still update
17457>>>>>>>            // foreign NoPuts unless this field flag is set.
17457>>>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
17458>>>>>>>            Send Entry_Update of hoBuff bIsFind (If(bCommit,1,0) + If(bIsForeign,2,0))
17459>>>>>>>            
17459>>>>>>>            // also move data from extended dd fields to buffer
17459>>>>>>>            Send ExtendedFieldsUpdate (not(bIsFind))
17460>>>>>>>        End
17460>>>>>>>>
17460>>>>>>>        Set Visited_State to True
17461>>>>>>>        
17461>>>>>>>    End_Procedure
17462>>>>>>>    
17462>>>>>>>    // is this field NoPut based passed Commit and Foreign flags.
17462>>>>>>>    Function FieldNoPut Integer iField Boolean bIsCommited Boolean bIsForeign Returns Boolean
17464>>>>>>>        Boolean bNoPut
17464>>>>>>>        // this uses runtime logic - the same use for moving DD Buffer to Field Buffer
17464>>>>>>>        Get IsFieldDDNoPut of Record_Buffer iField (If(bIsCommited,1,0) + If(bIsForeign,2,0)) to bNoPut
17465>>>>>>>        Function_Return bNoPut
17466>>>>>>>    End_Function
17467>>>>>>>    
17467>>>>>>>    
17467>>>>>>>    // Check that Server data-sets exist for all required server file numbers
17467>>>>>>>    Function Valid_Servers Returns Integer
17469>>>>>>>        Integer iRval
17469>>>>>>>        Integer iCount
17469>>>>>>>        Integer iMax
17469>>>>>>>        Integer iDSO
17469>>>>>>>        Integer iPos
17469>>>>>>>        Integer iFile
17469>>>>>>>        String  sFiles
17469>>>>>>>        
17469>>>>>>>        // First assemble a string of all server file#s in ','##',' format
17469>>>>>>>        Move ',' to sFiles
17470>>>>>>>        Get Data_Set_Server_Count to iMax
17471>>>>>>>        Decrement iMax
17472>>>>>>>        For iCount from 0 to iMax
17478>>>>>>>>
17478>>>>>>>            Get Data_Set_Server iCount to iDSO
17479>>>>>>>            Move ( sFiles + String(Main_file(iDSO)) + ",") to sFiles
17480>>>>>>>        Loop
17481>>>>>>>>
17481>>>>>>>        
17481>>>>>>>        // Make sure each required File exists
17481>>>>>>>        Get Server_File_Count to iMax
17482>>>>>>>        Decrement iMax
17483>>>>>>>        For iCount from 0 to iMax
17489>>>>>>>>
17489>>>>>>>            Get Server_File iCount to iFile
17490>>>>>>>            Move (Pos ( ','+String(iFile)+',' , sFiles)) to iPos
17491>>>>>>>            If (iPos = 0) ;                Move iFile to iRVal
17494>>>>>>>        Until iRval
17496>>>>>>>        Function_Return iRVal
17497>>>>>>>    End_Function
17498>>>>>>>    
17498>>>>>>>    
17498>>>>>>>    // Check that Client data-sets exist for all required Client file numbers
17498>>>>>>>    Function Valid_Clients Returns Integer
17500>>>>>>>        Integer iRval
17500>>>>>>>        Integer iCount
17500>>>>>>>        Integer iMax
17500>>>>>>>        Integer iDSO
17500>>>>>>>        Integer iPos
17500>>>>>>>        Integer iFile
17500>>>>>>>        String  sFiles
17500>>>>>>>        
17500>>>>>>>        // First assemble a string of all Client file#s in ','##',' format
17500>>>>>>>        Move ',' to sFiles
17501>>>>>>>        Get Data_Set_Client_Count to iMax
17502>>>>>>>        Decrement iMax
17503>>>>>>>        For iCount from 0 to iMax
17509>>>>>>>>
17509>>>>>>>            Get Data_Set_Client iCount to iDSO
17510>>>>>>>            Move ( sFiles + String(Main_file(iDSO))+",") to sFiles
17511>>>>>>>        Loop
17512>>>>>>>>
17512>>>>>>>        
17512>>>>>>>        // Make sure each required File exists
17512>>>>>>>        Get Client_File_Count to iMax
17513>>>>>>>        Decrement iMax
17514>>>>>>>        For iCount from 0 to iMax
17520>>>>>>>>
17520>>>>>>>            Get Client_File iCount to iFile
17521>>>>>>>            Move (Pos( ','+String(iFile)+',', sFiles)) to iPos
17522>>>>>>>            If (iPos = 0) ;                Move iFile to iRVal
17525>>>>>>>        Until iRval
17527>>>>>>>        Function_Return iRVal
17528>>>>>>>    End_Function
17529>>>>>>>    
17529>>>>>>>    
17529>>>>>>>    // Validates save updating connections. If error returns file# that is
17529>>>>>>>    // expected and missing. If no error Set Validated_Save_connectio_State
17529>>>>>>>    // indicating that the connection validation has occurred and is ok
17529>>>>>>>    Function Validate_Save_Structure Integer ForceFg Returns Integer
17531>>>>>>>        Integer iRval
17531>>>>>>>        Integer iMode
17531>>>>>>>        If not ForceFg Begin
17533>>>>>>>            Get Validate_Save_Structure_Mode to iMode
17534>>>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and ;                Save_Structure_Validated_state(Self)=0 ) ) ;                to ForceFg
17535>>>>>>>        End
17535>>>>>>>>
17535>>>>>>>        If ForceFg Begin
17537>>>>>>>            Get Valid_Structure False to iRval
17538>>>>>>>            If (iRVal = 0) ;                Set Save_Structure_Validated_State to True
17541>>>>>>>        End
17541>>>>>>>>
17541>>>>>>>        Function_Return iRVal
17542>>>>>>>    End_Function
17543>>>>>>>    
17543>>>>>>>    // Validates Delete Structure. If cascade_state is true this must check
17543>>>>>>>    // up and down the tree. If no cascade_state just check up the tree.  If
17543>>>>>>>    // Ok, set Validated_Delete_no_Cascade_Connection_State and and or
17543>>>>>>>    // Validated_Delete_Cascade_Connection_State
17543>>>>>>>    // Pass: ForceFg - if TRUE force the validation.
17543>>>>>>>    Function Validate_Delete_Structure Integer ForceFg Returns Integer
17545>>>>>>>        Integer iCascade
17545>>>>>>>        Integer iMode
17545>>>>>>>        Integer iSt
17545>>>>>>>        Integer iRval
17545>>>>>>>        Get Cascade_delete_State to iCascade
17546>>>>>>>        If not ForceFg Begin
17548>>>>>>>            Get Validate_Delete_Structure_Mode to iMode
17549>>>>>>>            If (iMode=DD_VALIDATE_STRUCTURE_ONCE and iCascade );                Get Cascade_Delete_Structure_Validated_state to iSt
17552>>>>>>>            Else ;                Get No_Cascade_Delete_Structure_Validated_state to iSt
17554>>>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and iSt=0) ) to ForceFg
17555>>>>>>>        End
17555>>>>>>>>
17555>>>>>>>        
17555>>>>>>>        If ForceFg Begin
17557>>>>>>>            Get Valid_Structure iCascade to iRval
17558>>>>>>>            If (iRval = 0) Begin
17560>>>>>>>                Set No_Cascade_Delete_Structure_Validated_State to True
17561>>>>>>>                If iCascade ;                    Set Cascade_Delete_Structure_Validated_State to True
17564>>>>>>>            End
17564>>>>>>>>
17564>>>>>>>        End
17564>>>>>>>>
17564>>>>>>>        Function_Return iRval
17565>>>>>>>    End_Function
17566>>>>>>>    
17566>>>>>>>    
17566>>>>>>>    // This procedure will be called whenever the Data_Set wants its DEOs to
17566>>>>>>>    // write their values to the record buffer. The value of OPERATION_MODE
17566>>>>>>>    // determines if this is for finding an record or before saving a record.
17566>>>>>>>    // We use this event to tell our Record_Buffer to update the
17566>>>>>>>    // global record buffer.
17566>>>>>>>    // Modified to visit all server DSOs
17566>>>>>>>    // Note that this is only sent to the DSO starting the operation.
17566>>>>>>>    // We must manually send this to all server data-sets ourselves
17566>>>>>>>    // Note that during a DSO save this will get passed iFile=0 and iAll=3
17566>>>>>>>    // Changed to Support EntryUpdateLocalState (private)
17566>>>>>>>    // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
17566>>>>>>>    // for finds now through the DD Buffer (saves always did).
17566>>>>>>>    Procedure Request_Entry_Update Integer iFile Integer iAll
17568>>>>>>>        If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
17570>>>>>>>            If (OPERATION_MODE=MODE_WAITING) Begin
17572>>>>>>>                // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
17572>>>>>>>                // set to true. In such a case make this a finding. I am not this is actually needed
17572>>>>>>>                Send Update_Focus_Field_For_Operation MODE_FINDING
17573>>>>>>>            End
17573>>>>>>>>
17573>>>>>>>            Else Begin
17574>>>>>>>                // if here we already have an operation_mode so there is no need to do anything special
17574>>>>>>>                Send Update_Focus_Field // Make sure buffer has latest focus item changes
17575>>>>>>>            End
17575>>>>>>>>
17575>>>>>>>            Send Initialize_Visited False False // Clear up, do not clear fields
17576>>>>>>>            Send Entry_Update_Data_Sets iFile iAll
17577>>>>>>>        End
17577>>>>>>>>
17577>>>>>>>        Forward Send Request_Entry_Update iFile iAll
17579>>>>>>>    End_Procedure
17580>>>>>>>    
17580>>>>>>>    
17580>>>>>>>    
17580>>>>>>>    // Forces the focus field to get update its value with the data-set.
17580>>>>>>>    // This insures that the DSO and DEO contain the same values.
17580>>>>>>>    Procedure Update_Focus_Field
17582>>>>>>>        Integer iFocObj
17582>>>>>>>        Get Focus of desktop to iFocObj
17583>>>>>>>        If (Extended_DEO_State(iFocObj)) ;            Send Update_Focus_Field to iFocObj
17586>>>>>>>    End_Procedure
17587>>>>>>>    
17587>>>>>>>    // very internal. Used to set Operation_mode and Operation_origin before the
17587>>>>>>>    // update. A developer can use this in the DEO to know what state the update is in.
17587>>>>>>>    // This was created because a DEO value change will trigger an OnChange event and you
17587>>>>>>>    // can look at this and know that this is part of a DD operation.
17587>>>>>>>    // This is *only* called by the DD operations in this class and the change is made for as
17587>>>>>>>    // small of a period as possible.
17587>>>>>>>    Procedure Update_Focus_Field_For_Operation Integer iOperationMode
17589>>>>>>>        Integer iOldMode iOldOrigin
17589>>>>>>>        
17589>>>>>>>        Move OPERATION_MODE to iOldMode
17590>>>>>>>        Move OPERATION_ORIGIN to iOldOrigin
17591>>>>>>>        Move iOperationMode to OPERATION_MODE
17592>>>>>>>        Move Self to OPERATION_ORIGIN
17593>>>>>>>        Send Update_Focus_Field
17594>>>>>>>        Move iOldMode to OPERATION_MODE
17595>>>>>>>        Move iOldOrigin to OPERATION_ORIGIN
17596>>>>>>>    End_Procedure
17597>>>>>>>    
17597>>>>>>>    
17597>>>>>>>    // Augment to validate all field values that do not get
17597>>>>>>>    // validated as part of the item validation process. The advantage
17597>>>>>>>    // of item validation (over only field validation) is that an error
17597>>>>>>>    // returns you to the offending item.
17597>>>>>>>    Function Request_Validate Returns Integer
17599>>>>>>>        Integer iRetval iOldOrigin iOldMode iRetVal2
17599>>>>>>>        Handle[] DDsWithFindReqErrors
17600>>>>>>>        
17600>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
17602>>>>>>>            Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
17603>>>>>>>        End
17603>>>>>>>>
17603>>>>>>>        Move Operation_Origin to iOldOrigin
17604>>>>>>>        Move Self to Operation_Origin
17605>>>>>>>        Move Operation_Mode to iOldMode
17606>>>>>>>        // clear all find req DD markers at the origin of the validate request. When request validates occur
17606>>>>>>>        // they will get added to this array and can be tested to see of such an error has occurred.
17606>>>>>>>        Set pDDsWithFindReqErrors to DDsWithFindReqErrors
17607>>>>>>>        // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
17607>>>>>>>        // We do this because:
17607>>>>>>>        //   1) because it is useful (more detail never hurts) and
17607>>>>>>>        //   2) we will allow set_field_current_value to update when mode_validation is set
17607>>>>>>>        Move MODE_VALIDATING to Operation_Mode
17608>>>>>>>        Send Initialize_Visited False True //false=up only, true=clear fields
17609>>>>>>>        Forward Get Request_Validate to iRetval // normal deo validate
17611>>>>>>>        // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
17611>>>>>>>        If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
17613>>>>>>>            Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
17614>>>>>>>            Move (iRetval or iRetVal2) to iRetval
17615>>>>>>>        End
17615>>>>>>>>
17615>>>>>>>        
17615>>>>>>>        If (iRetval=0) Begin
17617>>>>>>>            Get ValidateSwitchedCommittedParents True to iRetval
17618>>>>>>>        End
17618>>>>>>>>
17618>>>>>>>        
17618>>>>>>>        Move iOldMode   to Operation_Mode
17619>>>>>>>        Move iOldOrigin to Operation_Origin
17620>>>>>>>        Function_Return iRetval
17621>>>>>>>    End_Function
17622>>>>>>>    
17622>>>>>>>    Function Request_Validate_All Returns Integer
17624>>>>>>>        Integer bOld iRetVal
17624>>>>>>>        Get Validate_All_Fields_State to bOld
17625>>>>>>>        Set Validate_All_Fields_State to True
17626>>>>>>>        Get request_validate to iretVal
17627>>>>>>>        Set Validate_All_Fields_State to bOld
17628>>>>>>>        Function_Return iRetval
17629>>>>>>>    End_Function
17630>>>>>>>    
17630>>>>>>>    
17630>>>>>>>    
17630>>>>>>>    // Like Item_find except entry-update is forced through the DD, not DEO
17630>>>>>>>    Procedure File_Field_Find Integer iFindMode Integer iFile Integer iField ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
17632>>>>>>>        Integer bOld
17632>>>>>>>        Get EntryUpdateLocalState to bOld
17633>>>>>>>        Set EntryUpdateLocalState to True
17634>>>>>>>        Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
17635>>>>>>>        Set EntryUpdateLocalState to bOld
17636>>>>>>>    End_Procedure
17637>>>>>>>    
17637>>>>>>>    // Autofind for requestd file, field and mode.
17637>>>>>>>    //    If mode not passed, EQ is assummed
17637>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iFindMode
17639>>>>>>>        Integer eMode
17639>>>>>>>        If iFile  Begin
17641>>>>>>>            // if no 3rd argument, default to autofind
17641>>>>>>>            Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
17642>>>>>>>            Send File_Field_Find eMode iFile iField True False False
17643>>>>>>>        End
17643>>>>>>>>
17643>>>>>>>    End_Procedure
17644>>>>>>>    
17644>>>>>>>    // Autofind in default mode (does not set changed states). Can be used
17644>>>>>>>    // within Clear and Clear_all to autofind parents. Parent values can be
17644>>>>>>>    // maintained using retainAll option
17644>>>>>>>    Procedure File_Field_Default_AutoFind Integer iFile Integer iField
17646>>>>>>>        Integer iOldState
17646>>>>>>>        Handle  hoDD
17646>>>>>>>        Get Data_set iFile to hoDD
17647>>>>>>>        If hoDD Begin
17649>>>>>>>            Get Change_disabled_State of hoDD to iOldState
17650>>>>>>>            Set Change_disabled_State of hoDD to True
17651>>>>>>>            Send File_Field_AutoFind  of hoDD iFile iField EQ
17652>>>>>>>            Set Change_disabled_State of hoDD to iOldState
17653>>>>>>>            Set changed_state to False
17654>>>>>>>        End
17654>>>>>>>>
17654>>>>>>>    End_Procedure
17655>>>>>>>    
17655>>>>>>>    // File_Index_find
17655>>>>>>>    // Like item_find except you pass the index you want to find with and
17655>>>>>>>    // ent-update occurs through DDO buffers not deo buffers.
17655>>>>>>>    // This is currently private and is only used by web-applications
17655>>>>>>>    Procedure File_Index_Find Integer iFindMode Integer iFile Integer iIndex ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
17657>>>>>>>        Integer bOld
17657>>>>>>>        RowID riRec
17657>>>>>>>        Integer wasChanged hDD iOldStat
17657>>>>>>>        Boolean bOk
17657>>>>>>>        
17657>>>>>>>        Get Data_Set iFile to hDD
17658>>>>>>>        If (hDD=0) Begin
17660>>>>>>>            Error DFERR_PROGRAM C_$CannotFindDD
17661>>>>>>>>
17661>>>>>>>            Procedure_Return
17662>>>>>>>        End
17662>>>>>>>>
17662>>>>>>>        
17662>>>>>>>        Get EntryUpdateLocalState to bOld
17663>>>>>>>        Set EntryUpdateLocalState to True
17664>>>>>>>        
17664>>>>>>>        //  'hold' buffer to prepare for entry_update
17664>>>>>>>        Move (getRowId(iFile)) to riRec
17665>>>>>>>        Get_Attribute DF_FILE_STATUS of iFile to iOldStat
17668>>>>>>>        Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
17671>>>>>>>        
17671>>>>>>>        If bEntUpdt Begin
17673>>>>>>>            Send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
17674>>>>>>>            
17674>>>>>>>            //
17674>>>>>>>            // we really only need to know if any segment of the index changed
17674>>>>>>>            // but since we don't have field-changed flags, we look at the
17674>>>>>>>            // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
17674>>>>>>>            // behavior.
17674>>>>>>>            //
17674>>>>>>>            Move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
17675>>>>>>>            If not wasChanged ;                Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
17680>>>>>>>            If not wasChanged ;                Constrained_Clear iFindMode iFile by iIndex
17685>>>>>>>            
17685>>>>>>>        End
17685>>>>>>>>
17685>>>>>>>        Move False to Err
17686>>>>>>>        If bDfrd ;            Send Request_Read iFindMode iFile iIndex
17689>>>>>>>        Else ;            Send Request_Find iFindMode iFile iIndex
17691>>>>>>>        If (not(Found) and  not(err)) Begin
17693>>>>>>>            // refind original record (or leave it cleared if not record)
17693>>>>>>>            Move (FindByRowId(iFile,riRec)) to bOk
17694>>>>>>>            
17694>>>>>>>            If bShowErr ;                Error (If(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
17697>>>>>>>            Move False to Err
17698>>>>>>>        End
17698>>>>>>>>
17698>>>>>>>        Set EntryUpdateLocalState to bOld
17699>>>>>>>    End_Procedure
17700>>>>>>>    
17700>>>>>>>    // This does a refind of all records based on the contents of the
17700>>>>>>>    // refine_record_id property.
17700>>>>>>>    // This would be used after clearing the DDs and loading the local rencum
17700>>>>>>>    // buffer with recnums. This can be used by remote DEOs (BPOs).
17700>>>>>>>    //
17700>>>>>>>    // Find all existing records. This must be done in bottom-up, breadth
17700>>>>>>>    // first order. i.e., Start with the passed DD, find it and then find for
17700>>>>>>>    // parents. Only find if the record is non-zero and it is different than
17700>>>>>>>    // the current_record.
17700>>>>>>>    // This order will allow us to support changed parents.
17700>>>>>>>    // Don't use this if you do not understand what it does.
17700>>>>>>>    // Private.Find_Records is a helper. We will keep this private because
17700>>>>>>>    // it is rather specialized and only used by WebApp.
17700>>>>>>>    Procedure Find_Records
17702>>>>>>>        Send Initialize_Visited False False // Clear up, do not clear fields
17703>>>>>>>        Send Private.Find_Records           // refind all records in upward sweep
17704>>>>>>>    End_Procedure
17705>>>>>>>    
17705>>>>>>>    
17705>>>>>>>    Procedure Private.Find_Records
17707>>>>>>>        Integer hPrnt
17707>>>>>>>        Integer iMax
17707>>>>>>>        Integer iCount
17707>>>>>>>        RowID riRec
17707>>>>>>>        Integer iRec iMain
17707>>>>>>>        // works with both recId and rowId. Only one should ever be set.
17707>>>>>>>        // find(clear) record, if needed
17707>>>>>>>        Get Main_File to iMain
17708>>>>>>>        // assume that either prFindRowId or Find_record_id has a value - never both
17708>>>>>>>        // also assume Find_record_id only has values when you are using a recnum table
17708>>>>>>>        Get prFindRowId to riRec
17709>>>>>>>        If not (IsNullRowId(riRec)) Begin
17711>>>>>>>            If not (IsSameRowId(riRec, CurrentRowId(Self) ) ) Begin
17713>>>>>>>                Send FindByRowId iMain riRec // find an Relate all parents
17714>>>>>>>            End
17714>>>>>>>>
17714>>>>>>>            Set prFindRowId to (NullRowId())  // reset refind rec back to zero.
17715>>>>>>>        End
17715>>>>>>>>
17715>>>>>>>        Else Begin
17716>>>>>>>            // if this has a recnum, it better be a recnum table or an error will occur.
17716>>>>>>>            // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
17716>>>>>>>            // on a non-recnum table, they doing something wrong. An Error will be a good thing.
17716>>>>>>>            Get Find_Record_Id to iRec
17717>>>>>>>            If iRec Begin
17719>>>>>>>                If (iRec<>Current_record(Self)) Begin
17721>>>>>>>                    Send Find_By_Recnum iMain iRec // find an Relate all parents
17722>>>>>>>                End
17722>>>>>>>>
17722>>>>>>>                Set Find_record_id to 0 // reset refind rec back to zero.
17723>>>>>>>            End
17723>>>>>>>>
17723>>>>>>>        End
17723>>>>>>>>
17723>>>>>>>        Set Visited_State to True
17724>>>>>>>        
17724>>>>>>>        // recurse and do the same to all parent files
17724>>>>>>>        // in almost all cases, there will be no new finding here since the relate has
17724>>>>>>>        // found the records. If the record is different than the relate, we have
17724>>>>>>>        // a switched parent state (should_save will be set appropriately).
17724>>>>>>>        Get Data_Set_Server_Count to iMax
17725>>>>>>>        Decrement iMax
17726>>>>>>>        For iCount from 0 to iMax
17732>>>>>>>>
17732>>>>>>>            Get Data_Set_Server iCount to hPrnt
17733>>>>>>>            If not (Visited_state(hPrnt)) ;                Send Private.Find_Records to hPrnt
17736>>>>>>>        Loop
17737>>>>>>>>
17737>>>>>>>    End_Procedure
17738>>>>>>>    
17738>>>>>>>    // This Mark_Id creates a sequence Id for this clear. This way
17738>>>>>>>    // DDOs only get cleared one time during this process.
17738>>>>>>>    Procedure IncrementCurrentMarkId
17740>>>>>>>        If (DD_Current_Mark_ID>65536) Begin
17742>>>>>>>            Move 0 to DD_Current_Mark_id
17743>>>>>>>        End
17743>>>>>>>>
17743>>>>>>>        Increment DD_Current_Mark_id
17744>>>>>>>    End_Procedure
17745>>>>>>>    
17745>>>>>>>    
17745>>>>>>>    // private use by new webapp framework as of 18.2.
17745>>>>>>>    // pass bStart as True if this is the start of the resynch.
17745>>>>>>>    Function ReSyncRecords Boolean bStart Returns Handle
17747>>>>>>>        RowID riRowId riCrnt
17747>>>>>>>        Boolean bOk bOldReSync bVisited
17747>>>>>>>        Handle hoOtherDDO hoBadDDO hoBadPrntDDO
17747>>>>>>>        Integer iMax iCount iMain
17747>>>>>>>
17747>>>>>>>        If bStart Begin
17749>>>>>>>            Send InitializeAllVisited
17750>>>>>>>        End
17750>>>>>>>>
17750>>>>>>>        
17750>>>>>>>        // we want depth first traversal. Make sure children are handled before parents
17750>>>>>>>        // Recursively traverse Children, Find by RowId, Recursively traverse Parents
17750>>>>>>>        // Use visited_state logic to avoid multiple visits caused by diamond DDO strutures
17750>>>>>>>        
17750>>>>>>>        //mark first so we don't visit this coming back up.
17750>>>>>>>        Set Visited_State to True
17751>>>>>>>        
17751>>>>>>>        // traverse downward first
17751>>>>>>>        Get Data_Set_Client_Count to iMax
17752>>>>>>>        For iCount from 0 to (iMax-1)
17758>>>>>>>>
17758>>>>>>>            Get Data_Set_Client iCount to hoOtherDDO
17759>>>>>>>            Get Visited_State of hoOtherDDO to bVisited
17760>>>>>>>            If not bVisited Begin
17762>>>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
17763>>>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
17765>>>>>>>                    Move hoBadPrntDDO to hoBadDDO
17766>>>>>>>                End
17766>>>>>>>>
17766>>>>>>>            End
17766>>>>>>>>
17766>>>>>>>        Loop
17767>>>>>>>>
17767>>>>>>>        
17767>>>>>>>        // Find record for DD. It might already be correct if child has already
17767>>>>>>>        // related it in. If not correct after a relate, this has been switched by this
17767>>>>>>>        // user or switched by another user, in which case it will be swtitched back
17767>>>>>>>        // (DDOs have always worked this way).
17767>>>>>>>        Get prFindRowId to riRowId
17768>>>>>>>        Get Main_File to iMain
17769>>>>>>>        Get CurrentRowId to riCrnt
17770>>>>>>>        If ( not(IsSameRowId(riRowID, riCrnt)) ) Begin
17772>>>>>>>            Get pbInReSync to bOldReSync
17773>>>>>>>            Set pbInReSync to True
17774>>>>>>>            
17774>>>>>>>            If (IsNullRowId(riRowID)) Begin
17776>>>>>>>                Send Clear
17777>>>>>>>            End
17777>>>>>>>>
17777>>>>>>>            Else Begin
17778>>>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
17779>>>>>>>                If not bOk Begin
17781>>>>>>>                    Move Self to hoBadDDO
17782>>>>>>>                End
17782>>>>>>>>
17782>>>>>>>            End
17782>>>>>>>>
17782>>>>>>>            Set pbInReSync to bOldReSync
17783>>>>>>>        End
17783>>>>>>>>
17783>>>>>>>        
17783>>>>>>>        // finally traverse to parents
17783>>>>>>>        Get Data_Set_Server_Count to iMax
17784>>>>>>>        For iCount from 0 to (iMax-1)
17790>>>>>>>>
17790>>>>>>>            Get Data_Set_Server iCount to hoOtherDDO
17791>>>>>>>            Get Visited_State of hoOtherDDO to bVisited
17792>>>>>>>            If not bVisited Begin
17794>>>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
17795>>>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
17797>>>>>>>                    Move hoBadPrntDDO to hoBadDDO
17798>>>>>>>                End
17798>>>>>>>>
17798>>>>>>>            End
17798>>>>>>>>
17798>>>>>>>        Loop
17799>>>>>>>>
17799>>>>>>>        
17799>>>>>>>        If bStart Begin
17801>>>>>>>            Send InitializeAllVisited
17802>>>>>>>            Send ResetChangedStates
17803>>>>>>>        End
17803>>>>>>>>
17803>>>>>>>        
17803>>>>>>>        Function_Return hoBadDDO
17804>>>>>>>    End_Function
17805>>>>>>>    
17805>>>>>>>
17805>>>>>>>    Procedure ResetChangedStates
17807>>>>>>>        Boolean bVisited
17807>>>>>>>        Handle hoOtherDDO
17807>>>>>>>        Integer iMax iCount
17807>>>>>>>        tDDChangedInfo DDChangedInfo
17807>>>>>>>        tDDChangedInfo DDChangedInfo
17807>>>>>>>                
17807>>>>>>>        // we want depth first traversal.
17807>>>>>>>        //mark first so we don't visit this coming back up.
17807>>>>>>>        Set Visited_State to True
17808>>>>>>>        
17808>>>>>>>        // traverse downward first
17808>>>>>>>        Get Data_Set_Client_Count to iMax
17809>>>>>>>        For iCount from 0 to (iMax-1)
17815>>>>>>>>
17815>>>>>>>            Get Data_Set_Client iCount to hoOtherDDO
17816>>>>>>>            Get Visited_State of hoOtherDDO to bVisited
17817>>>>>>>            If not bVisited Begin
17819>>>>>>>                Send ResetChangedStates of hoOtherDDO
17820>>>>>>>            End
17820>>>>>>>>
17820>>>>>>>        Loop
17821>>>>>>>>
17821>>>>>>>        
17821>>>>>>>        // Set changed states for this DDO
17821>>>>>>>        Get pDDChangedInfo to DDChangedInfo
17822>>>>>>>        Set Changed_State to False // clears changed_state and parent_changed_states            
17823>>>>>>>        Set Changed_State to DDChangedInfo.bChanged            
17824>>>>>>>        For iCount from 0 to (SizeOfArray(DDChangedInfo.ParentChanged)-1)
17830>>>>>>>>
17830>>>>>>>            Send SetParentDDOSwitched DDChangedInfo.ParentChanged[iCount].iTable DDChangedInfo.ParentChanged[iCount].bSwitched
17831>>>>>>>        Loop
17832>>>>>>>>
17832>>>>>>>        
17832>>>>>>>        // finally traverse to parents
17832>>>>>>>        Get Data_Set_Server_Count to iMax
17833>>>>>>>        For iCount from 0 to (iMax-1)
17839>>>>>>>>
17839>>>>>>>            Get Data_Set_Server iCount to hoOtherDDO
17840>>>>>>>            Get Visited_State of hoOtherDDO to bVisited
17841>>>>>>>            If not bVisited Begin
17843>>>>>>>                Send ResetChangedStates of hoOtherDDO
17844>>>>>>>            End
17844>>>>>>>>
17844>>>>>>>        Loop
17845>>>>>>>>
17845>>>>>>>        
17845>>>>>>>    End_Procedure
17846>>>>>>>
17846>>>>>>>    // private use by new webapp framework (pre 18.2)
17846>>>>>>>    Function ReSyncRecord Returns Boolean
17848>>>>>>>        RowID riRowId
17848>>>>>>>        Boolean bOk bOldReSync
17848>>>>>>>        Handle hPrnt
17848>>>>>>>        Integer iMax iCount iMain
17848>>>>>>>        
17848>>>>>>>        Get pbInReSync to bOldReSync
17849>>>>>>>        
17849>>>>>>>        Get prFindRowId to riRowId
17850>>>>>>>        Get Main_File to iMain
17851>>>>>>>        If not (IsSameRowId(riRowID, CurrentRowId(Self) ) ) Begin
17853>>>>>>>            If (IsNullRowId(riRowID)) Begin
17855>>>>>>>                Set pbInReSync to True
17856>>>>>>>                Send Clear
17857>>>>>>>                Set pbInReSync to bOldReSync
17858>>>>>>>            End
17858>>>>>>>>
17858>>>>>>>            Else Begin
17859>>>>>>>                Set pbInReSync to True
17860>>>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
17861>>>>>>>                Set pbInReSync to bOldReSync
17862>>>>>>>                If not bOk Begin
17864>>>>>>>                    Function_Return False
17865>>>>>>>                End
17865>>>>>>>>
17865>>>>>>>            End
17865>>>>>>>>
17865>>>>>>>            
17865>>>>>>>            // check that the relate found all the parent records we expect.
17865>>>>>>>            // This should be correct unless a parent has been switched. Constrained
17865>>>>>>>            // parents, by definition, should already be correct. See **Note** below
17865>>>>>>>            Get Data_Set_Server_Count to iMax
17866>>>>>>>            For iCount from 0 to (iMax-1)
17872>>>>>>>>
17872>>>>>>>                Get Data_Set_Server iCount to hPrnt
17873>>>>>>>                If (Constrain_File(Self)<>Main_File(hPrnt) and ;                    not (IsSameRowID(prFindRowId(hPrnt),CurrentRowId(hPrnt)))) Begin
17875>>>>>>>                    // the parent is either wrong or not processed yet. Either way
17875>>>>>>>                    // make it right.
17875>>>>>>>                    Get ReSyncRecord of hPrnt to bOk
17876>>>>>>>                    If not bOk Begin
17878>>>>>>>                        Function_Return False
17879>>>>>>>                    End
17879>>>>>>>>
17879>>>>>>>                End
17879>>>>>>>>
17879>>>>>>>            Loop
17880>>>>>>>>
17880>>>>>>>        End
17880>>>>>>>>
17880>>>>>>>        
17880>>>>>>>        Function_Return True
17881>>>>>>>    End_Function
17882>>>>>>>    
17882>>>>>>>    // **Note** - dealing with changed parents and diamonds during a resync.
17882>>>>>>>    // If there is not a relates-to contraint between DD and child it is possible
17882>>>>>>>    // that the child find's relate will change the just found parent DD.
17882>>>>>>>    // Assuming this is not a structure bug, it means the parent is changed parent and that
17882>>>>>>>    // change must occur after the child record has been found and related. Therefore we add
17882>>>>>>>    // check after each child find to see if an parent is incorrect. If it is, either it is a
17882>>>>>>>    // switched parent or we haven't processed it yet. If the record is fine it
17882>>>>>>>    // just does nothing. For example (where *=relates-to):
17882>>>>>>>    //     W
17882>>>>>>>    //   */  \*
17882>>>>>>>    //   X    Y
17882>>>>>>>    //    \  /*
17882>>>>>>>    //     Z
17882>>>>>>>    // Assume you found a Z and changed its parent X.
17882>>>>>>>    // The refind order can be: WXZY or WYZX
17882>>>>>>>    // If WXZY the refound parent will be lost because Z will relate after the X
17882>>>>>>>    // find and replace it with the original parent. To control this we add this check
17882>>>>>>>    // after child Z has done its work. We only need to do this when child DDOs exist
17882>>>>>>>    // that are not constrained. This can change the order that DDOs are resynced but it
17882>>>>>>>    // should not matter.
17882>>>>>>>    
17882>>>>>>>    
17882>>>>>>>    
17882>>>>>>>    // Private use by new webapp framework
17882>>>>>>>    Procedure ReSyncClearAll
17884>>>>>>>        Boolean bOldReSync
17884>>>>>>>        Get pbInReSync to bOldReSync
17885>>>>>>>        // we need this to stop RememberLast and retains. We don't want those during a resyc clear
17885>>>>>>>        Set pbInReSync to True
17886>>>>>>>        Send Clear_All
17887>>>>>>>        Set pbInReSync to bOldReSync
17888>>>>>>>    End_Procedure
17889>>>>>>>    
17889>>>>>>>    // returns table name for error display. By default it returns the logical name
17889>>>>>>>    // can be augmented to return other information
17889>>>>>>>    Function ErrorMessageTableName Integer iTable Returns String
17891>>>>>>>        String sTable
17891>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTable
17894>>>>>>>        Function_Return sTable
17895>>>>>>>    End_Function
17896>>>>>>>    
17896>>>>>>>    
17896>>>>>>>    // Augmented to test updating connections.
17896>>>>>>>    // If error report it.
17896>>>>>>>    Procedure Request_Save
17898>>>>>>>        Integer iRval
17898>>>>>>>        String sTable
17898>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
17900>>>>>>>            Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
17901>>>>>>>            Get Validate_Save_Structure False to iRval
17902>>>>>>>            If iRval Begin
17904>>>>>>>                Get ErrorMessageTableName iRval to sTable
17905>>>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
17906>>>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_INVALID_SAVE_STRUCTURE sTable
17907>>>>>>>                Procedure_Return
17908>>>>>>>            End
17908>>>>>>>>
17908>>>>>>>        End
17908>>>>>>>>
17908>>>>>>>        Forward Send Request_Save
17910>>>>>>>    End_Procedure
17911>>>>>>>    
17911>>>>>>>    // Augmented to test updating connections.
17911>>>>>>>    // If error report it.
17911>>>>>>>    Procedure Request_Delete
17913>>>>>>>        Integer iRval
17913>>>>>>>        String sTable
17913>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
17915>>>>>>>            Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
17916>>>>>>>            Get Validate_Delete_Structure False to iRval
17917>>>>>>>            If iRval Begin
17919>>>>>>>                Get ErrorMessageTableName iRval to sTable
17920>>>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
17921>>>>>>>                Send data_Set_Error -1 DFERR_PROGRAM DD_INVALID_DELETE_STRUCTURE sTable
17922>>>>>>>                Procedure_Return
17923>>>>>>>            End
17923>>>>>>>>
17923>>>>>>>        End
17923>>>>>>>>
17923>>>>>>>        Forward Send Request_Delete
17925>>>>>>>    End_Procedure
17926>>>>>>>    
17926>>>>>>>    // Set status-line help for the passed field. This could have been named
17926>>>>>>>    // Set Field_Status_Help but this keeps this message interface consistent
17926>>>>>>>    // with the rest of DF for windows.
17926>>>>>>>    Procedure Set Status_Help Integer iField String sVal
17928>>>>>>>        Set Value of (StatusHelp_Array(Self)) iField to sVal
17929>>>>>>>    End_Procedure
17930>>>>>>>    
17930>>>>>>>    // Get status-line help for the passed field. This could have been named
17930>>>>>>>    // Get Field_Status_Help but this keeps this message interface consistent
17930>>>>>>>    // with the rest of DF for windows.
17930>>>>>>>    Function Status_Help Integer iField Returns String
17932>>>>>>>        String sHelp
17932>>>>>>>        Integer iObj
17932>>>>>>>        Move (StatusHelp_Array(Self)) to iObj
17933>>>>>>>        If (Item_Count(iObj)>iField) Begin
17935>>>>>>>            Get value of iObj iField to sHelp
17936>>>>>>>            If (sHelp = '0') ;                Move '' to shelp
17939>>>>>>>        End
17939>>>>>>>>
17939>>>>>>>        Function_Return shelp
17940>>>>>>>    End_Function
17941>>>>>>>    
17941>>>>>>>    // Get status-line help for the passed file and field. This is called
17941>>>>>>>    // by DEOs (or any other object) that needs help for a particular file
17941>>>>>>>    // and field.
17941>>>>>>>    Function File_Field_Status_Help Integer iFile Integer iField Returns String
17943>>>>>>>        Integer iDSO
17943>>>>>>>        String sValue
17943>>>>>>>        Get Data_set iFile to iDSO
17944>>>>>>>        If iDSO ;            Get Status_Help of iDSO iField to sValue
17947>>>>>>>        Function_Return sValue
17948>>>>>>>    End_Function
17949>>>>>>>    
17949>>>>>>>    // Allows user to set a mask type. Legal value is any of the current mask
17949>>>>>>>    // window types. 0 Means undefined.
17949>>>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
17951>>>>>>>        Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
17952>>>>>>>    End_Procedure
17953>>>>>>>    
17953>>>>>>>    Function Field_Mask_Type Integer iField Returns Integer
17955>>>>>>>        Function_Return (Field_Mask_Type(FieldMask_Array(Self),iField))
17956>>>>>>>    End_Function
17957>>>>>>>    
17957>>>>>>>    Function File_Field_Mask_Type Integer iFile Integer iField Returns Integer
17959>>>>>>>        Integer iDSO
17959>>>>>>>        Get Data_set iFile to iDSO
17960>>>>>>>        If iDSO ;            Function_Return (Field_Mask_Type(iDSO,iField))
17963>>>>>>>    End_Function
17964>>>>>>>    
17964>>>>>>>    // If TRUE the value returned by DEO will contain mask characters.
17964>>>>>>>    // Currently not supported.
17964>>>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
17966>>>>>>>        Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
17967>>>>>>>    End_Procedure
17968>>>>>>>    
17968>>>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
17970>>>>>>>        Function_Return (Field_Mask_Value_State(FieldMask_Array(Self),iField))
17971>>>>>>>    End_Function
17972>>>>>>>    
17972>>>>>>>    Function File_Field_Mask_Value_State Integer iFile Integer iField Returns Integer
17974>>>>>>>        Integer iDSO
17974>>>>>>>        Get Data_set iFile to iDSO
17975>>>>>>>        If iDSO ;            Function_Return (Field_Mask_Value_State(iDSO,iField))
17978>>>>>>>    End_Function
17979>>>>>>>    
17979>>>>>>>    // Allows user to set a mask strinng. Legal value is any of the current
17979>>>>>>>    // masks. Note an empty string with a valid mask type implies that the
17979>>>>>>>    // system should figure it out by itself.
17979>>>>>>>    Procedure Set Field_Mask Integer iField String sMask
17981>>>>>>>        Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
17982>>>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Mask_Changed iField sMask
17985>>>>>>>    End_Procedure
17986>>>>>>>    
17986>>>>>>>    Function Field_Mask Integer iField Returns String
17988>>>>>>>        Function_Return (Field_Mask(FieldMask_Array(Self),iField))
17989>>>>>>>    End_Function
17990>>>>>>>    
17990>>>>>>>    Function File_Field_Mask Integer iFile Integer iField Returns String
17992>>>>>>>        Integer iDSO
17992>>>>>>>        String sValue
17992>>>>>>>        Get Data_set iFile to iDSO
17993>>>>>>>        If iDSO ;            Get Field_Mask of iDSO iField to sValue
17996>>>>>>>        Function_Return sValue
17997>>>>>>>    End_Function
17998>>>>>>>    
17998>>>>>>>    // Short for field. This is normally used by grid headers.
17998>>>>>>>    Procedure Set Field_Label_Short Integer iField String sName
18000>>>>>>>        Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
18001>>>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 0 sName
18004>>>>>>>    End_Procedure
18005>>>>>>>    
18005>>>>>>>    Function Field_Label_Short Integer iField Returns String
18007>>>>>>>        Function_Return (Field_Label_Short(FieldMask_Array(Self),iField))
18008>>>>>>>    End_Function
18009>>>>>>>    
18009>>>>>>>    Function File_Field_Label_Short Integer iFile Integer iField Returns String
18011>>>>>>>        Integer iDSO
18011>>>>>>>        String sValue
18011>>>>>>>        Get Data_set iFile to iDSO
18012>>>>>>>        If iDSO ;            Get Field_Label_Short of iDSO iField to sValue
18015>>>>>>>        Function_Return sValue
18016>>>>>>>    End_Function
18017>>>>>>>    
18017>>>>>>>    // Full Name for field. This is normally used by form labels
18017>>>>>>>    Procedure Set Field_Label_Long Integer iField String sName
18019>>>>>>>        Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
18020>>>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 1 sName
18023>>>>>>>    End_Procedure
18024>>>>>>>    
18024>>>>>>>    Function Field_Label_Long Integer iField Returns String
18026>>>>>>>        Function_Return (Field_Label_Long(FieldMask_Array(Self),iField))
18027>>>>>>>    End_Function
18028>>>>>>>    
18028>>>>>>>    Function File_Field_Label_Long Integer iFile Integer iField Returns String
18030>>>>>>>        Integer iDSO
18030>>>>>>>        String sValue
18030>>>>>>>        Get Data_set iFile to iDSO
18031>>>>>>>        If iDSO ;            Get Field_Label_Long of iDSO iField to sValue
18034>>>>>>>        Function_Return sValue
18035>>>>>>>    End_Function
18036>>>>>>>    
18036>>>>>>>    // This is not really a DD attribute (it is in the API) but it is
18036>>>>>>>    // appropriate to be accessed from the DD
18036>>>>>>>    Function Field_Label_Tag Integer iField Returns String
18038>>>>>>>        String sName
18038>>>>>>>        Integer iFile
18038>>>>>>>        Get Main_File to iFile
18039>>>>>>>        If iFile ;            Get_Attribute DF_FIELD_NAME of iFile iField to sName
18044>>>>>>>        Function_Return sName
18045>>>>>>>    End_Function
18046>>>>>>>    
18046>>>>>>>    Function SmartCase String sName Returns String
18048>>>>>>>        Integer iPos iNewPos
18048>>>>>>>        String sRight
18048>>>>>>>        Move (Replaces("_",lowercase(sName)," ")) to sName
18049>>>>>>>        Move (Trim (Replaces(".",sName," "))) to sName
18050>>>>>>>        Move 1 to iPos
18051>>>>>>>        Repeat
18051>>>>>>>>
18051>>>>>>>            Move (mid(sName,255,iPos+1)) to sRight
18052>>>>>>>            Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
18053>>>>>>>            Move (Pos( " ", sRight)) to iNewPos
18054>>>>>>>            If (iNewPos = 0) ;                Break
18057>>>>>>>            Add (iNewPos+1) to iPos
18058>>>>>>>        Loop
18059>>>>>>>>
18059>>>>>>>        Function_Return sName
18060>>>>>>>    End_Function
18061>>>>>>>    
18061>>>>>>>    Enumeration_List
18061>>>>>>>        Define DD_LABEL_SHORT
18061>>>>>>>        Define DD_LABEL_LONG
18061>>>>>>>        Define DD_LABEL_TAG
18061>>>>>>>    End_Enumeration_List
18061>>>>>>>    
18061>>>>>>>    // Handy function to get the label for a field. Three "types" are
18061>>>>>>>    // supported:
18061>>>>>>>    // DD_LABEL_SHORT  use short, if none use long, if none use smart tag
18061>>>>>>>    // DD_LABEL_LONG   use long, if none use smart tag
18061>>>>>>>    // DD_LABEL_TAG    use smart tag
18061>>>>>>>    // If you want an explicit field name use oneof the other messages.
18061>>>>>>>    Function Field_Label Integer iField Integer iType Returns String
18063>>>>>>>        Integer iServer
18063>>>>>>>        String sValue
18063>>>>>>>        If (iType = DD_LABEL_SHORT) ;  // 0 = Short            Get Field_Label_Short iField to sValue
18066>>>>>>>        If (iType = DD_LABEL_LONG or (iType=DD_LABEL_SHORT and sValue='')) ;            Get Field_Label_Long iField to sValue
18069>>>>>>>        If (iType = DD_LABEL_TAG or sValue="") Begin
18071>>>>>>>            Get Field_Label_Tag iField to sValue
18072>>>>>>>            Get SmartCase sValue to sValue
18073>>>>>>>        End
18073>>>>>>>>
18073>>>>>>>        Function_Return sValue
18074>>>>>>>    End_Function
18075>>>>>>>    
18075>>>>>>>    Function File_Field_Label Integer iFile Integer iField Integer iType Returns String
18077>>>>>>>        Integer iDSO
18077>>>>>>>        String sValue
18077>>>>>>>        Get Data_set iFile to iDSO
18078>>>>>>>        If iDSO ;            Get Field_Label of iDSO iField iType to sValue
18081>>>>>>>        Function_Return sValue
18082>>>>>>>    End_Function
18083>>>>>>>    
18083>>>>>>>    // Normally this will not be used by a running program. However, it
18083>>>>>>>    // could be possible to create classes dynamically at runtime, in which
18083>>>>>>>    // case these messages could be useful. No File_Field is provided. If the
18083>>>>>>>    // person knows enough to create dynamic classes they can find the DD.
18083>>>>>>>    Procedure Set Field_Class_Name Integer iField String sName
18085>>>>>>>        Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
18086>>>>>>>    End_Procedure
18087>>>>>>>    
18087>>>>>>>    Function Field_Class_Name Integer iField Returns String
18089>>>>>>>        Function_Return (Field_Class_Name(FieldMask_Array(Self),iField))
18090>>>>>>>    End_Function
18091>>>>>>>    
18091>>>>>>>    // This procedure should be used to set a specific error number and
18091>>>>>>>    // message for a particular field. This can be used with the Field_error
18091>>>>>>>    // message to generate this error during a validation.
18091>>>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
18093>>>>>>>        Set Field_Error of (Field_Attributes(Self)) iField to iErr sMsg
18094>>>>>>>    End_Procedure
18095>>>>>>>    
18095>>>>>>>    // Used to retreive the error number and message for a particular field
18095>>>>>>>    Function Field_Error_Number Integer iField Returns Integer
18097>>>>>>>        Function_Return (Field_Error_Number(Field_Attributes(Self),iField))
18098>>>>>>>    End_Function
18099>>>>>>>    
18099>>>>>>>    Function Field_Error_Message Integer iField Returns String
18101>>>>>>>        Function_Return (Field_Error_Message(Field_Attributes(Self),iField))
18102>>>>>>>    End_Function
18103>>>>>>>    
18103>>>>>>>    // This procedure is used to declare an error on a standard field
18103>>>>>>>    // validation violation like Range or Check.
18103>>>>>>>    // Can pass 1 to 4 params:
18103>>>>>>>    // iField -                  Standard usage. Generates field as defined
18103>>>>>>>    //                           for this field. If field=-1, General error
18103>>>>>>>    // iField SDefault           If no field error mess (or field=-1) use
18103>>>>>>>    //                           the default message
18103>>>>>>>    // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and
18103>>>>>>>    //                           @PARAM2 in text with these values
18103>>>>>>>    Procedure Field_Error Integer iField String sDefault ;            String sParam1 String sParam2
18105>>>>>>>        Integer iErr
18105>>>>>>>        String  sMess
18105>>>>>>>        If (iField >= 0) Begin
18107>>>>>>>            Get Field_Error_Number  iField to iErr
18108>>>>>>>            Get Field_Error_Message iField to sMess
18109>>>>>>>        End
18109>>>>>>>>
18109>>>>>>>        If (sMess="" and Num_Arguments>1) ;            Move sDefault to sMess
18112>>>>>>>        If (Num_Arguments = 4) ;            Send Data_Set_Error iField iErr sMess sParam1 sParam2
18115>>>>>>>        Else If (Num_Arguments = 3) ;            Send Data_Set_Error iField iErr sMess sParam1
18119>>>>>>>        Else ;            Send Data_Set_Error iField iErr sMess
18121>>>>>>>    End_Procedure
18122>>>>>>>    
18122>>>>>>>    // Procedure Data_Set_Error
18122>>>>>>>    // This procedure is used to declare a data-set error. Pass error number
18122>>>>>>>    // and optional error message text.
18122>>>>>>>    // If iErr is 0, use the default error number.
18122>>>>>>>    // sParam1 and sParam2 are optional. If passed they are used as text
18122>>>>>>>    // replacements for @PARAM1 and @PARAM2.
18122>>>>>>>    // We pass iField (even though we don't use it) so that augmentations
18122>>>>>>>    // could support error logging down to a field level. If a non-field error
18122>>>>>>>    // is required the developer should pass negative values (e.g., -1)
18122>>>>>>>    // This will redirect errors locally if not already redirected
18122>>>>>>>    //
18122>>>>>>>    // Altered to additionally support %1 %2 replacements as well as
18122>>>>>>>    // replacements for @PARAM1 and @PARAM2. (vdf8.2)
18122>>>>>>>    Procedure Data_set_error Integer iField Integer iErr String sMess ;            String sParam1 String sParam2
18124>>>>>>>        Integer iOldField
18124>>>>>>>        Get Current_validate_field to iOldField
18125>>>>>>>        If (iField <> 0) ;            Set Current_Validate_field to iField
18128>>>>>>>        
18128>>>>>>>        If (iErr = 0) ; // if no error is passes, used a default error            Move DD_DEFAULT_ERROR_NUMBER to iErr
18131>>>>>>>        
18131>>>>>>>        If (sMess > "") Begin
18133>>>>>>>            
18133>>>>>>>            // Support message replacements.. Up to two values
18133>>>>>>>            // altered to support @Param1/2 and %1 %2 messages
18133>>>>>>>            If (Num_Arguments>3) Begin
18135>>>>>>>                Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
18136>>>>>>>                If (Num_Arguments>4) Begin
18138>>>>>>>                    Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
18139>>>>>>>                    Move (SFormat(sMess,sParam1,sParam2)) to sMess
18140>>>>>>>                End
18140>>>>>>>>
18140>>>>>>>                Else Begin
18141>>>>>>>                    Move (SFormat(sMess,sParam1)) to sMess
18142>>>>>>>                End
18142>>>>>>>>
18142>>>>>>>            End
18142>>>>>>>>
18142>>>>>>>            Move Self to ghoErrorSource
18143>>>>>>>            Error iErr sMess
18144>>>>>>>>
18144>>>>>>>            Move 0 to ghoErrorSource
18145>>>>>>>        End
18145>>>>>>>>
18145>>>>>>>        Else ;            Send Operation_Not_Allowed iErr
18147>>>>>>>        Set Current_validate_field to iOldField
18148>>>>>>>        Move True to Err // make sure Err is still set
18149>>>>>>>    End_Procedure
18150>>>>>>>    
18150>>>>>>>    // Augment to support Error_Report_Mode. Allows errors without error mess
18150>>>>>>>    // This will redirect errors locally if not already redirected
18150>>>>>>>    Procedure Operation_Not_Allowed Integer iErr
18152>>>>>>>        Integer bOK
18152>>>>>>>        Move Self to ghoErrorSource
18153>>>>>>>        Forward Send Operation_Not_Allowed iErr
18155>>>>>>>        Move 0 to ghoErrorSource
18156>>>>>>>    End_Procedure
18157>>>>>>>    
18157>>>>>>>    // Local error handler. When errors are redirected to the DD this proce-
18157>>>>>>>    // dure handles the errors. If error_report_mode is NO-report it sets
18157>>>>>>>    // the err indicator and returns. Else it redirects the error to the
18157>>>>>>>    // main error handler first moving its ID to ghoErrorSource. This way the
18157>>>>>>>    // handler knows who sent this message and will get additional error info
18157>>>>>>>    // by calling Get Extended_error_message
18157>>>>>>>    Procedure Error_Report Integer iError Integer iLine String ErrMsg
18159>>>>>>>        Integer hoErrId
18159>>>>>>>        Integer bRedirect
18159>>>>>>>        If (Error_Processing_State(Self)) ;  // this prevents recursion            Procedure_Return
18162>>>>>>>        Set Error_Processing_State to True
18163>>>>>>>        
18163>>>>>>>        // if no report mode, just set the err indicator to true.
18163>>>>>>>        If (Error_Report_Mode(Self)=DD_ERROR_NO_REPORT) ;            Move True to Err
18166>>>>>>>        Else Begin
18167>>>>>>>            Get Old_error_object_id to hoErrId  // the original error handler
18168>>>>>>>            If hoErrId Begin
18170>>>>>>>                Move (ghoErrorSource=0) to bRedirect
18171>>>>>>>                If bRedirect ;                    Move Self to ghoErrorSource // error handler can use this
18174>>>>>>>                Move hoErrID to Error_object_id
18175>>>>>>>                Send Error_Report to hoErrId iError iLine ErrMsg
18176>>>>>>>                Move Self to Error_object_id
18177>>>>>>>                If bRedirect ;                    Move 0 to ghoErrorSource
18180>>>>>>>            End
18180>>>>>>>>
18180>>>>>>>            Else ;                Send error_report of desktop iError iLine ErrMsg
18182>>>>>>>            //else forward send error_report iError iLine ErrMsg
18182>>>>>>>        End
18182>>>>>>>>
18182>>>>>>>        Set Error_Processing_State to False
18183>>>>>>>    End_Procedure
18184>>>>>>>    
18184>>>>>>>    // This is called (by the system error handler) to get additional informa-
18184>>>>>>>    // tion about the error. Returns a multi line string with each line
18184>>>>>>>    // separated by a "\n". Return the file number, name, and if possible
18184>>>>>>>    // the field number and name.
18184>>>>>>>    Function Extended_Error_Message Returns String
18186>>>>>>>        String sExtMess
18186>>>>>>>        String sFile
18186>>>>>>>        Integer iFile iField
18186>>>>>>>        Get main_file to iFile
18187>>>>>>>        Get Current_Validate_Field to iField
18188>>>>>>>        Get ErrorMessageTableName iFile to sFile
18189>>>>>>>        Move (DD_FILE_TEXT* String(iFile) * "-" * sFile) to sExtMess
18190>>>>>>>        If (iField > 0) ;            Append sExtMess "\n" ;            (DD_FIELD_TEXT* String(iField) * "-" * Field_Label(Self,iField,DD_LABEL_LONG))
18194>>>>>>>        Set Current_Validate_Field to 0
18195>>>>>>>        Function_Return sExtMess
18196>>>>>>>    End_Function
18197>>>>>>>    
18197>>>>>>>    Function Extended_Error_File Returns Integer
18199>>>>>>>        Function_Return (Main_File(Self))
18200>>>>>>>    End_Function
18201>>>>>>>    
18201>>>>>>>    Function Extended_Error_Field Returns Integer
18203>>>>>>>        Function_Return (Current_Validate_Field(Self))
18204>>>>>>>    End_Function
18205>>>>>>>    
18205>>>>>>>    
18205>>>>>>>    // The following messages are used to control smart file mode exception
18205>>>>>>>    // handling. The message "Send Add_system_File file# Fg" allows you to
18205>>>>>>>    // add system files (or any other files not known to the dso structure)
18205>>>>>>>    // within define_fields. This allows you to not have to augment the msg
18205>>>>>>>    // reset_filemodes_for_lock. The only truly public messages here are
18205>>>>>>>    // Add_system_file and Remove_system_File (which s/b rarely used).
18205>>>>>>>    
18205>>>>>>>    // Adds a system file for smart_file_mode handling. A second optional
18205>>>>>>>    // parameter may be passed to determine of the sys file should only be
18205>>>>>>>    // locked during a new save (and not during a delete or a save of an
18205>>>>>>>    // existing record). It is expected that this will be the only public
18205>>>>>>>    // message used to control smart filemode. All of the remaining sys file
18205>>>>>>>    // messages are considered advanced.
18205>>>>>>>    Procedure Add_System_File Integer iFile Integer iLock_Mode
18207>>>>>>>        Integer iobj iCnt iMode
18207>>>>>>>        If (Num_arguments = 1) ;            Move DD_Lock_on_All to iMode
18210>>>>>>>        Else ;            Move iLock_Mode     to iMode
18212>>>>>>>        Move (system_file_obj(Self)) to iObj
18213>>>>>>>        Get Item_Count  of iObj to iCnt
18214>>>>>>>        Set Array_Value of iObj iCnt to iFile
18215>>>>>>>        Increment iCnt
18216>>>>>>>        Set Array_Value of iObj iCnt to iMode
18217>>>>>>>    End_Procedure
18218>>>>>>>    
18218>>>>>>>    // Return number of system files
18218>>>>>>>    Function System_File_Count Returns Integer
18220>>>>>>>        Function_Return (Item_Count(System_File_Obj(Self))/2)
18221>>>>>>>    End_Function
18222>>>>>>>    
18222>>>>>>>    // Returns system file number for passed item.
18222>>>>>>>    Function System_File_Number Integer iItem Returns Integer
18224>>>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2))
18225>>>>>>>    End_Function
18226>>>>>>>    
18226>>>>>>>    // Returns system flag to determine if file is only used during a new
18226>>>>>>>    // save (and not during an exiting save or a delete).
18226>>>>>>>    Function System_File_Lock_Mode Integer iItem Returns Integer
18228>>>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2+1))
18229>>>>>>>    End_Function
18230>>>>>>>    
18230>>>>>>>    // Removes a system_file for smart_file_Mode handling. This remvoes the
18230>>>>>>>    // first occurance of the file (S/b the only occurance). We assume that
18230>>>>>>>    // this will be rarely used.
18230>>>>>>>    Procedure Remove_System_File Integer iFile
18232>>>>>>>        Integer iobj iCnt iItmCnt
18232>>>>>>>        Get System_file_Count to iItmCnt
18233>>>>>>>        Decrement iItmCnt
18234>>>>>>>        For iCnt from 0 to iItmCnt
18240>>>>>>>>
18240>>>>>>>            If (System_File_Number(Self,iCnt)=iFile) Begin
18242>>>>>>>                Move (system_file_obj(Self)) to iObj
18243>>>>>>>                Move (iCnt*2) to iCnt
18244>>>>>>>                Send Delete_Item to iObj iCnt
18245>>>>>>>                Send Delete_Item to iObj iCnt
18246>>>>>>>                Procedure_Return
18247>>>>>>>            End
18247>>>>>>>>
18247>>>>>>>        Loop
18248>>>>>>>>
18248>>>>>>>    End_Procedure
18249>>>>>>>    
18249>>>>>>>    // These set messages, add_client_file, add_server_file and add_system_file
18249>>>>>>>    // were added to more easily support visual DD class modeling. They do the
18249>>>>>>>    // same thing the Send counterpart messages do
18249>>>>>>>    
18249>>>>>>>    Procedure Set Add_Client_File Integer iFile
18251>>>>>>>        Send Add_Client_File iFile
18252>>>>>>>    End_Procedure
18253>>>>>>>    
18253>>>>>>>    Procedure Set Add_Server_File Integer iFile
18255>>>>>>>        Send Add_Server_File iFile
18256>>>>>>>    End_Procedure
18257>>>>>>>    
18257>>>>>>>    Procedure Set Add_System_File Integer iFile Integer iLock_Mode
18259>>>>>>>        // allow no arguments because the old message allowed this
18259>>>>>>>        If (Num_arguments=1) Begin
18261>>>>>>>            Send Add_System_File iFile
18262>>>>>>>        End
18262>>>>>>>>
18262>>>>>>>        Else Begin
18263>>>>>>>            Send Add_System_File iFile iLock_Mode
18264>>>>>>>        End
18264>>>>>>>>
18264>>>>>>>    End_Procedure
18265>>>>>>>    
18265>>>>>>>    // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
18265>>>>>>>    // command. This models more easily and it supports multiple auto-increment fields
18265>>>>>>>    Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
18267>>>>>>>        Integer[] AutoIncFields
18268>>>>>>>        tDDFileField[] SysFileFields
18268>>>>>>>        tDDFileField[] SysFileFields
18269>>>>>>>        Integer iIndex
18269>>>>>>>        
18269>>>>>>>        If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
18271>>>>>>>            Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
18272>>>>>>>>
18272>>>>>>>            Procedure_Return
18273>>>>>>>        End
18273>>>>>>>>
18273>>>>>>>        // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile
18273>>>>>>>        If (iSysFile=0) Begin
18275>>>>>>>            Move 0 to iSysField
18276>>>>>>>        End
18276>>>>>>>>
18276>>>>>>>        Get pAutoIncrementFields to AutoIncFields
18277>>>>>>>        Get pAutoIncrementSysFileFields to SysFileFields
18278>>>>>>>        // the destination field array is a list of fields that have auto-incr info. There
18278>>>>>>>        // can only be zero or one entry per field arranged in no defined order.
18278>>>>>>>        // see if field is already defined. If not add this to the end.
18278>>>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
18279>>>>>>>        If (iIndex=-1) Begin
18281>>>>>>>            Move (SizeOfArray(SysFileFields)) to iIndex
18282>>>>>>>        End
18282>>>>>>>>
18282>>>>>>>        Move iField    to AutoIncFields[iIndex]
18283>>>>>>>        Move iSysFile  to SysFileFields[iIndex].iFile
18284>>>>>>>        Move iSysField to SysFileFields[iIndex].iField
18285>>>>>>>        Set pAutoIncrementFields to AutoIncFields
18286>>>>>>>        Set pAutoIncrementSysFileFields to SysFileFields
18287>>>>>>>    End_Procedure
18288>>>>>>>    
18288>>>>>>>    // Get auto-increment system file/field value for a field. There really should be no
18288>>>>>>>    // reason to ever need this. Field is returned byref
18288>>>>>>>    Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer
18290>>>>>>>        Integer iSysFile
18290>>>>>>>        Integer[] AutoIncFields
18291>>>>>>>        tDDFileField[] SysFileFields
18291>>>>>>>        tDDFileField[] SysFileFields
18292>>>>>>>        Integer iIndex
18292>>>>>>>        
18292>>>>>>>        Get pAutoIncrementFields to AutoIncFields
18293>>>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
18294>>>>>>>        If (iIndex>-1) Begin
18296>>>>>>>            Get pAutoIncrementSysFileFields to SysFileFields
18297>>>>>>>            Move SysFileFields[iIndex].iFile to iSysFile
18298>>>>>>>            Move SysFileFields[iIndex].iField to iSysField
18299>>>>>>>        End
18299>>>>>>>>
18299>>>>>>>        Else Begin
18300>>>>>>>            Move 0 to iSysFile
18301>>>>>>>            Move 0 to iSysField
18302>>>>>>>        End
18302>>>>>>>>
18302>>>>>>>        Function_Return iSysFile
18303>>>>>>>    End_Function
18304>>>>>>>    
18304>>>>>>>    
18304>>>>>>>    // Augmented to set any system files defined via the Add_System_file
18304>>>>>>>    // message. This allows us to hide this procedure for the vast majority
18304>>>>>>>    // of cases.
18304>>>>>>>    Procedure Reset_Filemodes_For_Lock
18306>>>>>>>        Boolean bNewRec
18306>>>>>>>        Integer  iItmCnt iCnt iMode iFile
18306>>>>>>>        Integer iMain iMaster iOpts
18306>>>>>>>        Handle hoDD
18306>>>>>>>        
18306>>>>>>>        Forward Send Reset_Filemodes_for_lock
18308>>>>>>>        
18308>>>>>>>        Get System_File_Count to iItmCnt
18309>>>>>>>        If iItmCnt Begin
18311>>>>>>>            Move (not(HasRecord(Self))) to bNewRec
18312>>>>>>>            Decrement iItmCnt
18313>>>>>>>            For iCnt from 0 to iItmCnt
18319>>>>>>>>
18319>>>>>>>                Get System_File_Number         iCnt to iFile
18320>>>>>>>                Get System_File_Lock_Mode iCnt to iMode
18321>>>>>>>                If ( (iMode=DD_Lock_on_All) or ;                    (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                    (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                    ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
18323>>>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
18326>>>>>>>                End
18326>>>>>>>>
18326>>>>>>>            Loop
18327>>>>>>>>
18327>>>>>>>        End
18327>>>>>>>>
18327>>>>>>>        
18327>>>>>>>        // augment to support DD magnaged alias tables.
18327>>>>>>>        // If an alias, set the alias to the proper alias no locks only if
18327>>>>>>>        // the master file is actually part of this DDO structure. This allows you
18327>>>>>>>        // to use alias files without the master being present (or even open). This will work without needing
18327>>>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
18327>>>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
18327>>>>>>>        //
18327>>>>>>>        Get MasterForAlias to iMaster
18328>>>>>>>        If iMaster Begin
18330>>>>>>>            Get Main_File to iMain
18331>>>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
18332>>>>>>>            If hoDD Begin
18334>>>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts
18337>>>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)
18340>>>>>>>                // note this will be reset to what it was when the transaction ends
18340>>>>>>>            End
18340>>>>>>>>
18340>>>>>>>        End
18340>>>>>>>>
18340>>>>>>>        
18340>>>>>>>    End_Procedure
18341>>>>>>>    
18341>>>>>>>    // Augmented to handle auto-increment fields if defined. The value from
18341>>>>>>>    // the auto-incre sys file is incremented, saved and moved to the new
18341>>>>>>>    // record. As of 17.0 this is no longer in Creating, which is called after
18341>>>>>>>    // AutoIncrement.
18341>>>>>>>    Procedure AutoIncrement
18343>>>>>>>        Integer iSrcFile iSrcField i iAutoFields
18343>>>>>>>        Integer iDestFile iDestField
18343>>>>>>>        Number nNum
18343>>>>>>>        Integer[] AutoIncFields
18344>>>>>>>        tDDFileField[] AutoIncSysFileFields
18344>>>>>>>        tDDFileField[] AutoIncSysFileFields
18345>>>>>>>        Handle hoOwner
18345>>>>>>>        
18345>>>>>>>        Forward Send AutoIncrement
18347>>>>>>>        
18347>>>>>>>        // this supports the older Define_Auto_Increment logic. Only one is supported
18347>>>>>>>        // this is exists for backwards compatibility
18347>>>>>>>        Get Auto_Increment_Source_File to iSrcFile
18348>>>>>>>        If iSrcFile Begin // do we have auto increment?
18350>>>>>>>            Get Auto_Increment_Source_Field  to iSrcField
18351>>>>>>>            Get Auto_Increment_Dest_Field    to iDestField
18352>>>>>>>            If (iSrcField and iDestField) Begin  // just in case of error
18354>>>>>>>                Get Main_file to iDestFile
18355>>>>>>>                Get_Field_Value iSrcFile iSrcField to nNum
18358>>>>>>>                Move (nNum+1) to nNum
18359>>>>>>>                Set_Field_Value iSrcFile  iSrcField  to nNum
18362>>>>>>>                Set_Field_Value iDestFile iDestField to nNum
18365>>>>>>>                // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
18365>>>>>>>                // if the DD is not a parent file, it is a sysfile and we must save it
18365>>>>>>>                Get Which_Data_Set iSrcFile to hoOwner
18366>>>>>>>                If not hoOwner Begin
18368>>>>>>>                    SaveRecord iSrcFile
18369>>>>>>>                End
18369>>>>>>>>
18369>>>>>>>            End
18369>>>>>>>>
18369>>>>>>>        End
18369>>>>>>>>
18369>>>>>>>        // this supports the newer set syntax which support multiple fields. It is expected that you will
18369>>>>>>>        // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
18369>>>>>>>        Else Begin
18370>>>>>>>            Get pAutoIncrementFields to AutoIncFields
18371>>>>>>>            Move (SizeOfArray(AutoIncFields)) to iAutoFields
18372>>>>>>>            If (iAutoFields>0) Begin
18374>>>>>>>                Get pAutoIncrementSysFileFields to AutoIncSysFileFields
18375>>>>>>>                Get Main_file to iDestFile
18376>>>>>>>                For i from 0 to (iAutoFields-1)
18382>>>>>>>>
18382>>>>>>>                    // it is legal to set the sysfile to 0, this means it has been cleared and is not used
18382>>>>>>>                    If (AutoIncSysFileFields[i].iFile>0) Begin
18384>>>>>>>                        // we assume both the fields are valid and that they've already been tested when added
18384>>>>>>>                        Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
18387>>>>>>>                        Move (nNum+1) to nNum
18388>>>>>>>                        Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
18391>>>>>>>                        Set_Field_Value iDestFile AutoIncFields[i] to nNum
18394>>>>>>>                        // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
18394>>>>>>>                        // if the DD is not a parent file, it is a sysfile and we must save it
18394>>>>>>>                        Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
18395>>>>>>>                        If not hoOwner Begin
18397>>>>>>>                            SaveRecord AutoIncSysFileFields[i].iFile
18398>>>>>>>                        End
18398>>>>>>>>
18398>>>>>>>                    End
18398>>>>>>>>
18398>>>>>>>                Loop
18399>>>>>>>>
18399>>>>>>>            End
18399>>>>>>>>
18399>>>>>>>        End
18399>>>>>>>>
18399>>>>>>>        
18399>>>>>>>    End_Procedure
18400>>>>>>>    
18400>>>>>>>    // Augmented to fix a bug in the data-set C code. When a record is saved
18400>>>>>>>    // as part of a delete operation OnNewCurrentRecord is not called. It
18400>>>>>>>    // should be. We will do this in flex code for now.
18400>>>>>>>    Procedure Save_Main_File
18402>>>>>>>        RowID riRec
18402>>>>>>>        Integer iRec iMain
18402>>>>>>>        Boolean bRecnumTable bChanged
18402>>>>>>>        
18402>>>>>>>        Get Main_File to iMain
18403>>>>>>>        Get_Attribute DF_FILE_CHANGED of iMain to bChanged
18406>>>>>>>        If bChanged Begin
18408>>>>>>>            Send OnSaveRecord // OnSaveRecord sent if there is something to save
18409>>>>>>>        End
18409>>>>>>>>
18409>>>>>>>        
18409>>>>>>>        Forward Send Save_Main_File
18411>>>>>>>        
18411>>>>>>>        If (Operation_Mode = MODE_DELETING) Begin  // during a delete the crnt
18413>>>>>>>            Get CurrentRowId to riRec             // rec of parents do not change
18414>>>>>>>            Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
18415>>>>>>>            // for backwards compatibility reasons, we also send new_current_record if appropriate
18415>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
18418>>>>>>>            If (bRecnumTable) Begin
18420>>>>>>>                Get_Field_Value iMain 0 to iRec
18423>>>>>>>                Send New_Current_Record iRec iRec
18424>>>>>>>            End
18424>>>>>>>>
18424>>>>>>>        End
18424>>>>>>>>
18424>>>>>>>    End_Procedure
18425>>>>>>>    
18425>>>>>>>    // Augmented to not clear if a system-file. The auto-latching of views
18425>>>>>>>    // may cause a sys file DD to get cleared. This corrects this. This really
18425>>>>>>>    // belongs in Data_set (C) but we will not risk this for now.
18425>>>>>>>    Procedure Clear_Main_File
18427>>>>>>>        Integer iFile iIsSys
18427>>>>>>>        Get Main_File to iFile
18428>>>>>>>        If iFile Begin
18430>>>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
18433>>>>>>>            If iIsSys ;                Procedure_Return
18436>>>>>>>        End
18436>>>>>>>>
18436>>>>>>>        Forward Send Clear_main_file
18438>>>>>>>    End_Procedure
18439>>>>>>>    
18439>>>>>>>    // Executes a request_find on the mainfile. This is easier that having to
18439>>>>>>>    // pass file number all the time. Useful for batch operations.
18439>>>>>>>    // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)
18439>>>>>>>    Procedure Find Integer iMode Integer iIndex
18441>>>>>>>        Integer iFile
18441>>>>>>>        Integer iRec
18441>>>>>>>        Get Main_file to iFile
18442>>>>>>>        If (iIndex<>0 or iMode<>EQ) ;            Send request_find iMode iFile iIndex
18445>>>>>>>        Else Begin
18446>>>>>>>            // this would never happen with row ID
18446>>>>>>>            Get_Field_Value iFile 0 to iRec // get recnum value
18449>>>>>>>            Send find_by_recnum iFile iRec
18450>>>>>>>        End
18450>>>>>>>>
18450>>>>>>>    End_Procedure
18451>>>>>>>    
18451>>>>>>>    // So many people make the mistake of using requeset_clear and request_
18451>>>>>>>    // clear_all that will support these are alteratives to clear and
18451>>>>>>>    // clear_all. The preferred messages remain Clear and Clear_all.
18451>>>>>>>    // This would not work if you nested DEOs within DSOs (no-one does).
18451>>>>>>>    Procedure Request_Clear
18453>>>>>>>        Send Clear
18454>>>>>>>    End_Procedure
18455>>>>>>>    
18455>>>>>>>    Procedure Request_Clear_All
18457>>>>>>>        Send Clear_All
18458>>>>>>>    End_Procedure
18459>>>>>>>    
18459>>>>>>>    // we want changed_state to always go through the
18459>>>>>>>    // Record_buffer object. From there it is sent to
18459>>>>>>>    // here. So if state or RB does not match we must
18459>>>>>>>    // send to the RB object...it will delegate to here
18459>>>>>>>    
18459>>>>>>>    Procedure Set Changed_State Integer bState
18461>>>>>>>        Integer hRB
18461>>>>>>>        Move (record_buffer(Self)) to hRB
18462>>>>>>>        If (hRB and changed_state(hRB)<>bState) ;            Set changed_state of hRB to bState
18465>>>>>>>        Else ;            Forward Set changed_state to bState
18468>>>>>>>    End_Procedure
18469>>>>>>>    
18469>>>>>>>    // this lets us use the new attach logic
18469>>>>>>>    
18469>>>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
18469>>>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
18469>>>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
18469>>>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
18469>>>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
18469>>>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
18469>>>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
18469>>>>>>>    
18469>>>>>>>    // as if 18.1 this is only called when there is an attachable relationship. This gives us a chance to do any
18469>>>>>>>    // customizations and to cancel the attach. We've left this to the flex level so we can fine tune attaches.
18469>>>>>>>    Function ShouldFieldAttach Integer iField Handle hoRelDD Returns Boolean
18471>>>>>>>        Boolean bDoAttach bChanged
18471>>>>>>>        Integer iFile iStat iRelFile iType
18471>>>>>>>        String sValue
18471>>>>>>>        
18471>>>>>>>        Get Main_File to iFile
18472>>>>>>>        Get Main_File of hoRelDD to iRelFile
18473>>>>>>>        
18473>>>>>>>        // before we attach check if Find mode and relfile is new and unchanged..if so skip.
18473>>>>>>>        // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
18473>>>>>>>        Move True to bDoAttach
18474>>>>>>>        If (Operation_mode=MODE_FINDING or OPERATION_MODE=0) Begin
18476>>>>>>>            // we can test the file status to see if we have a record or not. If we have a record, we attach
18476>>>>>>>            Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
18479>>>>>>>            If (iStat=DF_FILE_INACTIVE) Begin
18481>>>>>>>                // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
18481>>>>>>>                // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
18481>>>>>>>                // because this is not set with default values. When doing a find entry_update this should be ok. If this were
18481>>>>>>>                // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
18481>>>>>>>                // applications because find entry_updates were done at the DEO level (unlike web applications).
18481>>>>>>>                Get Changed_State of hoRelDD to bChanged
18482>>>>>>>                Move bChanged to bDoAttach
18483>>>>>>>                
18483>>>>>>>                // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
18483>>>>>>>                // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
18483>>>>>>>                // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
18483>>>>>>>                // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
18483>>>>>>>                // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
18483>>>>>>>                // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
18483>>>>>>>                // There is no real logic as to why this is being done other than to make it work like it used to with the least
18483>>>>>>>                // amount of side-effects.
18483>>>>>>>                If (not(bDoAttach) and OPERATION_MODE=0) Begin
18485>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
18488>>>>>>>                    If (iType=DF_ASCII) Begin
18490>>>>>>>                        Get_Field_Value iFile iField to sValue
18493>>>>>>>                        // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
18493>>>>>>>                        If (Ascii(Left(sValue,1))=0) Begin
18495>>>>>>>                            Set_Field_Value iFile iField to ""
18498>>>>>>>                        End
18498>>>>>>>>
18498>>>>>>>                    End
18498>>>>>>>>
18498>>>>>>>                End
18498>>>>>>>>
18498>>>>>>>                
18498>>>>>>>            End
18498>>>>>>>>
18498>>>>>>>        End
18498>>>>>>>>
18498>>>>>>>        Function_Return bDoAttach
18499>>>>>>>    End_Function
18500>>>>>>>    
18500>>>>>>>    // Notify all DEOs that a mask has changed.
18500>>>>>>>    //        this message is sent by set Field_Mask
18500>>>>>>>    Procedure Field_Mask_Changed Integer iField String sMask
18502>>>>>>>        Integer i iDEOs iDEO
18502>>>>>>>        Integer iMain_File
18502>>>>>>>        Get Main_File to iMain_File
18503>>>>>>>        Get Data_Set_User_Interface_Count to iDEOs
18504>>>>>>>        Decrement iDEOs
18505>>>>>>>        For i from 0 to iDEOs
18511>>>>>>>>
18511>>>>>>>            Get Data_Set_User_Interface i to iDEO
18512>>>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                iMain_File iField sMask
18515>>>>>>>        Loop
18516>>>>>>>>
18516>>>>>>>    End_Procedure
18517>>>>>>>    
18517>>>>>>>    // Notify all DEOs that a label has changed.
18517>>>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short
18517>>>>>>>    Procedure Field_label_Changed Integer iField Boolean bLong String sLabel
18519>>>>>>>        Integer i iDEOs iDEO
18519>>>>>>>        Integer iMain_File
18519>>>>>>>        Get Main_File to iMain_File
18520>>>>>>>        Get Data_Set_User_Interface_Count to iDEOs
18521>>>>>>>        Decrement iDEOs
18522>>>>>>>        For i from 0 to iDEOs
18528>>>>>>>>
18528>>>>>>>            Get Data_Set_User_Interface i to iDEO
18529>>>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                iMain_File iField bLong sLabel
18532>>>>>>>        Loop
18533>>>>>>>>
18533>>>>>>>    End_Procedure
18534>>>>>>>    
18534>>>>>>>    // Notify all DEOs that a field option has changed.
18534>>>>>>>    //   This message is sent by Set Field_Option
18534>>>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
18536>>>>>>>        Integer i iDEOs iDEO
18536>>>>>>>        Integer iMain_File
18536>>>>>>>        Get Main_File to iMain_File
18537>>>>>>>        Get Data_Set_User_Interface_Count to iDEOs
18538>>>>>>>        Decrement iDEOs
18539>>>>>>>        For i from 0 to iDEOs
18545>>>>>>>>
18545>>>>>>>            Get Data_Set_User_Interface i to iDEO
18546>>>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                iMain_File iField iOptions bClear
18549>>>>>>>        Loop
18550>>>>>>>>
18550>>>>>>>    End_Procedure
18551>>>>>>>    
18551>>>>>>>    
18551>>>>>>>    //   Set, clear or toggle a field option
18551>>>>>>>    //   Multiple options can be passed as an expression
18551>>>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).
18551>>>>>>>    //   Unlike set Field_options this notifies DEOs of changes
18551>>>>>>>    // supports setting and clearing. e.g.:
18551>>>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
18551>>>>>>>    // This new syntax is now the recommended syntax but the older syntax without
18551>>>>>>>    // the last parameter is supported (where true is the default). The old syntax is
18551>>>>>>>    // only supported for compatibility. This means that Field_Option_Clear should
18551>>>>>>>    // also be replaced with Field_Option
18551>>>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
18553>>>>>>>        Boolean bSetTrue
18553>>>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
18554>>>>>>>        If bSetTrue Begin
18556>>>>>>>            Set Field_options iField to iOption
18557>>>>>>>        End
18557>>>>>>>>
18557>>>>>>>        Else Begin
18558>>>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
18559>>>>>>>        End
18559>>>>>>>>
18559>>>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
18561>>>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
18562>>>>>>>        End
18562>>>>>>>>
18562>>>>>>>    End_Procedure
18563>>>>>>>    
18563>>>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
18565>>>>>>>        Handle hoDD
18565>>>>>>>        Boolean bSetTrue
18565>>>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
18566>>>>>>>        Get Data_set iFile to hoDD
18567>>>>>>>        If hoDD Begin
18569>>>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
18570>>>>>>>        End
18570>>>>>>>>
18570>>>>>>>        
18570>>>>>>>    End_Procedure
18571>>>>>>>    
18571>>>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
18573>>>>>>>        Set Field_Option iField iOptions to False
18574>>>>>>>    End_Procedure
18575>>>>>>>    
18575>>>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
18577>>>>>>>        Set File_Field_Option iFile iField iOptions to False
18578>>>>>>>    End_Procedure
18579>>>>>>>    
18579>>>>>>>    Procedure Set Field_Option_Toggle Integer iField Integer iOption
18581>>>>>>>        Integer iOldOption
18581>>>>>>>        Get Field_Options iField to iOldOption
18582>>>>>>>        // if old and new have overlapping bits, we assume clear
18582>>>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
18583>>>>>>>    End_Procedure
18584>>>>>>>    
18584>>>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
18586>>>>>>>        Handle hoDD
18586>>>>>>>        Get Data_set iFile to hoDD
18587>>>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
18590>>>>>>>    End_Procedure
18591>>>>>>>    
18591>>>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
18591>>>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
18591>>>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
18591>>>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
18591>>>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
18591>>>>>>>    // the owner object.
18591>>>>>>>    Function Field_Index Integer iField Returns Integer
18593>>>>>>>        Integer iFile iIndex iOrder
18593>>>>>>>        // ordering takes precendence
18593>>>>>>>        Get ordering to iOrder
18594>>>>>>>        If (iOrder>=0);            Move iOrder to iIndex  //ordering takes precedence over main index
18597>>>>>>>        Else Begin
18598>>>>>>>            Get Main_file to iFile
18599>>>>>>>            Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
18602>>>>>>>            If (iIndex=0 and iField>0) ; // If field is not recnum and there is no index, the                Move -1 to iIndex        // field has no main index
18605>>>>>>>        End
18605>>>>>>>>
18605>>>>>>>        Function_Return iIndex
18606>>>>>>>    End_Function
18607>>>>>>>    
18607>>>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
18607>>>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
18607>>>>>>>    // is called.
18607>>>>>>>    
18607>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
18609>>>>>>>        Integer iIndex
18609>>>>>>>        Handle hoDD
18609>>>>>>>        Get Data_set iFile to hoDD
18610>>>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
18613>>>>>>>        Else ;            Move -1 to iIndex
18615>>>>>>>        Function_Return iIndex
18616>>>>>>>    End_Function
18617>>>>>>>    
18617>>>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
18617>>>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
18617>>>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
18617>>>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
18617>>>>>>>    // non-zero. If it is, it always gets from the DD buffer.
18617>>>>>>>    
18617>>>>>>>    Procedure Clear
18619>>>>>>>        Boolean bOpOk
18619>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18620>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
18622>>>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
18623>>>>>>>        End
18623>>>>>>>>
18623>>>>>>>        If (bOpOk) Begin
18625>>>>>>>            Send OnPreFind DDFindClear
18626>>>>>>>        End
18626>>>>>>>>
18626>>>>>>>        Forward Send Clear
18628>>>>>>>        If (bOpOk) Begin
18630>>>>>>>            Send DefaultParentAutofinds
18631>>>>>>>            Send OnPostFind DDFindClear True
18632>>>>>>>        End
18632>>>>>>>>
18632>>>>>>>    End_Procedure
18633>>>>>>>    
18633>>>>>>>    Procedure Clear_All
18635>>>>>>>        Boolean bOpOk
18635>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18636>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
18638>>>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
18639>>>>>>>        End
18639>>>>>>>>
18639>>>>>>>        Forward Send clear_all
18641>>>>>>>        If (bOpOk) Begin
18643>>>>>>>            Send DefaultParentAutofinds
18644>>>>>>>        End
18644>>>>>>>>
18644>>>>>>>    End_Procedure
18645>>>>>>>    
18645>>>>>>>    Procedure Request_Assign Integer iFile
18647>>>>>>>        Handle hoDD
18647>>>>>>>        Boolean bFound
18647>>>>>>>        Boolean bOpOk
18647>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18648>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
18650>>>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
18651>>>>>>>        End
18651>>>>>>>>
18651>>>>>>>        
18651>>>>>>>        If (bOpOk) Begin
18653>>>>>>>            If (num_arguments=0 or iFile=0) Begin
18655>>>>>>>                Move Self to hoDD
18656>>>>>>>            End
18656>>>>>>>>
18656>>>>>>>            Else Begin
18657>>>>>>>                Get Data_Set iFile to hoDD
18658>>>>>>>            End
18658>>>>>>>>
18658>>>>>>>            If hoDD Begin
18660>>>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
18661>>>>>>>            End
18661>>>>>>>>
18661>>>>>>>        End
18661>>>>>>>>
18661>>>>>>>        
18661>>>>>>>        If (num_arguments=0) Begin
18663>>>>>>>            Forward Send Request_Assign
18665>>>>>>>        End
18665>>>>>>>>
18665>>>>>>>        Else Begin
18666>>>>>>>            Forward Send Request_Assign iFile
18668>>>>>>>        End
18668>>>>>>>>
18668>>>>>>>        
18668>>>>>>>        If (bOpOk) Begin
18670>>>>>>>            If (hoDD) Begin
18672>>>>>>>                Move (Found) to bFound
18673>>>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound
18674>>>>>>>                Move bFound to Found
18675>>>>>>>            End
18675>>>>>>>>
18675>>>>>>>        End
18675>>>>>>>>
18675>>>>>>>    End_Procedure
18676>>>>>>>    
18676>>>>>>>    
18676>>>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
18678>>>>>>>        Handle hoDD
18678>>>>>>>        Boolean bFound
18678>>>>>>>        Boolean bOpOk
18678>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18679>>>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
18680>>>>>>>        
18680>>>>>>>        If (bOpOk) Begin
18682>>>>>>>            Get Data_Set iFile to hoDD
18683>>>>>>>            If hoDD Begin
18685>>>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
18686>>>>>>>            End
18686>>>>>>>>
18686>>>>>>>        End
18686>>>>>>>>
18686>>>>>>>        
18686>>>>>>>        Forward Send Find_By_Recnum iFile iRecord
18688>>>>>>>        
18688>>>>>>>        If (bOpOk) Begin
18690>>>>>>>            If (hoDD) Begin
18692>>>>>>>                Move (Found) to bFound
18693>>>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
18694>>>>>>>                Move bFound to Found
18695>>>>>>>            End
18695>>>>>>>>
18695>>>>>>>        End
18695>>>>>>>>
18695>>>>>>>    End_Procedure
18696>>>>>>>    
18696>>>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
18698>>>>>>>        Handle hoDD
18698>>>>>>>        Boolean bFound
18698>>>>>>>        Boolean bOpOk
18698>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18699>>>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
18700>>>>>>>        
18700>>>>>>>        If (bOpOk) Begin
18702>>>>>>>            Get Data_Set iFile to hoDD
18703>>>>>>>            If hoDD Begin
18705>>>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
18706>>>>>>>            End
18706>>>>>>>>
18706>>>>>>>        End
18706>>>>>>>>
18706>>>>>>>        
18706>>>>>>>        Forward Send FindByRowId iFile riRowId
18708>>>>>>>        
18708>>>>>>>        If (bOpOk) Begin
18710>>>>>>>            If (hoDD) Begin
18712>>>>>>>                Move (Found) to bFound
18713>>>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
18714>>>>>>>                Move bFound to Found
18715>>>>>>>            End
18715>>>>>>>>
18715>>>>>>>        End
18715>>>>>>>>
18715>>>>>>>    End_Procedure
18716>>>>>>>    
18716>>>>>>>    Function FindByRowIdEx Integer iFile RowID riRowId Returns Boolean
18718>>>>>>>        Handle hoDD
18718>>>>>>>        Boolean bFound bSuccess
18718>>>>>>>        Boolean bOpOk
18718>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18719>>>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
18720>>>>>>>        
18720>>>>>>>        If (bOpOk) Begin
18722>>>>>>>            Get Data_Set iFile to hoDD
18723>>>>>>>            If hoDD Begin
18725>>>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
18726>>>>>>>            End
18726>>>>>>>>
18726>>>>>>>        End
18726>>>>>>>>
18726>>>>>>>        
18726>>>>>>>        Forward Get FindByRowIdEx iFile riRowId to bSuccess
18728>>>>>>>        
18728>>>>>>>        If (bOpOk) Begin
18730>>>>>>>            If (hoDD) Begin
18732>>>>>>>                Move (Found) to bFound
18733>>>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
18734>>>>>>>                Move bFound to Found
18735>>>>>>>            End
18735>>>>>>>>
18735>>>>>>>        End
18735>>>>>>>>
18735>>>>>>>        Function_Return bSuccess
18736>>>>>>>    End_Function
18737>>>>>>>    
18737>>>>>>>    Function FindByRowIdExNoAutoFill Integer iFile RowID riRowId Returns Boolean
18739>>>>>>>        Handle hoDD
18739>>>>>>>        Boolean bFound bSuccess
18739>>>>>>>        Boolean bOpOk
18739>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18740>>>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
18741>>>>>>>        
18741>>>>>>>        If (bOpOk) Begin
18743>>>>>>>            Get Data_Set iFile to hoDD
18744>>>>>>>            If hoDD Begin
18746>>>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
18747>>>>>>>            End
18747>>>>>>>>
18747>>>>>>>        End
18747>>>>>>>>
18747>>>>>>>        
18747>>>>>>>        Forward Get FindByRowIdExNoAutoFill iFile riRowId to bSuccess
18749>>>>>>>        
18749>>>>>>>        If (bOpOk) Begin
18751>>>>>>>            If (hoDD) Begin
18753>>>>>>>                Move (Found) to bFound
18754>>>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
18755>>>>>>>                Move bFound to Found
18756>>>>>>>            End
18756>>>>>>>>
18756>>>>>>>        End
18756>>>>>>>>
18756>>>>>>>        Function_Return bSuccess
18757>>>>>>>    End_Function
18758>>>>>>>    
18758>>>>>>>    
18758>>>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
18760>>>>>>>        Handle hoDD
18760>>>>>>>        Boolean bFound
18760>>>>>>>        Boolean bOpOk
18760>>>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
18761>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
18763>>>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
18764>>>>>>>        End
18764>>>>>>>>
18764>>>>>>>        
18764>>>>>>>        If (bOpOk) Begin
18766>>>>>>>            Get Data_Set iFile to hoDD
18767>>>>>>>            If hoDD Begin
18769>>>>>>>                Send OnPreFind of hoDD DDFindRequestFind
18770>>>>>>>            End
18770>>>>>>>>
18770>>>>>>>        End
18770>>>>>>>>
18770>>>>>>>        
18770>>>>>>>        Forward Send Request_Find eFindMode iFile iIndex
18772>>>>>>>        
18772>>>>>>>        If (bOpOk) Begin
18774>>>>>>>            If (hoDD) Begin
18776>>>>>>>                Move (Found) to bFound
18777>>>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound
18778>>>>>>>                Move bFound to Found
18779>>>>>>>            End
18779>>>>>>>>
18779>>>>>>>        End
18779>>>>>>>>
18779>>>>>>>    End_Procedure
18780>>>>>>>    
18780>>>>>>>    Procedure OnPreFind Integer eMessage
18782>>>>>>>    End_Procedure
18783>>>>>>>    
18783>>>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
18785>>>>>>>    End_Procedure
18786>>>>>>>    
18786>>>>>>>    
18786>>>>>>>    
18786>>>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
18788>>>>>>>        Boolean bInSuperFind
18788>>>>>>>        // we need to set pbInSuperFind so Entry_update in the DEOs will know that
18788>>>>>>>        // they should perform an entry_update. Superfind entry_updates have never gone through
18788>>>>>>>        // the DD's field buffer.
18788>>>>>>>        Get pbInSuperFind to bInSuperFind
18789>>>>>>>        Set pbInSuperFind to True
18790>>>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
18792>>>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
18793>>>>>>>        End
18793>>>>>>>>
18793>>>>>>>        Forward Send Request_Superfind eFindMode iFile iField
18795>>>>>>>        Set pbInSuperFind to bInSuperFind
18796>>>>>>>    End_Procedure
18797>>>>>>>    
18797>>>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
18797>>>>>>>    // Should_Save_row only filters changes in a consrained parent.
18797>>>>>>>    
18797>>>>>>>    Function Should_Save_Row Returns Boolean
18799>>>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
18799>>>>>>>        Integer iServers iServer iServerFile
18799>>>>>>>        Handle hoServerDD
18799>>>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
18801>>>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
18802>>>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
18804>>>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
18804>>>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
18804>>>>>>>            // data (with RT changes made for 17.0).
18804>>>>>>>            Get Data_Set_Server_Count to iServers
18805>>>>>>>            For iServer from 0 to (iServers-1)
18811>>>>>>>>
18811>>>>>>>                Get Data_Set_Server iServer to hoServerDD
18812>>>>>>>                Get Should_Save of hoServerDD to bShouldSave
18813>>>>>>>                If bShouldSave Begin
18815>>>>>>>                    Get Main_File of hoServerDD to iServerFile
18816>>>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
18817>>>>>>>                    If not bRelatesToConstraint Begin
18819>>>>>>>                        Function_Return True
18820>>>>>>>                    End
18820>>>>>>>>
18820>>>>>>>                End
18820>>>>>>>>
18820>>>>>>>            Loop
18821>>>>>>>>
18821>>>>>>>        End
18821>>>>>>>>
18821>>>>>>>        Function_Return bShouldSaveRow
18822>>>>>>>    End_Function
18823>>>>>>>    
18823>>>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
18823>>>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
18823>>>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
18823>>>>>>>    // used to better determine the changed status of your DDO sructure
18823>>>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
18825>>>>>>>        Boolean bShouldSave bRelatesToConstraint
18825>>>>>>>        Integer iServers iServer iServerFile
18825>>>>>>>        Handle hoServerDD
18825>>>>>>>        Get Data_Set_Server_Count to iServers
18826>>>>>>>        For iServer from 0 to (iServers-1)
18832>>>>>>>>
18832>>>>>>>            Get Data_Set_Server iServer to hoServerDD
18833>>>>>>>            Get Main_File of hoServerDD to iServerFile
18834>>>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
18835>>>>>>>            If bRelatesToConstraint Begin
18837>>>>>>>                Get Should_Save of hoServerDD to bShouldSave
18838>>>>>>>                If bShouldSave Begin
18840>>>>>>>                    Function_Return True
18841>>>>>>>                End
18841>>>>>>>>
18841>>>>>>>            End
18841>>>>>>>>
18841>>>>>>>        Loop
18842>>>>>>>>
18842>>>>>>>        Function_Return False
18843>>>>>>>    End_Function
18844>>>>>>>    
18844>>>>>>>    Function FindServerInformationElement Integer iFile Returns Integer
18846>>>>>>>        tDDServerInformation[] ServerInformation
18846>>>>>>>        tDDServerInformation[] ServerInformation
18847>>>>>>>        tDDServerInformation ServerSearch
18847>>>>>>>        tDDServerInformation ServerSearch
18847>>>>>>>        Integer iIndex
18847>>>>>>>        Move iFile to ServerSearch.iParent
18848>>>>>>>        Get pServerInformation to ServerInformation
18849>>>>>>>        Function_Return (SearchArray(ServerSearch,ServerInformation))
18850>>>>>>>    End_Function
18851>>>>>>>    
18851>>>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
18853>>>>>>>        tDDServerInformation[] ServerInformation
18853>>>>>>>        tDDServerInformation[] ServerInformation
18854>>>>>>>        Integer iIndex
18854>>>>>>>        Handle hoDDO
18854>>>>>>>        
18854>>>>>>>        Get pServerInformation to ServerInformation
18855>>>>>>>        Get FindServerInformationElement iFile to iIndex
18856>>>>>>>        If (iIndex=-1) Begin
18858>>>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
18859>>>>>>>            Move iFile to ServerInformation[iIndex].iParent
18860>>>>>>>            // defaults must always be false!
18860>>>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
18861>>>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
18862>>>>>>>            Move False to ServerInformation[iIndex].bNoCascadeDelete
18863>>>>>>>            Move False to ServerInformation[iIndex].bCascadeDeleteNullTheParent
18864>>>>>>>        End
18864>>>>>>>>
18864>>>>>>>        
18864>>>>>>>        If (eParam=0) Begin
18866>>>>>>>            If (bValue<>ServerInformation[iIndex].bAllowNullParent) Begin
18868>>>>>>>                Move bValue to ServerInformation[iIndex].bAllowNullParent
18869>>>>>>>                Send AdjustDeleteValidateStructure iFile
18870>>>>>>>            End
18870>>>>>>>>
18870>>>>>>>        End
18870>>>>>>>>
18870>>>>>>>        Else If (eParam=1) Begin
18873>>>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
18874>>>>>>>        End
18874>>>>>>>>
18874>>>>>>>        Else If (eParam=2) Begin
18877>>>>>>>            Move bValue to ServerInformation[iIndex].bNoCascadeDelete
18878>>>>>>>        End
18878>>>>>>>>
18878>>>>>>>        Else Begin // (3)
18879>>>>>>>            If (bValue<>ServerInformation[iIndex].bCascadeDeleteNullTheParent) Begin
18881>>>>>>>                Move bValue to ServerInformation[iIndex].bCascadeDeleteNullTheParent
18882>>>>>>>                Send AdjustDeleteValidateStructure iFile
18883>>>>>>>            End
18883>>>>>>>>
18883>>>>>>>        End
18883>>>>>>>>
18883>>>>>>>        Set pServerInformation to ServerInformation
18884>>>>>>>    End_Procedure
18885>>>>>>>    
18885>>>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
18887>>>>>>>        Boolean bValue
18887>>>>>>>        tDDServerInformation[] ServerInformation
18887>>>>>>>        tDDServerInformation[] ServerInformation
18888>>>>>>>        Integer iIndex
18888>>>>>>>        Get pServerInformation to ServerInformation
18889>>>>>>>        Get FindServerInformationElement iFile to iIndex
18890>>>>>>>        // when not found in array, we want to make sure that we return false. Therefore
18890>>>>>>>        // false should always be the default.
18890>>>>>>>        If (iIndex<>-1) Begin
18892>>>>>>>            If (eParam=0) Begin
18894>>>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
18895>>>>>>>            End
18895>>>>>>>>
18895>>>>>>>            Else If (eParam=1) Begin
18898>>>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
18899>>>>>>>            End
18899>>>>>>>>
18899>>>>>>>            Else If (eParam=2) Begin
18902>>>>>>>                Move ServerInformation[iIndex].bNoCascadeDelete to bValue
18903>>>>>>>            End
18903>>>>>>>>
18903>>>>>>>            Else Begin
18904>>>>>>>                Move ServerInformation[iIndex].bCascadeDeleteNullTheParent to bValue
18905>>>>>>>            End
18905>>>>>>>>
18905>>>>>>>        End
18905>>>>>>>>
18905>>>>>>>        Function_Return bValue
18906>>>>>>>    End_Function
18907>>>>>>>    
18907>>>>>>>    Procedure AdjustDeleteValidateStructure2
18909>>>>>>>        Integer iCount i
18909>>>>>>>        Handle hoDDO
18909>>>>>>>        Boolean bVisited
18909>>>>>>>        Set Visited_State to True
18910>>>>>>>        Set Cascade_Delete_Structure_Validated_State to False
18911>>>>>>>        Get Data_Set_Server_Count to iCount
18912>>>>>>>        For i from 0 to (iCount-1)
18918>>>>>>>>
18918>>>>>>>            Get Data_Set_Server i to hoDDO
18919>>>>>>>            Get Visited_State of hoDDO to bVisited
18920>>>>>>>            If (not(bVisited)) Begin
18922>>>>>>>                Send AdjustDeleteValidateStructure2 of hoDDO
18923>>>>>>>            End
18923>>>>>>>>
18923>>>>>>>        Loop
18924>>>>>>>>
18924>>>>>>>    End_Procedure
18925>>>>>>>    
18925>>>>>>>    // This is called in the unlikely case that NullParent/CascadeNull are set dynamically. It
18925>>>>>>>    // tells the parent DDO to recheck its validate-delete structure and it tells all ancestors of
18925>>>>>>>    // this parent to do the same. If called while DDOs are being created (via a class setting) there
18925>>>>>>>    // will not be a connected parent for iFile, which is fine.
18925>>>>>>>    Procedure AdjustDeleteValidateStructure Integer iFile
18927>>>>>>>        Handle hoDDO
18927>>>>>>>        Get Which_Data_Set iFile to hoDDO
18928>>>>>>>        If hoDDO Begin
18930>>>>>>>            Send Initialize_Visited of hoDDO False False
18931>>>>>>>            Send AdjustDeleteValidateStructure2 of hoDDO
18932>>>>>>>        End
18932>>>>>>>>
18932>>>>>>>    End_Procedure
18933>>>>>>>    
18933>>>>>>>    // Used to add a null parent to the list of parents that allow this
18933>>>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
18935>>>>>>>        Send AddServerData iParent 0 bAllowed
18936>>>>>>>    End_Procedure
18937>>>>>>>    
18937>>>>>>>    // returns true if null parent allowed for this parent file
18937>>>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
18939>>>>>>>        Boolean bValue
18939>>>>>>>        Get GetServerData iParent 0 to bValue
18940>>>>>>>        Function_Return bValue
18941>>>>>>>    End_Function
18942>>>>>>>    
18942>>>>>>>    // returns true if null parent allowed for this parent file. This is the function
18942>>>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
18942>>>>>>>    // to determine if a null parent is allowed
18942>>>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
18944>>>>>>>        Boolean bAllowed
18944>>>>>>>        Get ParentNullAllowed iServer to bAllowed
18945>>>>>>>        Function_Return bAllowed
18946>>>>>>>    End_Function
18947>>>>>>>    
18947>>>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
18949>>>>>>>        Send AddServerData iParent 1 bAllowed
18950>>>>>>>    End_Procedure
18951>>>>>>>    
18951>>>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
18953>>>>>>>        Boolean bValue
18953>>>>>>>        Get GetServerData iParent 1 to bValue
18954>>>>>>>        Function_Return bValue
18955>>>>>>>    End_Function
18956>>>>>>>    
18956>>>>>>>    
18956>>>>>>>    Procedure Set CascadeDeleteAllowed Integer iParent Boolean bAllowed
18958>>>>>>>        Send AddServerData iParent 2 (not(bAllowed))
18959>>>>>>>    End_Procedure
18960>>>>>>>    
18960>>>>>>>    Function CascadeDeleteAllowed Integer iParent Returns Boolean
18962>>>>>>>        Boolean bValue
18962>>>>>>>        Get GetServerData iParent 2 to bValue // note that False=allowed
18963>>>>>>>        Function_Return (not(bValue))
18964>>>>>>>    End_Function
18965>>>>>>>    
18965>>>>>>>    Function IsCascadeDeleteAllowed Integer iServer Returns Boolean
18967>>>>>>>        Boolean bAllowed
18967>>>>>>>        Get CascadeDeleteAllowed iServer to bAllowed
18968>>>>>>>        Function_Return bAllowed
18969>>>>>>>    End_Function
18970>>>>>>>    
18970>>>>>>>    Procedure Set CascadeDeleteNull Integer iParent Boolean bAllowed
18972>>>>>>>        Send AddServerData iParent 3 bAllowed
18973>>>>>>>    End_Procedure
18974>>>>>>>    
18974>>>>>>>    Function CascadeDeleteNull Integer iParent Returns Boolean
18976>>>>>>>        Boolean bValue
18976>>>>>>>        Get GetServerData iParent 3 to bValue
18977>>>>>>>        Function_Return bValue
18978>>>>>>>    End_Function
18979>>>>>>>    
18979>>>>>>>    Function IsCascadeDeleteNull Integer iServer Returns Boolean
18981>>>>>>>        Boolean bAllowed
18981>>>>>>>        Get CascadeDeleteNull iServer to bAllowed
18982>>>>>>>        Function_Return bAllowed
18983>>>>>>>    End_Function
18984>>>>>>>    
18984>>>>>>>    // return an array with the server path from this DD to passed top. The top will be
18984>>>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
18984>>>>>>>    // this process the byref hoDDs array MUST be empty
18984>>>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
18986>>>>>>>        Handle hoServer
18986>>>>>>>        Integer iServers iServer
18986>>>>>>>        If (hoTop=Self) Begin
18988>>>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
18989>>>>>>>            Procedure_Return
18990>>>>>>>        End
18990>>>>>>>>
18990>>>>>>>        Get Data_Set_Server_Count to iServers
18991>>>>>>>        For iServer from 0 to (iServers-1)
18997>>>>>>>>
18997>>>>>>>            Get Data_Set_Server iServer to hoServer
18998>>>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
18999>>>>>>>            If (SizeOfArray(hoDDs)) Begin
19001>>>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
19002>>>>>>>                Procedure_Return
19003>>>>>>>            End
19003>>>>>>>>
19003>>>>>>>        Loop
19004>>>>>>>>
19004>>>>>>>    End_Procedure
19005>>>>>>>    
19005>>>>>>>    // returns True if the value passed can be considered empty for this field.
19005>>>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
19007>>>>>>>        Integer iFile iDataType iValidationType
19007>>>>>>>        Number nNum
19007>>>>>>>        Boolean bInvalid bChecked
19007>>>>>>>        Get Main_File to iFile
19008>>>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
19011>>>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
19012>>>>>>>        If bInvalid Begin
19014>>>>>>>            Function_Return True
19015>>>>>>>        End
19015>>>>>>>>
19015>>>>>>>        
19015>>>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
19015>>>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
19016>>>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
19018>>>>>>>            Get Field_Select_State iField to bChecked
19019>>>>>>>            If not bChecked Begin
19021>>>>>>>                Function_Return True
19022>>>>>>>            End
19022>>>>>>>>
19022>>>>>>>        End
19022>>>>>>>>
19022>>>>>>>        
19022>>>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
19024>>>>>>>            Move "" to sValue
19025>>>>>>>        End
19025>>>>>>>>
19025>>>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
19028>>>>>>>            Move "" to sValue
19029>>>>>>>        End
19029>>>>>>>>
19029>>>>>>>        Function_Return (sValue="")
19030>>>>>>>    End_Function
19031>>>>>>>    
19031>>>>>>>    
19031>>>>>>>    // is the record committed
19031>>>>>>>    Function IsCommitted Returns Boolean
19033>>>>>>>        Boolean bHasRecord
19033>>>>>>>        Get HasRecord to bHasRecord
19034>>>>>>>        Function_Return bHasRecord
19035>>>>>>>    End_Function
19036>>>>>>>    
19036>>>>>>>    // is the field committed. It assumes the record is already committed
19036>>>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
19038>>>>>>>        Boolean bIsCommitted
19038>>>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
19039>>>>>>>        Function_Return bIsCommitted
19040>>>>>>>    End_Function
19041>>>>>>>    
19041>>>>>>>    // is a parent change allowed for this parent server.
19041>>>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
19043>>>>>>>        Boolean bNoSwitch
19043>>>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
19044>>>>>>>        Function_Return (not(bNoSwitch))
19045>>>>>>>    End_Function
19046>>>>>>>    
19046>>>>>>>    // Are we allowed to find with this file when it is used as a parent?
19046>>>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
19046>>>>>>>    //  The rules for each child are switching is ok If:
19046>>>>>>>    // 1. the child is not committed,
19046>>>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
19046>>>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
19046>>>>>>>    //
19046>>>>>>>    Function AllowParentFind Returns Boolean
19048>>>>>>>        Integer iClients iClient iMain
19048>>>>>>>        Handle hoChild
19048>>>>>>>        Boolean bIsCommitted
19048>>>>>>>        Get Data_Set_Client_Count to iClients
19049>>>>>>>        For iClient from 0 to (iClients-1)
19055>>>>>>>>
19055>>>>>>>            Get Data_Set_Client iClient to hoChild
19056>>>>>>>            Get IsCommitted of hoChild to bIsCommitted
19057>>>>>>>            If bIsCommitted Begin
19059>>>>>>>                Get Main_File to iMain
19060>>>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
19061>>>>>>>                If not bIsCommitted Begin
19063>>>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
19064>>>>>>>                    If (not(bIsCommitted)) Begin
19066>>>>>>>                        Function_Return False
19067>>>>>>>                    End
19067>>>>>>>>
19067>>>>>>>                End
19067>>>>>>>>
19067>>>>>>>            End
19067>>>>>>>>
19067>>>>>>>        Loop
19068>>>>>>>>
19068>>>>>>>        Function_Return True
19069>>>>>>>    End_Function
19070>>>>>>>    
19070>>>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
19070>>>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
19070>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
19072>>>>>>>        
19072>>>>>>>        Integer iIndex iMain
19072>>>>>>>        Handle  hoOwner
19072>>>>>>>        Boolean bOk
19072>>>>>>>        
19072>>>>>>>        Get File_Field_Index iFile iField to iIndex
19073>>>>>>>        If (iIndex=-1)  Begin
19075>>>>>>>            Procedure_Return
19076>>>>>>>        End
19076>>>>>>>>
19076>>>>>>>        Get Main_File to iMain
19077>>>>>>>        If (iMain<>iFile) Begin
19079>>>>>>>            Get Which_Data_Set iFile to hoOwner
19080>>>>>>>            If hoOwner Begin
19082>>>>>>>                Get AllowParentFind of hoOwner to bOk
19083>>>>>>>                If not bOk Begin
19085>>>>>>>                    Procedure_Return
19086>>>>>>>                End
19086>>>>>>>>
19086>>>>>>>            End
19086>>>>>>>>
19086>>>>>>>        End
19086>>>>>>>>
19086>>>>>>>        
19086>>>>>>>        If not bDeferred Begin
19088>>>>>>>            Send Refind_Records // make sure the buffers are correct before the find
19089>>>>>>>        End
19089>>>>>>>>
19089>>>>>>>        
19089>>>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
19091>>>>>>>    End_Procedure
19092>>>>>>>    
19092>>>>>>>    
19092>>>>>>>    Function Field_CommitNoEnterOnIndex Integer iField Returns Boolean
19094>>>>>>>        Function_Return False
19095>>>>>>>    End_Function
19096>>>>>>>    
19096>>>>>>>    // Return the committed options for this field based on the committed status or this record,
19096>>>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
19096>>>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
19098>>>>>>>        Boolean bIsCommitted bNoEnter
19098>>>>>>>        Integer iNewOpts iIndex
19098>>>>>>>        Handle hoOwner
19098>>>>>>>        
19098>>>>>>>        Get Which_Data_Set iFile to hoOwner
19099>>>>>>>        If not hoOwner ;            Function_Return 0
19102>>>>>>>        
19102>>>>>>>        Get File_Field_Index iFile iField to iIndex
19103>>>>>>>        Get IsCommitted of hoOwner iField to bIsCommitted
19104>>>>>>>        If bIsCommitted Begin
19106>>>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
19107>>>>>>>            If bIsCommitted Begin
19109>>>>>>>                Move True to bNoEnter
19110>>>>>>>                If (iIndex<>-1) Begin
19112>>>>>>>                    Get Field_CommitNoEnterOnIndex iField to bNoEnter
19113>>>>>>>                End
19113>>>>>>>>
19113>>>>>>>                // if committed, it is noput and, if non-indexed, also noenter
19113>>>>>>>                Move (If(bNoEnter,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
19114>>>>>>>            End
19114>>>>>>>>
19114>>>>>>>        End
19114>>>>>>>>
19114>>>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
19114>>>>>>>        // that this field is used for finding.
19114>>>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
19116>>>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
19117>>>>>>>            If not bIsCommitted Begin
19119>>>>>>>                Move DD_DISPLAYONLY to iNewOpts
19120>>>>>>>            End
19120>>>>>>>>
19120>>>>>>>        End
19120>>>>>>>>
19120>>>>>>>        
19120>>>>>>>        Function_Return iNewOpts
19121>>>>>>>    End_Function
19122>>>>>>>    
19122>>>>>>>    // Returns the current field-field options based on regular options, foreign field status
19122>>>>>>>    // plus committed record status
19122>>>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
19124>>>>>>>        Integer iCOpts iFOpts
19124>>>>>>>        If (iFile=0) Begin
19126>>>>>>>            Function_Return 0
19127>>>>>>>        End
19127>>>>>>>>
19127>>>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
19128>>>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
19129>>>>>>>        Function_Return (iFOpts ior iCOpts)
19130>>>>>>>    End_Function
19131>>>>>>>    
19131>>>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
19133>>>>>>>        tDDRemembered[] DefaultValues
19133>>>>>>>        tDDRemembered[] DefaultValues
19134>>>>>>>        tDDRemembered SearchItem
19134>>>>>>>        tDDRemembered SearchItem
19134>>>>>>>        Integer iIndex
19134>>>>>>>        Get pDDDefaults to DefaultValues
19135>>>>>>>        Move iField to SearchItem.iField
19136>>>>>>>        Move (SearchArray(SearchItem,DefaultValues)) to iIndex
19137>>>>>>>        Function_Return iIndex
19138>>>>>>>    End_Function
19139>>>>>>>    
19139>>>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
19139>>>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
19139>>>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
19139>>>>>>>    // passed value as the default
19139>>>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
19141>>>>>>>        tDDRemembered[] DefaultValues
19141>>>>>>>        tDDRemembered[] DefaultValues
19142>>>>>>>        Integer iIndex
19142>>>>>>>        Boolean bNull
19142>>>>>>>        Get DDRememberedFieldIndex iField to iIndex
19143>>>>>>>        Get pDDDefaults to DefaultValues
19144>>>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
19146>>>>>>>            Get IsEmptyField iField sValue to bNull
19147>>>>>>>        End
19147>>>>>>>>
19147>>>>>>>        If (not(bNull)) Begin
19149>>>>>>>            If (iIndex=-1) Begin
19151>>>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
19152>>>>>>>                Move iField to DefaultValues[iIndex].iField
19153>>>>>>>            End
19153>>>>>>>>
19153>>>>>>>            Move sValue to DefaultValues[iIndex].sDefault
19154>>>>>>>            Set pDDDefaults to DefaultValues
19155>>>>>>>        End
19155>>>>>>>>
19155>>>>>>>        Else If  (iIndex<>-1) Begin
19158>>>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
19159>>>>>>>        End
19159>>>>>>>>
19159>>>>>>>    End_Procedure
19160>>>>>>>    
19160>>>>>>>    // get the remembered value as per rules above
19160>>>>>>>    Function Field_RememberedValue Integer iField Returns String
19162>>>>>>>        tDDRemembered[] DefaultValues
19162>>>>>>>        tDDRemembered[] DefaultValues
19163>>>>>>>        Integer iIndex
19163>>>>>>>        Get DDRememberedFieldIndex iField to iIndex
19164>>>>>>>        If (iIndex<>-1) Begin
19166>>>>>>>            Get pDDDefaults to DefaultValues
19167>>>>>>>            Function_Return DefaultValues[iIndex].sDefault
19168>>>>>>>        End
19168>>>>>>>>
19168>>>>>>>        Function_Return ''
19169>>>>>>>    End_Function
19170>>>>>>>    
19170>>>>>>>    Procedure AssignDynamicDefaults
19172>>>>>>>        Integer iField iFields iFile
19172>>>>>>>        tDDRemembered[] DefaultValues
19172>>>>>>>        tDDRemembered[] DefaultValues
19173>>>>>>>        Boolean bMain
19173>>>>>>>        String sValue
19173>>>>>>>        
19173>>>>>>>        Get Main_File to iFile
19174>>>>>>>        Get pDDDefaults to DefaultValues
19175>>>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
19176>>>>>>>        For iField from 0 to (iFields-1)
19182>>>>>>>>
19182>>>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
19184>>>>>>>                If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
19186>>>>>>>                    Move DefaultValues[iField].sLastValue to sValue
19187>>>>>>>                End
19187>>>>>>>>
19187>>>>>>>                Else Begin
19188>>>>>>>                    Move DefaultValues[iField].sDefault to sValue
19189>>>>>>>                End
19189>>>>>>>>
19189>>>>>>>                Set Field_Changed_Value DefaultValues[iField].iField to sValue
19190>>>>>>>            End
19190>>>>>>>>
19190>>>>>>>        Loop
19191>>>>>>>>
19191>>>>>>>    End_Procedure
19192>>>>>>>    
19192>>>>>>>    // Clears all remembered defaults for this DD.
19192>>>>>>>    Procedure ClearRememberedDefaults
19194>>>>>>>        tDDRemembered[] DefaultValues
19194>>>>>>>        tDDRemembered[] DefaultValues
19195>>>>>>>        Set pDDDefaults to DefaultValues
19196>>>>>>>    End_Procedure
19197>>>>>>>    
19197>>>>>>>    Procedure PrivateClearAllRememberedDefaults
19199>>>>>>>        Integer iCount iMax
19199>>>>>>>        Handle hoDD
19199>>>>>>>        Boolean bVisisted
19199>>>>>>>        
19199>>>>>>>        Set Visited_State to True
19200>>>>>>>        
19200>>>>>>>        Get Data_Set_Server_Count to iMax
19201>>>>>>>        Decrement iMax
19202>>>>>>>        For iCount from 0 to iMax
19208>>>>>>>>
19208>>>>>>>            Get Data_Set_Server iCount to hoDD
19209>>>>>>>            Get Visited_State of hoDD to bVisisted
19210>>>>>>>            If not (bVisisted) Begin
19212>>>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
19213>>>>>>>            End
19213>>>>>>>>
19213>>>>>>>        Loop
19214>>>>>>>>
19214>>>>>>>        
19214>>>>>>>        Send ClearRememberedDefaults
19215>>>>>>>        
19215>>>>>>>        Get Data_Set_Client_Count to iMax
19216>>>>>>>        Decrement iMax
19217>>>>>>>        For iCount from 0 to iMax
19223>>>>>>>>
19223>>>>>>>            Get Data_Set_Client iCount to hoDD
19224>>>>>>>            Get Visited_State of hoDD to bVisisted
19225>>>>>>>            If not (bVisisted) Begin
19227>>>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
19228>>>>>>>            End
19228>>>>>>>>
19228>>>>>>>        Loop
19229>>>>>>>>
19229>>>>>>>        
19229>>>>>>>    End_Procedure
19230>>>>>>>    
19230>>>>>>>    // Clears all remembered defaults for all DDs in this structure.
19230>>>>>>>    Procedure ClearAllRememberedDefaults
19232>>>>>>>        Send InitializeAllVisited
19233>>>>>>>        Send PrivateClearAllRememberedDefaults
19234>>>>>>>    End_Procedure
19235>>>>>>>    
19235>>>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
19235>>>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
19235>>>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
19235>>>>>>>    Procedure DefaultParentAutofinds
19237>>>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
19237>>>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
19237>>>>>>>        String sValue
19237>>>>>>>        Handle hoServer
19237>>>>>>>        Get Data_Set_Server_Count to iServers
19238>>>>>>>        For i from 0 to (iServers-1)
19244>>>>>>>>
19244>>>>>>>            Get Data_Set_Server i to hoServer
19245>>>>>>>            Get Main_File of hoServer to iFile
19246>>>>>>>            Get IsRelatesToConstrained iFile to bRelates
19247>>>>>>>            // never autofind on a relates-to constraining parent
19247>>>>>>>            If not (bRelates) Begin
19249>>>>>>>                
19249>>>>>>>                Get Field_Count of hoServer to iFields
19250>>>>>>>                Move False to bDoAutoFind
19251>>>>>>>                Move 1 to iField
19252>>>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
19256>>>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
19259>>>>>>>                    If (iIndex>0) Begin
19261>>>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
19262>>>>>>>                        If bDoAutoFind Begin
19264>>>>>>>                            Get Field_Current_Value of hoServer iField to sValue
19265>>>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
19266>>>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
19267>>>>>>>                            If bDoAutoFind Begin
19269>>>>>>>                                Get File_Field_Options iFile iField to iOpts
19270>>>>>>>                                // if this is a retain or retainall we don't do this because we want
19270>>>>>>>                                // to maintain backwards compatibility
19270>>>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                    not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
19271>>>>>>>                                If bDoAutoFind Begin
19273>>>>>>>                                    Send File_Field_Default_AutoFind iFile iField
19274>>>>>>>                                    Set Changed_State to False // clears parent changed state
19275>>>>>>>                                End
19275>>>>>>>>
19275>>>>>>>                            End
19275>>>>>>>>
19275>>>>>>>                        End
19275>>>>>>>>
19275>>>>>>>                    End
19275>>>>>>>>
19275>>>>>>>                    Increment iField
19276>>>>>>>                Loop
19277>>>>>>>>
19277>>>>>>>                
19277>>>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
19277>>>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
19277>>>>>>>                If not bDoAutoFind Begin
19279>>>>>>>                    Send DefaultParentAutofinds of hoServer
19280>>>>>>>                End
19280>>>>>>>>
19280>>>>>>>            End
19280>>>>>>>>
19280>>>>>>>        Loop
19281>>>>>>>>
19281>>>>>>>    End_Procedure
19282>>>>>>>    
19282>>>>>>>    // Set this DD to be an alias, passing the file number of the alias
19282>>>>>>>    // This can only be called once per instance and the Main_File must already have been set
19282>>>>>>>    // most likely in a superclass.
19282>>>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
19282>>>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
19282>>>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
19282>>>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
19282>>>>>>>    // studio it will set these two properties.
19282>>>>>>>    // This means you must set any required relationships yourself
19282>>>>>>>    Procedure Set Alias_File Integer iTable
19284>>>>>>>        Integer iMain iMaster iFieldsM iFieldsA
19284>>>>>>>        Get Main_File to iMain
19285>>>>>>>        Get MasterForAlias to iMaster
19286>>>>>>>        
19286>>>>>>>        If (iTable=0 and iMaster) Begin
19288>>>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
19289>>>>>>>>
19289>>>>>>>            Procedure_Return
19290>>>>>>>        End
19290>>>>>>>>
19290>>>>>>>        If (iTable=iMain) Begin
19292>>>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
19293>>>>>>>>
19293>>>>>>>            Procedure_Return
19294>>>>>>>        End
19294>>>>>>>>
19294>>>>>>>        If (iMaster) Begin
19296>>>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
19297>>>>>>>>
19297>>>>>>>            Procedure_Return
19298>>>>>>>        End
19298>>>>>>>>
19298>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
19301>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
19304>>>>>>>        If (iFieldsA<>iFieldsM) Begin
19306>>>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
19307>>>>>>>>
19307>>>>>>>            Procedure_Return
19308>>>>>>>        End
19308>>>>>>>>
19308>>>>>>>        
19308>>>>>>>        Set piMasterTable to iMain
19309>>>>>>>        Set Main_File to iTable
19310>>>>>>>        Send DefineAsAlias
19311>>>>>>>    End_Procedure
19312>>>>>>>    
19312>>>>>>>    Procedure DefineAsAlias
19314>>>>>>>        Integer i iFile
19314>>>>>>>        
19314>>>>>>>        // We expect he developer to set these properties to True
19314>>>>>>>        //Set pbUseDDRelates to True
19314>>>>>>>        //Set pbNoCascadeDeleteStrict to True
19314>>>>>>>        
19314>>>>>>>        Send ClearDDRelates
19315>>>>>>>        Get Client_File_Count to i
19316>>>>>>>        While i
19320>>>>>>>            Decrement i
19321>>>>>>>            Get Client_File i to iFile
19322>>>>>>>            Send Remove_Client_File iFile
19323>>>>>>>        Loop
19324>>>>>>>>
19324>>>>>>>        Get Server_File_Count to i
19325>>>>>>>        While i
19329>>>>>>>            Decrement i
19330>>>>>>>            Get Server_File i to iFile
19331>>>>>>>            Send Remove_Server_File iFile
19332>>>>>>>        Loop
19333>>>>>>>>
19333>>>>>>>    End_Procedure
19334>>>>>>>    
19334>>>>>>>    Function MasterForAlias Returns Integer
19336>>>>>>>        Integer iMaster
19336>>>>>>>        Get piMasterTable to iMaster
19337>>>>>>>        Function_Return iMaster
19338>>>>>>>    End_Function
19339>>>>>>>    
19339>>>>>>>    Function IsAlias Returns Boolean
19341>>>>>>>        Integer iMaster
19341>>>>>>>        Get piMasterTable to iMaster
19342>>>>>>>        Function_Return (iMaster<>0)
19343>>>>>>>    End_Function
19344>>>>>>>    
19344>>>>>>>    
19344>>>>>>>    Procedure OnSaveRecord
19346>>>>>>>    End_Procedure
19347>>>>>>>    
19347>>>>>>>    Procedure StoreDefaultSQLFilters
19349>>>>>>>        Handle hoSQLHelper
19349>>>>>>>        Get phoSQLHelper to hoSQLHelper
19350>>>>>>>        Send StoreDefaultSQLFilters of hoSQLHelper
19351>>>>>>>    End_Procedure
19352>>>>>>>    
19352>>>>>>>    Procedure RestoreDefaultSQLFilters
19354>>>>>>>        Handle hoSQLHelper
19354>>>>>>>        Get phoSQLHelper to hoSQLHelper
19355>>>>>>>        Send RestoreDefaultSQLFilters of hoSQLHelper
19356>>>>>>>    End_Procedure
19357>>>>>>>    
19357>>>>>>>    Procedure ApplySQLFilterStr String sFilter
19359>>>>>>>        Handle hoSQLHelper
19359>>>>>>>        Get phoSQLHelper to hoSQLHelper
19360>>>>>>>        Send ApplySQLFilterStr of hoSQLHelper sFilter
19361>>>>>>>    End_Procedure
19362>>>>>>>    
19362>>>>>>>    
19362>>>>>>>    Procedure ApplySQLFilter
19364>>>>>>>        String sNewFilter sOldFilter
19364>>>>>>>        Boolean bApplyGlobalSQLFilters bOldFilterActive
19364>>>>>>>        Handle hoSQLHelper
19364>>>>>>>        Get phoSQLHelper to hoSQLHelper
19365>>>>>>>        Get psSQLFilter to sNewFilter
19366>>>>>>>        // if we have am active  table filter we can either ignore it or and it to the where clause
19366>>>>>>>        // pbApplyGlobalSQLFilters determines what to do.
19366>>>>>>>        Get pbApplyGlobalSQLFilters to bApplyGlobalSQLFilters
19367>>>>>>>        Get pbOldFilterActive to bOldFilterActive
19368>>>>>>>        If (bApplyGlobalSQLFilters and bOldFilterActive) Begin
19370>>>>>>>            Get psOldFilter to sOldFilter
19371>>>>>>>            Get SQLStrAppend sOldFilter sNewFilter to sNewFilter
19372>>>>>>>        End
19372>>>>>>>>
19372>>>>>>>        Send ApplySQLFilterStr of hoSQLHelper sNewFilter
19373>>>>>>>    End_Procedure
19374>>>>>>>    
19374>>>>>>>    Procedure Data_Set_PreFind
19376>>>>>>>        Boolean bUseDDSQLFilters
19376>>>>>>>        String sOldDDFilter
19376>>>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
19377>>>>>>>        If bUseDDSQLFilters Begin
19379>>>>>>>            
19379>>>>>>>            Send StoreDefaultSQLFilters
19380>>>>>>>            
19380>>>>>>>            // this can get called during cascade deletes. In such a case we will
19380>>>>>>>            // never explicitly not apply an SQL filters because it could violate relational integrity
19380>>>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
19382>>>>>>>                Get psSQLFilter to sOldDDFilter
19383>>>>>>>                Set psSQLFilter to "" // make sure there is no filter applied
19384>>>>>>>            End
19384>>>>>>>>
19384>>>>>>>            
19384>>>>>>>            Send ApplySQLFilter
19385>>>>>>>            
19385>>>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
19387>>>>>>>                Set psSQLFilter to sOldDDFilter
19388>>>>>>>            End
19388>>>>>>>>
19388>>>>>>>        End
19388>>>>>>>>
19388>>>>>>>    End_Procedure
19389>>>>>>>    
19389>>>>>>>    Procedure Data_Set_PostFind
19391>>>>>>>        Boolean bUseDDSQLFilters
19391>>>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
19392>>>>>>>        If bUseDDSQLFilters Begin
19394>>>>>>>            Send RestoreDefaultSQLFilters
19395>>>>>>>        End
19395>>>>>>>>
19395>>>>>>>    End_Procedure
19396>>>>>>>    
19396>>>>>>>    
19396>>>>>>>    // returns active constraints in atConstraintDef array.
19396>>>>>>>    // Should be called after constraints are built
19396>>>>>>>    // typically right after Rebuild_Constraints
19396>>>>>>>    
19396>>>>>>>    Function DDOConstraints Returns tConstraintDef[]
19398>>>>>>>        tConstraintDef[] Constraints
19398>>>>>>>        tConstraintDef[] Constraints
19399>>>>>>>        Integer i iCount i1
19399>>>>>>>        Get DATA_SET_CONSTRAINT_COUNT to iCount
19400>>>>>>>        For i from 0 to (iCount-1)
19406>>>>>>>>
19406>>>>>>>            Get DATA_SET_CONSTRAINT_INFO i 0 to i1 // type / mode
19407>>>>>>>            Move (Hi(i1)) to  Constraints[i].eType
19408>>>>>>>            Move (Low(i1)) to  Constraints[i].eMode
19409>>>>>>>            Get DATA_SET_CONSTRAINT_INFO i 1 to i1 // file / field
19410>>>>>>>            Move (Hi(i1)) to  Constraints[i].iFile
19411>>>>>>>            Move (Low(i1)) to  Constraints[i].iField
19412>>>>>>>            Get DATA_SET_CONSTRAINT_INFO i 2 to i1 // other file /field
19413>>>>>>>            Move (Hi(i1)) to  Constraints[i].iOtherFile
19414>>>>>>>            Move (Low(i1)) to  Constraints[i].iOtherField
19415>>>>>>>            Get DATA_SET_CONSTRAINT_INFO_Value i  to Constraints[i].sValue
19416>>>>>>>        Loop
19417>>>>>>>>
19417>>>>>>>        Function_Return Constraints
19418>>>>>>>    End_Function
19419>>>>>>>    
19419>>>>>>>    // returns constraint finding information about the current find. This tells us what kinds
19419>>>>>>>    // of constraint find "expressions" are used. This will actually do a cosntrained find
19419>>>>>>>    // initialization much like Establish_Find_Direction, which means it can change the values in
19419>>>>>>>    // the file buffer to assist with a jump-in.
19419>>>>>>>    Function DDOConstraintFindMeta Integer eMode Integer iOrder Returns tDDOConstraintFindMeta
19421>>>>>>>        tDDOConstraintFindMeta FindMeta
19421>>>>>>>        tDDOConstraintFindMeta FindMeta
19421>>>>>>>        Integer i
19421>>>>>>>        Get Data_Set_Constraint_Exps eMode iOrder to i
19422>>>>>>>        Move (Hi(i)) to FindMeta.iJumpInSegments
19423>>>>>>>        Move (i iand CONST_EXP_JUMPOUT) to FindMeta.bJumpOut
19424>>>>>>>        Move (i iand CONST_EXP_PRE_RELATE) to FindMeta.bPreRelate
19425>>>>>>>        Move (i iand CONST_EXP_POST_RELATE) to FindMeta.bPostRelate
19426>>>>>>>        Function_Return FindMeta
19427>>>>>>>    End_Function
19428>>>>>>>    
19428>>>>>>>    // this tells you if the current find or read requires a relate to evaluate the DF constraint.
19428>>>>>>>    // If false you could use this to set no_relate_state to false for the find/read process and then
19428>>>>>>>    // restore it when complete. Be careful using this.
19428>>>>>>>    Function DDOConstraintNeedsRelate Integer iOrder Returns Boolean
19430>>>>>>>        tDDOConstraintFindMeta FindMeta
19430>>>>>>>        tDDOConstraintFindMeta FindMeta
19430>>>>>>>        Get DDOConstraintFindMeta (GE) iOrder to FindMeta
19431>>>>>>>        Function_Return FindMeta.bPostRelate
19432>>>>>>>    End_Function
19433>>>>>>>    
19433>>>>>>>    // returns true if this table supports SQL filter interface
19433>>>>>>>    Function SupportsSQLFilters Returns Boolean
19435>>>>>>>        Boolean bSupports
19435>>>>>>>        Handle hoSQLHelper
19435>>>>>>>        Get phoSQLHelper to hoSQLHelper
19436>>>>>>>        Get SupportsSQLFilters of hoSQLHelper to bSupports
19437>>>>>>>        Function_Return bSupports
19438>>>>>>>    End_Function
19439>>>>>>>    
19439>>>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
19439>>>>>>>    
19439>>>>>>>    // Creates an SQL Like Filter for this field and search target
19439>>>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
19441>>>>>>>        String sFilter
19441>>>>>>>        Handle hoSQLHelper
19441>>>>>>>        Get phoSQLHelper to hoSQLHelper
19442>>>>>>>        Get SQLStrLike of hoSQLHelper iField sSearch to sFilter
19443>>>>>>>        Function_Return sFilter
19444>>>>>>>    End_Function
19445>>>>>>>    
19445>>>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
19445>>>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
19447>>>>>>>        Handle hoSQLHelper
19447>>>>>>>        Get phoSQLHelper to hoSQLHelper
19448>>>>>>>        Get SQLStrAppend of hoSQLHelper sOrigFilter sFilter to sFilter
19449>>>>>>>        Function_Return sFilter
19450>>>>>>>    End_Function
19451>>>>>>>    
19451>>>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
19451>>>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
19453>>>>>>>        Handle hoSQLHelper
19453>>>>>>>        Get phoSQLHelper to hoSQLHelper
19454>>>>>>>        Get SQLStrAppendOr of hoSQLHelper sOrigFilter sFilter to sFilter
19455>>>>>>>        Function_Return sFilter
19456>>>>>>>    End_Function
19457>>>>>>>
19457>>>>>>>    // returns the name of the File and Field suitable for an SQL where statement
19457>>>>>>>    Function SQLStrFileFieldName Integer iField Returns String
19459>>>>>>>        String sName
19459>>>>>>>        Handle hoSQLHelper
19459>>>>>>>        Get phoSQLHelper to hoSQLHelper
19460>>>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
19461>>>>>>>        Function_Return sName
19462>>>>>>>    End_Function
19463>>>>>>>
19463>>>>>>>    // returns the name of the Field suitable for an SQL where statement
19463>>>>>>>    Function SQLStrFieldName Integer iField Returns String
19465>>>>>>>        String sName
19465>>>>>>>        Handle hoSQLHelper
19465>>>>>>>        Get phoSQLHelper to hoSQLHelper
19466>>>>>>>        Get SQLStrFieldName of hoSQLHelper iField to sName
19467>>>>>>>        Function_Return sName
19468>>>>>>>    End_Function
19469>>>>>>>
19469>>>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement
19469>>>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
19471>>>>>>>        String sName
19471>>>>>>>        Handle hoSQLHelper
19471>>>>>>>        Get phoSQLHelper to hoSQLHelper
19472>>>>>>>        Get SQLStrSchemaFileFieldName of hoSQLHelper iField to sName
19473>>>>>>>        Function_Return sName
19474>>>>>>>    End_Function
19475>>>>>>>    
19475>>>>>>>    //  returns the name of a file suitable for a SQL statement
19475>>>>>>>    Function SQLStrFileName Integer iField Returns String
19477>>>>>>>        String sName
19477>>>>>>>        Handle hoSQLHelper
19477>>>>>>>        Get phoSQLHelper to hoSQLHelper
19478>>>>>>>        Get SQLStrFileName of hoSQLHelper iField to sName
19479>>>>>>>        Function_Return sName
19480>>>>>>>    End_Function
19481>>>>>>>    
19481>>>>>>>    // creates escaped SQL string by replacing single quote with two single quotes
19481>>>>>>>    Function SQLEscapedStr String sSQL Returns String
19483>>>>>>>        Handle hoSQLHelper
19483>>>>>>>        Get phoSQLHelper to hoSQLHelper
19484>>>>>>>        Get SQLEscapedStr of hoSQLHelper sSQL to sSQL
19485>>>>>>>        Function_Return sSQL
19486>>>>>>>    End_Function
19487>>>>>>>    
19487>>>>>>>    // Returns:
19487>>>>>>>    //       The record id string based on piPrimaryIndex.
19487>>>>>>>    Function PrimaryRecordId Returns String
19489>>>>>>>        Integer iIndex iFile iSegments iSegment iField
19489>>>>>>>        String sVal sId
19489>>>>>>>        
19489>>>>>>>        Get Main_File to iFile
19490>>>>>>>        Get piPrimaryIndex to iIndex
19491>>>>>>>        
19491>>>>>>>        If (iIndex < 0) Begin
19493>>>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
19496>>>>>>>        End
19496>>>>>>>>
19496>>>>>>>        
19496>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
19499>>>>>>>        For iSegment from 1 to iSegments
19505>>>>>>>>
19505>>>>>>>            Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
19508>>>>>>>            
19508>>>>>>>            Get_Field_Value iFile iField to sVal
19511>>>>>>>            Move (Trim(sVal)) to sVal
19512>>>>>>>            
19512>>>>>>>            //  Encode join sign for multi segment indexes
19512>>>>>>>            If (iSegments > 1) Begin
19514>>>>>>>                Move (Replaces("_", sVal, "~5F~")) to sVal
19515>>>>>>>            End
19515>>>>>>>>
19515>>>>>>>            
19515>>>>>>>            If (iSegment = 1) Begin
19517>>>>>>>                Move sVal to sId
19518>>>>>>>            End
19518>>>>>>>>
19518>>>>>>>            Else Begin
19519>>>>>>>                Move (sId + "_" + sVal) to sId
19520>>>>>>>            End
19520>>>>>>>>
19520>>>>>>>            
19520>>>>>>>        Loop
19521>>>>>>>>
19521>>>>>>>        
19521>>>>>>>        Function_Return sId
19522>>>>>>>    End_Function
19523>>>>>>>    
19523>>>>>>>    
19523>>>>>>>    // Finds a record on the global buffer based on the record id.
19523>>>>>>>    //
19523>>>>>>>    // Params:
19523>>>>>>>    //       sRecordId   Record id generated by PrimaryRecordId.
19523>>>>>>>    Function FindByPrimaryRecordId String sRecordId Returns Boolean
19525>>>>>>>        Integer iIndex iFile iSegments iSegment iField
19525>>>>>>>        String[] aValues
19526>>>>>>>        String sVal
19526>>>>>>>        Boolean bTrapped
19526>>>>>>>        
19526>>>>>>>        Get Main_File to iFile
19527>>>>>>>        Get piPrimaryIndex to iIndex
19528>>>>>>>        
19528>>>>>>>        If (iIndex < 0) Begin
19530>>>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
19533>>>>>>>        End
19533>>>>>>>>
19533>>>>>>>        
19533>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
19536>>>>>>>        
19536>>>>>>>        If (iSegments > 1) Begin
19538>>>>>>>            Move (StrSplitToArray(sRecordId, "_")) to aValues
19539>>>>>>>        End
19539>>>>>>>>
19539>>>>>>>        Else Begin
19540>>>>>>>            Move sRecordId to aValues[0]
19541>>>>>>>        End
19541>>>>>>>>
19541>>>>>>>        
19541>>>>>>>        If (iSegments = SizeOfArray(aValues)) Begin
19543>>>>>>>            Clear iFile
19544>>>>>>>            
19544>>>>>>>            Send Ignore_Error of Error_Object_Id 56
19545>>>>>>>            Send Ignore_Error of Error_Object_Id 11
19546>>>>>>>            
19546>>>>>>>            For iSegment from 1 to iSegments
19552>>>>>>>>
19552>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
19555>>>>>>>                
19555>>>>>>>                Move aValues[iSegment - 1] to sVal
19556>>>>>>>                If (iSegments > 1) Begin
19558>>>>>>>                    Move (Replaces("~5F~", sVal, "_")) to sVal
19559>>>>>>>                End
19559>>>>>>>>
19559>>>>>>>                
19559>>>>>>>                Set_Field_Value iFile iField to sVal
19562>>>>>>>            Loop
19563>>>>>>>>
19563>>>>>>>            Send Trap_Error of Error_Object_Id 56
19564>>>>>>>            Send Trap_Error of Error_Object_Id 11
19565>>>>>>>            
19565>>>>>>>            Vfind iFile iIndex EQ
19567>>>>>>>            
19567>>>>>>>            Function_Return (Found)
19568>>>>>>>        End
19568>>>>>>>>
19568>>>>>>>        
19568>>>>>>>        Function_Return False
19569>>>>>>>    End_Function
19570>>>>>>>    
19570>>>>>>>    // Converts a RecordId to a RowId by finding it on the global buffer.
19570>>>>>>>    //
19570>>>>>>>    // Params:
19570>>>>>>>    //       sRecordId   Record id based on piPrimaryIndex.
19570>>>>>>>    //       rRowId      (ByRef) Will be filled with the rowid.
19570>>>>>>>    // Returns:
19570>>>>>>>    //       True if the record id was valid.
19570>>>>>>>    Function RecordIdToRowId String sRecordId RowID ByRef rRowId Returns Boolean
19572>>>>>>>        Boolean bFound
19572>>>>>>>        
19572>>>>>>>        Get FindByPrimaryRecordId sRecordId to bFound
19573>>>>>>>        If (bFound) Begin
19575>>>>>>>            Move (GetRowID(Main_File(Self))) to rRowId
19576>>>>>>>        End
19576>>>>>>>>
19576>>>>>>>        Else Begin
19577>>>>>>>            Move (NullRowID()) to rRowId
19578>>>>>>>        End
19578>>>>>>>>
19578>>>>>>>        
19578>>>>>>>        Function_Return bFound
19579>>>>>>>    End_Function
19580>>>>>>>    
19580>>>>>>>    // Converts a RowId into a record ID. Note that it performs a find on the global buffer.
19580>>>>>>>    //
19580>>>>>>>    // Params:
19580>>>>>>>    //       riRowId     RowID.
19580>>>>>>>    // Returns:
19580>>>>>>>    //       Record id based on piPrimaryIndex.
19580>>>>>>>    Function RowIdToRecordId RowID riRowId Returns String
19582>>>>>>>        Boolean bFound
19582>>>>>>>        String sRecId
19582>>>>>>>        
19582>>>>>>>        If (not(IsNullRowID(riRowId))) Begin
19584>>>>>>>            Move (FindByRowID(Main_File(Self), riRowId)) to bFound
19585>>>>>>>            
19585>>>>>>>            If (bFound) Begin
19587>>>>>>>                Get PrimaryRecordId to sRecId
19588>>>>>>>            End
19588>>>>>>>>
19588>>>>>>>        End
19588>>>>>>>>
19588>>>>>>>        
19588>>>>>>>        Function_Return sRecId
19589>>>>>>>    End_Function
19590>>>>>>>End_Class
19591>>>>>>>
19591>>>>>>>// This message will be send as a notification message from an
19591>>>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.
19591>>>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached
19591>>>>>>>// DEO which do not know anything about Extended_Data_Sets don't get
19591>>>>>>>// frustrated.
19591>>>>>>>// All focusable objects and DEOs must understand this. This should be
19591>>>>>>>// changed at some point in the future.
19591>>>>>>>Function Extended_DEO_State for cUIObject Returns Integer
19593>>>>>>>End_Function
19594>>>>>>>
19594>>>>>>>
19594>>>>>>>// this command is now obsolete. use Set Field_auto_increment
19594>>>>>>>
19594>>>>>
19594>>>>>Open Recipe
Including file: Recipe.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\Recipe.fd)
19596>>>>>
19596>>>>>Class cRecipeDataDictionary is a DataDictionary
19597>>>>>    
19597>>>>>    Procedure Construct_Object
19599>>>>>        Forward Send Construct_Object
19601>>>>>        Set Main_File to Recipe.File_Number
19602>>>>>
19602>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
19603>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
19604>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
19605>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
19606>>>>>
19606>>>>>    End_Procedure
19607>>>>>
19607>>>>>End_Class
19608>>>Use cKitchenDataDictionary.dd
Including file: cKitchenDataDictionary.dd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\cKitchenDataDictionary.dd)
19608>>>>>Use DataDict.pkg
19608>>>>>
19608>>>>>Open Kitchen
Including file: Kitchen.fd    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Working with Databases\DDSrc\Kitchen.fd)
19610>>>>>
19610>>>>>Class cKitchenDataDictionary is a DataDictionary
19611>>>>>    
19611>>>>>    Procedure Construct_Object
19613>>>>>        Forward Send Construct_Object
19615>>>>>        Set Main_File to Kitchen.File_Number
19616>>>>>
19616>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
19617>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
19618>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
19619>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
19620>>>>>
19620>>>>>    End_Procedure
19621>>>>>
19621>>>>>End_Class
19622>>>
19622>>>Object oLocalBuffer is a BusinessProcess
19624>>>    Object oKitchen_DD is a cKitchenDataDictionary
19626>>>    End_Object
19627>>>
19627>>>    Object oRecipe_DD is a cRecipeDataDictionary
19629>>>    End_Object
19630>>>
19630>>>    Set Main_DD to oRecipe_DD
19631>>>
19631>>>    Set Display_Error_State to True
19632>>>
19632>>>    // Send DoProcess to this BPO to start the business process
19632>>>    // DoProcess is a predefined method in the BusinessProcess class
19632>>>    // Send DoProcess of oNewBusinessProcess
19632>>>
19632>>>    // OnProcess
19632>>>    // ---------
19632>>>    // Place your processing code into Procedure OnProcess
19632>>>    // OnProcess is a predefined method in the BusinessProcess class
19632>>>
19632>>>    Procedure OnProcess
19635>>>        Send Clear of oRecipe_DD
19636>>>        Send Find of oRecipe_DD FIRST_RECORD 2
19637>>>        
19637>>>        While (Found)
19641>>>            Showln (SFormat("Recipe %1 (Kitchen %2)", Field_Current_Value(oRecipe_DD, RefTable(Recipe.Name)), Field_Current_Value(oKitchen_DD, RefTable(Kitchen.Name))))
19643>>>            
19643>>>            Send Find of oRecipe_DD NEXT_RECORD 2
19644>>>        Loop
19645>>>>
19645>>>    End_Procedure
19646>>>
19646>>>End_Object
19647>Send DoProcess of oLocalBuffer
19648>
19648>Send Info_Box "Hello World" "DataFlex Basic Project"
19649>
Summary
Memory Available: 8841547776
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 15610
Total Resources: 0
Total Commands : 19648
Total Windows  : 0
Total Pages    : 0
Static Data    : 201412
Message area   : 103954
Total Blocks   : 9308
