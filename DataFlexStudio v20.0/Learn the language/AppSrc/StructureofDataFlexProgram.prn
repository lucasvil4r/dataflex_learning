Compiling Program: C:\Users\lucas.GPCABLING\Documents\repositorios\dataflex_learning\DataFlexStudio v20.0\Learn the language\AppSrc\StructureofDataFlexProgram.src
Memory Available: 530989056
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 20.0\Pkg\dfallent.pkd)
68480>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardCommandBarSystem.pkg)
68480>>>// these are all the packages used in a standard MDI menubar/toolbar system
68480>>>
68480>>>Use cCJCommandBarSystem.pkg
68480>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardMenuItemClasses.pkg)
68480>>>>>Use Dfpanel.pkg
68480>>>>>Use cCJCommandBarSystem.pkg
68480>>>>>Use LanguageText.pkg
68480>>>>>
68480>>>>>
68480>>>>>Class cCJUndoMenuItem is a cCJMenuItem
68481>>>>>    
68481>>>>>    Procedure Construct_Object
68483>>>>>        Forward Send Construct_Object
68485>>>>>        Set psCaption   to C_$CaptionUndo
68486>>>>>        Set psToolTip to C_$ToolTipUndo
68487>>>>>        Set psDescription to C_$DescUndo
68488>>>>>        Set psImage to "ActionUndo.ico"
68489>>>>>        Set pbActiveUpdate to True
68490>>>>>        Set psCategory to C_$CategoryEdit
68491>>>>>        Set psShortcut to C_$Key_Ctrl_Z
68492>>>>>    End_Procedure
68493>>>>>    
68493>>>>>    Procedure OnExecute Variant vCommandBarControl
68495>>>>>        Send Undo of (focus(Self))
68496>>>>>    End_Procedure
68497>>>>>    
68497>>>>>    Function IsEnabled Returns Boolean
68499>>>>>        Boolean bEnabled
68499>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
68500>>>>>        Function_Return bEnabled
68501>>>>>    End_Function
68502>>>>>    
68502>>>>>End_Class
68503>>>>>
68503>>>>>
68503>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
68504>>>>>    
68504>>>>>    Procedure Construct_Object
68506>>>>>        Forward Send Construct_Object
68508>>>>>        Set psCaption   to C_$CaptionDelete
68509>>>>>        Set psToolTip to C_$ToolTipDelete
68510>>>>>        Set psDescription to C_$DescDelete
68511>>>>>        Set psImage to "actionDelete.ico"
68512>>>>>        Set psShortcut to C_$Key_Delete
68513>>>>>        Set pbActiveUpdate to True
68514>>>>>        Set psCategory to C_$CategoryEdit
68515>>>>>    End_Procedure
68516>>>>>    
68516>>>>>    
68516>>>>>    Procedure OnExecute Variant vCommandBarControl
68518>>>>>        Send Delete of (focus(Self))
68519>>>>>    End_Procedure
68520>>>>>    
68520>>>>>    Function IsEnabled Returns Boolean
68522>>>>>        Boolean bEnabled
68522>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
68523>>>>>        Function_Return bEnabled
68524>>>>>    End_Function
68525>>>>>    
68525>>>>>End_Class
68526>>>>>
68526>>>>>
68526>>>>>Class cCJCutMenuItem is a cCJMenuItem
68527>>>>>    
68527>>>>>    Procedure Construct_Object
68529>>>>>        Forward Send Construct_Object
68531>>>>>        Set psCaption   to C_$CaptionCut
68532>>>>>        Set psToolTip to C_$TooltipCut
68533>>>>>        Set psDescription to C_$DescCut
68534>>>>>        Set psImage to "actionCut.ico"
68535>>>>>        Set psShortcut to C_$Key_Ctrl_X
68536>>>>>        Set pbActiveUpdate to True
68537>>>>>        Set psCategory to C_$CategoryEdit
68538>>>>>    End_Procedure
68539>>>>>    
68539>>>>>    
68539>>>>>    Procedure OnExecute Variant vCommandBarControl
68541>>>>>        Send Cut of (focus(Self))
68542>>>>>    End_Procedure
68543>>>>>    
68543>>>>>    Function IsEnabled Returns Boolean
68545>>>>>        Boolean bEnabled
68545>>>>>        Get CanCut of (Focus(Self)) to bEnabled
68546>>>>>        Function_Return bEnabled
68547>>>>>    End_Function
68548>>>>>    
68548>>>>>End_Class
68549>>>>>
68549>>>>>
68549>>>>>Class cCJCopyMenuItem is a cCJMenuItem
68550>>>>>    
68550>>>>>    Procedure Construct_Object
68552>>>>>        Forward Send Construct_Object
68554>>>>>        Set psCaption   to C_$CaptionCopy
68555>>>>>        Set psToolTip to C_$ToolTipCopy
68556>>>>>        Set psDescription to C_$DescCopy
68557>>>>>        Set psImage to "actionCopy.ico"
68558>>>>>        Set psShortcut to C_$Key_Ctrl_C
68559>>>>>        Set pbActiveUpdate to True
68560>>>>>        Set psCategory to C_$CategoryEdit
68561>>>>>    End_Procedure
68562>>>>>    
68562>>>>>    
68562>>>>>    Procedure OnExecute Variant vCommandBarControl
68564>>>>>        Send Copy of (focus(Self))
68565>>>>>    End_Procedure
68566>>>>>    
68566>>>>>    Function IsEnabled Returns Boolean
68568>>>>>        Boolean bEnabled
68568>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
68569>>>>>        Function_Return bEnabled
68570>>>>>    End_Function
68571>>>>>    
68571>>>>>End_Class
68572>>>>>
68572>>>>>
68572>>>>>Class cCJPasteMenuItem is a cCJMenuItem
68573>>>>>    
68573>>>>>    Procedure Construct_Object
68575>>>>>        Forward Send Construct_Object
68577>>>>>        Set psCaption   to C_$CaptionPaste
68578>>>>>        Set psToolTip to C_$ToolTipPaste
68579>>>>>        Set psDescription to C_$DescPaste
68580>>>>>        Set psImage to "actionPaste.ico"
68581>>>>>        Set pbActiveUpdate to True
68582>>>>>        Set psShortcut to C_$Key_Ctrl_V
68583>>>>>        Set psCategory to C_$CategoryEdit
68584>>>>>    End_Procedure
68585>>>>>    
68585>>>>>    
68585>>>>>    Procedure OnExecute Variant vCommandBarControl
68587>>>>>        Send Paste of (focus(Self))
68588>>>>>    End_Procedure
68589>>>>>    
68589>>>>>    Function IsEnabled Returns Boolean
68591>>>>>        Boolean bEnabled
68591>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
68592>>>>>        Function_Return bEnabled
68593>>>>>    End_Function
68594>>>>>    
68594>>>>>End_Class
68595>>>>>
68595>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
68596>>>>>    
68596>>>>>    Procedure Construct_Object
68598>>>>>        Forward Send Construct_Object
68600>>>>>        Set psCaption   to C_$CaptionSelectAll
68601>>>>>        Set psToolTip to C_$ToolTipSelectAll
68602>>>>>        Set psDescription to C_$DescSelectAll
68603>>>>>        Set pbActiveUpdate to True
68604>>>>>        Set psShortcut to C_$Key_Ctrl_A
68605>>>>>        Set psCategory to C_$CategoryEdit
68606>>>>>    End_Procedure
68607>>>>>    
68607>>>>>    
68607>>>>>    Procedure OnExecute Variant vCommandBarControl
68609>>>>>        Send Select_All of (focus(Self))
68610>>>>>    End_Procedure
68611>>>>>    
68611>>>>>    Function IsEnabled Returns Boolean
68613>>>>>        Boolean bEnabled
68613>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
68614>>>>>        Function_Return bEnabled
68615>>>>>    End_Function
68616>>>>>    
68616>>>>>End_Class
68617>>>>>
68617>>>>>
68617>>>>>Class cCJExitMenuItem is a cCJMenuItem
68618>>>>>    
68618>>>>>    Procedure Construct_Object
68620>>>>>        Forward Send Construct_Object
68622>>>>>        Set psCaption to C_$CaptionExit
68623>>>>>        Set psToolTip to C_$ToolTipExit
68624>>>>>        Set psDescription to C_$ToolTipExit
68625>>>>>        Set psShortcut to C_$Key_Alt_F4
68626>>>>>        Set psCategory to C_$CategoryFile
68627>>>>>    End_Procedure
68628>>>>>    
68628>>>>>    Procedure OnExecute Variant vCommandBarControl
68630>>>>>        Send Exit_Application of Desktop
68631>>>>>    End_Procedure
68632>>>>>    
68632>>>>>End_Class
68633>>>>>
68633>>>>>Class cCJHelpMenuItem is a cCJMenuItem
68634>>>>>    
68634>>>>>    Procedure Construct_Object
68636>>>>>        Forward Send Construct_Object
68638>>>>>        Set psCaption to C_$CaptionHelp
68639>>>>>        Set psDescription to C_$ToolTipHelp
68640>>>>>        Set psToolTip to C_$DescHelp
68641>>>>>        Set psImage to "ActionHelp.ico"
68642>>>>>        Set psShortcut to "F1"
68643>>>>>        Set psCategory to C_$CategoryHelp
68644>>>>>    End_Procedure
68645>>>>>    
68645>>>>>    Procedure OnExecute Variant vCommandBarControl
68647>>>>>        Send Help of (Focus(Self))
68648>>>>>    End_Procedure
68649>>>>>    
68649>>>>>End_Class
68650>>>>>
68650>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
68651>>>>>    
68651>>>>>    Procedure Construct_Object
68653>>>>>        Forward Send Construct_Object
68655>>>>>        Set psCaption to C_$CaptionAddStatusbar
68656>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
68657>>>>>        Set psDescription to  C_$DescAddStatusbar
68658>>>>>        Set psCategory to C_$CategoryWindow
68659>>>>>    End_Procedure
68660>>>>>    
68660>>>>>    Procedure OnExecute Variant vCommandBarControl
68662>>>>>        Handle hoCommandBars hoClientArea
68662>>>>>        Get CommandBarSystemObject to hoCommandBars
68663>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68664>>>>>        If hoClientArea Begin
68666>>>>>            // the clientarea's parent panel has message
68666>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
68667>>>>>        End
68667>>>>>>
68667>>>>>    End_Procedure
68668>>>>>    
68668>>>>>    Function IsChecked Returns Boolean
68670>>>>>        Boolean bOn
68670>>>>>        Handle hoCommandBars hoClientArea
68670>>>>>        Get CommandBarSystemObject to hoCommandBars
68671>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68672>>>>>        If hoClientArea Begin
68674>>>>>            // the clientarea's parent panel has message
68674>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
68675>>>>>        End
68675>>>>>>
68675>>>>>        Function_Return bOn
68676>>>>>    End_Function
68677>>>>>End_Class
68678>>>>>
68678>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
68679>>>>>    
68679>>>>>    Procedure Construct_Object
68681>>>>>        Forward Send Construct_Object
68683>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
68684>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
68685>>>>>        Set psDescription to C_$DescAutoArrangeIcons
68686>>>>>        Set psCategory to C_$CategoryWindow
68687>>>>>    End_Procedure
68688>>>>>    
68688>>>>>    Procedure OnExecute Variant vCommandBarControl
68690>>>>>        Handle hoCommandBars hoClientArea
68690>>>>>        Get CommandBarSystemObject to hoCommandBars
68691>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68692>>>>>        If hoClientArea Begin
68694>>>>>            // the clientarea's parent panel has message
68694>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
68695>>>>>        End
68695>>>>>>
68695>>>>>    End_Procedure
68696>>>>>    
68696>>>>>    Function IsChecked Returns Boolean
68698>>>>>        Boolean bOn
68698>>>>>        Handle hoCommandBars hoClientArea
68698>>>>>        Get CommandBarSystemObject to hoCommandBars
68699>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68700>>>>>        If hoClientArea Begin
68702>>>>>            // the clientarea's parent panel has message
68702>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
68703>>>>>        End
68703>>>>>>
68703>>>>>        Function_Return bOn
68704>>>>>    End_Function
68705>>>>>End_Class
68706>>>>>
68706>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
68707>>>>>    
68707>>>>>    Procedure Construct_Object
68709>>>>>        Forward Send Construct_Object
68711>>>>>        Set psCaption to C_$CaptionRestoreMenus
68712>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
68713>>>>>        Set psDescription to C_$DescRestoreMenus
68714>>>>>        Set psCategory to C_$CategoryWindow
68715>>>>>    End_Procedure
68716>>>>>    
68716>>>>>    Procedure OnExecute Variant vCommandBarControl
68718>>>>>        Handle hoCommandBars
68718>>>>>        Get CommandBarSystemObject to hoCommandBars
68719>>>>>        Send RestoreLayout of hoCommandBars
68720>>>>>    End_Procedure
68721>>>>>    
68721>>>>>End_Class
68722>>>>>
68722>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
68723>>>>>    
68723>>>>>    Procedure Construct_Object
68725>>>>>        Forward Send Construct_Object
68727>>>>>        Set psCaption to C_$CaptionCascade
68728>>>>>        Set psToolTip to C_$ToolTipCascade
68729>>>>>        Set psDescription to  C_$DescCascade
68730>>>>>        Set psImage to "ActionCascade.ico"
68731>>>>>        Set psCategory to C_$CategoryWindow
68732>>>>>    End_Procedure
68733>>>>>    
68733>>>>>    Procedure OnExecute Variant vCommandBarControl
68735>>>>>        Handle hoCommandBars hoClientArea
68735>>>>>        Get CommandBarSystemObject to hoCommandBars
68736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68737>>>>>        If hoClientArea Begin
68739>>>>>            Send Cascade_Windows of hoClientArea
68740>>>>>        End
68740>>>>>>
68740>>>>>    End_Procedure
68741>>>>>End_Class
68742>>>>>
68742>>>>>Class cCJTileHorizontally is a cCJMenuItem
68743>>>>>    
68743>>>>>    Procedure Construct_Object
68745>>>>>        Forward Send Construct_Object
68747>>>>>        Set psCaption to C_$CaptionTileHorizontally
68748>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
68749>>>>>        Set psDescription to  C_$DescTileHorizontally
68750>>>>>        Set psImage to "ActionTileHorizontally.ico"
68751>>>>>        Set psCategory to C_$CategoryWindow
68752>>>>>    End_Procedure
68753>>>>>    
68753>>>>>    Procedure OnExecute Variant vCommandBarControl
68755>>>>>        Handle hoCommandBars hoClientArea
68755>>>>>        Get CommandBarSystemObject to hoCommandBars
68756>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68757>>>>>        If hoClientArea Begin
68759>>>>>            Send Tile_Windows_Horizontal of hoClientArea
68760>>>>>        End
68760>>>>>>
68760>>>>>    End_Procedure
68761>>>>>End_Class
68762>>>>>
68762>>>>>Class cCJTileVertically is a cCJMenuItem
68763>>>>>    
68763>>>>>    Procedure Construct_Object
68765>>>>>        Forward Send Construct_Object
68767>>>>>        Set psCaption to C_$CaptionTileVertically
68768>>>>>        Set psToolTip to C_$ToolTipTileVertically
68769>>>>>        Set psDescription to  C_$DescTileVertically
68770>>>>>        Set psImage to "ActionTileVertically.ico"
68771>>>>>        Set psCategory to C_$CategoryWindow
68772>>>>>    End_Procedure
68773>>>>>    
68773>>>>>    Procedure OnExecute Variant vCommandBarControl
68775>>>>>        Handle hoCommandBars hoClientArea
68775>>>>>        Get CommandBarSystemObject to hoCommandBars
68776>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68777>>>>>        If hoClientArea Begin
68779>>>>>            Send Tile_Windows_Vertical of hoClientArea
68780>>>>>        End
68780>>>>>>
68780>>>>>    End_Procedure
68781>>>>>End_Class
68782>>>>>
68782>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
68783>>>>>    
68783>>>>>    Procedure Construct_Object
68785>>>>>        Forward Send Construct_Object
68787>>>>>        Set psCaption to C_$CaptionMinimizeWindows
68788>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
68789>>>>>        Set psDescription to  C_$DescMinimizeWindows
68790>>>>>        Set psCategory to C_$CategoryWindow
68791>>>>>    End_Procedure
68792>>>>>    
68792>>>>>    Procedure OnExecute Variant vCommandBarControl
68794>>>>>        Handle hoCommandBars hoClientArea
68794>>>>>        Get CommandBarSystemObject to hoCommandBars
68795>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68796>>>>>        If hoClientArea Begin
68798>>>>>            // the clientarea's parent panel has message
68798>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
68799>>>>>        End
68799>>>>>>
68799>>>>>    End_Procedure
68800>>>>>End_Class
68801>>>>>
68801>>>>>
68801>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
68802>>>>>    
68802>>>>>    Procedure Construct_Object
68804>>>>>        Forward Send Construct_Object
68806>>>>>        Set psCaption to C_$CaptionRestoreWindows
68807>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
68808>>>>>        Set psDescription to  C_$DescRestoreWindows
68809>>>>>        Set psCategory to C_$CategoryWindow
68810>>>>>    End_Procedure
68811>>>>>    
68811>>>>>    Procedure OnExecute Variant vCommandBarControl
68813>>>>>        Handle hoCommandBars hoClientArea
68813>>>>>        Get CommandBarSystemObject to hoCommandBars
68814>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68815>>>>>        If hoClientArea Begin
68817>>>>>            // the clientarea's parent panel has message
68817>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
68818>>>>>        End
68818>>>>>>
68818>>>>>    End_Procedure
68819>>>>>End_Class
68820>>>>>
68820>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
68821>>>>>    
68821>>>>>    Procedure Construct_Object
68823>>>>>        Forward Send Construct_Object
68825>>>>>        Set psCaption to C_$CaptionArrangeIcons
68826>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
68827>>>>>        Set psDescription to  C_$DescArrangeIcons
68828>>>>>        Set psCategory to C_$CategoryWindow
68829>>>>>    End_Procedure
68830>>>>>    
68830>>>>>    Procedure OnExecute Variant vCommandBarControl
68832>>>>>        Handle hoCommandBars hoClientArea
68832>>>>>        Get CommandBarSystemObject to hoCommandBars
68833>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68834>>>>>        If hoClientArea Begin
68836>>>>>            Send Arrange_Icons of hoClientArea
68837>>>>>        End
68837>>>>>>
68837>>>>>    End_Procedure
68838>>>>>    
68838>>>>>End_Class
68839>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJAboutMenuItem.pkg)
68839>>>>>Use cCJCommandBarSystem.pkg
68839>>>>>Use LanguageText.pkg
68839>>>>>
68839>>>>>// It is expected that if you use this class that you provide an about object that is
68839>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
68839>>>>>// because you may wish to create your own custom about package.
68839>>>>>
68839>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
68840>>>>>
68840>>>>>    Procedure Construct_Object
68842>>>>>        Forward Send Construct_Object
68844>>>>>        Set psCaption to C_$CaptionAbout
68845>>>>>        Set psDescription to C_$ToolTipAbout
68846>>>>>        Set psToolTip to C_$DescAbout
68847>>>>>        Set psImage to "ActionAbout.ico"
68848>>>>>        Set psCategory to C_$CategoryHelp
68849>>>>>    End_Procedure
68850>>>>>    
68850>>>>>    Procedure OnExecute Variant vCommandBarControl
68852>>>>>        Handle hoCommandBars hoClientArea
68852>>>>>        Get CommandBarSystemObject to hoCommandBars
68853>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68854>>>>>        If hoClientArea Begin
68856>>>>>            Send Activate_About of hoClientArea
68857>>>>>        End
68857>>>>>>
68857>>>>>    End_Procedure
68858>>>>>
68858>>>>>End_Class
68859>>>>>
68859>>>>>
68859>>>Use cCJDeoMenuItemClasses.pkg
68859>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJMDIWindowsMenuItem.pkg)
68859>>>>>Use cCJCommandBarSystem.pkg
68859>>>>>
68859>>>>>Register_Function Client_ID Returns Integer
68859>>>>>
68859>>>>>// only used by cCJMDIWIndowsMenuItem
68859>>>>>Class cCJMDIWindowItem is a cCJMenuItem
68860>>>>>    
68860>>>>>    Procedure Construct_Object
68862>>>>>        Forward Send Construct_Object
68864>>>>>        Property Handle phWindow 0 // object id of view
68865>>>>>        Set pbControlFlagNoMovable to True
68866>>>>>        Set pbActiveUpdate to True
68867>>>>>    End_Procedure
68868>>>>>    
68868>>>>>    Procedure OnExecute Variant vCommandBarControl
68870>>>>>        Handle hWindow
68870>>>>>        Get phWindow to hWindow
68871>>>>>        Send Activate_View of hWindow
68872>>>>>    End_Procedure
68873>>>>>    
68873>>>>>End_Class
68874>>>>>
68874>>>>>
68874>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
68875>>>>>    
68875>>>>>    Procedure Construct_Object
68877>>>>>        Forward Send Construct_Object
68879>>>>>        Property Handle[] phArrayOfWindows
68880>>>>>        Set peControlType to xtpControlPopup
68881>>>>>        Set psCategory to C_$CategoryWindow
68882>>>>>    End_Procedure
68883>>>>>    
68883>>>>>    // This adds MDI windows to the existing menu items.
68883>>>>>    // This removes any existing windows menus and always adds a new set to the end
68883>>>>>    
68883>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
68885>>>>>        Handle  hClientArea hView
68885>>>>>        String  sLabel
68885>>>>>        Integer i iWindows
68885>>>>>        Handle[] hArrayOfWindows
68886>>>>>        Variant vItem
68886>>>>>        
68886>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
68886>>>>>        // also assume that destroying an action removes all menu instances of that action
68886>>>>>        Get phArrayOfWindows to hArrayOfWindows
68887>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
68888>>>>>        For i from 0 to (iWindows-1)
68894>>>>>>
68894>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
68895>>>>>        Loop
68896>>>>>>
68896>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
68897>>>>>        
68897>>>>>        // Add all views to this menu. Create the action and add the item
68897>>>>>        Move 0 to i
68898>>>>>        Get Client_Id to hClientArea // object id of client area
68899>>>>>        If (hClientArea > 0) Begin
68901>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
68902>>>>>            While (hView <> 0)
68906>>>>>                If (Active_State(hView)) Begin
68908>>>>>                    // create the action
68908>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
68909>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
68910>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
68911>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
68912>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
68914>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
68915>>>>>                    End
68915>>>>>>
68915>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
68916>>>>>                    If (i=0) Begin
68918>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
68919>>>>>                    End
68919>>>>>>
68919>>>>>                    // Create a menu item for this action
68919>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
68920>>>>>                    Increment i
68921>>>>>                End
68921>>>>>>
68921>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
68922>>>>>            Loop
68923>>>>>>
68923>>>>>        End
68923>>>>>>
68923>>>>>        
68923>>>>>        Set phArrayOfWindows to hArrayOfWindows
68924>>>>>        
68924>>>>>    End_Procedure
68925>>>>>    
68925>>>>>End_Class
68926>
68926>Object oHtmlHelp is a cHtmlHelp
68928>End_Object
68929>
68929>Object oApplication is a cApplication
68931>    Set peHelpType to htHtmlHelp
68932>
68932>    Object oConnection is a cConnection
68934>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\LoginEncryption.pkg)
68934>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLoginEncryption.pkg)
68934>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCryptographerEx.pkg)
68934>>>>>>>Use VdfBase.pkg
68934>>>>>>>
68934>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.0\Pkg\CryptographerConstants.pkg)
68934>>>>>>>>>//   Author  : Ulbe Stellema
68934>>>>>>>>>// Algorithm classes
68934>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
68934>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
68934>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
68934>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
68934>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
68934>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
68934>>>>>>>>>
68934>>>>>>>>>// Algorithm types
68934>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
68934>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
68934>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
68934>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
68934>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
68934>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
68934>>>>>>>>>
68934>>>>>>>>>// Generic sub-ids
68934>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
68934>>>>>>>>>
68934>>>>>>>>>// RSA sub-ids
68934>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
68934>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
68934>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
68934>>>>>>>>>
68934>>>>>>>>>// DSS sub-ids
68934>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
68934>>>>>>>>>
68934>>>>>>>>>// DES sub_ids
68934>>>>>>>>>Define ALG_SID_DES                      for 1
68934>>>>>>>>>Define ALG_SID_3DES                     for 3
68934>>>>>>>>>Define ALG_SID_DESX                     for 4
68934>>>>>>>>>Define ALG_SID_IDEA                     for 5
68934>>>>>>>>>Define ALG_SID_CAST                     for 6
68934>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
68934>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
68934>>>>>>>>>Define ALG_SID_3DES_112                 for 9
68934>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
68934>>>>>>>>>Define ALG_SID_RC5                      for 13
68934>>>>>>>>>Define ALG_SID_AES_128                  for 14
68934>>>>>>>>>Define ALG_SID_AES_192                  for 15
68934>>>>>>>>>Define ALG_SID_AES_256                  for 16
68934>>>>>>>>>Define ALG_SID_AES                      for 17
68934>>>>>>>>>
68934>>>>>>>>>// Fortezza sub-ids
68934>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
68934>>>>>>>>>Define ALG_SID_TEK                      for 11
68934>>>>>>>>>
68934>>>>>>>>>// RC2 sub-ids
68934>>>>>>>>>Define ALG_SID_RC2                      for 2
68934>>>>>>>>>
68934>>>>>>>>>// Stream cipher sub-ids
68934>>>>>>>>>Define ALG_SID_RC4                      for 1
68934>>>>>>>>>Define ALG_SID_SEAL                     for 2
68934>>>>>>>>>
68934>>>>>>>>>// Diffie-Hellman sub-ids
68934>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
68934>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
68934>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
68934>>>>>>>>>Define ALG_SID_KEA                      for 4
68934>>>>>>>>>
68934>>>>>>>>>// Hash sub ids
68934>>>>>>>>>Define ALG_SID_MD2                      for 1
68934>>>>>>>>>Define ALG_SID_MD4                      for 2
68934>>>>>>>>>Define ALG_SID_MD5                      for 3
68934>>>>>>>>>Define ALG_SID_SHA                      for 4
68934>>>>>>>>>Define ALG_SID_SHA1                     for 4
68934>>>>>>>>>Define ALG_SID_MAC                      for 5
68934>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
68934>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
68934>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
68934>>>>>>>>>Define ALG_SID_HMAC                     for 9
68934>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
68934>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
68934>>>>>>>>>Define ALG_SID_SHA_256                  for 12
68934>>>>>>>>>Define ALG_SID_SHA_384                  for 13
68934>>>>>>>>>Define ALG_SID_SHA_512                  for 14
68934>>>>>>>>>
68934>>>>>>>>>// secure channel sub ids
68934>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
68934>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
68934>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
68934>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
68934>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
68934>>>>>>>>>
68934>>>>>>>>>// algorithm identifier definitions
68934>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
68934>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
68934>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
68934>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
68934>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
68934>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
68934>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
68934>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
68934>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
68934>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
68934>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
68934>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
68934>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
68934>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
68934>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
68934>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
68934>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
68934>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
68934>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
68934>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
68934>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
68934>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
68934>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
68934>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
68934>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
68934>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
68934>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
68934>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
68934>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
68934>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
68934>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
68934>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
68934>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
68934>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
68934>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
68934>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
68934>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
68934>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
68934>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
68934>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
68934>>>>>>>>>
68934>>>>>>>>>// Providers
68934>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
68934>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
68934>>>>>>>>>
68934>>>>>>>>>// dwFlags definitions for CryptAcquireContext
68934>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
68934>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
68934>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
68934>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
68934>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
68934>>>>>>>>>
68934>>>>>>>>>// dwFlag definitions for CryptGenKey
68934>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
68934>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
68934>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
68934>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
68934>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
68934>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
68934>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
68934>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
68934>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
68934>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
68934>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
68934>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
68934>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
68934>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
68934>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
68934>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
68934>>>>>>>>>
68934>>>>>>>>>// Provider types
68934>>>>>>>>>Define PROV_RSA_FULL                    for 1
68934>>>>>>>>>Define PROV_RSA_SIG                     for 2
68934>>>>>>>>>Define PROV_DSS                         for 3
68934>>>>>>>>>Define PROV_FORTEZZA                    for 4
68934>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
68934>>>>>>>>>Define PROV_SSL                         for 6
68934>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
68934>>>>>>>>>Define PROV_DSS_DH                      for 13
68934>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
68934>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
68934>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
68934>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
68934>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
68934>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
68934>>>>>>>>>Define PROV_RNG                         for 21
68934>>>>>>>>>Define PROV_INTEL_SEC                   for 22
68934>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
68934>>>>>>>>>Define PROV_RSA_AES                     for 24
68934>>>>>>>>>
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
68934>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
68934>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
68934>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
68934>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
68934>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetKeyParam
68934>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
68934>>>>>>>>>Define KP_SALT                          for 2       // Salt value
68934>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
68934>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
68934>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
68934>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
68934>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
68934>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
68934>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
68934>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
68934>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
68934>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
68934>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
68934>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
68934>>>>>>>>>Define KP_Y                             for 15      // Y value
68934>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
68934>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
68934>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
68934>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
68934>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
68934>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
68934>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
68934>>>>>>>>>Define KP_RP                            for 23
68934>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
68934>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
68934>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
68934>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
68934>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
68934>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
68934>>>>>>>>>Define KP_KEYVAL                        for 30
68934>>>>>>>>>Define KP_ADMIN_PIN                     for 31
68934>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
68934>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
68934>>>>>>>>>Define KP_PREHASH                       for 34
68934>>>>>>>>>Define KP_ROUNDS                        for 35
68934>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
68934>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
68934>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
68934>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
68934>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
68934>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
68934>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetHashParam
68934>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
68934>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
68934>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
68934>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
68934>>>>>>>>>
68934>>>>>>>>>// key BLOB types
68934>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
68934>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
68934>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
68934>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
68934>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
68934>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
68934>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
68934>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
68934>>>>>>>>>
68934>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
68934>>>>>>>>>
68934>>>>>>>>>// KP_PADDING
68934>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
68934>>>>>>>>>Define RANDOM_PADDING                   for 2
68934>>>>>>>>>Define ZERO_PADDING                     for 3
68934>>>>>>>>>
68934>>>>>>>>>//  Structure cryptimportkey
68934>>>>>>>>>Struct PUBLICKEYSTRUC
68934>>>>>>>>>    UChar    bType
68934>>>>>>>>>    UChar    bVersion
68934>>>>>>>>>    UShort   reserved
68934>>>>>>>>>    UInteger aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct tPLAINTEXTKEYBLOB
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    UInteger       dwKeySize
68934>>>>>>>>>//    UChar[]        rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
68934>>>>>>>>>Struct HMAC_INFO
68934>>>>>>>>>    UInteger HashAlgid
68934>>>>>>>>>    Pointer pbInnerString
68934>>>>>>>>>    DWord cbInnerString
68934>>>>>>>>>    Pointer pbOuterString
68934>>>>>>>>>    DWord cbOuterString
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct BLOBHEADER
68934>>>>>>>>>    UChar   bType
68934>>>>>>>>>    UChar   bVersion
68934>>>>>>>>>    Short   reserved
68934>>>>>>>>>    Integer aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct CryptoBlob
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    Integer     cbKeySize
68934>>>>>>>>>    UChar[32]   rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
68934>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68935>>>>>>>>>
68935>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
68935>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68937>>>>>>>>>    
68937>>>>>>>>>    Boolean bResult
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>
68937>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
68938>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
68939>>>>>>>>>    
68939>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
68940>>>>>>>>>
68940>>>>>>>>>    Function_Return bResult
68941>>>>>>>>>End_Function
68942>>>>>>>>>
68942>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
68943>>>>>>>>>
68943>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
68944>>>>>>>>>
68944>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
68945>>>>>>>>>
68945>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
68946>>>>>>>>>
68946>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68947>>>>>>>>>
68947>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
68948>>>>>>>>>
68948>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
68949>>>>>>>>>
68949>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68950>>>>>>>>>
68950>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
68951>>>>>>>>>    
68951>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
68952>>>>>>>>>
68952>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
68953>>>>>>>>>
68953>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68954>>>>>>>>>
68954>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
68955>>>>>>>>>    
68955>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
68956>>>>>>>>>    
68956>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68957>>>>>>>>>    
68957>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68958>>>>>>>
68958>>>>>>>Class cCryptographerEx is a cObject
68959>>>>>>>    
68959>>>>>>>    Procedure Construct_Object
68961>>>>>>>        Forward Send Construct_Object
68963>>>>>>>        
68963>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
68964>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
68965>>>>>>>        Property Integer    piCipher    CALG_RC4
68966>>>>>>>        Property Integer    piHash      CALG_MD5
68967>>>>>>>        
68967>>>>>>>        // Private properties
68967>>>>>>>        Property Handle     Private_phProv
68968>>>>>>>        
68968>>>>>>>        // Block cipher properties
68968>>>>>>>        Property UChar[]    paKey
68969>>>>>>>        Property UChar[]    paIV
68970>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
68971>>>>>>>        Property Integer    piKeyType       CALG_AES_256
68972>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
68973>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
68974>>>>>>>        Property Integer    piBlockSize     16
68975>>>>>>>    End_Procedure
68976>>>>>>>    
68976>>>>>>>    
68976>>>>>>>    // Acquire key container handle
68976>>>>>>>    Function AcquireContext Returns Handle
68978>>>>>>>        Integer iProvider
68978>>>>>>>        WString wProvider
68978>>>>>>>        Handle hProv
68978>>>>>>>        Boolean bOk
68978>>>>>>>        Pointer pProv
68978>>>>>>>        
68978>>>>>>>        Move 0 to hProv
68979>>>>>>>        Get piProvider to iProvider
68980>>>>>>>        Get psProvider to wProvider
68981>>>>>>>        
68981>>>>>>>        //  Determine address to be passed as provider
68981>>>>>>>        If (Trim(wProvider) <> "") Begin
68983>>>>>>>            Move (AddressOf(wProvider)) to pProv
68984>>>>>>>        End
68984>>>>>>>>
68984>>>>>>>        Else Begin
68985>>>>>>>            Move 0 to pProv
68986>>>>>>>        End
68986>>>>>>>>
68986>>>>>>>        
68986>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
68986>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
68987>>>>>>>        If (not(bOk) or hProv = 0) Begin
68989>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
68990>>>>>>>        End
68990>>>>>>>>
68990>>>>>>>        
68990>>>>>>>        If (not(bOk) or hProv = 0) Begin
68992>>>>>>>            // Fallback to original
68992>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
68993>>>>>>>            
68993>>>>>>>            If (not(bOk) or hProv = 0) Begin
68995>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
68996>>>>>>>            End
68996>>>>>>>>
68996>>>>>>>        End
68996>>>>>>>>
68996>>>>>>>        Set Private_phProv to hProv
68997>>>>>>>        
68997>>>>>>>        Function_Return hProv
68998>>>>>>>    End_Function
68999>>>>>>>    
68999>>>>>>>    // Releases key container handle
68999>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
69001>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
69002>>>>>>>    End_Function
69003>>>>>>>    
69003>>>>>>>    // Creates hash object
69003>>>>>>>    Function CreateHash Handle hProv Returns Handle
69005>>>>>>>        Integer iAlgorithm
69005>>>>>>>        Handle hHash
69005>>>>>>>        Boolean bOk
69005>>>>>>>        
69005>>>>>>>        Move 0 to hHash
69006>>>>>>>        Get piHash to iAlgorithm
69007>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
69008>>>>>>>        
69008>>>>>>>        Function_Return hHash
69009>>>>>>>    End_Function
69010>>>>>>>    
69010>>>>>>>    // Destroys the hash object
69010>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
69012>>>>>>>        Function_Return (CryptDestroyHash(hHash))
69013>>>>>>>    End_Function
69014>>>>>>>    
69014>>>>>>>    // Adds data to hash object
69014>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
69016>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
69017>>>>>>>    End_Function
69018>>>>>>>    
69018>>>>>>>    // Generates session key
69018>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
69020>>>>>>>        Integer iAlgorithm
69020>>>>>>>        Handle hKey
69020>>>>>>>        Boolean bOk
69020>>>>>>>        
69020>>>>>>>        Move 0 to hKey
69021>>>>>>>        Get piCipher to iAlgorithm
69022>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
69023>>>>>>>        
69023>>>>>>>        Function_Return hKey
69024>>>>>>>    End_Function
69025>>>>>>>    
69025>>>>>>>    // Imports a plain text key
69025>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        Boolean   bSuccess
69027>>>>>>>        Handle    hKey
69027>>>>>>>        Integer   iHeadSize iKeySize
69027>>>>>>>        UChar[]   ucaKeyblob
69028>>>>>>>        Integer iVoid
69028>>>>>>>        
69028>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
69029>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
69030>>>>>>>        
69030>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
69031>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
69032>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
69033>>>>>>>        Move iKeySize           to blobhead.dwKeySize
69034>>>>>>>        
69034>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
69035>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
69036>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
69037>>>>>>>        
69037>>>>>>>        Move 0 to hKey
69038>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
69039>>>>>>>        If (not(bSuccess)) Begin
69041>>>>>>>            Move (ShowLastError()) to iVoid
69042>>>>>>>        End
69042>>>>>>>>
69042>>>>>>>        
69042>>>>>>>        Function_Return hKey
69043>>>>>>>    End_Function
69044>>>>>>>    
69044>>>>>>>    // Destroys the key
69044>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
69046>>>>>>>        Function_Return (CryptDestroyKey(hKey))
69047>>>>>>>    End_Function
69048>>>>>>>    
69048>>>>>>>    // Retrieves key data
69048>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
69050>>>>>>>        Integer iBuffer iLen
69050>>>>>>>        Boolean bOk
69050>>>>>>>        
69050>>>>>>>        Move (SizeOfType(Integer)) to iLen
69051>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
69052>>>>>>>        Function_Return iBuffer
69053>>>>>>>    End_Function
69054>>>>>>>    
69054>>>>>>>    // Retrieves a hash value
69054>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
69056>>>>>>>        UChar[] ucHash
69057>>>>>>>        Integer liResult
69057>>>>>>>        DWord   dwDataLen
69057>>>>>>>        
69057>>>>>>>        Move 0 to dwDataLen
69058>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
69059>>>>>>>        If (liResult = 0) ;            Function_Return ""
69062>>>>>>>        
69062>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
69063>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
69064>>>>>>>        If (liResult = 0) ;            Function_Return ""
69067>>>>>>>        
69067>>>>>>>        Function_Return ucHash
69068>>>>>>>    End_Function
69069>>>>>>>
69069>>>>>>>    // Encrypts data
69069>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69071>>>>>>>        Handle hProv hHash hKey
69071>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
69071>>>>>>>        Boolean bOk
69071>>>>>>>        
69071>>>>>>>        Get AcquireContext to hProv
69072>>>>>>>        If (hProv) Begin
69074>>>>>>>            Get CreateHash hProv to hHash
69075>>>>>>>            If (hHash) Begin
69077>>>>>>>                Get HashData hHash ucPassword to bOk
69078>>>>>>>                If (bOk) Begin
69080>>>>>>>                    Get piCipher to iAlgorithm
69081>>>>>>>                    Get DeriveKey hProv hHash to hKey
69082>>>>>>>                End
69082>>>>>>>>
69082>>>>>>>                Get DestroyHash hHash to bOk
69083>>>>>>>            End
69083>>>>>>>>
69083>>>>>>>            
69083>>>>>>>            If (hKey) Begin
69085>>>>>>>                //  First call to determine resulting data size
69085>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69086>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
69087>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
69088>>>>>>>                
69088>>>>>>>                //  Reserve space in string
69088>>>>>>>                If (iDataLen < iCipherLen) Begin
69090>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
69091>>>>>>>                End
69091>>>>>>>>
69091>>>>>>>                
69091>>>>>>>                //  Call to really decrypt
69091>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
69092>>>>>>>                //If (not(bOk)) Begin
69092>>>>>>>                //Move "" to sData
69092>>>>>>>                //Move (GetLastError()) to iErr
69092>>>>>>>                //End
69092>>>>>>>                
69092>>>>>>>                Get DestroyKey hKey to bOk
69093>>>>>>>            End 
69093>>>>>>>>
69093>>>>>>>            Get ReleaseContext hProv to bOk
69094>>>>>>>        End 
69094>>>>>>>>
69094>>>>>>>        Function_Return ucData
69095>>>>>>>    End_Function
69096>>>>>>>    
69096>>>>>>>    // Decrypts data
69096>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69098>>>>>>>        Handle hProv hHash hKey
69098>>>>>>>        Integer iAlgorithm iDataLen
69098>>>>>>>        Boolean bOk
69098>>>>>>>        
69098>>>>>>>        Get AcquireContext to hProv
69099>>>>>>>        If (hProv) Begin
69101>>>>>>>            Get CreateHash hProv to hHash
69102>>>>>>>            If (hHash) Begin
69104>>>>>>>                Get HashData hHash ucPassword to bOk
69105>>>>>>>                If (bOk) Begin
69107>>>>>>>                    Get piCipher to iAlgorithm
69108>>>>>>>                    Get DeriveKey hProv hHash to hKey
69109>>>>>>>                End
69109>>>>>>>>
69109>>>>>>>                Get DestroyHash hHash to bOk
69110>>>>>>>            End
69110>>>>>>>>
69110>>>>>>>            
69110>>>>>>>            If (hKey) Begin
69112>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69113>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
69114>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
69114>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
69116>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
69117>>>>>>>                End
69117>>>>>>>>
69117>>>>>>>                
69117>>>>>>>                Get DestroyKey hKey to bOk
69118>>>>>>>            End
69118>>>>>>>>
69118>>>>>>>            Get ReleaseContext hProv to bOk
69119>>>>>>>        End
69119>>>>>>>>
69119>>>>>>>        Function_Return ucData
69120>>>>>>>    End_Function
69121>>>>>>>    
69121>>>>>>>    // Creates a key
69121>>>>>>>    Function CreateKey Handle hProv Returns Handle
69123>>>>>>>        Integer iAlg iType iByte iLength iSize
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        Boolean bOk
69123>>>>>>>        Handle hKey
69123>>>>>>>        UChar[] aKey
69124>>>>>>>
69124>>>>>>>        Get paKey to aKey
69125>>>>>>>        Get piKeyAlg to iAlg
69126>>>>>>>        Get piKeyType to iType
69127>>>>>>>        Move iAlg                   to keyBlob.header.bType
69128>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
69129>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
69130>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
69131>>>>>>>        
69131>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
69132>>>>>>>        For iByte from 0 to iLength
69138>>>>>>>>
69138>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
69139>>>>>>>        Loop
69140>>>>>>>>
69140>>>>>>>        
69140>>>>>>>        Move 0 to hKey
69141>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
69142>>>>>>>        Function_Return hKey
69143>>>>>>>    End_Function
69144>>>>>>>    
69144>>>>>>>    // Sets the key parameters
69144>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
69146>>>>>>>        Integer iPadding iMode
69146>>>>>>>        Boolean bOk
69146>>>>>>>        UChar[] aIV
69147>>>>>>>        
69147>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
69147>>>>>>>        //For iByte from 0 to iLength
69147>>>>>>>        //    Move iByte to aIV[iByte]
69147>>>>>>>        //Loop
69147>>>>>>>
69147>>>>>>>        // Set initialization vector
69147>>>>>>>        Get paIV to aIV
69148>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
69149>>>>>>>        If (bOk) Begin
69151>>>>>>>            // Set padding
69151>>>>>>>            Get piKeyPadding to iPadding
69152>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
69153>>>>>>>            If (bOk) Begin
69155>>>>>>>                // Set move
69155>>>>>>>                Get piKeyMode to iMode
69156>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
69157>>>>>>>            End
69157>>>>>>>>
69157>>>>>>>        End
69157>>>>>>>>
69157>>>>>>>        Function_Return bOk        
69158>>>>>>>    End_Function
69159>>>>>>>    
69159>>>>>>>    // Encrypts using block cipher
69159>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
69161>>>>>>>        Handle hProv hKey
69161>>>>>>>        Integer iLen iSize iBlocks
69161>>>>>>>        Boolean bOk
69161>>>>>>>        
69161>>>>>>>        Get AcquireContext to hProv
69162>>>>>>>        If (hProv) Begin
69164>>>>>>>            // Create key
69164>>>>>>>            Get CreateKey hProv to hKey
69165>>>>>>>            If (hKey) Begin
69167>>>>>>>                Get SetKeyParameters hKey to bOk
69168>>>>>>>                If (bOk) Begin
69170>>>>>>>                    // Buffer for block ciphers can be up to block length larger
69170>>>>>>>                    Get piBlockSize to iSize
69171>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69172>>>>>>>                    
69172>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
69173>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
69174>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
69175>>>>>>>                End
69175>>>>>>>>
69175>>>>>>>                Get DestroyKey hKey to bOk
69176>>>>>>>            End
69176>>>>>>>>
69176>>>>>>>            Get ReleaseContext hProv to bOk
69177>>>>>>>        End
69177>>>>>>>>
69177>>>>>>>        Function_Return ucData
69178>>>>>>>    End_Function
69179>>>>>>>    
69179>>>>>>>    // Decrypts using block cipher
69179>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
69181>>>>>>>        Handle hProv hKey
69181>>>>>>>        Integer iLen
69181>>>>>>>        Boolean bOk
69181>>>>>>>        
69181>>>>>>>        Get AcquireContext to hProv
69182>>>>>>>        If (hProv) Begin
69184>>>>>>>            // Create key
69184>>>>>>>            Get CreateKey hProv to hKey
69185>>>>>>>            If (hKey) Begin
69187>>>>>>>                Get SetKeyParameters hKey to bOk
69188>>>>>>>                If (bOk) Begin
69190>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69191>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
69192>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
69193>>>>>>>                End
69193>>>>>>>>
69193>>>>>>>                Get DestroyKey hKey to bOk
69194>>>>>>>            End
69194>>>>>>>>
69194>>>>>>>            Get ReleaseContext hProv to bOk
69195>>>>>>>        End
69195>>>>>>>>
69195>>>>>>>        Function_Return ucData
69196>>>>>>>    End_Function
69197>>>>>>>    
69197>>>>>>>    
69197>>>>>>>    //  Generates random data.
69197>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
69199>>>>>>>        Handle hProv
69199>>>>>>>        UChar[] uaResult
69200>>>>>>>        Boolean bRes
69200>>>>>>>        
69200>>>>>>>        Get AcquireContext to hProv
69201>>>>>>>        
69201>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
69202>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
69203>>>>>>>        
69203>>>>>>>        Get ReleaseContext hProv to bRes
69204>>>>>>>        
69204>>>>>>>        Function_Return uaResult
69205>>>>>>>    End_Function
69206>>>>>>>    
69206>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
69206>>>>>>>    Function GenerateRandomString Integer iLength Returns String
69208>>>>>>>        String sResult
69208>>>>>>>        UChar[] ucData
69209>>>>>>>        Pointer pBase64
69209>>>>>>>        Integer iVoid
69209>>>>>>>        
69209>>>>>>>        Get GenerateRandom iLength to ucData
69210>>>>>>>        
69210>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
69211>>>>>>>        Move (PointerToString(pBase64)) to sResult
69212>>>>>>>        Move (Free(pBase64)) to iVoid
69213>>>>>>>        
69213>>>>>>>        Function_Return (Left(sResult, iLength))
69214>>>>>>>    End_Function
69215>>>>>>>    
69215>>>>>>>End_Class
69216>>>>>
69216>>>>>Class cLoginEncryption is a cObject
69217>>>>>    
69217>>>>>    Procedure Construct_Object
69219>>>>>        Forward Send Construct_Object
69221>>>>>        // this must be set to a multi (40ish) character random key
69221>>>>>        Property String psEncryptPassword ""
69222>>>>>        
69222>>>>>        Object oDataCrypter is a cCryptographerEx
69224>>>>>            Set piHash to CALG_SHA_256
69225>>>>>            Set piCipher to CALG_AES_256
69226>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
69227>>>>>            Set piProvider to PROV_RSA_AES
69228>>>>>        End_Object
69229>>>>>    End_Procedure
69230>>>>>    
69230>>>>>    // This can be augmented to return a password encryption key using any
69230>>>>>    // hidden mechanism desired.
69230>>>>>    Function GetEncryptionPassword Returns String
69232>>>>>        String sPassword
69232>>>>>        Get psEncryptPassword to sPassword
69233>>>>>        Function_Return sPassword
69234>>>>>    End_Function
69235>>>>>    
69235>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
69235>>>>>    //
69235>>>>>    // Params:
69235>>>>>    //   sPlainText     String to encrypt.
69235>>>>>    // Returns:
69235>>>>>    //   Base64 encoded hash.
69235>>>>>    Function EncryptPassword String sPlainText Returns String
69237>>>>>        String sEncryptPassword sBase64
69237>>>>>        UChar[] ucBinary
69238>>>>>        Pointer pBase64
69238>>>>>        Integer iVoid
69238>>>>>        
69238>>>>>        //  Encrypt Key
69238>>>>>        Get GetEncryptionPassword to sEncryptPassword
69239>>>>>        If (sEncryptPassword = "") Begin
69241>>>>>            Error DFERR_PROGRAM "No encryption password set"
69242>>>>>>
69242>>>>>        End
69242>>>>>>
69242>>>>>        
69242>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
69243>>>>>        
69243>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
69245>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
69246>>>>>>
69246>>>>>            Function_Return ""
69247>>>>>        End
69247>>>>>>
69247>>>>>        
69247>>>>>        //  Encode binary hash to Base64
69247>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
69248>>>>>        Move (PointerToString(pBase64)) to sBase64
69249>>>>>        Move (Free(pBase64)) to iVoid
69250>>>>>        
69250>>>>>        Function_Return sBase64
69251>>>>>    End_Function
69252>>>>>    
69252>>>>>    
69252>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
69252>>>>>    //
69252>>>>>    // Params:
69252>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
69252>>>>>    // Returns:
69252>>>>>    //   Readable plain text password
69252>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
69254>>>>>        String sEncryptPassword
69254>>>>>        UChar[] ucBinary ucPlain
69256>>>>>        Boolean bIsHex
69256>>>>>        Integer iLen iVoid
69256>>>>>        Pointer pBinary
69256>>>>>        
69256>>>>>        If (sBase64EncryptedPassword <> "") Begin
69258>>>>>            //  Decode from Base64
69258>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
69259>>>>>            
69259>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
69260>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
69261>>>>>                        
69261>>>>>            Move (Free(pBinary)) to iVoid
69262>>>>>            
69262>>>>>            //  Encrypted binary hash to string
69262>>>>>            Get GetEncryptionPassword to sEncryptPassword
69263>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
69264>>>>>        End
69264>>>>>>
69264>>>>>        
69264>>>>>        Function_Return (UCharArrayToString(ucPlain))
69265>>>>>    End_Function
69266>>>>>End_Class
69267>>>
69267>>>Object oLoginEncryption is a cLoginEncryption
69269>>>
69269>>>    // this must be created in your appsrc directory and must contain an encryption
69269>>>    // key that is set to psEncryptPassword. It will look something like this
69269>>>    //
69269>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
69269>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Users\lucas.GPCABLING\Documents\repositorios\dataflex_learning\DataFlexStudio v20.0\Learn the language\AppSrc\LoginEncryptionKey.inc)
69269>>>>// Studio generated login encryption key
69269>>>>Set psEncryptPassword to "o9?|yO_W#yf-mDQXl$D#lW7\~u:(P<:PL}#7{.QU"
69270>>>>
69270>>>    
69270>>>    // use this to register this object to your cConnection Object. This object
69270>>>    // must be created after the cConnection object
69270>>>    Move Self to ghoLoginEncryption
69271>>>End_Object
69272>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.0\Pkg\DatabaseLoginDialog.dg)
69272>>>
69272>>>Use Windows.pkg
69272>>>Use cConnection.pkg
69272>>>Use dfLine.pkg
69272>>>
69272>>>Object oDatabaseLoginDialog is a ModalPanel
69274>>>    Set Label to "Database Login"
69275>>>    Set Location to 2 2
69276>>>    Set Size to 110 211
69277>>>    
69277>>>    Property String psId
69279>>>    Property Boolean pbOk False
69281>>>    Property Boolean pbChanged False
69283>>>    Property Boolean pbAllowRemember True
69285>>>    
69285>>>    // this registers this object with the cConnection object.
69285>>>    Move Self to ghoLoginConnectDialog
69286>>>    
69286>>>    Object oUserIDForm is a Form
69288>>>        Set Label to "User Name"
69289>>>        Set Size to 12 85
69290>>>        Set Location to 34 79
69291>>>        Set Label_Col_Offset to 64
69292>>>        Set peAnchors to anTopLeftRight
69293>>>    End_Object
69294>>>    
69294>>>    Object oPwdForm is a Form
69296>>>        Set Size to 12 85
69297>>>        Set Location to 49 79
69298>>>        Set Label_Col_Offset to 64
69299>>>        Set Password_State to True
69300>>>        Set peAnchors to anTopLeftRight
69301>>>        Set Label to "Password"
69302>>>    End_Object
69303>>>    
69303>>>    Object oTrustedConnection is a CheckBox
69305>>>        Set Size to 10 50
69306>>>        Set Location to 65 79
69307>>>        Set Label to "Trusted Connection"
69308>>>    End_Object
69309>>>    
69309>>>    Object oRemember is a CheckBox
69311>>>        Set Size to 10 50
69312>>>        Set Location to 79 14
69313>>>        Set Label to "Remember and don't ask again"
69314>>>        Set Checked_State to True
69315>>>    End_Object
69316>>>    
69316>>>    Object oLogin_btn is a Button
69318>>>        Set Label to "&Login"
69319>>>        Set Location to 92 102
69320>>>        Set peAnchors to anBottomRight
69321>>>        Set Default_State to True
69322>>>        
69322>>>        Procedure OnClick
69325>>>            Boolean bTrust
69325>>>            String sUser sPwd sConn sErr sId
69325>>>            Integer iError
69325>>>            Get psId to sId
69326>>>            Get Value of oUserIDForm to sUser
69327>>>            Get Value of oPwdForm to sPwd
69328>>>            Get Checked_State of oTrustedConnection to bTrust
69329>>>            
69329>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
69330>>>            If (iError=0) Begin
69332>>>                Set pbOk to True
69333>>>                Set pbChanged to True
69334>>>                Send Close_Panel
69335>>>            End
69335>>>>
69335>>>            Else Begin
69336>>>                Get psErrorText of ghoConnection to sErr
69337>>>                Send UserError sErr "Login Error"
69338>>>            End
69338>>>>
69338>>>        End_Procedure
69339>>>    End_Object
69340>>>    
69340>>>    Object oCancel_btn is a Button
69342>>>        Set Label to "&Cancel"
69343>>>        Set Location to 92 157
69344>>>        Set peAnchors to anBottomRight
69345>>>        
69345>>>        Procedure OnClick
69348>>>            Send Close_Panel
69349>>>        End_Procedure
69350>>>    End_Object
69351>>>    
69351>>>    Object oConnectionIdInfo is a TextBox
69353>>>        Set Size to 10 50
69354>>>        Set Location to 4 14
69355>>>        Set Label to 'Connection Id='
69356>>>    End_Object
69357>>>    
69357>>>    Object oConnectionServerInfo is a TextBox
69359>>>        Set Size to 10 50
69360>>>        Set Location to 16 14
69361>>>        Set Label to 'Server'
69362>>>    End_Object
69363>>>    
69363>>>    Object oLineControl1 is a LineControl
69365>>>        Set Size to 2 202
69366>>>        Set Location to 29 5
69367>>>    End_Object
69368>>>    
69368>>>    Function LoginConnectIdDialog String sId Returns Boolean
69371>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
69371>>>        String sUser sPwd sDescription
69371>>>        tConnection Connect
69371>>>        tConnection Connect
69371>>>        
69371>>>        Get pbAllowRemember to bAllowRemember
69372>>>        
69372>>>        
69372>>>        If not bAllowRemember Begin
69374>>>            Set Enabled_State of oRemember to bRemember
69375>>>            Set Visible_State of oRemember to bRemember
69376>>>        End
69376>>>>
69376>>>        
69376>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
69377>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
69378>>>        Set Value of oConnectionServerInfo to Connect.sString
69379>>>        
69379>>>        Set psId to sId
69380>>>        Set pbOk to False
69381>>>        Set pbChanged to False
69382>>>        Set Value of oUserIDForm to Connect.sUID
69383>>>        Set Value of oPwdForm to ""
69384>>>        
69384>>>        Send Popup
69385>>>        
69385>>>        Get pbOk to bOk
69386>>>        Get pbChanged to bChanged
69387>>>        If (bChanged and bOk) Begin
69389>>>            If bAllowRemember Begin
69391>>>                Get Checked_State of oRemember to bRemember
69392>>>                If bRemember Begin
69394>>>                    Get Checked_State of oTrustedConnection to bTrusted
69395>>>                    If not (bTrusted) Begin
69397>>>                        Get Value of oUserIDForm to sUser
69398>>>                        Get Value of oPwdForm to sPwd
69399>>>                    End
69399>>>>
69399>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
69400>>>                End
69400>>>>
69400>>>            End
69400>>>>
69400>>>        End
69400>>>>
69400>>>        Function_Return bOk
69401>>>    End_Function
69402>>>    
69402>>>    
69402>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
69403>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
69404>>>End_Object
69405>>>
69405>    End_Object
69406>
69406>End_Object
69407>
69407>Object oToolTipController is a cToolTipController
69409>    Move Self to ghoToolTipController
69410>End_Object
69411>
69411>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oEditContextMenu.pkg)
69411>>>Use cCJStandardMenuItemClasses.pkg
69411>>>
69411>>>Object oEditContextMenu is a cCJContextMenu
69413>>>    
69413>>>    Move Self to Default_Form_Floating_Menu_ID
69414>>>    
69414>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69416>>>    End_Object
69417>>>    
69417>>>    Object oCutMenuItem is a cCJCutMenuItem
69419>>>        Set pbControlBeginGroup to True
69420>>>    End_Object
69421>>>    
69421>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69423>>>    End_Object
69424>>>
69424>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69426>>>    End_Object
69427>>>
69427>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69429>>>    End_Object
69430>>>
69430>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69432>>>        Set pbControlBeginGroup to True
69433>>>    End_Object
69434>>>
69434>>>End_Object
69435>>>
69435>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oDEOEditContextMenu17.pkg)
69435>>>Use Windows.pkg
69435>>>Use cCJStandardMenuItemClasses.pkg
69435>>>Use cCJDeoMenuItemClasses.pkg
69435>>>
69435>>>
69435>>>Object oDEOEditContextMenu17 is a cCJContextMenu
69437>>>    
69437>>>    Move Self to Default_dbFloating_Menu_ID
69438>>>    
69438>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69440>>>    End_Object
69441>>>    
69441>>>    Object oCutMenuItem is a cCJCutMenuItem
69443>>>        Set pbControlBeginGroup to True
69444>>>    End_Object
69445>>>    
69445>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69447>>>    End_Object
69448>>>
69448>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69450>>>    End_Object
69451>>>
69451>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69453>>>    End_Object
69454>>>
69454>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69456>>>        Set pbControlBeginGroup to True
69457>>>    End_Object
69458>>>
69458>>>    Object oPromptMenuItem is a cCJPromptMenuItem
69460>>>        Set pbControlBeginGroup to True
69461>>>    End_Object
69462>>>
69462>>>    Object oFindNextMenu is a cCJFindNextMenuItem
69464>>>        Set pbControlBeginGroup to True
69465>>>    End_Object
69466>>>
69466>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69468>>>    End_Object
69469>>>
69469>>>    Object oClearMenuItem is a cCJClearMenuItem
69471>>>        Set pbControlBeginGroup to True
69472>>>    End_Object
69473>>>
69473>>>    Object oClearAllMenu is a cCJClearAllMenuItem
69475>>>    End_Object
69476>>>
69476>>>    Object oSaveMenu is a cCJSaveMenuItem
69478>>>    End_Object
69479>>>    
69479>>>    Object oDeleteMenu is a cCJDeleteMenuItem
69481>>>    End_Object
69482>>>
69482>>>    Object oRememberitem is a cCJRememberFieldMenuItem
69484>>>        Set pbControlBeginGroup to True
69485>>>    End_Object
69486>>>
69486>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
69488>>>    End_Object
69489>>>
69489>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
69491>>>    End_Object
69492>>>
69492>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
69494>>>    End_Object
69495>>>
69495>>>End_Object
69496>
69496>Object oMain is a Panel
69498>    Set Label To "My Project"
69499>    Set Location to 4 3
69500>    Set Size to 300 450
69501>
69501>    Object oCommandBarSystem is a cCJCommandBarSystem
69503>        Set pbTimerUpdate to True
69504>        Set peVisualTheme to xtpThemeOffice2013Outlook
69505>        Set pbAutoResizeIcons to True
69506>
69506>        Procedure OnCreateCommandBars
69509>            Handle hoOptions
69509>            Get OptionsObject to hoOptions
69510>            Forward Send OnCreateCommandBars
69512>        End_Procedure
69513>
69513>        Object oMenuBar is a cCJMenuBar
69515>
69515>            Object oFileMenu is a cCJMenuItem
69517>                Set peControlType to xtpControlPopup          
69518>                Set psCaption   to "&File"
69519>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
69520>                Set psCategory to "Menus"
69521>
69521>                Object oClearMenuItem is a cCJClearMenuItem
69523>                    Set pbAddToDesignerMenu to True
69524>                End_Object
69525>
69525>                Object oClearAllMenu is a cCJClearAllMenuItem
69527>                    Set pbAddToDesignerMenu to True
69528>                End_Object
69529>
69529>                Object oPromptMenuItem is a cCJPromptMenuItem
69531>                    Set pbAddToDesignerMenu to True
69532>                    Set pbControlBeginGroup to True
69533>                End_Object
69534>
69534>                Object oFindMenuItem is a cCJFindMenuItem
69536>                    Set pbAddToDesignerMenu to True
69537>                    Set pbControlBeginGroup to True
69538>                End_Object
69539>
69539>                Object oFindNextMenu is a cCJFindNextMenuItem
69541>                    Set pbAddToDesignerMenu to True
69542>                End_Object
69543>
69543>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69545>                    Set pbAddToDesignerMenu to True
69546>                End_Object
69547>
69547>                Object oFindFirstMenu is a cCJFindFirstMenuItem
69549>                    Set pbAddToDesignerMenu to True
69550>                End_Object
69551>
69551>                Object oFindLastMenu is a cCJFindLastMenuItem
69553>                    Set pbAddToDesignerMenu to True
69554>                End_Object
69555>
69555>                Object oSaveMenuItem is a cCJSaveMenuItem
69557>                    Set pbAddToDesignerMenu to True
69558>                    Set pbControlBeginGroup to True
69559>                End_Object
69560>
69560>                Object oDeleteMenuItem is a cCJDeleteMenuItem
69562>                    Set pbAddToDesignerMenu to True
69563>                End_Object
69564>
69564>                Object oExitMenu is a cCJExitMenuItem
69566>                    Set pbControlBeginGroup to True
69567>                End_Object
69568>
69568>            End_Object
69569>
69569>            Object oViewMenu is a cCJMenuItem
69571>                Set peControlType to xtpControlPopup
69572>                Set psCaption to "&View"
69573>                Set psToolTip to "View"
69574>                Set psDescription to "Available Views"
69575>
69575>                Object oTabbedDemoMenuItem is a cCJMenuItem
69577>                    Set psCaption to "TabbedDemo"
69578>                    Set psTooltip to "TabbedDemo"
69579>                
69579>                    Procedure OnExecute Variant vCommandBarControl
69582>                        Handle hoClient
69582>                        Get Client_Id to hoClient
69583>                        Send Activate_oTabbedDemo of hoClient
69584>                    End_Procedure
69585>                End_Object
69586>
69586>                Object oConsultaFileMenuItem is a cCJMenuItem
69588>                    Set psCaption to "ConsultaFile"
69589>                    Set psTooltip to "ConsultaFile"
69590>                
69590>                    Procedure OnExecute Variant vCommandBarControl
69593>                        Handle hoClient
69593>                        Get Client_Id to hoClient
69594>                        Send Activate_oConsultaFile of hoClient
69595>                    End_Procedure
69596>                End_Object
69597>            End_Object
69598>            
69598>            Object oReportMenu is a cCJMenuItem
69600>                Set peControlType to xtpControlPopup          
69601>                Set psCaption to "&Report"
69602>                Set psToolTip to "Report"
69603>                Set psDescription to "Available Reports"
69604>            End_Object
69605>
69605>            Object oNavigateMenu is a cCJMenuItem
69607>                Set peControlType to xtpControlPopup      
69608>                Set psCaption to "&Navigate"    
69609>                Set psTooltip to "Navigate"    
69610>                Set psDescription to "Move to different areas of the application"
69611>
69611>                Object oNextAreaMenu is a cCJNextAreaMenu
69613>                End_Object
69614>
69614>                Object oPriorAreaMenu is a cCJPriorAreaMenu
69616>                End_Object
69617>
69617>                Object oNextViewMenu is a cCJNextViewMenu
69619>                End_Object
69620>
69620>                Object oPriorViewMenu is a cCJPriorViewMenu
69622>                End_Object
69623>
69623>                Object oPromptMenu is a cCJPromptMenuItem
69625>                    Set pbControlBeginGroup to True
69626>                End_Object
69627>
69627>                Object oZoomMenu is a cCJZoomMenuItem
69629>                End_Object
69630>
69630>            End_Object
69631>
69631>            Object oWindowMenu is a cCJMDIWindowsMenuItem
69633>                Set peControlType to xtpControlPopup
69634>                Set psCaption to "&Window"
69635>                Set psToolTip to "Window"
69636>                Set psDescription to "Display Current Views and set other display options."    
69637>
69637>                // These are the static windows items. More will be created in onInitPopup 
69637>                Object oDisplayOptionsMenu is a cCJMenuItem
69639>                    Set peControlType to xtpControlPopup          
69640>                    Set psCaption to "&Display Options"
69641>                    Set psToolTip to "Display Options"
69642>                    Set psDescription to "Set display options"
69643>
69643>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
69645>                    End_Object
69646>
69646>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
69648>                    End_Object
69649>
69649>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
69651>                        Set pbControlBeginGroup to True
69652>                    End_Object
69653>
69653>                End_Object
69654>
69654>                Object oCascadeMenu is a cCJCascadeMenuItem
69656>                    Set pbControlBeginGroup to True
69657>                End_Object
69658>
69658>                Object oHorizTile is a cCJTileHorizontally
69660>                End_Object
69661>
69661>                Object oVertTile is a cCJTileVertically
69663>                End_Object
69664>
69664>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
69666>                    Set pbControlBeginGroup to True
69667>                End_Object
69668>
69668>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
69670>                End_Object
69671>
69671>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
69673>                    Set pbControlBeginGroup to True
69674>                End_Object
69675>
69675>            End_Object
69676>
69676>            Object oHelpMenu is a cCJMenuItem
69678>                Set peControlType to xtpControlPopup    
69679>                Set psCaption to "&Help"
69680>                Set psDescription to "Access Information for learning and using this DataFlex application."
69681>                Set psToolTip to "Help"
69682>
69682>                Object oHelpMenuItem is a cCJHelpMenuItem 
69684>                End_Object
69685>
69685>                Object oAboutMenuItem is a cCJAboutMenuItem
69687>                End_Object
69688>
69688>            End_Object
69689>
69689>        End_Object
69690>
69690>        Object oFindToolBar is a cCJToolbar
69692>            Set psTitle to "Finding Toolbar"
69693>
69693>            Object oFindFirstTool is a cCJFindFirstMenuItem
69695>            End_Object
69696>
69696>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
69698>            End_Object
69699>
69699>            Object oFindMenuTool is a cCJFindMenuItem
69701>            End_Object
69702>
69702>            Object oFindNextTool is a cCJFindNextMenuItem
69704>            End_Object
69705>
69705>            Object oFindLastTool is a cCJFindLastMenuItem
69707>            End_Object
69708>
69708>            Object oPromptToolItem is a cCJPromptMenuItem
69710>                Set pbControlBeginGroup to True
69711>            End_Object
69712>
69712>        End_Object
69713>
69713>        Object oFileToolBar is a cCJToolbar
69715>            Set psTitle to "Data Entry Toolbar"
69716>
69716>            Object oClearToolItem is a cCJClearMenuItem
69718>                Set peControlStyle to xtpButtonIconAndCaption
69719>            End_Object
69720>
69720>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
69722>                Set peControlStyle to xtpButtonIconAndCaption
69723>            End_Object
69724>
69724>            Object oSaveToolItem is a cCJSaveMenuItem
69726>                Set peControlStyle to xtpButtonIconAndCaption
69727>                Set pbControlBeginGroup to True
69728>            End_Object
69729>
69729>            Object oDeleteToolItem is a cCJDeleteMenuItem
69731>                Set peControlStyle to xtpButtonIconAndCaption
69732>            End_Object
69733>
69733>        End_Object
69734>
69734>        Object oEditToolBar is a cCJToolbar
69736>            Set psTitle to "Edit Toolbar"
69737>
69737>            Object oCutToolbarItem is a cCJCutMenuItem
69739>            End_Object
69740>
69740>            Object oCopyToolbarItem is a cCJCopyMenuItem
69742>            End_Object
69743>
69743>            Object oPasteToolbarItem is a cCJPasteMenuItem
69745>            End_Object
69746>
69746>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
69748>                Set pbControlBeginGroup to True
69749>            End_Object
69750>
69750>        End_Object
69751>
69751>        Object oRememberToolbar is a cCJToolbar
69753>            Set psTitle to C_$Remember
69754>
69754>            Object oRememberItems is a cCJMenuItem
69756>
69756>                Set peControlType to xtpControlPopup
69757>                Set peControlStyle to xtpButtonCaption
69758>                Set psCaption to C_$Remember
69759>                
69759>                Object oMenuItem is a cCJRememberFieldMenuItem
69761>                    Set peControlStyle to xtpButtonIconAndCaption
69762>                End_Object
69763>                
69763>                Object oMenuItem is a cCJRememberLastFieldMenuItem
69765>                    Set peControlStyle to xtpButtonIconAndCaption
69766>                End_Object
69767>                
69767>                Object oMenuItem is a cCJUnRememberFieldMenuItem
69769>                    Set peControlStyle to xtpButtonIconAndCaption
69770>                End_Object
69771>                
69771>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
69773>                    Set peControlStyle to xtpButtonIconAndCaption
69774>                End_Object
69775>
69775>            End_Object
69776>            
69776>        End_Object
69777>        
69777>        Object oStatusBar is a cCJStatusBar
69779>
69779>            Object oStatusPane1 is a cCJStatusBarPane
69781>                Set piID to sbpIDIdlePane
69782>                Set pbStyleStretch to True
69783>            End_Object
69784>
69784>            Object oStatusPane2 is a cCJStatusBarPane
69786>                Set phoViewPane to Self
69787>                Set pbStyleStretch to True
69788>            End_Object
69789>
69789>        End_Object
69790>
69790>    End_Object
69791>
69791>    Object oClientArea is a ClientArea
69793>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\StdAbout.pkg)
69793>>>// This provides a quick and simple way to create an about package for a program.
69793>>>// You need to create a message inside you client area called Activate_About.
69793>>>// Within this message you should send the message DoAbout passing needed
69793>>>// string information.
69793>>>//
69793>>>//       Procedure Activate_About
69793>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
69793>>>//       End_Procedure
69793>>>//    where: sTitle =     Name of application. If none provided, uses caption
69793>>>//                        bar title
69793>>>//           sVersion   = Version Line. If none provided, will be blank
69793>>>//           sCopyRight = Copyright Line. If none provided, will be blank
69793>>>//           sAuthor    = Author name, blank if none provided
69793>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
69793>>>//                        is used.
69793>>>// It is expected that you will place this in your own object package. For
69793>>>// example an order about package may look like this:
69793>>>//
69793>>>//   // OrderAbout.pkg
69793>>>//   Use StdAbout.pkg
69793>>>//   Procedure Activate_About
69793>>>//      String sTitle sCopyright sVersion sAuthor
69793>>>//      Move "My Order Entry System" to sTitle
69793>>>//      Move "Version 2.1" to sVersion
69793>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
69793>>>//      Move "John Smith"  to sAuthor
69793>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
69793>>>//   end_procedure
69793>>>//   // end of file.
69793>>>
69793>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dfabout.pkg)
69793>>>>>Use LanguageText.pkg
69793>>>>>Use Windows.pkg
69793>>>>>Use DFbitmap.pkg
69793>>>>>Use GlobalFunctionsProcedures.pkg
69793>>>>>Use cTextEdit.pkg
69793>>>>>Use tWinStructs.pkg
69793>>>>>
69793>>>>>Use cli.pkg
69793>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.0\Pkg\DFBTRDRV.PKG)
69793>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
69793>>>>>>>// Notice      : This package contains constants and commands, used to call
69793>>>>>>>//               specific functions in the DFBTRDRV.
69793>>>>>>>Use Ui
69793>>>>>>>//
69793>>>>>>>// Driver Indentification
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>// Driver attributes
69793>>>>>>>//
69793>>>>>>>// Call_Driver functions ID's
69793>>>>>>>//
69793>>>>>>>//
69793>>>>>>>// DFBTRFN_CONVERT_FILE options
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// DFBTRFN_SET_OWNER options
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to create all vars which may be needed
69793>>>>>>>// in other commands.
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to set the owner of a Btrieve file.
69793>>>>>>>// File must have been opened.
69793>>>>>>>// Filenumber needs to be passed.
69793>>>>>>>// To clear set the owner to "".
69793>>>>>>>// Examples:
69793>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
69793>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
69793>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
69793>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
69793>>>>>>>// To clear:
69793>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to parse DFBTR_SET_OWNVER
69793>>>>>>>// options.
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to parse for Callback
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to clear the owner of a Btrieve file.
69793>>>>>>>// File must have been opened.
69793>>>>>>>// Filenumber needs to be passed.
69793>>>>>>>// Examples:
69793>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to add a owner name to the internal list of ownernames
69793>>>>>>>// which will be tries when opening files.
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to remove all owners from the internal list of ownernames
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to set the owner name to be used when opening the DDF files.
69793>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
69793>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
69793>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to change the transaction type.
69793>>>>>>>// Valid types are:
69793>>>>>>>//     DFBTRTT_NONE
69793>>>>>>>//     DFBTRTT_EXCLUSIVE
69793>>>>>>>//     DFBTRTT_CONCURRENT
69793>>>>>>>//
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to get the current transaction type.
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to set explicit_locking
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to get explicit locking
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>//
69793>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
69793>>>>>>>//
69793>>>>>>>
69793>>>>>>>// Purpose: An instance of this class can be used as a broker object to
69793>>>>>>>//          call several Dfbtrdrv releated methods.
69793>>>>>>>
69793>>>>>>>Class cDFBtrDrvHandler is an Array
69794>>>>>>>    
69794>>>>>>>    Procedure Construct_Object Integer iImage
69796>>>>>>>        Forward Send Construct_object iImage
69798>>>>>>>        
69798>>>>>>>        Property String  psDriverID "DFBTRDRV"
69799>>>>>>>    End_Procedure
69800>>>>>>>    
69800>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
69800>>>>>>>    //
69800>>>>>>>    
69800>>>>>>>    Function CKRevision Returns String
69802>>>>>>>        String  sDriverID
69802>>>>>>>        String  sRevision
69802>>>>>>>        String  sVoid
69802>>>>>>>        Integer iRetval
69802>>>>>>>        
69802>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69802>>>>>>>        // This error would otherwise be raised when we have an older
69802>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69802>>>>>>>        Send Ignore_error to Error_object_Id 20491
69803>>>>>>>        Get psDriverID to sDriverID
69804>>>>>>>        Move (Repeat(" ", 255)) to sRevision
69805>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
69810>>>>>>>        Send Trap_Error to Error_object_Id 20491
69811>>>>>>>        If (Trim(sRevision) = "") Begin
69813>>>>>>>            // Unable to get the revision. return all zeroes.
69813>>>>>>>            Move "0.0.0.0" to sRevision
69814>>>>>>>        End
69814>>>>>>>>
69814>>>>>>>        Function_Return sRevision
69815>>>>>>>    End_Function
69816>>>>>>>    
69816>>>>>>>    Function CkUsesUri Returns Integer
69818>>>>>>>        String  sDriverID
69818>>>>>>>        String  sVoid1
69818>>>>>>>        String  sVoid2
69818>>>>>>>        Integer iRetval
69818>>>>>>>        
69818>>>>>>>        Get psDriverID to sDriverID
69819>>>>>>>        
69819>>>>>>>        Move 0 to iRetval
69820>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69820>>>>>>>        // This error would otherwise be raised when we have an older
69820>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
69820>>>>>>>        Send Ignore_error to Error_object_Id 20491
69821>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
69826>>>>>>>        Send Trap_Error to Error_object_Id 20491
69827>>>>>>>        
69827>>>>>>>        Function_Return iRetval
69828>>>>>>>    End_Function
69829>>>>>>>    
69829>>>>>>>    
69829>>>>>>>    
69829>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
69829>>>>>>>    //
69829>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
69829>>>>>>>    //
69829>>>>>>>    
69829>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
69831>>>>>>>        Integer iPartRev
69831>>>>>>>        Integer iCurrentPart
69831>>>>>>>        Integer iSeparatorPos
69831>>>>>>>        
69831>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
69834>>>>>>>        
69834>>>>>>>        Move 0 to iCurrentPart
69835>>>>>>>        Repeat
69835>>>>>>>>
69835>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
69836>>>>>>>            If (iSeparatorPos > 0) Begin
69838>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
69839>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
69840>>>>>>>                Increment iCurrentPart
69841>>>>>>>            End
69841>>>>>>>>
69841>>>>>>>            Else If (sRevision <> "") Begin
69844>>>>>>>                Move sRevision to iPartRev
69845>>>>>>>                Move "" to sRevision
69846>>>>>>>                Increment iCurrentPart
69847>>>>>>>            End
69847>>>>>>>>
69847>>>>>>>            Else ;                Move -1 to iPartRev
69849>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
69851>>>>>>>        
69851>>>>>>>        Function_Return iPartRev
69852>>>>>>>    End_Function
69853>>>>>>>    
69853>>>>>>>    
69853>>>>>>>    
69853>>>>>>>    //
69853>>>>>>>    //  Returns the major revision of the CK
69853>>>>>>>    //
69853>>>>>>>    
69853>>>>>>>    Function CKMajorRevision Returns Integer
69855>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
69856>>>>>>>    End_Function
69857>>>>>>>    
69857>>>>>>>    
69857>>>>>>>    
69857>>>>>>>    //  Returns the minor revision of the CK
69857>>>>>>>    //
69857>>>>>>>    
69857>>>>>>>    Function CKMinorRevision Returns Integer
69859>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
69860>>>>>>>    End_Function
69861>>>>>>>    
69861>>>>>>>    
69861>>>>>>>    //  Returns the release revision of the CK
69861>>>>>>>    //
69861>>>>>>>    
69861>>>>>>>    Function CKReleaseRevision Returns Integer
69863>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
69864>>>>>>>    End_Function
69865>>>>>>>    
69865>>>>>>>    
69865>>>>>>>    //  Returns the major revision of the CK
69865>>>>>>>    //
69865>>>>>>>    
69865>>>>>>>    Function CKBuildRevision Returns Integer
69867>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
69868>>>>>>>    End_Function
69869>>>>>>>    
69869>>>>>>>    
69869>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
69869>>>>>>>    //
69869>>>>>>>    
69869>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
69871>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
69874>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
69877>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
69880>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
69883>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
69886>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
69890>>>>>>>            End
69890>>>>>>>>
69890>>>>>>>        End
69890>>>>>>>>
69890>>>>>>>        
69890>>>>>>>        Function_Return (False)
69891>>>>>>>    End_Function
69892>>>>>>>    
69892>>>>>>>    //   Functions to query the Pervasive.SQL version:
69892>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
69892>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
69892>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
69892>>>>>>>    //
69892>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
69892>>>>>>>    //   in the following format:
69892>>>>>>>    //       <version>.<revision>.<type>
69892>>>>>>>    //   possible values for <type>:
69892>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
69892>>>>>>>    //         server using Workgroup authentication mode
69892>>>>>>>    //       C for client cache engine
69892>>>>>>>    //       D for DOS workstation
69892>>>>>>>    //       N for client Requester
69892>>>>>>>    //       S for NetWare server
69892>>>>>>>    //       T for 32-bit Windows server engine
69892>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
69892>>>>>>>    //
69892>>>>>>>    //   example:
69892>>>>>>>    //       8.50.T
69892>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
69892>>>>>>>    //   32-bits Windows server.
69892>>>>>>>    //
69892>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
69892>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
69892>>>>>>>    //
69892>>>>>>>    //   If the version information is not available or can not be obtained
69892>>>>>>>    //   the functions will return "0.0.0"
69892>>>>>>>    
69892>>>>>>>    //  Returns the version information of the
69892>>>>>>>    //           Pervasive.SQL Client requester.
69892>>>>>>>    
69892>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
69894>>>>>>>        
69894>>>>>>>        String  sDriverID
69894>>>>>>>        String  sVersion
69894>>>>>>>        String  sVoid
69894>>>>>>>        Integer iRetval
69894>>>>>>>        
69894>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69894>>>>>>>        // This error would otherwise be raised when we have an older
69894>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69894>>>>>>>        Send Ignore_error to Error_object_Id 20491
69895>>>>>>>        Get psDriverID to sDriverID
69896>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69897>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69902>>>>>>>        Send Trap_Error to Error_object_Id 20491
69903>>>>>>>        If (Trim(sVersion) = "") Begin
69905>>>>>>>            // Unable to get the revision. return all zeroes.
69905>>>>>>>            Move "0.0.0" to sVersion
69906>>>>>>>        End
69906>>>>>>>>
69906>>>>>>>        Function_Return sVersion
69907>>>>>>>    End_Function
69908>>>>>>>    
69908>>>>>>>    //           Pervasive.SQL Engine
69908>>>>>>>    
69908>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
69910>>>>>>>        
69910>>>>>>>        String  sDriverID
69910>>>>>>>        String  sVersion
69910>>>>>>>        String  sVoid
69910>>>>>>>        Integer iRetval
69910>>>>>>>        
69910>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69910>>>>>>>        // This error would otherwise be raised when we have an older
69910>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69910>>>>>>>        Send Ignore_error to Error_object_Id 20491
69911>>>>>>>        Get psDriverID to sDriverID
69912>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69913>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69918>>>>>>>        Send Trap_Error to Error_object_Id 20491
69919>>>>>>>        If (Trim(sVersion) = "") Begin
69921>>>>>>>            // Unable to get the revision. return all zeroes.
69921>>>>>>>            Move "0.0.0" to sVersion
69922>>>>>>>        End
69922>>>>>>>>
69922>>>>>>>        Function_Return sVersion
69923>>>>>>>    End_Function
69924>>>>>>>    
69924>>>>>>>    //  Returns the version information of the
69924>>>>>>>    //           Pervasive.SQL Server Engine
69924>>>>>>>    
69924>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
69926>>>>>>>        
69926>>>>>>>        String  sDriverID
69926>>>>>>>        String  sVersion
69926>>>>>>>        String  sVoid
69926>>>>>>>        Integer iRetval
69926>>>>>>>        
69926>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69926>>>>>>>        // This error would otherwise be raised when we have an older
69926>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69926>>>>>>>        Send Ignore_error to Error_object_Id 20491
69927>>>>>>>        Get psDriverID to sDriverID
69928>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69929>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69934>>>>>>>        Send Trap_Error to Error_object_Id 20491
69935>>>>>>>        If (Trim(sVersion) = "") Begin
69937>>>>>>>            // Unable to get the revision. return all zeroes.
69937>>>>>>>            Move "0.0.0" to sVersion
69938>>>>>>>        End
69938>>>>>>>>
69938>>>>>>>        Function_Return sVersion
69939>>>>>>>    End_Function
69940>>>>>>>    
69940>>>>>>>End_Class
69941>>>>>>>
69941>>>>>>>
69941>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.0\Pkg\MSSqldrv.pkg)
69941>>>>>>>//     Package that declares MS SQL driver constants and functions.
69941>>>>>>>//     This package can be used by developers who want to add Data Access
69941>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69941>>>>>>>
69941>>>>>>>Use Cli.pkg
69941>>>>>>>Use SQL.pkg
69941>>>>>>>
69941>>>>>>>//   Driver Indentification
69941>>>>>>>
69941>>>>>>>//   Error number constants
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>// SQL Server spcific types.
69941>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69941>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69941>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69941>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69941>>>>>>>
69941>>>>>>>// SQL Server spcific types.
69941>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69941>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69941>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69941>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69941>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69941>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69941>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69941>>>>>>>//
69941>>>>>>>//     Setup a constraint for a file.
69941>>>>>>>
69941>>>>>>>
69941>>>>>>>Class cMSSQLHandler is a cCLIHandler
69942>>>>>>>    
69942>>>>>>>    Procedure Construct_Object
69944>>>>>>>        Forward Send Construct_Object
69946>>>>>>>        
69946>>>>>>>        Set psDriverID to MSSQLDRV_ID
69947>>>>>>>    End_Procedure
69948>>>>>>>    
69948>>>>>>>    
69948>>>>>>>    
69948>>>>>>>    //   Extract the list from the out connect string.
69948>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69950>>>>>>>        String  sItem
69950>>>>>>>        Integer iStart
69950>>>>>>>        Integer iEnd
69950>>>>>>>        
69950>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69953>>>>>>>        
69953>>>>>>>        Send Delete_Data to hoStore
69954>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69955>>>>>>>        While (iStart > 0)
69959>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69960>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69963>>>>>>>            Else Begin
69964>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69965>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69966>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69969>>>>>>>                
69969>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69972>>>>>>>                
69972>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69975>>>>>>>            End
69975>>>>>>>>
69975>>>>>>>        Loop
69976>>>>>>>>
69976>>>>>>>        
69976>>>>>>>        Function_Return (Item_Count(hoStore))
69977>>>>>>>    End_Procedure
69978>>>>>>>    
69978>>>>>>>    
69978>>>>>>>    
69978>>>>>>>    //   Call the driver's browse connect function
69978>>>>>>>    Function BrowseConnect String sInConnStr Returns String
69980>>>>>>>        String  sDriver
69980>>>>>>>        String  sOutConnStr
69980>>>>>>>        Integer iArg
69980>>>>>>>        Integer iRetval
69980>>>>>>>        
69980>>>>>>>        Get psDriverID to sDriver
69981>>>>>>>        If (sDriver <> "") Begin
69983>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69984>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69989>>>>>>>        End
69989>>>>>>>>
69989>>>>>>>        
69989>>>>>>>        Function_Return sOutConnStr
69990>>>>>>>    End_Function// BrowseConnect
69991>>>>>>>    
69991>>>>>>>    
69991>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
69993>>>>>>>        String  sDriver
69993>>>>>>>        String  sOutConnStr
69993>>>>>>>        Integer iArg
69993>>>>>>>        Integer iRetval
69993>>>>>>>        
69993>>>>>>>        Move 1 to iArg // Browses only local
69994>>>>>>>        
69994>>>>>>>        Get psDriverID to sDriver
69995>>>>>>>        If (sDriver <> "") Begin
69997>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69998>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70003>>>>>>>        End
70003>>>>>>>>
70003>>>>>>>        
70003>>>>>>>        Function_Return sOutConnStr
70004>>>>>>>    End_Function// BrowseConnect
70005>>>>>>>    
70005>>>>>>>    
70005>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
70007>>>>>>>        
70007>>>>>>>        String  sServerList
70007>>>>>>>        Integer iNumServers
70007>>>>>>>        Integer iDriver
70007>>>>>>>        Integer iClientVersion
70007>>>>>>>        String  sDriver
70007>>>>>>>        
70007>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
70008>>>>>>>        
70008>>>>>>>        If (iDriver) Begin
70010>>>>>>>            
70010>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
70013>>>>>>>            
70013>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
70014>>>>>>>            
70014>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
70015>>>>>>>            If (iNetworkLocal = 0) Begin
70017>>>>>>>                Get BrowseConnect sDriver to sServerList
70018>>>>>>>            End
70018>>>>>>>>
70018>>>>>>>            Else Begin
70019>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
70020>>>>>>>            End
70020>>>>>>>>
70020>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
70021>>>>>>>        End
70021>>>>>>>>
70021>>>>>>>        
70021>>>>>>>        Function_Return iNumServers
70022>>>>>>>        
70022>>>>>>>    End_Function
70023>>>>>>>    
70023>>>>>>>    //   Enumerate the available SQL Server database servers
70023>>>>>>>    //   This function will return all SQL Server instances on the network.
70023>>>>>>>    //   This may take a long time.
70023>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
70023>>>>>>>    Function EnumerateServers Returns Integer
70025>>>>>>>        
70025>>>>>>>        Integer iNumServers
70025>>>>>>>        Integer iNetworkLocal
70025>>>>>>>        
70025>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
70026>>>>>>>        
70026>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70027>>>>>>>        
70027>>>>>>>        Function_Return iNumServers
70028>>>>>>>        
70028>>>>>>>    End_Function
70029>>>>>>>    
70029>>>>>>>    
70029>>>>>>>    //   Enumerate the available SQL Server database servers
70029>>>>>>>    //   This function will return only return SQL Server instance on the local machine
70029>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
70029>>>>>>>    Function EnumerateServersLocal Returns Integer
70031>>>>>>>        
70031>>>>>>>        Integer iNumServers
70031>>>>>>>        Integer iNetworkLocal
70031>>>>>>>        
70031>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
70032>>>>>>>        
70032>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70033>>>>>>>        
70033>>>>>>>        Function_Return iNumServers
70034>>>>>>>        
70034>>>>>>>    End_Function
70035>>>>>>>    
70035>>>>>>>    
70035>>>>>>>    
70035>>>>>>>    //   Enumerate database in a given server.
70035>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
70037>>>>>>>        Integer hoSQL
70037>>>>>>>        String  sConnect
70037>>>>>>>        String  sDatabase
70037>>>>>>>        Integer hdbc
70037>>>>>>>        Integer hstmt
70037>>>>>>>        Integer iFetchResult
70037>>>>>>>        
70037>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70040>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70043>>>>>>>        
70043>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70046>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70048>>>>>>>        
70048>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70050>>>>>>>            Move Current_Object to hoSQL
70051>>>>>>>        End_Object
70052>>>>>>>        
70052>>>>>>>        If (hoSQL <> 0) Begin
70054>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70055>>>>>>>            If (hdbc <> 0) Begin
70057>>>>>>>                Get SQLOpen of hdbc to hstmt
70058>>>>>>>                If (hstmt <> 0) Begin
70060>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70060>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70060>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70060>>>>>>>                    //   stay the same.
70060>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70061>>>>>>>                    Send SQLCall to hstmt
70062>>>>>>>                    Repeat
70062>>>>>>>>
70062>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70063>>>>>>>                        If (iFetchResult <> 0) Begin
70065>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70066>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70067>>>>>>>                        End
70067>>>>>>>>
70067>>>>>>>                    Until (iFetchResult = 0)
70069>>>>>>>                    
70069>>>>>>>                    Send SQLClose to hstmt
70070>>>>>>>                End
70070>>>>>>>>
70070>>>>>>>                Send SQLDisconnect to hdbc
70071>>>>>>>            End
70071>>>>>>>>
70071>>>>>>>        End
70071>>>>>>>>
70071>>>>>>>        Send Destroy_Object to hoSQL
70072>>>>>>>        
70072>>>>>>>        Function_Return (Item_Count(Current_Object))
70073>>>>>>>    End_Function
70074>>>>>>>    
70074>>>>>>>    
70074>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70076>>>>>>>        
70076>>>>>>>        String  sSqlServerClientVersionName
70076>>>>>>>        
70076>>>>>>>        
70076>>>>>>>        Case Begin
70076>>>>>>>            
70076>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70078>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70079>>>>>>>                Case Break
70080>>>>>>>                
70080>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70083>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70084>>>>>>>                Case Break
70085>>>>>>>            
70085>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70088>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70089>>>>>>>                Case Break
70090>>>>>>>            
70090>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70093>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70094>>>>>>>                Case Break
70095>>>>>>>            
70095>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70098>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70099>>>>>>>                Case Break
70100>>>>>>>            
70100>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70103>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70104>>>>>>>                Case Break
70105>>>>>>>            
70105>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70108>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70109>>>>>>>                Case Break
70110>>>>>>>            
70110>>>>>>>            Case Else
70110>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70111>>>>>>>                
70111>>>>>>>        Case End
70111>>>>>>>        
70111>>>>>>>        
70111>>>>>>>        Function_Return sSqlServerClientVersionName
70112>>>>>>>        
70112>>>>>>>    End_Function
70113>>>>>>>
70113>>>>>>>
70113>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70115>>>>>>>        
70115>>>>>>>        String  sSqlServerClientDriverName
70115>>>>>>>        
70115>>>>>>>        Case Begin
70115>>>>>>>            
70115>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70117>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70118>>>>>>>                Case Break
70119>>>>>>>                
70119>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70122>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70123>>>>>>>                Case Break
70124>>>>>>>            
70124>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70127>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70128>>>>>>>                Case Break
70129>>>>>>>            
70129>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70132>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70133>>>>>>>                Case Break
70134>>>>>>>            
70134>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70137>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70138>>>>>>>                Case Break
70139>>>>>>>            
70139>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70142>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70143>>>>>>>                Case Break
70144>>>>>>>            
70144>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70147>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70148>>>>>>>                Case Break
70149>>>>>>>            
70149>>>>>>>            Case Else
70149>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70150>>>>>>>                
70150>>>>>>>        Case End
70150>>>>>>>        
70150>>>>>>>        
70150>>>>>>>        Function_Return sSqlServerClientDriverName
70151>>>>>>>        
70151>>>>>>>    End_Function
70152>>>>>>>    
70152>>>>>>>    
70152>>>>>>>End_Class
70153>>>>>>>
70153>>>>>>>
70153>>>>>
70153>>>>>Register_Function phoWorkspace Returns Handle
70153>>>>>Register_Function Help_filename Returns String
70153>>>>>Register_Function GetHelpFile Returns String
70153>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
70153>>>>>
70153>>>>>// Do not call directly, use the wrapper function instead
70153>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70154>>>>>
70154>>>>>// Wrapper Function WNetGetUser
70154>>>>>Function WNetGetUser Global ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70156>>>>>    
70156>>>>>    DWord   dwResult     
70156>>>>>    UWide   uwName uwUserName
70156>>>>>    UWide   uwName uwUserName
70156>>>>>        
70156>>>>>    Send StringToWide lpName (&uwName)
70157>>>>>    
70157>>>>>    Send WideSetBuffer lpUser_Name lpLength (&uwUserName)    
70158>>>>>    
70158>>>>>    Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
70159>>>>>    
70159>>>>>    Send WideToString (&uwUserName) lpUser_Name
70160>>>>>    
70160>>>>>    Function_Return dwResult
70161>>>>>End_Function
70162>>>>>
70162>>>>>//    This function reads the current username Of windows and returns that
70162>>>>>//    name or an text unknown user
70162>>>>>Function Network_User_Name for cDesktop Returns String
70164>>>>>    WString wName
70164>>>>>    Integer iRetval iLength
70164>>>>>    
70164>>>>>    Move 0 to iLength
70165>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
70166>>>>>    Move (ZeroString(iLength)) to wName
70167>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
70168>>>>>    
70168>>>>>    If (iRetval = NO_ERROR) Begin
70170>>>>>        Function_Return (CString (wName))
70171>>>>>    End
70171>>>>>>
70171>>>>>    
70171>>>>>    Function_Return "User Unknown"
70172>>>>>End_Function
70173>>>>>
70173>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
70174>>>>>
70174>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
70175>>>>>
70175>>>>>Class SysinfoDisplay is a cTextEdit
70176>>>>>    Procedure Construct_Object
70178>>>>>        Forward Send Construct_Object
70180>>>>>        
70180>>>>>        Set Location to 6 6
70181>>>>>        Set Size to 110 255
70182>>>>>        Set Read_Only_State to True
70183>>>>>        Set pbWrap to False
70184>>>>>    End_Procedure
70185>>>>>    
70185>>>>>    //    This method will show the name Of the current directory in the system
70185>>>>>    //    information box
70185>>>>>    Procedure Show_Current_Directory
70187>>>>>        String sDir
70187>>>>>        
70187>>>>>        Get_Current_Directory to sDir
70188>>>>>        
70188>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
70189>>>>>    End_Procedure
70190>>>>>    
70190>>>>>    Procedure Show_Windows_Directory
70192>>>>>        String sWindir
70192>>>>>        
70192>>>>>        Get_Windows_Directory to sWindir
70193>>>>>        
70193>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
70194>>>>>    End_Procedure
70195>>>>>    
70195>>>>>    Procedure Show_Current_User
70197>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
70198>>>>>    End_Procedure
70199>>>>>    
70199>>>>>    Procedure Show_Number_Format
70201>>>>>        Integer iFormat
70201>>>>>        String sFormatText
70201>>>>>        
70201>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
70204>>>>>        Move (Character (iFormat)) to sFormatText
70205>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
70206>>>>>        
70206>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
70209>>>>>        Move (Character (iFormat)) to sFormatText
70210>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
70211>>>>>    End_Procedure
70212>>>>>    
70212>>>>>    Procedure Show_Filelist_Name
70214>>>>>        String sFilename
70214>>>>>        
70214>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
70217>>>>>        
70217>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
70218>>>>>        Send AppendTextLn ""
70219>>>>>    End_Procedure
70220>>>>>    
70220>>>>>    Procedure Show_Lock_Delay
70222>>>>>        Integer iLockdelay
70222>>>>>        
70222>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
70225>>>>>        
70225>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
70226>>>>>    End_Procedure
70227>>>>>    
70227>>>>>    Procedure Show_Lock_Timeout
70229>>>>>        Integer iLockTimeout
70229>>>>>        
70229>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
70232>>>>>        
70232>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
70233>>>>>    End_Procedure
70234>>>>>    
70234>>>>>    Procedure Show_Screen_Size
70236>>>>>        Integer iYscreensize iXscreensize
70236>>>>>        
70236>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
70237>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
70238>>>>>        
70238>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
70239>>>>>    End_Procedure
70240>>>>>    
70240>>>>>    Procedure Show_Page_Size
70242>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
70243>>>>>    End_Procedure
70244>>>>>    
70244>>>>>    Procedure Show_Date
70246>>>>>        Date dToday
70246>>>>>        
70246>>>>>        Move (CurrentDateTime()) to  dToday
70247>>>>>        
70247>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
70248>>>>>    End_Procedure
70249>>>>>    
70249>>>>>    Procedure Show_Date_Format
70251>>>>>        Integer iDateFormat
70251>>>>>        String sDateFormat
70251>>>>>        
70251>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
70254>>>>>        Case Begin
70254>>>>>            Case (iDateFormat = DF_DATE_USA)
70256>>>>>                Move C_$USA to sDateFormat
70257>>>>>                Case Break
70258>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
70261>>>>>                Move C_$European to sDateFormat
70262>>>>>                Case Break
70263>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
70266>>>>>                Move C_$Military to sDateFormat
70267>>>>>                Case Break
70268>>>>>            Case Else
70268>>>>>                Move C_$UnknownDateType to sDateFormat
70269>>>>>                Case Break
70270>>>>>        Case End
70270>>>>>        
70270>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
70271>>>>>    End_Procedure
70272>>>>>    
70272>>>>>    Procedure Show_Systemresources
70274>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70274>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70274>>>>>        Integer iRetval
70274>>>>>        
70274>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
70275>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
70276>>>>>        If (iRetval = 0) Begin
70278>>>>>            Move (ShowLastError ()) to iRetval
70279>>>>>        End
70279>>>>>>
70279>>>>>        
70279>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
70280>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
70281>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
70282>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
70283>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
70284>>>>>    End_Procedure
70285>>>>>    
70285>>>>>    Procedure Show_Registration
70287>>>>>        String sRegName
70287>>>>>        Integer iSN iMaxUsers
70287>>>>>        
70287>>>>>        Registration sRegName iSN
70288>>>>>>
70288>>>>>        
70288>>>>>        Get_Licensed_Max_Users to iMaxUsers
70289>>>>>        
70289>>>>>        Send AppendTextLn ""
70290>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
70291>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
70292>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
70293>>>>>    End_Procedure
70294>>>>>    
70294>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
70294>>>>>    // To the workspace object passing the an object and message To send back
70294>>>>>    // To this object. It is expected that the workspace object will send this
70294>>>>>    // message for every line Of information it wants displayed (passing the
70294>>>>>    // information To be displayed
70294>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
70294>>>>>    
70294>>>>>    Procedure Show_ServicePack
70296>>>>>        String sKey sVersionDescription sVersion
70296>>>>>        Handle hoRegistry
70296>>>>>        Boolean bExists bOpened
70296>>>>>        
70296>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
70297>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
70298>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
70299>>>>>        
70299>>>>>        Move C_DFVersionRegistryRoot to sKey
70300>>>>>        Get KeyExists of hoRegistry sKey to bExists
70301>>>>>        If (bExists) Begin
70303>>>>>            Get OpenKey of hoRegistry sKey to bOpened
70304>>>>>            If (bOpened) Begin
70306>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
70307>>>>>                If (bExists) Begin
70309>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
70310>>>>>                End
70310>>>>>>
70310>>>>>                
70310>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
70311>>>>>                If (bExists) Begin
70313>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
70314>>>>>                End
70314>>>>>>
70314>>>>>                Send CloseKey of hoRegistry
70315>>>>>            End
70315>>>>>>
70315>>>>>        End
70315>>>>>>
70315>>>>>        Send Destroy of hoRegistry
70316>>>>>        
70316>>>>>        If (sVersionDescription <> "") Begin
70318>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
70319>>>>>            Send AppendTextLn ""
70320>>>>>        End
70320>>>>>>
70320>>>>>    End_Procedure
70321>>>>>    
70321>>>>>    
70321>>>>>    Procedure Show_WorkspaceInformation
70323>>>>>        Integer hoWorkspace
70323>>>>>        
70323>>>>>        If (ghoApplication <> 0) Begin
70325>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70326>>>>>            If (hoWorkspace <> 0) Begin
70328>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
70329>>>>>                Send AppendTextLn ""
70330>>>>>            End
70330>>>>>>
70330>>>>>        End
70330>>>>>>
70330>>>>>    End_Procedure
70331>>>>>    
70331>>>>>    // If connection ids are used, we will send the message EnumerateConnections
70331>>>>>    // to the connection manager object passing the an object and message to send
70331>>>>>    // back to this object. It is expected that the connection manager object will
70331>>>>>    // send this message for every line Of information it wants displayed (passing
70331>>>>>    // the information To be displayed
70331>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
70331>>>>>    
70331>>>>>    Procedure Show_ConnectionIdInformation
70333>>>>>        If (ghoConnection > 0) Begin
70335>>>>>            Send AppendTextLn ""
70336>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
70337>>>>>        End
70337>>>>>>
70337>>>>>    End_Procedure
70338>>>>>    
70338>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
70340>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
70341>>>>>    End_Function
70342>>>>>    
70342>>>>>    Procedure Show_Versions
70344>>>>>        Integer iVersion iRevision iBuild
70344>>>>>        
70344>>>>>        Version_Information iVersion iRevision iBuild
70346>>>>>        
70346>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
70347>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
70348>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
70349>>>>>    End_Procedure
70350>>>>>    
70350>>>>>    Procedure Show_Platform
70352>>>>>        Send AppendTextLn (SFormat (C_$Platform,"32-bit"))
70353>>>>>    End_Procedure
70354>>>>>    
70354>>>>>    Function CKRevisionNumber String sDriverID Returns String
70356>>>>>        Handle hoCLIHandler
70356>>>>>        Handle hoDFBtrDrvHandler
70356>>>>>        String sCKRevision
70356>>>>>        
70356>>>>>        
70356>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
70358>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
70359>>>>>            Set psDriverID of hoCLIHandler to sDriverID
70360>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
70361>>>>>            Send Destroy of hoCLIHandler
70362>>>>>        End
70362>>>>>>
70362>>>>>        Else Begin
70363>>>>>            If (sDriverID = "DFBTRDRV") Begin
70365>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
70366>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
70367>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
70368>>>>>                Send Destroy of hoDFBtrDrvHandler
70369>>>>>            End
70369>>>>>>
70369>>>>>        End
70369>>>>>>
70369>>>>>        
70369>>>>>        Function_Return sCKRevision
70370>>>>>    End_Function
70371>>>>>    
70371>>>>>    
70371>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
70373>>>>>        
70373>>>>>        If (sDriverID = "DATAFLEX") Begin
70375>>>>>            Function_Return False
70376>>>>>        End
70376>>>>>>
70376>>>>>        
70376>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
70377>>>>>    End_Function
70378>>>>>    
70378>>>>>    
70378>>>>>    Procedure Show_Drivers
70380>>>>>        String sCurrentDriver sRevNumber
70380>>>>>        String sLoadedDrivers sClientDriver
70380>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
70380>>>>>        Boolean bOK
70380>>>>>        Handle hoMsqlDrv
70380>>>>>        
70380>>>>>        Move "" to sLoadedDrivers
70381>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
70384>>>>>        For iCount from 1 to iNumberOfDrivers
70390>>>>>>
70390>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
70393>>>>>            If (sLoadedDrivers <> "") Begin
70395>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
70396>>>>>            End
70396>>>>>>
70396>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
70397>>>>>            If (bOK) Begin
70399>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
70401>>>>>                    Move iCount to iMSSQLIndex
70402>>>>>                End
70402>>>>>>
70402>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
70403>>>>>                // if mssqldrv, show the client number
70403>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
70404>>>>>            End
70404>>>>>>
70404>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
70405>>>>>        Loop
70406>>>>>>
70406>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
70407>>>>>        If (iMSSQLIndex>0) Begin
70409>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
70412>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
70413>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
70414>>>>>            Send Destroy of hoMsqlDrv
70415>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
70416>>>>>        End
70416>>>>>>
70416>>>>>    End_Procedure
70417>>>>>    
70417>>>>>    Procedure Show_HelpFile
70419>>>>>        String sHelpFile
70419>>>>>        Integer eHelpType
70419>>>>>        
70419>>>>>        If (ghoApplication <> 0) Begin
70421>>>>>            Get peHelpType of ghoApplication to eHelpType
70422>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
70424>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
70425>>>>>            End
70425>>>>>>
70425>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
70428>>>>>                Get Help_filename of Help_object_id to sHelpFile
70429>>>>>            End
70429>>>>>>
70429>>>>>            Else Begin
70430>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
70431>>>>>            End
70431>>>>>>
70431>>>>>            
70431>>>>>            Send AppendTextLn ""
70432>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
70433>>>>>        End
70433>>>>>>
70433>>>>>    End_Procedure
70434>>>>>    
70434>>>>>    Procedure Show_EnterAsTab
70436>>>>>        Boolean bEnterKeyAsTabKey
70436>>>>>        String sText
70436>>>>>        
70436>>>>>        If (ghoApplication <> 0) Begin
70438>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
70439>>>>>            If (bEnterKeyAsTabKey) Begin
70441>>>>>                Move "True" to sText
70442>>>>>            End
70442>>>>>>
70442>>>>>            Else Begin
70443>>>>>                Move "False" to sText
70444>>>>>            End
70444>>>>>>
70444>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
70445>>>>>        End
70445>>>>>>
70445>>>>>    End_Procedure
70446>>>>>    
70446>>>>>    //    During activation we will remove the old information and add the newly
70446>>>>>    //    found systeminformation
70446>>>>>    Procedure Add_Focus Integer hoRoot
70448>>>>>        Forward Send Add_Focus hoRoot
70450>>>>>        
70450>>>>>        Send Delete_Data
70451>>>>>        
70451>>>>>        Set Changed_State to False
70452>>>>>        Set Read_Only_State to True
70453>>>>>        
70453>>>>>        Send Show_ServicePack
70454>>>>>        Send Show_Versions
70455>>>>>        Send Show_Platform
70456>>>>>        Send Show_Drivers
70457>>>>>        If (ghoConnection <> 0) Begin
70459>>>>>            Send Show_ConnectionIdInformation
70460>>>>>        End
70460>>>>>>
70460>>>>>        Send Show_HelpFile
70461>>>>>        Send Show_Current_Directory
70462>>>>>        Send Show_Filelist_Name
70463>>>>>        If (ghoApplication <> 0) Begin
70465>>>>>            Send Show_WorkSpaceInformation // added To show WS info
70466>>>>>        End
70466>>>>>>
70466>>>>>        Send Show_Current_User
70467>>>>>        Send Show_Windows_Directory
70468>>>>>        Send Show_Screen_Size
70469>>>>>        Send Show_Page_Size
70470>>>>>        Send Show_EnterAsTab
70471>>>>>        Send Show_Number_Format
70472>>>>>        Send Show_Date_Format
70473>>>>>        Send Show_Lock_Delay
70474>>>>>        Send Show_Lock_Timeout
70475>>>>>        Send Show_Date
70476>>>>>        Send Show_Systemresources
70477>>>>>        Send Show_Registration
70478>>>>>        Send Beginning_of_Data
70479>>>>>        
70479>>>>>        Set Icon to 'default.ico'
70480>>>>>    End_Procedure
70481>>>>>End_Class
70482>>>>>
70482>>>>>Class SysInfoDialog is a ModalPanel
70483>>>>>    Procedure Construct_Object
70485>>>>>        Forward Send Construct_Object
70487>>>>>        
70487>>>>>        Set Label to C_$SystemInformation
70488>>>>>        Set Size to 140 267
70489>>>>>        Set piMinSize to 140 267
70490>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70491>>>>>        Set Border_Style to Border_Thick
70492>>>>>        
70492>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
70494>>>>>            Set peAnchors to anAll
70495>>>>>        End_Object
70496>>>>>        
70496>>>>>        Object oCloseButton is a Button
70498>>>>>            Set Label to C_$Close
70499>>>>>            Set Location to 120 210
70500>>>>>            Set Message 0 to (Refproc (Close_Panel))
70501>>>>>            Set Default_State to True
70502>>>>>            Set peAnchors to anBottomRight
70503>>>>>        End_Object
70504>>>>>        
70504>>>>>        On_Key kCancel Send Close_Panel
70505>>>>>    End_Procedure
70506>>>>>End_Class
70507>>>>>
70507>>>>>Class AboutDialog is a ModalPanel
70508>>>>>    Procedure Construct_Object
70510>>>>>        String sVdfRootDir
70510>>>>>        
70510>>>>>        Forward Send Construct_Object
70512>>>>>        
70512>>>>>        Set Label to C_$About
70513>>>>>        Set Size to 89 212
70514>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70515>>>>>        
70515>>>>>        Object oSysInfoDialog is a SysInfoDialog
70517>>>>>        End_Object
70518>>>>>        
70518>>>>>        Object oBox is a Container3d
70520>>>>>            Set Border_Style to Border_StaticEdge
70521>>>>>            Set Size to 63 202
70522>>>>>            Set Location to 4 5
70523>>>>>            
70523>>>>>            Object oAboutGraphic is a BitmapContainer
70525>>>>>                Set Border_Style to Border_None
70526>>>>>                Set Bitmap_Style to Bitmap_Center
70527>>>>>                Set Size to 48 48
70528>>>>>                Set Location to 7 2
70529>>>>>            End_Object
70530>>>>>            
70530>>>>>            Object oProductName is a TextBox
70532>>>>>                Set Label to C_$ProductName
70533>>>>>                Set Size to 10 45
70534>>>>>                Set Location to 8 53
70535>>>>>            End_Object
70536>>>>>            
70536>>>>>            Object oVersion is a TextBox
70538>>>>>                Set Label to C_$Version
70539>>>>>                Set Size to 10 25
70540>>>>>                Set Location to 21 53
70541>>>>>            End_Object
70542>>>>>            
70542>>>>>            Object oCopyright is a TextBox
70544>>>>>                Set Label to C_$Copyright
70545>>>>>                Set Size to 10 31
70546>>>>>                Set Location to 34 53
70547>>>>>            End_Object
70548>>>>>            
70548>>>>>            Object oAuthor is a TextBox
70550>>>>>                Set Label to C_$Author
70551>>>>>                Set Size to 10 22
70552>>>>>                Set Location to 46 53
70553>>>>>            End_Object
70554>>>>>        End_Object
70555>>>>>        
70555>>>>>        Object oOKButton is a Button
70557>>>>>            On_Item C_$OK Send Close_Panel
70558>>>>>            Set Size to 14 50
70559>>>>>            Set Location to 71 157
70560>>>>>        End_Object
70561>>>>>        
70561>>>>>        Object oSysInfoButton is a Button
70563>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
70564>>>>>            Set Size to 14 50
70565>>>>>            Set Location to 71 101
70566>>>>>        End_Object
70567>>>>>        
70567>>>>>        On_Key Kcancel Send KeyAction of oOKButton
70568>>>>>        
70568>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
70569>>>>>    End_Procedure
70570>>>>>    
70570>>>>>    Procedure Set ProductName String sProductName
70572>>>>>        Set Label of oProductName to sProductName
70573>>>>>    End_Procedure
70574>>>>>    
70574>>>>>    Procedure Set Version String sVersion
70576>>>>>        Set Label of oVersion to sVersion
70577>>>>>    End_Procedure
70578>>>>>    
70578>>>>>    Procedure Set Copyright String sCopyright
70580>>>>>        Set Label of oCopyright to sCopyright
70581>>>>>    End_Procedure
70582>>>>>    
70582>>>>>    Procedure Set Author String sAuthor
70584>>>>>        Set Label of oAuthor to sAuthor
70585>>>>>    End_Procedure
70586>>>>>    
70586>>>>>    Procedure Set Logo String sLogo
70588>>>>>        // square bitmaps Of 42x42 work best
70588>>>>>        Set Bitmap of oAboutGraphic to sLogo
70589>>>>>    End_Procedure
70590>>>>>    
70590>>>>>    Procedure Show_Sysinfo
70592>>>>>        Send Popup_Modal of oSysinfoDialog
70593>>>>>    End_Procedure
70594>>>>>    
70594>>>>>    Procedure End_Construct_Object
70596>>>>>        Handle hoVersionInfo
70596>>>>>        Boolean bIncluded
70596>>>>>        Integer iMajor iMinor iRelease iBuild
70596>>>>>        String sLabel
70596>>>>>        
70596>>>>>        Get Label of oVersion to sLabel
70597>>>>>        If (sLabel = C_$VERSION) Begin
70599>>>>>            // set it To the version info Of the program, if available
70599>>>>>            If (ghoApplication <> 0) Begin
70601>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
70602>>>>>                If (hoVersionInfo <> 0) Begin
70604>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
70605>>>>>                    If (bIncluded) Begin
70607>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
70608>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
70609>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
70610>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
70611>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
70612>>>>>                        Set Version to sLabel
70613>>>>>                    End
70613>>>>>>
70613>>>>>                End
70613>>>>>>
70613>>>>>            End
70613>>>>>>
70613>>>>>        End
70613>>>>>>
70613>>>>>        
70613>>>>>        Forward Send End_Construct_Object
70615>>>>>    End_Procedure
70616>>>>>End_Class
70617>>>
70617>>>//  This is the default message. It is expected that you will
70617>>>//  create your own message to override this
70617>>>Procedure Activate_About
70620>>>    Send DoAbout "" "" "" "" ""
70621>>>End_Procedure
70622>>>
70622>>>//  It is expected that you will send this message (most
70622>>>//  likely from Activate_About. This creates an about object, activates it
70622>>>//  and destroys it when done. It is not exepected that you will augment this.
70622>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
70625>>>    Integer hoObj hoMain
70625>>>    
70625>>>    // create object
70625>>>    Object About is an AboutDialog
70627>>>        // if no title passed use the label of the main panel
70627>>>        // (if a main panel exists).
70627>>>        If (sTitle = "") Begin
70629>>>            Get Main_Window of desktop to hoMain
70630>>>            If hoMain ;                Get Label of hoMain to sTitle
70633>>>        End
70633>>>>
70633>>>        Set productname to sTitle
70634>>>        Set version     to sVersion
70635>>>        Set copyright   to sCopyRight
70636>>>        Set author      to sAuthor
70637>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
70640>>>        Move Self to hoObj // object Id
70641>>>    End_Object
70642>>>    Send Popup   of hoObj    // popup the about object
70643>>>    Send Destroy of hoObj // when done, it will be destroyed
70644>>>End_Procedure
70645>>>
70645>        Use TabbedDemo.vw
Including file: TabbedDemo.vw    (C:\Users\lucas.GPCABLING\Documents\repositorios\dataflex_learning\DataFlexStudio v20.0\Learn the language\AppSrc\TabbedDemo.vw)
70645>>>Use Windows.pkg
70645>>>Use DFClient.pkg
70645>>>Use DFTabDlg.pkg
70645>>>Use DfAllEnt.pkg
70645>>>
70645>>>Activate_View Activate_oTabbedDemo for oTabbedDemo
70655>>>>
70655>>>Object oTabbedDemo is a dbView
70657>>>    
70657>>>    Set Label to "TabbedDemo"
70658>>>    Set Size to 273 470
70659>>>    Set Location to 0 4
70660>>>    
70660>>>    Global_Variable String sDiretorio
70660>>>
70660>>>    Object oReadDir is a Form
70662>>>        Set Size to 14 326
70663>>>        Set Location to 14 68
70664>>>        Set Label to "Caminho arquivo:"
70665>>>        
70665>>>//        Procedure Construct_Object  
70665>>>//            Forward Send Construct_Object  // very important! 
70665>>>//            Property String psDiretorio 
70665>>>//        End_Procedure
70665>>>        
70665>>>        //    OnChange is called on every changed character
70665>>>        Procedure OnChange
70668>>>               
70668>>>        End_Procedure
70669>>>    
70669>>>    End_Object
70670>>>    
70670>>>    Object oButton1 is a Button
70672>>>        Set Size to 14 56
70673>>>        Set Location to 14 399
70674>>>        Set Label to "Ver diretorio"
70675>>>        
70675>>>        Procedure OnClick
70678>>>            Send Activate_oConsultaFile    
70679>>>        End_Procedure
70680>>>    End_Object
70681>>>
70681>>>    Object oOpenExplorer is a Form
70683>>>        Set Size to 14 330
70684>>>        Set Location to 250 67
70685>>>        Set Label to "Caminho arquivo:"
70686>>>        
70686>>>        Property String psDiretorio
70688>>>
70688>>>        Set Form_Mask to "Digite caminho"
70689>>>
70689>>>        
70689>>>    End_Object
70690>>>    
70690>>>    Object oButton2 is a Button
70692>>>        Set Size to 14 53
70693>>>        Set Location to 250 404
70694>>>        Set Label to "Abrir explorer"
70695>>>    
70695>>>        Procedure OnClick
70698>>>            
70698>>>            Get psDiretorio to sDiretorio
70699>>>            
70699>>>            Runprogram Background ('c:\windows\explorer.exe' *  '"' + ((sDiretorio)) + '"')
70700>>>        End_Procedure  
70701>>>    End_Object
70702>>>
70702>>>End_Object
70703>>>
70703>>>Start_UI
70704>        Use ConsultaFile.vw
Including file: ConsultaFile.vw    (C:\Users\lucas.GPCABLING\Documents\repositorios\dataflex_learning\DataFlexStudio v20.0\Learn the language\AppSrc\ConsultaFile.vw)
70704>>>Use Windows.pkg
70704>>>Use DFClient.pkg
70704>>>Use DFTabDlg.pkg
70704>>>Use DfAllEnt.pkg
70704>>>Use cCJGrid.pkg
70704>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cProgressBar.pkg)
70704>>>>>Use Windows.pkg
70704>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cWinControl.pkg)
70704>>>>>>>Use Windows.pkg
70704>>>>>>>
70704>>>>>>>// Key State Masks for Mouse Messages
70704>>>>>>>
70704>>>>>>>Define MK_LBUTTON  for |CI$0001
70704>>>>>>>Define MK_RBUTTON  for |CI$0002
70704>>>>>>>Define MK_SHIFT    for |CI$0004
70704>>>>>>>Define MK_CONTROL  for |CI$0008
70704>>>>>>>Define MK_MBUTTON  for |CI$0010
70704>>>>>>>Define MK_XBUTTON1 for |CI$0020
70704>>>>>>>Define MK_XBUTTON2 for |CI$0040
70704>>>>>>>
70704>>>>>>>Enum_List // Mouse Key Flags
70704>>>>>>>    Define mkLeft    for MK_LBUTTON
70704>>>>>>>    Define mkMiddle  for MK_MBUTTON
70704>>>>>>>    Define mkRight   for MK_RBUTTON
70704>>>>>>>    Define mkX1      for MK_XBUTTON1
70704>>>>>>>    Define mkX2      for MK_XBUTTON2
70704>>>>>>>    Define mkShift   for MK_SHIFT
70704>>>>>>>    Define mkControl for MK_CONTROL
70704>>>>>>>End_Enum_List
70704>>>>>>>
70704>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
70704>>>>>>>    Define mbLeft
70704>>>>>>>    Define mbMiddle
70704>>>>>>>    Define mbRight
70704>>>>>>>    Define mbX1
70704>>>>>>>    Define mbX2
70704>>>>>>>End_Enum_List
70704>>>>>>>
70704>>>>>>>Class cWinControl is a DfBaseControl
70705>>>>>>>    Procedure Construct_Object
70707>>>>>>>        Forward Send Construct_Object
70709>>>>>>>        Property Integer private_pbEnabled True
70710>>>>>>>        Property Integer private_pbVisible True
70711>>>>>>>    End_Procedure
70712>>>>>>>    
70712>>>>>>>    Procedure End_Construct_Object
70714>>>>>>>        Forward Send End_Construct_Object
70716>>>>>>>        
70716>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
70717>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
70718>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
70719>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
70720>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
70721>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
70722>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
70723>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
70724>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
70725>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
70726>>>>>>>    End_Procedure
70727>>>>>>>    
70727>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
70729>>>>>>>        //Intentionally cancelled
70729>>>>>>>    End_Procedure
70730>>>>>>>    
70730>>>>>>>    Procedure Command Longptr wParam Longptr lParam
70732>>>>>>>        //Intentionally cancelled
70732>>>>>>>    End_Procedure
70733>>>>>>>    
70733>>>>>>>    Procedure DoRecreateWindow
70735>>>>>>>        // Recreates the window
70735>>>>>>>        If (Window_Handle(Self)) Begin
70737>>>>>>>            // attempt to do this without disturbing the focus tree.
70737>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
70738>>>>>>>            Send Page 1      //                       Send Page_Object 1
70739>>>>>>>        End
70739>>>>>>>>
70739>>>>>>>    End_Procedure
70740>>>>>>>    
70740>>>>>>>    Procedure DoUpdateWindow
70742>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
70742>>>>>>>        Handle hWnd
70742>>>>>>>        
70742>>>>>>>        Get Window_Handle to hWnd
70743>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
70746>>>>>>>    End_Procedure
70747>>>>>>>    
70747>>>>>>>    Procedure Page Integer iState
70749>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
70750>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
70751>>>>>>>        Forward Send Page iState
70753>>>>>>>    End_Procedure
70754>>>>>>>    
70754>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
70756>>>>>>>        Integer x y eButton
70756>>>>>>>        
70756>>>>>>>        Move (Hi(lParam))  to y
70757>>>>>>>        Move (Low(lParam)) to x
70758>>>>>>>        
70758>>>>>>>        Send OnMouseUp mbLeft x y wParam
70759>>>>>>>    End_Procedure
70760>>>>>>>    
70760>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
70762>>>>>>>        Integer x y eButton
70762>>>>>>>        
70762>>>>>>>        Move (Hi(lParam))  to y
70763>>>>>>>        Move (Low(lParam)) to x
70764>>>>>>>        
70764>>>>>>>        Send OnMouseUp mbMiddle x y wParam
70765>>>>>>>    End_Procedure
70766>>>>>>>    
70766>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
70768>>>>>>>        Integer x y eButton
70768>>>>>>>        
70768>>>>>>>        Move (Hi(lParam))  to y
70769>>>>>>>        Move (Low(lParam)) to x
70770>>>>>>>        
70770>>>>>>>        Send OnMouseUp mbRight x y wParam
70771>>>>>>>    End_Procedure
70772>>>>>>>    
70772>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
70774>>>>>>>        Integer x y eButton fKeys
70774>>>>>>>        
70774>>>>>>>        Move (Hi(lParam))  to y
70775>>>>>>>        Move (Low(lParam)) to x
70776>>>>>>>        
70776>>>>>>>        Send OnMouseDown mbLeft x y wParam
70777>>>>>>>    End_Procedure
70778>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
70780>>>>>>>        Integer x y eButton
70780>>>>>>>        
70780>>>>>>>        Move (Hi(lParam))  to y
70781>>>>>>>        Move (Low(lParam)) to x
70782>>>>>>>        
70782>>>>>>>        Send OnMouseDown mbMiddle x y wParam
70783>>>>>>>    End_Procedure
70784>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
70786>>>>>>>        Integer x y eButton
70786>>>>>>>        
70786>>>>>>>        Move (Hi(lParam))  to y
70787>>>>>>>        Move (Low(lParam)) to x
70788>>>>>>>        
70788>>>>>>>        Send OnMouseDown mbRight x y wParam
70789>>>>>>>    End_Procedure
70790>>>>>>>    
70790>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
70792>>>>>>>        Integer x y eButton
70792>>>>>>>        
70792>>>>>>>        Move (Hi(lParam))  to y
70793>>>>>>>        Move (Low(lParam)) to x
70794>>>>>>>        
70794>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
70795>>>>>>>    End_Procedure
70796>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
70798>>>>>>>        Integer x y eButton
70798>>>>>>>        
70798>>>>>>>        Move (Hi(lParam))  to y
70799>>>>>>>        Move (Low(lParam)) to x
70800>>>>>>>        
70800>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
70801>>>>>>>    End_Procedure
70802>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
70804>>>>>>>        Integer x y eButton
70804>>>>>>>        
70804>>>>>>>        Move (Hi(lParam))  to y
70805>>>>>>>        Move (Low(lParam)) to x
70806>>>>>>>        
70806>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
70807>>>>>>>    End_Procedure
70808>>>>>>>    
70808>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
70810>>>>>>>        Integer x y eButton
70810>>>>>>>        
70810>>>>>>>        Move (Hi(lParam))  to y
70811>>>>>>>        Move (Low(lParam)) to x
70812>>>>>>>        
70812>>>>>>>        Send OnMouseMove x y wParam
70813>>>>>>>    End_Procedure
70814>>>>>>>    
70814>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
70816>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
70816>>>>>>>        //String sButton
70816>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
70816>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
70816>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
70816>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
70816>>>>>>>        
70816>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
70816>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
70816>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
70816>>>>>>>    End_Procedure
70817>>>>>>>    
70817>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
70819>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
70819>>>>>>>        //String sButton
70819>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
70819>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
70819>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
70819>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
70819>>>>>>>        
70819>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
70819>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
70819>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
70819>>>>>>>    End_Procedure
70820>>>>>>>    
70820>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
70822>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
70822>>>>>>>        //String sButton
70822>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
70822>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
70822>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
70822>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
70822>>>>>>>        
70822>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
70822>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
70822>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
70822>>>>>>>    End_Procedure
70823>>>>>>>    
70823>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
70825>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
70825>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
70825>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
70825>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
70825>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
70825>>>>>>>        
70825>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
70825>>>>>>>    End_Procedure
70826>>>>>>>    
70826>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
70828>>>>>>>        Handle hWnd
70828>>>>>>>        
70828>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
70830>>>>>>>            Set private_pbEnabled to bEnabled
70831>>>>>>>            Get Window_Handle to hWnd
70832>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
70835>>>>>>>        End
70835>>>>>>>>
70835>>>>>>>    End_Procedure
70836>>>>>>>    Function pbEnabled Returns Boolean
70838>>>>>>>        Function_Return (private_pbEnabled(Self))
70839>>>>>>>    End_Function
70840>>>>>>>    
70840>>>>>>>    Procedure Set pbVisible Boolean bVisible
70842>>>>>>>        Handle  hWnd
70842>>>>>>>        Integer iVoid
70842>>>>>>>        
70842>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
70844>>>>>>>            Set private_pbVisible to bVisible
70845>>>>>>>            Get Window_Handle to hWnd
70846>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
70849>>>>>>>        End
70849>>>>>>>>
70849>>>>>>>    End_Procedure
70850>>>>>>>    Function pbVisible Returns Boolean
70852>>>>>>>        Function_Return (private_pbVisible(Self))
70853>>>>>>>    End_Function
70854>>>>>>>    
70854>>>>>>>End_Class
70855>>>>>Use CommCtrl.pkg
70855>>>>>
70855>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
70855>>>>>Class cProgressBar is a cWinControl
70856>>>>>    
70856>>>>>    Procedure Construct_Object
70858>>>>>        Forward Send Construct_Object
70860>>>>>        Property Integer private_piMinimum
70861>>>>>        Property Integer private_piMaximum   100
70862>>>>>        Property Integer private_piAdvanceBy 10
70863>>>>>        Property Integer private_piPosition
70864>>>>>        Property Integer private_pbVertical  False
70865>>>>>        Property Integer private_pbSmooth    False
70866>>>>>        Property Integer private_piBackColor clDefault
70867>>>>>        Property Integer private_piBarColor  clDefault
70868>>>>>        
70868>>>>>        Send Define_ToolTip_Support_Mixin
70869>>>>>        
70869>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
70870>>>>>        Set Focus_Mode to NonFocusable
70871>>>>>        Set Skip_State to True
70872>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
70873>>>>>    End_Procedure
70874>>>>>    
70874>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
70875>>>>>    
70875>>>>>    Procedure Set piMinimum Integer iMin
70877>>>>>        Integer iMax
70877>>>>>        
70877>>>>>        Set private_piMinimum to iMin
70878>>>>>        Get private_piMaximum to iMax
70879>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
70880>>>>>    End_Procedure
70881>>>>>    Function piMinimum Returns Integer
70883>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
70886>>>>>        Else;            Function_Return (private_piMinimum(Self))
70888>>>>>    End_Function
70889>>>>>    
70889>>>>>    Procedure Set piMaximum Integer iMax
70891>>>>>        Integer iMin
70891>>>>>        
70891>>>>>        Set private_piMaximum to iMax
70892>>>>>        Get private_piMinimum to iMin
70893>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
70894>>>>>    End_Procedure
70895>>>>>    Function piMaximum Returns Integer
70897>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
70900>>>>>        Else;            Function_Return (private_piMaximum(Self))
70902>>>>>    End_Function
70903>>>>>    
70903>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
70905>>>>>        Set private_piAdvanceBy to iAdvanceBy
70906>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
70907>>>>>    End_Procedure
70908>>>>>    Function piAdvanceBy Returns Integer
70910>>>>>        Function_Return (private_piAdvanceBy(Self))
70911>>>>>    End_Function
70912>>>>>    
70912>>>>>    Procedure Set piPosition Integer iPos
70914>>>>>        Set private_piPosition to iPos
70915>>>>>        Send Windows_Message PBM_SETPOS iPos 0
70916>>>>>    End_Procedure
70917>>>>>    
70917>>>>>    Function piPosition Returns Integer
70919>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
70922>>>>>        Else;            Function_Return (private_piPosition(Self))
70924>>>>>    End_Function
70925>>>>>    
70925>>>>>    Procedure Set pbVertical Boolean bVertical
70927>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
70929>>>>>            Set private_pbVertical to bVertical
70930>>>>>            Send DoRecreateWindow
70931>>>>>        End
70931>>>>>>
70931>>>>>    End_Procedure
70932>>>>>    
70932>>>>>    Function pbVertical Returns Boolean
70934>>>>>        Function_Return (private_pbVertical(Self))
70935>>>>>    End_Function
70936>>>>>    
70936>>>>>    Procedure Set pbSmooth Boolean bSmooth
70938>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
70940>>>>>            Set private_pbSmooth to bSmooth
70941>>>>>            Send DoRecreateWindow
70942>>>>>        End
70942>>>>>>
70942>>>>>    End_Procedure
70943>>>>>    Function pbSmooth Returns Boolean
70945>>>>>        Function_Return (private_pbSmooth(Self))
70946>>>>>    End_Function
70947>>>>>    
70947>>>>>    Procedure Set piBackColor Integer rgbColor
70949>>>>>        Set private_piBackColor to rgbColor
70950>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
70951>>>>>    End_Procedure
70952>>>>>    Function piBackColor Returns Integer
70954>>>>>        Function_Return (private_piBackColor(Self))
70955>>>>>    End_Function
70956>>>>>    
70956>>>>>    Procedure Set piBarColor Integer rgbColor
70958>>>>>        Set private_piBarColor to rgbColor
70959>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
70960>>>>>    End_Procedure
70961>>>>>    Function piBarColor Returns Integer
70963>>>>>        Function_Return (private_piBarColor(Self))
70964>>>>>    End_Function
70965>>>>>    
70965>>>>>    Procedure DoAdvance
70967>>>>>        Send Windows_Message PBM_STEPIT 0 0
70968>>>>>    End_Procedure
70969>>>>>    
70969>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
70971>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
70972>>>>>    End_Procedure
70973>>>>>    
70973>>>>>    Procedure private_DoInitWindow
70975>>>>>        Set piBarColor  to (private_piBarColor(Self))
70976>>>>>        Set piBackColor to (private_piBackColor(Self))
70977>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
70978>>>>>        Set piMinimum   to (private_piMinimum(Self))
70979>>>>>        Set piMaximum   to (private_piMaximum(Self))
70980>>>>>        Set piPosition  to (private_piPosition(Self))
70981>>>>>    End_Procedure
70982>>>>>    
70982>>>>>    Procedure Page_Object Integer iState
70984>>>>>        Handle hWnd
70984>>>>>        
70984>>>>>        Get Window_Handle to hWnd
70985>>>>>        If (hWnd=0 and iState) Begin
70987>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
70988>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
70989>>>>>            Forward Send Page_Object True
70991>>>>>        End
70991>>>>>>
70991>>>>>        Else ;            Forward Send Page_Object iState
70994>>>>>        
70994>>>>>        // Handle tooltip support....
70994>>>>>        If (iState = 0) Begin
70996>>>>>            Send RequestDeleteToolTip
70997>>>>>        End
70997>>>>>>
70997>>>>>        Else Begin
70998>>>>>            Send RequestAddToolTip
70999>>>>>        End
70999>>>>>>
70999>>>>>    End_Procedure
71000>>>>>    
71000>>>>>    Procedure Page Integer iState
71002>>>>>        Forward Send Page iState
71004>>>>>        If (iState =1);            Send private_DoInitWindow
71007>>>>>    End_Procedure
71008>>>>>    
71008>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
71008>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
71008>>>>>    // is implemented in a mixin class.
71008>>>>>    Procedure RequestAddToolTip
71010>>>>>        Send AddToolTip
71011>>>>>    End_Procedure
71012>>>>>    
71012>>>>>    
71012>>>>>    // Called by Page_Object. Handles tooltip removal.
71012>>>>>    Procedure RequestDeleteToolTip
71014>>>>>        Send DeleteToolTip
71015>>>>>    End_Procedure
71016>>>>>End_Class
71017>>>Use dfTreeVw.pkg
71017>>>Use TrckBr.pkg
71017>>>Use cCJGridColumn.pkg
71017>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJGridColumnRowIndicator.pkg)
71017>>>>>Use cCJGridColumn.pkg
71017>>>>>
71017>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
71018>>>>>    
71018>>>>>    Procedure Construct_Object
71020>>>>>        Forward Send Construct_Object
71022>>>>>        
71022>>>>>        Property Integer piImage 0
71023>>>>>        
71023>>>>>        Set psCaption to ""
71024>>>>>        Set piWidth to 20
71025>>>>>        Set pbResizable to False
71026>>>>>        Set pbEditable to False
71027>>>>>        Set pbFocusable to False
71028>>>>>        Set pbAllowDrag to False
71029>>>>>        Set psToolTip to "Row Indicator"
71030>>>>>    End_Procedure
71031>>>>>    
71031>>>>>    Procedure OnCreateColumn
71033>>>>>        Integer iImage
71033>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
71035>>>>>        Set piImage to iImage
71036>>>>>    End_Procedure
71037>>>>>    
71037>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
71039>>>>>        Integer iImage iFocusedRow
71039>>>>>        Handle hoDataSource
71039>>>>>        
71039>>>>>        Get phoDataSource to hoDataSource
71040>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
71041>>>>>        Move -1 to iImage
71042>>>>>        If (iRow = iFocusedRow) Begin
71044>>>>>            Get piImage to iImage
71045>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
71046>>>>>        End
71046>>>>>>
71046>>>>>    End_Procedure
71047>>>>>    
71047>>>>>End_Class
71048>>>Use File_dlg.pkg
71048>>>Use Font_dlg.pkg
Including file: Font_dlg.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Font_dlg.pkg)
71048>>>>>Use VDFBase.pkg
71048>>>>>Use GlobalFunctionsProcedures.pkg
71048>>>>>Use tWinStructs.pkg
71048>>>>>
71048>>>>>// Flags
71048>>>>>// The following flags are for Windows '95 only.
71048>>>>>
71048>>>>>// Orginal FontTypes constants
71048>>>>>
71048>>>>>
71048>>>>>// Character sets
71048>>>>>
71048>>>>>// Output precision
71048>>>>>
71048>>>>>// Clipping precision
71048>>>>>
71048>>>>>// Output quality
71048>>>>>// The following output quality's are for Windows '95 only
71048>>>>>
71048>>>>>// Pitch
71048>>>>>// The following pitch is for Window '95 only
71048>>>>>
71048>>>>>// Font family
71048>>>>>
71048>>>>>// Font type
71048>>>>>
71048>>>>>// When called directly, be sure to use WString types.
71048>>>>>External_Function ChooseFontW "ChooseFontW" COMDLG32.DLL ;    Pointer lpChooseFont Returns Integer
71049>>>>>
71049>>>>>// Compatibility wrapper Function ChooseFont
71049>>>>>Function ChooseFont Global ;    Pointer lpChooseFont ;    Returns Integer
71051>>>>>    
71051>>>>>    // lpChooseFont is a pointer to a ChooseFont struct, which contains two pointers to strings,
71051>>>>>    // and a pointer to a winLogFont struct, which also contains a pointer to a strings. 
71051>>>>>    // All these strings must be converted to UTF-16 and afterwards back to UTF-8.
71051>>>>>    Integer iResult iVoid
71051>>>>>    Pointer pCF pLogF pOrigLogF pOrigTemplateName pOrigStyle
71051>>>>>    String  sTemplateName szStyle sFaceName
71051>>>>>    WString wTemplateName wStyle wFaceName
71051>>>>>    tWinChooseFont tCF
71051>>>>>    tWinChooseFont tCF
71051>>>>>    tWinLogFontW tLogF  // UShort array for facename
71051>>>>>    tWinLogFontW tLogF  // UShort array for facename
71051>>>>>
71051>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
71051>>>>>    Move (AddressOf(tCF)) to pCF
71052>>>>>    Move (MemCopy(pCF, lpChooseFont, SizeOfType(tWinChooseFont))) to iVoid
71053>>>>>    // Memorize the address of the inner struct
71053>>>>>    Move tCF.lpLogFont to pOrigLogF
71054>>>>>
71054>>>>>    // Change lpTemplateName to UTF-16. This address is pointing to the original string.
71054>>>>>    Move tCF.lpTemplateName to pOrigTemplateName
71055>>>>>    Move (PointerToString(tCF.lpTemplateName)) to wTemplateName
71056>>>>>    Move (AddressOf(wTemplateName)) to tCF.lpTemplateName
71057>>>>>
71057>>>>>    // Change lpszStyle to UTF-16
71057>>>>>    Move tCF.lpszStyle to pOrigStyle
71058>>>>>    Move (PointerToString(tCF.lpszStyle)) to wStyle
71059>>>>>    Move (AddressOf(wStyle)) to tCF.lpszStyle
71060>>>>>
71060>>>>>    // There is a winLogFont struct within this struct - copy that too, to modify it.
71060>>>>>    Move (AddressOf(tLogF)) to pLogF
71061>>>>>    Move (MemCopy(pLogF, tCF.lpLogFont, SizeOfType(tWinLogFont))) to iVoid
71062>>>>>    Move pLogF to tCF.lpLogFont     // connect it
71063>>>>>    
71063>>>>>    // lfFaceName is expected to be coming in as UTF-8 Char[]. 
71063>>>>>    // Convert in place to UTF16 Short[] (be sure to terminate with zero).
71063>>>>>    Move (PointerToString(AddressOf(tLogF.lfFaceName))) to sFaceName
71064>>>>>    Append sFaceName (character(0))
71065>>>>>    Move sFaceName to wFaceName
71066>>>>>    Move (MemCopy(AddressOf(tLogF.lfFaceName), AddressOf(wFaceName), SizeOfWString(wFaceName) * 2)) to iVoid
71067>>>>>    
71067>>>>>    // Call the function using the local struct
71067>>>>>    Move (ChooseFontW(pCF)) to iResult
71068>>>>>    
71068>>>>>    // The struct is now filled with data. Convert facename back to UTF-8 (in place) 
71068>>>>>    // and then copy the struct back to the original memory location.
71068>>>>>    Move (PointerToWString(AddressOf(tLogF.lfFaceName))) to sFaceName
71069>>>>>    // Extend string with 0 to the maximum number of characters
71069>>>>>    If (SizeOfString(sFaceName)<LF_FACESIZE) ;        Append sFaceName (Repeat(Character(0), LF_FACESIZE - SizeOfString(sFaceName)))
71072>>>>>
71072>>>>>    Move (MemCopy(AddressOf(tLogF.lfFaceName), AddressOf(sFaceName), SizeOfString(sFaceName))) to iVoid
71073>>>>>    
71073>>>>>    // Change lpTemplateName to UTF-8
71073>>>>>    Move (PointerToWString(tCF.lpTemplateName)) to sTemplateName
71074>>>>>
71074>>>>>    // Copy the string to the original location
71074>>>>>    Move pOrigTemplateName to tCF.lpTemplateName
71075>>>>>    Move (MemCopy(pOrigTemplateName, AddressOf(sTemplateName), SizeOfString(sTemplateName)+1)) to iVoid
71076>>>>>    
71076>>>>>    // Change lpszStyle to UTF-8
71076>>>>>    Move (PointerToWString(tCF.lpszStyle)) to szStyle
71077>>>>>
71077>>>>>    // Copy the string to the original location
71077>>>>>    Move pOrigStyle to tCF.lpszStyle
71078>>>>>    Move (MemCopy(pOrigStyle, Addressof(szStyle), SizeOfString(szStyle)+1)) to iVoid
71079>>>>>
71079>>>>>    // Put back the address of the inner struct
71079>>>>>    Move pOrigLogF to tCF.lpLogFont
71080>>>>>    // Copy the innner struct back
71080>>>>>    Move (MemCopy(tCF.lpLogFont, pLogF, SizeOfType(tWinLogFont))) to iVoid
71081>>>>>    
71081>>>>>    // Copy the struct back to the incoming one
71081>>>>>    Move (MemCopy(lpChooseFont, pCF, SizeOfType(tWinChooseFont))) to iVoid
71082>>>>>    
71082>>>>>    Function_Return iResult
71083>>>>>End_Function
71084>>>>>
71084>>>>>Class FontDialog is a cObject
71085>>>>>    Procedure Construct_Object
71087>>>>>        Forward Send Construct_Object
71089>>>>>        
71089>>>>>        // Old interface property's
71089>>>>>        Property Integer FontTypes 0
71090>>>>>        // ChooseFont property's
71090>>>>>        Property Integer FontPointSize 0
71091>>>>>        Property Integer ScreenFonts_State True // False
71092>>>>>        Property Integer ShowHelp_State False
71093>>>>>        Property Integer Effects_State True // False
71094>>>>>        Property Integer NoVectorFonts_State False
71095>>>>>        Property Integer NoOEMFonts_State False
71096>>>>>        Property Integer NoSimulations_State False
71097>>>>>        Property Integer FixedPitchOnly_State False
71098>>>>>        Property Integer ForceFontExist_State True // False
71099>>>>>        Property Integer ScalableOnly_State False
71100>>>>>        Property Integer TTOnly_State False
71101>>>>>        Property Integer NoFaceSel_State False
71102>>>>>        Property Integer NoStyleSel_State False
71103>>>>>        Property Integer NoSizeSel_State False
71104>>>>>        Property Integer SelectScript_State False
71105>>>>>        Property Integer NoScriptSel_State False
71106>>>>>        Property Integer NoVertFonts_State False
71107>>>>>        Property Integer ScriptsOnly_State False
71108>>>>>        Property Integer ANSIOnly_State False
71109>>>>>        Property Integer FontRGBColors 0
71110>>>>>        Property Integer FontType 0
71111>>>>>        Property Integer FontSizeMin 1
71112>>>>>        Property Integer FontSizeMax 9999
71113>>>>>        // LogFont property's
71113>>>>>        Property Integer FontHeight -1    // see comments below
71114>>>>>        Property Integer FontWidth -1     // see comments below
71115>>>>>        Property Integer FontEscapement 0
71116>>>>>        Property Integer FontOrientation 0
71117>>>>>        Property Integer FontWeight -1    // see comments below
71118>>>>>        Property Integer FontItalic -1    // see comments below
71119>>>>>        Property Integer FontUnderline -1 // see comments below
71120>>>>>        Property Integer FontStrikeOut 0
71121>>>>>        Property Integer FontCharSet 0
71122>>>>>        Property Integer FontOutPrecision 0
71123>>>>>        Property Integer FontClipPrecision 0
71124>>>>>        Property Integer FontQuality 0
71125>>>>>        Property Integer FontPitch 0
71126>>>>>        Property Integer FontFamily 0
71127>>>>>        Property String  FaceName "EMPTY"  // see comments below
71128>>>>>        
71128>>>>>        // Set Focus_Mode To NonFocusable
71128>>>>>    End_Procedure
71129>>>>>    
71129>>>>>    Function OwnerHandle Returns Handle
71131>>>>>        Handle hWnd
71131>>>>>        Handle hoObj
71131>>>>>        Get Focus of desktop to hoObj // start with the focus
71132>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
71133>>>>>        Function_Return hWnd
71134>>>>>    End_Function
71135>>>>>    
71135>>>>>    Function FontDialog Returns Integer
71137>>>>>        Integer iResult iPitchAndFamily iFlags
71137>>>>>        String sResult
71137>>>>>        WString wFaceName
71137>>>>>        Handle hOwner
71137>>>>>        tWinChooseFont ChseFont
71137>>>>>        tWinChooseFont ChseFont
71137>>>>>        tWinLogFontW LogicalFont    // UShort array for facename
71137>>>>>        tWinLogFontW LogicalFont    // UShort array for facename
71137>>>>>        
71137>>>>>        //Delegate Get Container_Handle To hOwner
71137>>>>>        Get OwnerHandle to hOwner
71138>>>>>        // Some property's default to -1 because we want to determine if the user
71138>>>>>        // changed these properties. If he changed the property's we will take their
71138>>>>>        // value and pass it on to the function. If the user didn't change the
71138>>>>>        // properties we will retrieve them from the DFWindow class.
71138>>>>>        // DF19.1: Changed TYPE into STRUCT, which means that -1 cannot be assigned to a UChar member.
71138>>>>>        Integer iVal
71138>>>>>        If (FontItalic(Self) = -1) Begin
71140>>>>>            Move (FontItalics(Self)) to iVal
71141>>>>>            If (iVal = -1) ;                Set FontItalic to 255
71144>>>>>            Else ;                Set FontItalic to iVal
71146>>>>>        End
71146>>>>>>
71146>>>>>        If (FontUnderline(Self) = -1) ;            Set FontUnderline to 255
71149>>>>>        If (FontWeight(Self) = -1) ;            Set FontWeight to 255
71152>>>>>        If (FontHeight(Self) = -1) Begin
71154>>>>>            Move (Hi(FontSize(Self))) to iVal
71155>>>>>            If (iVal = -1) ;                Set FontHeight to 255
71158>>>>>            Else ;                Set FontHeight to iVal
71160>>>>>        End
71160>>>>>>
71160>>>>>        If (FontWidth(Self) = -1) Begin
71162>>>>>            Move (Low(FontSize(Self))) to iVal
71163>>>>>            If (iVal = -1) ;                Set FontWidth to 255
71166>>>>>            Else ;                Set FontWidth to iVal
71168>>>>>        End
71168>>>>>>
71168>>>>>        If (FaceName(Self) = "EMPTY") ;            Set FaceName to (TypeFace(Self))
71171>>>>>        
71171>>>>>        Move (FontHeight(Self)) to LogicalFont.lfHeight
71172>>>>>        Move (FontWidth(Self)) to LogicalFont.lfWidth
71173>>>>>        Move (FontEscapement(Self)) to LogicalFont.lfEscapement
71174>>>>>        Move (FontOrientation(Self)) to LogicalFont.lfOrientation
71175>>>>>        Move (FontWeight(Self))    to LogicalFont.lfWeight
71176>>>>>        Move (FontItalic(Self))    to LogicalFont.lfItalic
71177>>>>>        Move (FontUnderline(Self)) to LogicalFont.lfUnderline
71178>>>>>        Move (FontStrikeOut(Self)) to LogicalFont.lfStrikeOut
71179>>>>>        Move (FontCharSet(Self))   to LogicalFont.lfCharSet
71180>>>>>        Move (FontOutPrecision(Self)) to LogicalFont.lfOutPrecision
71181>>>>>        Move (FontClipPrecision(Self)) to LogicalFont.lfClipPrecision
71182>>>>>        Move (FontQuality(Self)) to LogicalFont.lfQuality
71183>>>>>
71183>>>>>        // Family is an integer using bits 5-7 (has values 0,16,32,48,64 and 80), 
71183>>>>>        // and Pitch uses bits 1-4 (values 0,1,2,8). They can be simply added using IOR to get the PitchAndFamily.
71183>>>>>        Move (FontFamily(Self) ior FontPitch(Self)) to LogicalFont.lfPitchAndFamily
71184>>>>>
71184>>>>>        Get FaceName to wFaceName
71185>>>>>        Move (Left(wFaceName, LF_FACESIZE - 1)) to wFaceName  // Left takes the number of characters.
71186>>>>>        Move (MemCopy(AddressOf(LogicalFont.lfFaceName), AddressOf(wFaceName), SizeOfWString(wfaceName) * 2 + 2)) to iResult
71187>>>>>
71187>>>>>        Move (SizeOfType(tWinChooseFont)) to ChseFont.lStructSize
71188>>>>>        Move hOwner to ChseFont.hwndOwner
71189>>>>>        Move (AddressOf(LogicalFont)) to ChseFont.lpLogFont
71190>>>>>        // The original FONT_DLG.PKG (by Stuart) always sets the CF_LIMITSIZE, CF_SCREENFONT and
71190>>>>>        // CF_INITTOLOGFONTSTRUCT flags. We will do the same...
71190>>>>>        // This defeats the use of CF_SCREENFONTS and CF_LIMITSIZE !
71190>>>>>        Move (CF_LIMITSIZE+CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+FontTypes(Self)) to iFlags
71191>>>>>        If (ShowHelp_State(Self)) ;            Move (iFlags+CF_SHOWHELP) to iFlags
71194>>>>>        If (Effects_State(Self)) ;            Move (iFlags+CF_EFFECTS) to iFlags
71197>>>>>        If (NoOEMFonts_State(Self)) ;            Move (iFlags+CF_NOOEMFONTS) to iFlags
71200>>>>>        If (ForceFontExist_State(Self)) ;            Move (iFlags+CF_FORCEFONTEXIST) to iFlags
71203>>>>>        If (NoFaceSel_State(Self)) ;            Move (iFlags+CF_NOFACESEL) to iFlags
71206>>>>>        If (NoStyleSel_State(Self)) ;            Move (iFlags+CF_NOSTYLESEL) to iFlags
71209>>>>>        If (NoSizeSel_State(Self)) ;            Move (iFlags+CF_NOSIZESEL) to iFlags
71212>>>>>        If (SelectScript_State(Self)) ;            Move (iFlags+CF_SELECTSCRIPT) to iFlags
71215>>>>>        If (NoScriptSel_State(Self)) ;            Move (iFlags+CF_NOSCRIPTSEL) to iFlags
71218>>>>>        If (NoVertFonts_State(Self)) ;            Move (iFlags+CF_NOVERTFONTS) to iFlags
71221>>>>>        If (ScriptsOnly_State(Self)) ;            Move (iFlags+CF_SCRIPTSONLY) to iFlags
71224>>>>>        If (not(FontTypes(Self))) Begin
71226>>>>>            If (ANSIOnly_State(Self)) ;                Move (iFlags+CF_ANSIONLY) to iFlags
71229>>>>>            If (NoVectorFonts_State(Self)) ;                Move (iFlags+CF_NOVECTORFONTS) to iFlags
71232>>>>>            If (NoSimulations_State(Self)) ;                Move (iFlags+CF_NOSIMULATIONS) to iFlags
71235>>>>>            If (FixedPitchOnly_State(Self)) ;                Move (iFlags+CF_FIXEDPITCHONLY) to iFlags
71238>>>>>            If (ScalableOnly_State(Self)) ;                Move (iFlags+CF_SCALABLEONLY) to iFlags
71241>>>>>            If (TTOnly_State(Self)) ;                Move (iFlags+CF_TTONLY) to iFlags
71244>>>>>        End
71244>>>>>>
71244>>>>>        Move iFlags to ChseFont.Flags
71245>>>>>        Move (FontPointSize(Self)) to ChseFont.iPointSize
71246>>>>>        Move (FontRGBColors(Self)) to ChseFont.rgbColors
71247>>>>>        Move (FontType(Self)) to ChseFont.nFontType
71248>>>>>        Move (FontSizeMin(Self)) to ChseFont.nSizeMin
71249>>>>>        Move (FontSizeMax(Self)) to ChseFont.nSizeMax
71250>>>>>        
71250>>>>>        Move (ChooseFontW(AddressOf(ChseFont))) to iResult
71251>>>>>        If not iResult ;            Function_Return iResult
71254>>>>>        Move LogicalFont.lfHeight to iResult
71255>>>>>        Set FontHeight to iResult
71256>>>>>        Move LogicalFont.lfWidth to iResult
71257>>>>>        Set FontWidth to iResult
71258>>>>>        Move LogicalFont.lfEscapement to iResult
71259>>>>>        Set FontEscapement to iResult
71260>>>>>        Move LogicalFont.lfOrientation to iResult
71261>>>>>        Set FontOrientation to iResult
71262>>>>>        Move LogicalFont.lfWeight to iResult
71263>>>>>        Set FontWeight to iResult
71264>>>>>        Move LogicalFont.lfItalic to iResult
71265>>>>>        Set FontItalic to iResult
71266>>>>>        Move LogicalFont.lfUnderline to iResult
71267>>>>>        Set FontUnderline to iResult
71268>>>>>        Move LogicalFont.lfStrikeOut to iResult
71269>>>>>        Set FontStrikeOut to iResult
71270>>>>>        Move LogicalFont.lfCharSet to iResult
71271>>>>>        Set FontCharSet to iResult
71272>>>>>        Move LogicalFont.lfOutPrecision to iResult
71273>>>>>        Set FontOutPrecision to iResult
71274>>>>>        Move LogicalFont.lfClipPrecision to iResult
71275>>>>>        Set FontClipPrecision to iResult
71276>>>>>        Move LogicalFont.lfQuality to iResult
71277>>>>>        Set FontQuality to iResult
71278>>>>>        Move LogicalFont.lfPitchAndFamily to iPitchAndFamily
71279>>>>>
71279>>>>>        Set FaceName to (PointerToWString(AddressOf (LogicalFont.lfFaceName)))
71280>>>>>
71280>>>>>        // https://docs.microsoft.com/en-us/previous-versions/windows/desktop/bb322837(v=vs.85)
71280>>>>>        // Pitch is the lower 4 bits and can have values 0,1,2, and 8. 
71280>>>>>        // Family is the higher 4 bits and can have values: 0,16,32,48,64 and 80.
71280>>>>>        // The correct function for getting them is IAND
71280>>>>>        Set FontPitch to (Integer (iPitchAndFamily iand |CI$0F))
71281>>>>>        Set FontFamily to (Integer (iPitchAndFamily iand |CI$F0))
71282>>>>>
71282>>>>>        Move ChseFont.iPointSize to iResult
71283>>>>>        Set FontPointSize to iResult
71284>>>>>        Move ChseFont.rgbColors to iResult
71285>>>>>        Set FontRGBColors to iResult
71286>>>>>        Move ChseFont.nFontType to iResult
71287>>>>>        Set FontType to iResult
71288>>>>>        Move ChseFont.nSizeMin to iResult
71289>>>>>        Set FontSizeMin to iResult
71290>>>>>        Move ChseFont.nSizeMax to iResult
71291>>>>>        Set FontSizeMax to iResult
71292>>>>>        Function_Return True
71293>>>>>    End_Function
71294>>>>>    
71294>>>>>    
71294>>>>>    Procedure Set ShowEffects_State Integer iState
71296>>>>>        Set Effects_State to iState
71297>>>>>    End_Procedure
71298>>>>>    
71298>>>>>    Function ShowEffects Returns Integer
71300>>>>>        Function_Return (Effects_State(Self))
71301>>>>>    End_Function
71302>>>>>    
71302>>>>>    Procedure Set InitialFont_State Integer iState
71304>>>>>        Set NoFaceSel_State to (not(iState))
71305>>>>>    End_Procedure
71306>>>>>    
71306>>>>>    Function InitialFontState Returns Integer
71308>>>>>        Function_Return (not(NoFaceSel_State(Self)))
71309>>>>>    End_Function
71310>>>>>    
71310>>>>>    Procedure Set InitialSize_State Integer iState
71312>>>>>        Set NoSizeSel_State to (not(iState))
71313>>>>>    End_Procedure
71314>>>>>    
71314>>>>>    Function InitialSize_State Returns Integer
71316>>>>>        Function_Return (not(NoSizeSel_State(Self)))
71317>>>>>    End_Function
71318>>>>>    
71318>>>>>    Procedure Set InitialStyle_State Integer iState
71320>>>>>        Set NoStyleSel_State to (not(iState))
71321>>>>>    End_Procedure
71322>>>>>    
71322>>>>>    Function InitialStyle_State Returns Integer
71324>>>>>        Function_Return (not(NoStyleSel_State(Self)))
71325>>>>>    End_Function
71326>>>>>    
71326>>>>>    Procedure Set FontExists_State Integer iState
71328>>>>>        Set ForceFontExist_State to iState
71329>>>>>    End_Procedure
71330>>>>>    
71330>>>>>    Function FontExists_State Returns Integer
71332>>>>>        Function_Return (ForceFontExist_State(Self))
71333>>>>>    End_Function
71334>>>>>    
71334>>>>>    Procedure Set FontMinSize Integer iSize
71336>>>>>        Set FontSizeMin to iSize
71337>>>>>    End_Procedure
71338>>>>>    
71338>>>>>    Function FontMinSize Returns Integer
71340>>>>>        Function_Return (FontSizeMin(Self))
71341>>>>>    End_Function
71342>>>>>    
71342>>>>>    Procedure Set FontMaxSize Integer iSize
71344>>>>>        Set FontSizeMax to iSize
71345>>>>>    End_Procedure
71346>>>>>    
71346>>>>>    Function FontMaxSize Returns Integer
71348>>>>>        Function_Return (FontSizeMax(Self))
71349>>>>>    End_Function
71350>>>>>    
71350>>>>>    Procedure Set FontColor Integer iColor
71352>>>>>        Set FontRGBColors to iColor
71353>>>>>    End_Procedure
71354>>>>>    
71354>>>>>    Function FontColor Returns Integer
71356>>>>>        Function_Return (FontRGBColors(Self))
71357>>>>>    End_Function
71358>>>>>    
71358>>>>>    Function Show_Dialog Returns Integer
71360>>>>>        Function_Return (FontDialog(Self))
71361>>>>>    End_Function
71362>>>>>    
71362>>>>>End_Class
71363>>>>>
71363>>>Use dfEnChk.pkg
71363>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cRichEdit.pkg)
71363>>>>>Use Windows.pkg
71363>>>>>Use cEdit_Mixin.pkg
71363>>>>>
71363>>>>>// constants used for RichEdit Properties
71363>>>>>// peAlignment
71363>>>>>Enum_List
71363>>>>>    Define alLeft   for 1
71363>>>>>    Define alRight  for 2
71363>>>>>    Define alCenter for 3
71363>>>>>End_Enum_List
71363>>>>>
71363>>>>>// peBullets
71363>>>>>Enum_List
71363>>>>>    Define buNone
71363>>>>>    Define buBullets
71363>>>>>    Define buArabicNumbers
71363>>>>>    Define buLowerLetters
71363>>>>>    Define buUpperLetters
71363>>>>>    Define buLowerRomans
71363>>>>>    Define buUpperRomans
71363>>>>>End_Enum_List
71363>>>>>
71363>>>>>// peBulletStyle
71363>>>>>Enum_List
71363>>>>>    Define busRightParen   for 0
71363>>>>>    Define busEncloseParen for 256
71363>>>>>    Define busPeriod       for 512
71363>>>>>    Define busNumberOnly   for 768
71363>>>>>    Define busNoDisplay    for 1024
71363>>>>>End_Enum_List
71363>>>>>
71363>>>>>// peLineSpacingType
71363>>>>>Enum_List
71363>>>>>    Define lstSingle
71363>>>>>    Define lstSingleAndOneHalf
71363>>>>>    Define lstDouble
71363>>>>>End_Enum_List
71363>>>>>
71363>>>>>Class cRichEdit is a DFBaseRichEdit
71364>>>>>    
71364>>>>>    Procedure Construct_Object
71366>>>>>        Forward Send Construct_Object
71368>>>>>        Send Define_cEdit_Mixin
71369>>>>>        
71369>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
71370>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
71371>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
71372>>>>>        
71372>>>>>    End_Procedure
71373>>>>>    
71373>>>>>    Import_Class_Protocol cEdit_Mixin
71374>>>>>    
71374>>>>>    Procedure ToggleBold
71376>>>>>        Set pbBold to (not(pbBold(Self)))
71377>>>>>    End_Procedure
71378>>>>>    
71378>>>>>    Procedure ToggleItalics
71380>>>>>        Set pbItalics to (not(pbItalics(Self)))
71381>>>>>    End_Procedure
71382>>>>>    
71382>>>>>    Procedure ToggleUnderline
71384>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
71385>>>>>    End_Procedure
71386>>>>>    
71386>>>>>End_Class
71387>>>>>
71387>>>>>
71387>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJGridPromptList.pkg)
71387>>>>>Use Windows.pkg
71387>>>>>Use cCJGrid.pkg
71387>>>>>
71387>>>>>
71387>>>>>
71387>>>>>Class cCJGridPromptList is a cCJGrid
71388>>>>>    
71388>>>>>    Procedure Construct_Object
71390>>>>>        Forward Send Construct_Object
71392>>>>>        
71392>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
71393>>>>>        Property Boolean Private_pbAutoOrdering True
71394>>>>>        Property Boolean pbAutoSearch True  // pops up search window
71395>>>>>        Property Integer peUpdateMode umPromptValue
71396>>>>>        Property Integer piUpdateColumn 0
71397>>>>>        Property Integer piInitialColumn -1
71398>>>>>        Property String  psSeedValue ''
71399>>>>>        Property Handle phmPromptUpdateCallback 0
71400>>>>>        Property Integer phoInvokingObject
71401>>>>>        
71401>>>>>        Property Boolean pbStoredAutoSeed
71402>>>>>        Property Boolean pbStoredAutoOrdering
71403>>>>>        Property Boolean pbStoredAutoSearch
71404>>>>>        Property Integer peStoredUpdateMode
71405>>>>>        Property Integer piStoredUpdateColumn
71406>>>>>        Property Integer piStoredInitialColumn
71407>>>>>        Property Handle  phmStoredPromptUpdateCallback
71408>>>>>        Property Boolean pbStoredSelectionEnable
71409>>>>>        Property Boolean pbStoredMultipleSelection
71410>>>>>        
71410>>>>>        // internally set by list
71410>>>>>        // these must be set upon closing the list and can be used for manual list updates
71410>>>>>        Property Boolean pbCanceled
71411>>>>>        Property Integer[] pSelectedRows
71412>>>>>        
71412>>>>>        Property Boolean pbNeedsNewOrdering
71413>>>>>        Property Boolean pbRequestSearch
71414>>>>>        Property tGridKeyPair[] pSearchKeys
71415>>>>>        
71415>>>>>        // these properties makes a prompt list a prompt list
71415>>>>>        // and should not be changed.
71415>>>>>        Set pbEditOnKeyNavigation to False
71416>>>>>        Set pbEditOnClick to False
71417>>>>>        Set pbReadOnly to True
71418>>>>>        Set pbFocusSubItems to True
71419>>>>>        
71419>>>>>        // these could maybe be changed
71419>>>>>        Set pbShadeSortColumn to True
71420>>>>>        Set pbHeaderReorders to True
71421>>>>>        Set pbHeaderTogglesDirection to True
71422>>>>>        Set pbHeaderSelectsColumn to True
71423>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
71424>>>>>        Set piFocusCellBackColor to clNone
71425>>>>>        Set piFocusCellForeColor to clNone
71426>>>>>        Set piFocusCellRectangleColor to clBlack
71427>>>>>        Set pbUseFocusCellRectangle to False
71428>>>>>        Set pbSelectionEnable to True
71429>>>>>        
71429>>>>>        On_Key kEnter Send Ok
71430>>>>>        On_Key kCancel Send Cancel
71431>>>>>        
71431>>>>>    End_Procedure
71432>>>>>    
71432>>>>>    // reorder list automatically on column change
71432>>>>>    // this also set pbFocusSubItems which is required to make the two states work
71432>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
71434>>>>>        Set Private_pbAutoOrdering to bAutoOrder
71435>>>>>        Set pbFocusSubItems to bAutoOrder
71436>>>>>    End_Procedure
71437>>>>>    
71437>>>>>    Function pbAutoOrdering Returns Boolean
71439>>>>>        Boolean bAutoOrder
71439>>>>>        Get Private_pbAutoOrdering to bAutoOrder
71440>>>>>        Function_Return bAutoOrder
71441>>>>>    End_Function
71442>>>>>    
71442>>>>>    // augmented to handle auto-ordering and invoking the search popup list
71442>>>>>    Procedure OnIdle
71444>>>>>        Boolean bNeedsReorder bSearch bOldToggle
71444>>>>>        Handle hoCol
71444>>>>>        Integer iKy1 iKy2 iCol
71444>>>>>        
71444>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
71445>>>>>        If bNeedsReorder Begin
71447>>>>>            Get SelectedColumn to iCol
71448>>>>>            If (iCol<>-1) Begin
71450>>>>>                
71450>>>>>                Get pbHeaderTogglesDirection to bOldToggle
71451>>>>>                Set pbHeaderTogglesDirection to False
71452>>>>>                Send HeaderReorder iCol
71453>>>>>                Set pbHeaderTogglesDirection to bOldToggle
71454>>>>>                
71454>>>>>                Set pbNeedsNewOrdering to False
71455>>>>>            End
71455>>>>>>
71455>>>>>        End
71455>>>>>>
71455>>>>>        
71455>>>>>        Get pbRequestSearch to bSearch
71456>>>>>        If bSearch Begin
71458>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
71459>>>>>        End
71459>>>>>>
71459>>>>>        
71459>>>>>        Forward Send OnIdle
71461>>>>>    End_Procedure
71462>>>>>    
71462>>>>>    Procedure OnStoreDefaults
71464>>>>>        Integer iVal
71464>>>>>        Boolean bVal
71464>>>>>        
71464>>>>>        Get pbAutoSeed to bVal
71465>>>>>        Set pbStoredAutoSeed to bVal
71466>>>>>        
71466>>>>>        Get pbAutoOrdering to bVal
71467>>>>>        Set pbStoredAutoOrdering to bVal
71468>>>>>        
71468>>>>>        Get pbAutoSearch to bVal
71469>>>>>        Set pbStoredAutoSearch to bVal
71470>>>>>        
71470>>>>>        Get peUpdateMode to iVal
71471>>>>>        Set peStoredUpdateMode to iVal
71472>>>>>        
71472>>>>>        Get piUpdateColumn to iVal
71473>>>>>        Set piStoredUpdateColumn to iVal
71474>>>>>        
71474>>>>>        Get piInitialColumn to iVal
71475>>>>>        Set piStoredInitialColumn to iVal
71476>>>>>        
71476>>>>>        Get phmPromptUpdateCallback to iVal
71477>>>>>        Set phmStoredPromptUpdateCallback to iVal
71478>>>>>        
71478>>>>>        Get pbSelectionEnable to bVal
71479>>>>>        Set pbStoredSelectionEnable to bVal
71480>>>>>        
71480>>>>>        Get pbMultipleSelection to bVal
71481>>>>>        Set pbStoredMultipleSelection to bVal
71482>>>>>        
71482>>>>>    End_Procedure
71483>>>>>    
71483>>>>>    Procedure OnRestoreDefaults
71485>>>>>        Integer iVal
71485>>>>>        Boolean bVal
71485>>>>>        
71485>>>>>        Get pbStoredAutoSeed to bVal
71486>>>>>        Set pbAutoSeed to bVal
71487>>>>>        
71487>>>>>        Get pbStoredAutoOrdering to bVal
71488>>>>>        Set pbAutoOrdering to bVal
71489>>>>>        
71489>>>>>        Get pbStoredAutoSearch to bVal
71490>>>>>        Set pbAutoSearch to bVal
71491>>>>>        
71491>>>>>        Get peStoredUpdateMode to iVal
71492>>>>>        Set peUpdateMode to iVal
71493>>>>>        
71493>>>>>        Get piStoredInitialColumn to iVal
71494>>>>>        Set piInitialColumn to iVal
71495>>>>>        
71495>>>>>        Get phmStoredPromptUpdateCallback to iVal
71496>>>>>        Set phmPromptUpdateCallback to iVal
71497>>>>>        
71497>>>>>        Get pbStoredSelectionEnable to bVal
71498>>>>>        Set pbSelectionEnable to bVal
71499>>>>>        
71499>>>>>        Get pbStoredMultipleSelection to bVal
71500>>>>>        Set pbMultipleSelection to bVal
71501>>>>>        
71501>>>>>    End_Procedure
71502>>>>>    
71502>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
71502>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
71502>>>>>    // Suitable for augmentation
71502>>>>>    Procedure OnSeedData
71504>>>>>        Integer iUpdateColumn iSortColumn
71504>>>>>        Boolean bSeed bAuto
71504>>>>>        String sValue
71504>>>>>        Handle hoCol
71504>>>>>        
71504>>>>>        Get piUpdateColumn to iUpdateColumn
71505>>>>>        Get psSeedValue to sValue
71506>>>>>        Get pbAutoSeed to bSeed
71507>>>>>        Get piSortColumn to iSortColumn
71508>>>>>        Get pbAutoOrdering to bAuto
71509>>>>>        // if not yet sorted and this is auto ordering we will
71509>>>>>        // sort the data for the search column. We do this to make the
71509>>>>>        // column search GE logic work properly.
71509>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
71511>>>>>            Get ColumnObject iUpdateColumn to hoCol
71512>>>>>            Send SortGridByColumn hoCol False
71513>>>>>        End
71513>>>>>>
71513>>>>>        
71513>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
71515>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
71516>>>>>        End
71516>>>>>>
71516>>>>>        Else Begin
71517>>>>>            Send MovetoFirstRow
71518>>>>>        End
71518>>>>>>
71518>>>>>        
71518>>>>>    End_Procedure
71519>>>>>    
71519>>>>>    Procedure OnMoveValueOutByValue
71521>>>>>        String sValue
71521>>>>>        Handle hoInvokingObject hoCol  hoDataSource
71521>>>>>        Integer iRow iCol
71521>>>>>        Integer[] SelRowsIndexes
71522>>>>>        
71522>>>>>        Get phoInvokingObject to hoInvokingObject
71523>>>>>        Get pSelectedRows to SelRowsIndexes
71524>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
71526>>>>>            Get piUpdateColumn to iCol
71527>>>>>            Get ColumnObject iCol to hoCol
71528>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
71529>>>>>            Set Value of hoInvokingObject to sValue
71530>>>>>            Set Item_Changed_State of hoInvokingObject to True
71531>>>>>        End
71531>>>>>>
71531>>>>>    End_Procedure
71532>>>>>    
71532>>>>>    Procedure OnMoveValueOutByCustom
71534>>>>>    End_Procedure
71535>>>>>    
71535>>>>>    // augment to popup a search window when allowed
71535>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
71537>>>>>        Boolean bSubFocus bAutoSearch bChar
71537>>>>>        Integer iVal
71537>>>>>        
71537>>>>>        Get pbFocusSubItems to bSubFocus
71538>>>>>        Get pbAutoSearch to bAutoSearch
71539>>>>>        Forward Send OnComKeyDown llKeyCode llShift
71541>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
71543>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
71545>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
71546>>>>>                Move (iVal<>0) to bChar
71547>>>>>            End
71547>>>>>>
71547>>>>>            If bChar Begin
71549>>>>>                // this can get called multiple times before a search dialog pops up
71549>>>>>                Send AddToSearchKeys llKeyCode llShift
71550>>>>>            End
71550>>>>>>
71550>>>>>        End
71550>>>>>>
71550>>>>>    End_Procedure
71551>>>>>    
71551>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
71553>>>>>        Boolean bAutoSearch
71553>>>>>        Integer iKeyCode iShiftCode
71553>>>>>        Get pbAutoSearch to bAutoSearch
71554>>>>>        If bAutoSearch Begin
71556>>>>>            // this can get called multiple times before a search dialog pops up
71556>>>>>            Get piLastKey to iKeyCode
71557>>>>>            Get piLastKey2 to iShiftCode
71558>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
71559>>>>>        End
71559>>>>>>
71559>>>>>        Move True to llCancel
71560>>>>>    End_Procedure
71561>>>>>    
71561>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
71563>>>>>        Send ClearSearchRequest // kill any deferred search popup
71564>>>>>        Forward Send OnComRowDblClick llRow llItem
71566>>>>>    End_Procedure
71567>>>>>    
71567>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
71569>>>>>        Send Ok
71570>>>>>    End_Procedure
71571>>>>>    
71571>>>>>    
71571>>>>>    // we don't want a menu for prompt lists
71571>>>>>    Function CreateContextMenu Returns Handle
71573>>>>>        Function_Return 0
71574>>>>>    End_Function
71575>>>>>    
71575>>>>>    // if we use auto-ordering, change the order when the column changes
71575>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
71577>>>>>        Boolean bAutoOrder
71577>>>>>        Forward Send ColumnChanged iOld iNew
71579>>>>>        Get pbAutoOrdering to bAutoOrder
71580>>>>>        If bAutoOrder Begin
71582>>>>>            // will be reordered in idle event
71582>>>>>            Set pbNeedsNewOrdering to True
71583>>>>>        End
71583>>>>>>
71583>>>>>    End_Procedure
71584>>>>>    
71584>>>>>    
71584>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
71586>>>>>        Integer eMode
71586>>>>>        Integer[] SelRowsIndexes
71587>>>>>        Set pbCanceled to True // assume cancel unless changed
71588>>>>>        Set pSelectedRows to SelRowsIndexes // empty
71589>>>>>        Get peUpdateMode to eMode
71590>>>>>        If (eMode<>umPromptNonInvoking) Begin
71592>>>>>            Send OnStoreDefaults
71593>>>>>        End
71593>>>>>>
71593>>>>>        Send InitializePromptList
71594>>>>>        Forward Send Add_Focus hoParent
71596>>>>>        Send LoadData
71597>>>>>        Set psSeedValue to ""
71598>>>>>    End_Procedure
71599>>>>>    
71599>>>>>    // called before the list is activated.
71599>>>>>    Procedure InitializePromptList
71601>>>>>        Integer hoInvokingObject
71601>>>>>        Boolean bAutoColumn bAutoSeed
71601>>>>>        Integer i iOldMode eUpdateMode
71601>>>>>        String sValue
71601>>>>>        
71601>>>>>        Get peUpdateMode to eUpdateMode
71602>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
71604>>>>>            Get Focus of Desktop to hoInvokingObject
71605>>>>>            If (hoInvokingObject<=Desktop) Begin
71607>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
71608>>>>>>
71608>>>>>                Procedure_Return
71609>>>>>            End
71609>>>>>>
71609>>>>>            
71609>>>>>            Set phoInvokingObject to hoInvokingObject
71610>>>>>            
71610>>>>>            Send Prompt_Callback to hoInvokingObject Self
71611>>>>>            Get peUpdateMode to eUpdateMode
71612>>>>>        End
71612>>>>>>
71612>>>>>        
71612>>>>>        Send ClearSearchRequest // clear the search keys
71613>>>>>        Set pbNeedsNewOrdering to False
71614>>>>>        
71614>>>>>        Get pbAutoSeed to bAutoSeed
71615>>>>>        
71615>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
71617>>>>>            Get Value of hoInvokingObject to sValue
71618>>>>>            Set psSeedValue to sValue
71619>>>>>        End
71619>>>>>>
71619>>>>>        
71619>>>>>    End_Procedure
71620>>>>>    
71620>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
71620>>>>>    Procedure LoadData
71622>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
71622>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
71622>>>>>        Integer eUpdateMode
71622>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
71622>>>>>        
71622>>>>>        Get phoDataSource to hoDataSource
71623>>>>>        Get peUpdateMode to eUpdateMode
71624>>>>>        Get phoInvokingObject to hoInvokingObject
71625>>>>>        Get pbAutoSeed to bAutoSeed
71626>>>>>        Get piInitialColumn to iInitialColumn
71627>>>>>        Get piUpdateColumn to iUpdateColumn
71628>>>>>        Get RowCount of hoDataSource to iRows
71629>>>>>        
71629>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
71629>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
71629>>>>>        If (iInitialColumn=-1) Begin
71631>>>>>            Move iUpdateColumn to iInitialColumn
71632>>>>>        End
71632>>>>>>
71632>>>>>        If (iInitialColumn>=0) Begin
71634>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
71635>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
71636>>>>>        End
71636>>>>>>
71636>>>>>        Send OnSeedData // find a good starting place for the row
71637>>>>>        Get pbFocusSubItems to bSubFocus
71638>>>>>        If bSubFocus Begin
71640>>>>>            // if column focus, which is normal, go to initialcolumn
71640>>>>>            If hoInitialColumn Begin
71642>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
71643>>>>>            End
71643>>>>>>
71643>>>>>            Else Begin
71644>>>>>                Send MoveToFirstEnterableColumn
71645>>>>>            End
71645>>>>>>
71645>>>>>        End
71645>>>>>>
71645>>>>>        
71645>>>>>    End_Procedure
71646>>>>>    
71646>>>>>    // This is only called in a successful close
71646>>>>>    Procedure ClosePromptList
71648>>>>>        Handle hoDataSource hoInvokingObject
71648>>>>>        Handle hmCallBack
71648>>>>>        Integer iRow eUpdateMode
71648>>>>>        Integer[] SelRowsIndexes
71649>>>>>        
71649>>>>>        Get phoDataSource to hoDataSource
71650>>>>>        Get phoInvokingObject to hoInvokingObject
71651>>>>>        
71651>>>>>        If (pbMultipleSelection(Self)) Begin
71653>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
71654>>>>>        End
71654>>>>>>
71654>>>>>        Else Begin
71655>>>>>            Get SelectedRow of hoDataSource to iRow
71656>>>>>            If (iRow<>-1) Begin
71658>>>>>                Move iRow to SelRowsIndexes[0]
71659>>>>>            End
71659>>>>>>
71659>>>>>        End
71659>>>>>>
71659>>>>>        
71659>>>>>        Set pbCanceled to False
71660>>>>>        Set pSelectedRows to SelRowsIndexes
71661>>>>>        
71661>>>>>        Get peUpdateMode to eUpdateMode
71662>>>>>        // if non-invoking there is by definition, no move value out
71662>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
71664>>>>>            
71664>>>>>            If (eUpdateMode=umPromptValue) Begin
71666>>>>>                Send OnMoveValueOutByValue
71667>>>>>            End
71667>>>>>>
71667>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
71670>>>>>                Send OnMoveValueOutByCustom
71671>>>>>            End
71671>>>>>>
71671>>>>>            Get phmPromptUpdateCallback to hmCallBack
71672>>>>>            If hmCallBack Begin
71674>>>>>                Send hmCallBack of hoInvokingObject Self
71675>>>>>            End
71675>>>>>>
71675>>>>>        End
71675>>>>>>
71675>>>>>        
71675>>>>>        Send Close_Panel
71676>>>>>    End_Procedure
71677>>>>>    
71677>>>>>    // augment to send OnRestoreDefaults.
71677>>>>>    Procedure Release_Focus
71679>>>>>        Integer eUpdateMode
71679>>>>>        Get peUpdateMode to eUpdateMode
71680>>>>>        Forward Send Release_Focus
71682>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
71684>>>>>            Send OnRestoreDefaults
71685>>>>>        End
71685>>>>>>
71685>>>>>    End_Procedure
71686>>>>>    
71686>>>>>    Function SelectedRowIds Returns RowID[]
71688>>>>>        RowID[] SelectedRowids
71689>>>>>        Integer[] SelectedRows
71690>>>>>        Integer i iRows
71690>>>>>        Handle hoDataSource
71690>>>>>        Get phoDataSource to hoDataSource
71691>>>>>        Get pSelectedRows to SelectedRows
71692>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
71693>>>>>        For i from 0 to (iRows-1)
71699>>>>>>
71699>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
71700>>>>>        Loop
71701>>>>>>
71701>>>>>        Function_Return SelectedRowids
71702>>>>>    End_Function
71703>>>>>    
71703>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
71705>>>>>        String[] SelectedValues
71706>>>>>        Integer[] SelectedRows
71707>>>>>        Integer i iRows
71707>>>>>        Handle hoCol
71707>>>>>        Get ColumnObject iCol to hoCol
71708>>>>>        Get pSelectedRows to SelectedRows
71709>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
71710>>>>>        For i from 0 to (iRows-1)
71716>>>>>>
71716>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
71717>>>>>        Loop
71718>>>>>>
71718>>>>>        Function_Return SelectedValues
71719>>>>>    End_Function
71720>>>>>    
71720>>>>>    Procedure Ok Returns Integer
71722>>>>>        Send ClosePromptList
71723>>>>>    End_Procedure
71724>>>>>    
71724>>>>>    Procedure Cancel Returns Integer
71726>>>>>        Send Close_Panel
71727>>>>>    End_Procedure
71728>>>>>    
71728>>>>>    Procedure Search
71730>>>>>        Send Activate // give focus back to list so focus things are correct
71731>>>>>        Send Request_Search 0 0
71732>>>>>    End_Procedure
71733>>>>>    
71733>>>>>    // do a search using the current keys in the search key buffer for the sort column.
71733>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
71733>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
71733>>>>>    Procedure Request_SearchEx
71735>>>>>        tGridKeyPair[] Keys
71735>>>>>        tGridKeyPair[] Keys
71736>>>>>        Integer iCol
71736>>>>>        Handle hoCol hoSearchDialog
71736>>>>>        Boolean bOk
71736>>>>>        String sValue
71736>>>>>        
71736>>>>>        Get piSortColumn to iCol
71737>>>>>        If (iCol<>-1) Begin
71739>>>>>            Get ColumnObject iCol to hoCol
71740>>>>>            Get pSearchKeys to Keys
71741>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
71742>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
71743>>>>>            If bOk Begin
71745>>>>>                Send RequestFindColumnValue iCol sValue True 0
71746>>>>>            End
71746>>>>>>
71746>>>>>            Send Destroy of hoSearchDialog
71747>>>>>        End
71747>>>>>>
71747>>>>>        Send ClearSearchRequest // clear the search keys
71748>>>>>    End_Procedure
71749>>>>>    
71749>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
71749>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
71751>>>>>        tGridKeyPair[] Keys
71751>>>>>        tGridKeyPair[] Keys
71752>>>>>        tGridKeyPair KeyPair
71752>>>>>        tGridKeyPair KeyPair
71752>>>>>        Set pbRequestSearch to True
71753>>>>>        Move iKeyCode to KeyPair.KeyCode
71754>>>>>        Move iShiftCode to KeyPair.ShiftCode
71755>>>>>        Get pSearchKeys to Keys
71756>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
71757>>>>>        Set pSearchKeys to Keys
71758>>>>>    End_Procedure
71759>>>>>    
71759>>>>>    Procedure ClearSearchRequest
71761>>>>>        tGridKeyPair[] SearchKeys
71761>>>>>        tGridKeyPair[] SearchKeys
71762>>>>>        Set pSearchKeys to SearchKeys
71763>>>>>        Set pbRequestSearch to False
71764>>>>>    End_Procedure
71765>>>>>    
71765>>>>>End_Class
71766>>>>>
71766>>>Use cLinkLabel.pkg
Including file: cLinkLabel.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLinkLabel.pkg)
71766>>>>>Use Windows.pkg
71766>>>>>Use GlobalFunctionsProcedures.pkg
71766>>>>>Use Commctrl.pkg
71766>>>>>Use tWinStructs.pkg
71766>>>>>Use CharTranslate.pkg
71766>>>>>Use Unicode.Pkg
71766>>>>>
71766>>>>>// we use container3d because it has better next/previous navigation logic
71766>>>>>// we use a container because it works better (fonts and things are correct)
71766>>>>>Class cLinkLabel is a container3d
71767>>>>>    
71767>>>>>    Import_Class_Protocol Label_Mixin
71768>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
71769>>>>>    
71769>>>>>    Procedure Construct_Object
71771>>>>>        Boolean bSupported
71771>>>>>        Forward Send Construct_Object
71773>>>>>        
71773>>>>>        
71773>>>>>        Send Define_ToolTip_Support_Mixin
71774>>>>>        
71774>>>>>        // determines if enter key opens link or is passed to parent
71774>>>>>        Property Boolean pbEnterPassThrough False
71775>>>>>        
71775>>>>>        // if true, height is adjusted to fit width and text
71775>>>>>        Property Boolean pbAutoSizeHeight True
71776>>>>>        
71776>>>>>        
71776>>>>>        // Setting this allows it to take the DataFlex focus. Don't change!
71776>>>>>        Set Client_Area_State to False
71777>>>>>        
71777>>>>>        // only supported in XP and above. If not supported, you get no useful control
71777>>>>>        Get IsControlSupported to bSupported
71778>>>>>        If not bSupported Begin
71780>>>>>            Send OnControlNotSupported
71781>>>>>            Procedure_Return
71782>>>>>        End
71782>>>>>>
71782>>>>>        
71782>>>>>        Set Color to clBtnFace
71783>>>>>        Set Size to 14 100
71784>>>>>        Set Border_Style to Border_None
71785>>>>>        // if True, the links are not navigated to via keyboard.
71785>>>>>        Set Skip_State to True
71786>>>>>        // needed by tooltip
71786>>>>>        Set pbUseFormWindowHandle to False
71787>>>>>        
71787>>>>>        Set External_Class_Name "DFSysLink" to "SysLink"
71788>>>>>        //Set Window_Style LWS_TRANSPARENT to True
71788>>>>>        Set Window_Style WS_CLIPCHILDREN to False
71789>>>>>        // to be consistent with other VDF controls like TextBox
71789>>>>>        Set Window_Style WS_CLIPSIBLINGS to True
71790>>>>>        Set External_Message WM_NOTIFY to msg_Notify
71791>>>>>        
71791>>>>>    End_Procedure
71792>>>>>    
71792>>>>>    // control is only supported in XP (5.1) and above.
71792>>>>>    Function IsControlSupported Returns Boolean
71794>>>>>        Integer iMajor iMinor
71794>>>>>        Boolean bSupported
71794>>>>>        // this is supported in 5.1 and above
71794>>>>>        Move (SysConf(SYSCONF_COMCTL_REV)) to iMajor
71795>>>>>        Move (Low(iMajor)) to iMinor
71796>>>>>        Move (Hi(iMajor)) to iMajor
71797>>>>>        // Check for XP or above (5.1 or above)
71797>>>>>        Move (iMajor>5 or (iMajor=5 and iMinor>0)) to bSupported
71798>>>>>        Function_Return bSupported
71799>>>>>    End_Function
71800>>>>>    
71800>>>>>    // augmented to handle NC_CLICK and NM_RETURN
71800>>>>>    Procedure Notify Longptr wParam Longptr lParam
71802>>>>>        tWinNmHdr Hdr
71802>>>>>        tWinNmHdr Hdr
71802>>>>>        tWinNmLink nmLink
71802>>>>>        tWinNmLink nmLink
71802>>>>>        tWinLItem LItem
71802>>>>>        tWinLItem LItem
71802>>>>>        Boolean bOk bPass
71802>>>>>        Integer i
71802>>>>>        String sID sUrl
71802>>>>>        
71802>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to i
71803>>>>>        If (Hdr.code=NM_CLICK or Hdr.code=NM_RETURN) Begin
71805>>>>>            If (Hdr.code=NM_CLICK) Begin
71807>>>>>                // if click, the LItem data is passed to us
71807>>>>>                Move (MemCopy(AddressOf(nmLink),lParam,SizeOfType(tWinNmLink))) to i
71808>>>>>                Move nmLink.item to LItem
71809>>>>>            End
71809>>>>>>
71809>>>>>            Else Begin
71810>>>>>                // do nothing is we pass Enters through
71810>>>>>                Get pbEnterPassThrough to bPass
71811>>>>>                If bPass Begin
71813>>>>>                    Procedure_Return
71814>>>>>                End
71814>>>>>>
71814>>>>>                // If Enter, we need to see which item has the focus.
71814>>>>>                Get GetCurrentItem (&LItem) to bOK
71815>>>>>                If not bOk Begin
71817>>>>>                    Procedure_Return
71818>>>>>                End
71818>>>>>>
71818>>>>>            End
71818>>>>>>
71818>>>>>            
71818>>>>>            // LItem is received from a windows function. Translate back to UTF8.
71818>>>>>            Get GetLItemIDtoString LItem to sID
71819>>>>>            Get GetLItemURLtoString LItem to sUrl
71820>>>>>            Send OnClick LItem.iLink sID sUrl
71821>>>>>            
71821>>>>>        End
71821>>>>>>
71821>>>>>        
71821>>>>>    End_Procedure
71822>>>>>    
71822>>>>>    // get the ideal GUI height based on current GUI width and size of text
71822>>>>>    Function IdealGUIHeight Returns Integer
71824>>>>>        Integer iSize iGuiHeight
71824>>>>>        Handle hWnd
71824>>>>>        tWinSize Size1
71824>>>>>        tWinSize Size1
71824>>>>>        
71824>>>>>        Get Window_Handle to hWnd
71825>>>>>        If (hWnd=0) Begin
71827>>>>>            Error DFERR_PROGRAM "LM_GETIDEALSIZE has been called before the windows control is paged"
71828>>>>>>
71828>>>>>            Function_Return
71829>>>>>        End
71829>>>>>>
71829>>>>>        
71829>>>>>        Get GuiSize to iSize
71830>>>>>        Move (WindowsMessage( LM_GETIDEALSIZE, low(iSize), AddressOf(Size1))) to iGuiHeight
71831>>>>>        Function_Return iGuiHeight
71832>>>>>    End_Function
71833>>>>>    
71833>>>>>    // set the controls height to make it fit
71833>>>>>    Procedure AutoSizeHeight
71835>>>>>        Integer iSize iHeight
71835>>>>>        Get Size to iSize
71836>>>>>        Get IdealGUIHeight to iHeight
71837>>>>>        Get GuiToDialog iHeight 0 to iHeight
71838>>>>>        Set Size to (hi(iHeight)) (Low(iSize))
71839>>>>>    End_Procedure
71840>>>>>    
71840>>>>>    // get item by item number. Returns the item data byref in a tWinLItem struct and
71840>>>>>    // returns true if the item existed. Note that the string data returns in Unicode.
71840>>>>>    Function GetItem Integer iItem tWinLItem ByRef LItem Returns Boolean
71842>>>>>        Integer iRet
71842>>>>>        Move iItem to Litem.iLink
71843>>>>>        Move (LIS_ENABLED ior LIS_FOCUSED ior LIS_VISITED ior LIS_HOTTRACK ior LIS_DEFAULTCOLORS) to Litem.stateMask
71844>>>>>        Move (LIF_ITEMID ior LIF_ITEMINDEX ior LIF_STATE ior LIF_URL) to Litem.Mask
71845>>>>>        Move (WindowsMessage( LM_GETITEM, 0, AddressOf(Litem))) to iRet
71846>>>>>        Function_Return (iRet<>0)
71847>>>>>    End_Function
71848>>>>>    
71848>>>>>    // get the item current, the item that has the windows focus.
71848>>>>>    // Returns the item data ByRef in a tWinLItem Struct and
71848>>>>>    // returns true if a current focus item exists. If the object does not have the
71848>>>>>    // focus there is no current item.
71848>>>>>    Function GetCurrentItem tWinLItem ByRef LItem Returns Boolean
71850>>>>>        Integer iRet i
71850>>>>>        Boolean bOk
71850>>>>>        Repeat
71850>>>>>>
71850>>>>>            Get GetItem i (&LItem) to bOk
71851>>>>>            If (bOk and (LItem.state iand LIS_FOCUSED)) Begin
71853>>>>>                Function_Return True
71854>>>>>            End
71854>>>>>>
71854>>>>>            Increment i
71855>>>>>        Until (not(bOk))
71857>>>>>        Function_Return False
71858>>>>>        
71858>>>>>    End_Function
71859>>>>>    
71859>>>>>    // convert unicode ID string in tWinLItem to a UTF8 string
71859>>>>>    Function GetLItemIDtoString tWinLItem LItem Returns String
71861>>>>>        Pointer pWideBuf
71861>>>>>        String sID
71861>>>>>        
71861>>>>>        Move (AddressOf(LItem.szID)) to pWideBuf
71862>>>>>        Move (PointerToWString(pWideBuf)) to sID
71863>>>>>        
71863>>>>>        Function_Return sID
71864>>>>>    End_Function
71865>>>>>    
71865>>>>>    // convert unicode URL string in tWinLItem to a UTF8 string
71865>>>>>    Function GetLItemURLtoString tWinLItem LItem Returns String
71867>>>>>        Pointer pWideBuf
71867>>>>>        String sURL
71867>>>>>        
71867>>>>>        Move (AddressOf(LItem.szUrl)) to pWideBuf
71868>>>>>        Move (PointerToWString(pWideBuf)) to sURL
71869>>>>>        
71869>>>>>        Function_Return sURL
71870>>>>>    End_Function
71871>>>>>    
71871>>>>>    
71871>>>>>    // augmented to switch to next item and then switch to next object
71871>>>>>    Procedure Next
71873>>>>>        tWinLItem LItem
71873>>>>>        tWinLItem LItem
71873>>>>>        Boolean bOK
71873>>>>>        Get GetCurrentItem (&LItem) to Bok
71874>>>>>        If bOK Begin
71876>>>>>            // if next item exists, let windows handle this.
71876>>>>>            Get GetItem (LItem.iLink+1) (&LItem) to bOK
71877>>>>>            If bOK Begin
71879>>>>>                Set Windows_Override_State to False
71880>>>>>                Procedure_Return
71881>>>>>            End
71881>>>>>>
71881>>>>>        End
71881>>>>>>
71881>>>>>        Forward Send Next
71883>>>>>    End_Procedure
71884>>>>>    
71884>>>>>    // augmented to switch to the previuous item and then switch to previous object
71884>>>>>    Procedure Previous
71886>>>>>        tWinLItem LItem
71886>>>>>        tWinLItem LItem
71886>>>>>        Boolean bOK
71886>>>>>        Get GetCurrentItem (&LItem) to Bok
71887>>>>>        // if prior item exists, let windows handle this.
71887>>>>>        If (bOK and LItem.iLink>0) Begin
71889>>>>>            Set Windows_Override_State to False
71890>>>>>            Procedure_Return
71891>>>>>        End
71891>>>>>>
71891>>>>>        Forward Send Previous
71893>>>>>    End_Procedure
71894>>>>>    
71894>>>>>    // augmented to determine if an Enter should be handled here or passed to
71894>>>>>    // the container.
71894>>>>>    Procedure Default_action
71896>>>>>        Boolean bPass
71896>>>>>        Get pbEnterPassThrough to bPass
71897>>>>>        If bPass Begin
71899>>>>>            Forward Send Default_action
71901>>>>>        End
71901>>>>>>
71901>>>>>        Else Begin
71902>>>>>            Set Windows_Override_State to False
71903>>>>>        End
71903>>>>>>
71903>>>>>    End_Procedure
71904>>>>>    
71904>>>>>    // augmented to only page if the control is supported and to
71904>>>>>    // autosize as needed
71904>>>>>    Procedure Page Integer iPageObject
71906>>>>>        Boolean bAutoSize bSupported
71906>>>>>        Integer iSize iHeight
71906>>>>>        
71906>>>>>        Get IsControlSupported to bSupported
71907>>>>>        If not bSupported Begin
71909>>>>>            Procedure_Return
71910>>>>>        End
71910>>>>>>
71910>>>>>        
71910>>>>>        Forward Send Page iPageObject
71912>>>>>        
71912>>>>>        If (iPageObject=1) Begin
71914>>>>>            Send Shadow_Display // synch enabled_state
71915>>>>>            Get pbAutoSizeHeight to bAutoSize
71916>>>>>            If bAutoSize Begin
71918>>>>>                Send AutoSizeHeight
71919>>>>>            End
71919>>>>>>
71919>>>>>        End
71919>>>>>>
71919>>>>>    End_Procedure
71920>>>>>    
71920>>>>>    // augmented to handle tooltips
71920>>>>>    Procedure Page_Object Integer iState
71922>>>>>        Handle hWnd
71922>>>>>        Get Window_Handle to hWnd
71923>>>>>        Forward Send Page_Object iState
71925>>>>>        
71925>>>>>        // Handle tooltip support....
71925>>>>>        If (iState = 0) Begin
71927>>>>>            Send RequestDeleteToolTip
71928>>>>>        End
71928>>>>>>
71928>>>>>        Else Begin
71929>>>>>            Send RequestAddToolTip
71930>>>>>        End
71930>>>>>>
71930>>>>>        
71930>>>>>    End_Procedure
71931>>>>>    
71931>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
71931>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
71931>>>>>    // is implemented in a mixin class.
71931>>>>>    Procedure RequestAddToolTip
71933>>>>>        Send AddToolTip
71934>>>>>    End_Procedure
71935>>>>>    
71935>>>>>    
71935>>>>>    // Called by Page_Object. Handles tooltip removal.
71935>>>>>    Procedure RequestDeleteToolTip
71937>>>>>        Send DeleteToolTip
71938>>>>>    End_Procedure
71939>>>>>    
71939>>>>>    // augmented to autosize as needed.
71939>>>>>    Procedure Set Value Integer iItem String sValue
71941>>>>>        Boolean bAutoSize
71941>>>>>        Forward Set Value to sValue
71943>>>>>        // only autosize if paged and we allow autosizing
71943>>>>>        If (Window_Handle(Self)) Begin
71945>>>>>            Get pbAutoSizeHeight to bAutoSize
71946>>>>>            If bAutoSize Begin
71948>>>>>                Send AutoSizeHeight
71949>>>>>            End
71949>>>>>>
71949>>>>>        End
71949>>>>>>
71949>>>>>    End_Procedure
71950>>>>>    
71950>>>>>    // default OnClick behavior shells and executes the URL if one exists. If Id is used
71950>>>>>    // or you wish other things with your url you must augment this.
71950>>>>>    Procedure OnClick Integer iItem String sID String sUrl
71952>>>>>        
71952>>>>>        If (sUrl<>"") Begin
71954>>>>>            Runprogram Shell Background sUrl
71955>>>>>        End
71955>>>>>>
71955>>>>>        
71955>>>>>    End_Procedure
71956>>>>>    
71956>>>>>    // sent if this is run on a pre-XP system. This could be augmented to raise
71956>>>>>    // an error, warning or whatever.
71956>>>>>    Procedure OnControlNotSupported
71958>>>>>    End_Procedure
71959>>>>>    
71959>>>>>    
71959>>>>>    Procedure Enable_Window Integer iState
71961>>>>>        Handle hWnd
71961>>>>>        Get Window_Handle to hWnd
71962>>>>>        If hWnd Begin
71964>>>>>            // note that disabling the control makes no visual change but it does make it
71964>>>>>            // impossible to select the item
71964>>>>>            Move (EnableWindow(hWnd,iState)) to hWnd
71965>>>>>        End
71965>>>>>>
71965>>>>>    End_Procedure
71966>>>>>    
71966>>>>>    // must override because container class does nothing here.
71966>>>>>    Procedure Shadow_Display
71968>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
71969>>>>>    End_Procedure
71970>>>>>    
71970>>>>>End_Class
71971>>>Use cAnimation.pkg
Including file: cAnimation.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cAnimation.pkg)
71971>>>>>Use LanguageText.pkg
71971>>>>>Use cWinControl.pkg
71971>>>>>Use GlobalFunctionsProcedures.pkg
71971>>>>>
71971>>>>>// Styles:
71971>>>>>Define ACS_CENTER      for |CI0001
71971>>>>>Define ACS_TRANSPARENT for |CI0002
71971>>>>>Define ACS_AUTOPLAY    for |CI0004
71971>>>>>Define ACS_TIMER       for |CI0008  // don't use threads... use timers
71971>>>>>
71971>>>>>// Messages:
71971>>>>>Define ACM_OPEN        for (WM_USER+103) //ANSI (WM_USER + 100)
71971>>>>>Define ACM_PLAY        for (WM_USER+101)
71971>>>>>Define ACM_STOP        for (WM_USER+102)
71971>>>>>
71971>>>>>// Notifications:
71971>>>>>Define ACN_START       for 1
71971>>>>>Define ACN_STOP        for 2
71971>>>>>
71971>>>>>Enum_List  // for peAnimation
71971>>>>>    Define aviEmptyRecycle
71971>>>>>    Define aviFileCopy
71971>>>>>    Define aviFileDelete
71971>>>>>    Define aviFileFind
71971>>>>>    Define aviFileMove
71971>>>>>    Define aviFileRecycle
71971>>>>>    Define aviFindComputer
71971>>>>>    Define aviNone
71971>>>>>    Define aviSearch
71971>>>>>End_Enum_List
71971>>>>>
71971>>>>>Register_Function GetAnimationFile Returns String
71971>>>>>
71971>>>>>
71971>>>>>Class cAnimation is a cWinControl
71972>>>>>    Procedure Construct_Object
71974>>>>>        Forward Send Construct_Object
71976>>>>>        
71976>>>>>        Set External_Class_Name "cVdfAnimation" to "SysAnimate32"
71977>>>>>        
71977>>>>>        Property Boolean pbIsOpen     // is the AVI open?
71978>>>>>        
71978>>>>>        Property Boolean private_pbActive       False
71979>>>>>        Property Boolean private_pbAutoSize     True
71980>>>>>        Property Boolean private_pbTransparent  True
71981>>>>>        Property Integer private_peAnimation    aviNone
71982>>>>>        Property Integer private_piRepetitions  0
71983>>>>>        Property String  private_psFileName
71984>>>>>        
71984>>>>>        Set Focus_Mode to NonFocusable
71985>>>>>        Set Color      to clBtnFace
71986>>>>>        Set Skip_State to True
71987>>>>>        
71987>>>>>        Set External_Message WM_NCHITTEST to msg_OnWmNcHitTest
71988>>>>>    End_Procedure
71989>>>>>    
71989>>>>>    Procedure OnWmNcHitTest Longptr wParam Longptr lParam
71991>>>>>        Set Windows_Override_State to True
71992>>>>>        Procedure_Return HTCLIENT //  by default, the control will return HTTRANSPARENT, which would not give us mouse messages
71993>>>>>    End_Procedure
71994>>>>>    
71994>>>>>    Procedure Command Integer wParam Integer lParam
71996>>>>>        Integer eEvent
71996>>>>>        
71996>>>>>        Move (Hi(wParam)) to eEvent
71997>>>>>        If      (eEvent = ACN_START) ;            Send OnStart
72000>>>>>        Else If (eEvent = ACN_STOP) ;            Send OnStop
72004>>>>>    End_Procedure
72005>>>>>    
72005>>>>>    Procedure Page Integer iState
72007>>>>>        Handle hWnd
72007>>>>>        String sFileName
72007>>>>>        
72007>>>>>        Get Window_Handle to hWnd
72008>>>>>        If (hWnd =0 and iState =1) Begin
72010>>>>>            Set Window_Style to ACS_CENTER      (private_pbAutoSize(Self) = False)
72011>>>>>            Set Window_Style to ACS_TRANSPARENT (private_pbTransparent(Self))
72012>>>>>        End
72012>>>>>>
72012>>>>>        Forward Send Page iState
72014>>>>>        
72014>>>>>        Get GetAnimationFile to sFilename
72015>>>>>        If (sFileName <> '') Begin
72017>>>>>            Send DoOpen sFileName
72018>>>>>            If (pbIsOpen(Self) and private_pbActive(Self)) ;                Send DoPlay
72021>>>>>            If (pbIsOpen(Self) =False) ;                Set private_pbActive to False // if we couldn't open the file, we need to ensure the pbActive property is False
72024>>>>>        End
72024>>>>>>
72024>>>>>    End_Procedure
72025>>>>>    
72025>>>>>    
72025>>>>>    Procedure DoOpen String sAvi
72027>>>>>        Boolean bOpenedOk
72027>>>>>        WString sWAvi
72027>>>>>        
72027>>>>>        Move sAvi to sWAvi
72028>>>>>        Get WindowsMessage ACM_OPEN 0 (AddressOf(sWAvi)) to bOpenedOk
72029>>>>>        Set pbIsOpen to bOpenedOk
72030>>>>>        If (bOpenedOk =False) Begin
72032>>>>>            Error DFERR_CANT_OPEN_INPUT_FILE (SFormat(C_$UnableToOpen, sAvi))
72033>>>>>>
72033>>>>>            Set private_pbActive to False
72034>>>>>        End
72034>>>>>>
72034>>>>>    End_Procedure
72035>>>>>    
72035>>>>>    Procedure DoClose
72037>>>>>        Send Windows_Message ACM_OPEN 0 0
72038>>>>>        Set pbIsOpen to False
72039>>>>>        Set private_pbActive to False
72040>>>>>    End_Procedure
72041>>>>>    
72041>>>>>    Procedure DoPlay Integer iFrameStart Integer iFrameEnd
72043>>>>>        Integer icRepetition
72043>>>>>        
72043>>>>>        If (pbIsOpen(Self)= False) ;            Send DoOpen (GetAnimationFile(Self))
72046>>>>>        If (pbIsOpen(Self)) Begin
72048>>>>>            Get piRepetitions to icRepetition
72049>>>>>            If (icRepetition =0) ;                Move -1 to icRepetition // windows wants -1 for continuous
72052>>>>>            If (Num_Arguments = 0) ;                Send Windows_Message ACM_PLAY icRepetition -1
72055>>>>>            Else ;                Send Windows_Message ACM_PLAY icRepetition (iFrameEnd*65536 +iFrameStart)
72057>>>>>        End
72057>>>>>>
72057>>>>>    End_Procedure
72058>>>>>    
72058>>>>>    Procedure DoStop
72060>>>>>        Send Windows_Message ACM_STOP 0 0
72061>>>>>    End_Procedure
72062>>>>>    
72062>>>>>    Procedure Set pbActive Boolean bActive
72064>>>>>        If (Window_Handle(Self)) Begin
72066>>>>>            If (bActive <> private_pbActive(Self)) Begin
72068>>>>>                Set private_pbActive to bActive
72069>>>>>                If bActive ;                    Send DoPlay
72072>>>>>                Else ;                    Send DoStop
72074>>>>>            End
72074>>>>>>
72074>>>>>        End
72074>>>>>>
72074>>>>>        Else ;            Set private_pbActive to bActive
72076>>>>>    End_Procedure
72077>>>>>    Function pbActive Returns Boolean
72079>>>>>        Function_Return (private_pbActive(Self))
72080>>>>>    End_Function
72081>>>>>    
72081>>>>>    Procedure Set pbAutoSize Boolean bAutoSize
72083>>>>>        If (bAutoSize <> private_pbAutoSize(Self)) Begin
72085>>>>>            Set private_pbAutoSize to bAutoSize
72086>>>>>            Send DoRecreateWindow
72087>>>>>        End
72087>>>>>>
72087>>>>>    End_Procedure
72088>>>>>    Function pbAutoSize Returns Boolean
72090>>>>>        Function_Return (private_pbAutoSize(Self))
72091>>>>>    End_Function
72092>>>>>    
72092>>>>>    Procedure Set pbTransparent Boolean bTransparent
72094>>>>>        Set private_pbTransparent to bTransparent
72095>>>>>        Send DoRecreateWindow
72096>>>>>    End_Procedure
72097>>>>>    Function pbTransparent Returns Boolean
72099>>>>>        Function_Return (private_pbTransparent(Self))
72100>>>>>    End_Function
72101>>>>>    
72101>>>>>    Procedure Set peAnimation Integer eAnimation
72103>>>>>        Integer eAnimationOld
72103>>>>>        
72103>>>>>        Get private_peAnimation to eAnimationOld
72104>>>>>        If (eAnimation <> eAnimationOld) Begin
72106>>>>>            Set private_peAnimation to eAnimation
72107>>>>>            If (eAnimation <> aviNone) ;                Set private_psFileName to "" // If a built-in animation is required, reset the psFileName
72110>>>>>            If (eAnimationOld <> aviNone) ;                Send DoClose // close the old animation file
72113>>>>>            Send DoRecreateWindow
72114>>>>>        End
72114>>>>>>
72114>>>>>    End_Procedure
72115>>>>>    Function peAnimation Returns Integer
72117>>>>>        Function_Return (private_peAnimation(Self))
72118>>>>>    End_Function
72119>>>>>    
72119>>>>>    Procedure Set piRepetitions Integer iRepetitions
72121>>>>>        Set private_piRepetitions to iRepetitions
72122>>>>>    End_Procedure
72123>>>>>    Function piRepetitions Returns Integer
72125>>>>>        Function_Return (private_piRepetitions(Self))
72126>>>>>    End_Function
72127>>>>>    
72127>>>>>    Procedure Set psFileName String sFileName
72129>>>>>        If (sFileName <> private_psFileName(Self)) Begin
72131>>>>>            Set private_psFileName to sFileName
72132>>>>>            // If a filename is set, reset the peAnimation property:
72132>>>>>            If (sFileName <>"") ;                Set private_peAnimation to aviNone
72135>>>>>            Send DoRecreateWindow
72136>>>>>        End
72136>>>>>>
72136>>>>>    End_Procedure
72137>>>>>    Function psFileName Returns String
72139>>>>>        Function_Return (private_psFileName(Self))
72140>>>>>    End_Function
72141>>>>>    
72141>>>>>    Function GetAnimationFile Returns String
72143>>>>>        // returns the filename to open. If AnimationMode <> aviNone, this will be Filename,
72143>>>>>        // otherwise it will be the filename of the animation
72143>>>>>        Integer eAnimation
72143>>>>>        String sFileName
72143>>>>>        
72143>>>>>        Get private_peAnimation to eAnimation
72144>>>>>        If      (eAnimation = aviNone) ;            Get private_psFileName         to sFileName
72147>>>>>        Else If (eAnimation = aviFileCopy) ;            Get_File_Path "FileCopy.avi"   to sFileName
72151>>>>>        Else If (eAnimation = aviFileDelete) ;            Get_File_Path "FileDel.avi"    to sFileName
72155>>>>>        Else If (eAnimation = aviFileRecycle) ;            Get_File_Path "FileDelR.avi"   to sFileName
72159>>>>>        Else If (eAnimation = aviFileMove) ;            Get_File_Path "FileMove.avi"   to sFileName
72163>>>>>        Else If (eAnimation = aviEmptyRecycle) ;            Get_File_Path "FileNuke.avi"   to sFileName
72167>>>>>        Else If (eAnimation = aviFindComputer) ;            Get_File_Path "FindComp.avi"   to sFileName
72171>>>>>        Else If (eAnimation = aviFileFind) ;            Get_File_Path "FindFile.avi"   to sFileName
72175>>>>>        Else If (eAnimation = aviSearch) ;            Get_File_Path "Search.avi"     to sFileName
72179>>>>>        
72179>>>>>        Function_Return sFileName
72180>>>>>    End_Function
72181>>>>>    
72181>>>>>    Procedure OnStart
72183>>>>>        // The animation has started playing
72183>>>>>    End_Procedure
72184>>>>>    Procedure OnStop
72186>>>>>        // The animation has stopped playing
72186>>>>>    End_Procedure
72187>>>>>    
72187>>>>>End_Class
72188>>>>>
72188>>>>>
72188>>>Use cSplitButton.pkg
Including file: cSplitButton.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cSplitButton.pkg)
72188>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
72188>>>>>// older versions you will just get a regular button with no split part.
72188>>>>>
72188>>>>>Use Windows.pkg
72188>>>>>
72188>>>>>Class cSplitButton is a Button
72189>>>>>    
72189>>>>>    Procedure Page Integer iPageObject
72191>>>>>        Integer iStyle
72191>>>>>        Boolean bSupported
72191>>>>>        Get IsExControlSupported to bSupported
72192>>>>>        If (iPageObject=1  and bSupported) Begin
72194>>>>>            Get Form_Style iStyle to iStyle
72195>>>>>            Move (iStyle ior BS_SPLITBUTTON) to iStyle
72196>>>>>            Set Form_Style 0 to iStyle
72197>>>>>        End
72197>>>>>>
72197>>>>>        Forward Send Page iPageObject
72199>>>>>    End_Procedure
72200>>>>>    
72200>>>>>    Procedure Notify Longptr wParam Longptr lParam
72202>>>>>        tWinNmHdr Hdr
72202>>>>>        tWinNmHdr Hdr
72202>>>>>        Integer iVoid
72202>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to iVoid
72203>>>>>        If (Hdr.code=BCN_DROPDOWN) Begin
72205>>>>>            Send OnDropDown
72206>>>>>        End
72206>>>>>>
72206>>>>>        Else Begin
72207>>>>>            Forward Send Notify wParam lParam
72209>>>>>        End
72209>>>>>>
72209>>>>>    End_Procedure
72210>>>>>    
72210>>>>>End_Class
72211>>>>>
72211>>>>>
72211>>>Use dfBitmap.pkg
72211>>>Use cTextEdit.pkg
72211>>>
72211>>>Activate_View Activate_oConsultaFile for oConsultaFile
72221>>>>
72221>>>Object oConsultaFile is a dbView
72223>>>    Set Location to 2 4
72224>>>    Set Border_Style to Border_Thick
72225>>>    Set Size to 241 567
72226>>>    Set piMinSize to 228 525
72227>>>       
72227>>>    Object oPathFile is a Form
72229>>>        Set Location to 22 80
72230>>>        Set Size to 13 469
72231>>>        Set Label to "Caminho arquivo:"
72232>>>        Set Enabled_State to False
72233>>>    
72233>>>         //OnChange is called on every changed character
72233>>>        Procedure OnChange
72236>>>            Global_Variable String[] aFiles
72236>>>            
72236>>>            Move "Lucas" to aFiles[0]
72237>>>            Move "Richard" to aFiles[1]
72238>>>            Move "Ricardo" to aFiles[2]
72239>>>            Move "Cris" to aFiles[3]
72240>>>            
72240>>>        End_Procedure
72241>>>        
72241>>>        Send OnChange
72242>>>    End_Object
72243>>>    
72243>>>    Object oCustomerGrid is a cCJGrid
72245>>>        Set Size to 165 533
72246>>>        Set Location to 54 17
72247>>>        Set peAnchors to anAll
72248>>>        Set pbReadOnly to True
72249>>>        Set pbSelectionEnable to True      
72250>>>
72250>>>        Object oFileSearch is a cCJGridColumn
72252>>>            Set piWidth to 889
72253>>>            Set psCaption to "Arquivos encontrados:"
72254>>>        End_Object
72255>>>                 
72255>>>        Procedure LoadData 
72258>>>            Handle hoDataSource
72258>>>            tDataSourceRow[] TheData
72258>>>            tDataSourceRow[] TheData
72259>>>            Boolean bFound
72259>>>            Integer iIndex    
72259>>>            Integer iRows iFile
72259>>>            
72259>>>            Get phoDataSource to hoDataSource
72260>>>            
72260>>>//            Get the datasource indexes of the various columns
72260>>>//            Get piColumnId of oCustomer_Customer_Number to iNum
72260>>>
72260>>>//            Load All data into the datasource array
72260>>>//            Clear Customer
72260>>>//            Find ge Customer by 1
72260>>>
72260>>>//            Move (Found) to bFound
72260>>>//            While (bFound)
72260>>>//                Move Customer.Customer_Number to TheData[iRows].sValue[iFile] 
72260>>>//                Move (Found) to bFound
72260>>>//                Increment iRows
72260>>>//            Loop
72260>>>
72260>>>            For iIndex from 0 to (SizeOfArray(aFiles) - 1)
72266>>>>
72266>>>                Move aFiles[iIndex] to TheData[iRows].sValue[iFile]
72267>>>                Increment iRows
72268>>>            Loop
72269>>>>
72269>>>
72269>>>            // Initialize Grid with new data
72269>>>            Send InitializeData TheData
72270>>>            Send MovetoFirstRow
72271>>>        End_Procedure
72272>>>    
72272>>>        Procedure Activating
72275>>>            Forward Send Activating
72277>>>            Send LoadData
72278>>>        End_Procedure
72279>>>    
72279>>>    End_Object
72280>>>
72280>>>End_Object
72281>
72281>        Procedure Activate_About
72284>            Send DoAbout "" "" "" "" ""
72285>        End_Procedure
72286>
72286>    End_Object
72287>
72287>End_Object
72288>
72288>Start_UI
72289>
Summary
Memory Available: 505348096
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 42242
Total Resources: 0
Total Commands : 72288
Total Windows  : 0
Total Pages    : 0
Static Data    : 430429
Message area   : 509034
Total Blocks   : 26196
