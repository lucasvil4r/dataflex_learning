Compiling Program: C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\ProjectTeste.src
Memory Available: 659226624
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 20.0\Pkg\dfallent.pkd)
68480>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardCommandBarSystem.pkg)
68480>>>// these are all the packages used in a standard MDI menubar/toolbar system
68480>>>
68480>>>Use cCJCommandBarSystem.pkg
68480>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardMenuItemClasses.pkg)
68480>>>>>Use Dfpanel.pkg
68480>>>>>Use cCJCommandBarSystem.pkg
68480>>>>>Use LanguageText.pkg
68480>>>>>
68480>>>>>
68480>>>>>Class cCJUndoMenuItem is a cCJMenuItem
68481>>>>>    
68481>>>>>    Procedure Construct_Object
68483>>>>>        Forward Send Construct_Object
68485>>>>>        Set psCaption   to C_$CaptionUndo
68486>>>>>        Set psToolTip to C_$ToolTipUndo
68487>>>>>        Set psDescription to C_$DescUndo
68488>>>>>        Set psImage to "ActionUndo.ico"
68489>>>>>        Set pbActiveUpdate to True
68490>>>>>        Set psCategory to C_$CategoryEdit
68491>>>>>        Set psShortcut to C_$Key_Ctrl_Z
68492>>>>>    End_Procedure
68493>>>>>    
68493>>>>>    Procedure OnExecute Variant vCommandBarControl
68495>>>>>        Send Undo of (focus(Self))
68496>>>>>    End_Procedure
68497>>>>>    
68497>>>>>    Function IsEnabled Returns Boolean
68499>>>>>        Boolean bEnabled
68499>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
68500>>>>>        Function_Return bEnabled
68501>>>>>    End_Function
68502>>>>>    
68502>>>>>End_Class
68503>>>>>
68503>>>>>
68503>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
68504>>>>>    
68504>>>>>    Procedure Construct_Object
68506>>>>>        Forward Send Construct_Object
68508>>>>>        Set psCaption   to C_$CaptionDelete
68509>>>>>        Set psToolTip to C_$ToolTipDelete
68510>>>>>        Set psDescription to C_$DescDelete
68511>>>>>        Set psImage to "actionDelete.ico"
68512>>>>>        Set psShortcut to C_$Key_Delete
68513>>>>>        Set pbActiveUpdate to True
68514>>>>>        Set psCategory to C_$CategoryEdit
68515>>>>>    End_Procedure
68516>>>>>    
68516>>>>>    
68516>>>>>    Procedure OnExecute Variant vCommandBarControl
68518>>>>>        Send Delete of (focus(Self))
68519>>>>>    End_Procedure
68520>>>>>    
68520>>>>>    Function IsEnabled Returns Boolean
68522>>>>>        Boolean bEnabled
68522>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
68523>>>>>        Function_Return bEnabled
68524>>>>>    End_Function
68525>>>>>    
68525>>>>>End_Class
68526>>>>>
68526>>>>>
68526>>>>>Class cCJCutMenuItem is a cCJMenuItem
68527>>>>>    
68527>>>>>    Procedure Construct_Object
68529>>>>>        Forward Send Construct_Object
68531>>>>>        Set psCaption   to C_$CaptionCut
68532>>>>>        Set psToolTip to C_$TooltipCut
68533>>>>>        Set psDescription to C_$DescCut
68534>>>>>        Set psImage to "actionCut.ico"
68535>>>>>        Set psShortcut to C_$Key_Ctrl_X
68536>>>>>        Set pbActiveUpdate to True
68537>>>>>        Set psCategory to C_$CategoryEdit
68538>>>>>    End_Procedure
68539>>>>>    
68539>>>>>    
68539>>>>>    Procedure OnExecute Variant vCommandBarControl
68541>>>>>        Send Cut of (focus(Self))
68542>>>>>    End_Procedure
68543>>>>>    
68543>>>>>    Function IsEnabled Returns Boolean
68545>>>>>        Boolean bEnabled
68545>>>>>        Get CanCut of (Focus(Self)) to bEnabled
68546>>>>>        Function_Return bEnabled
68547>>>>>    End_Function
68548>>>>>    
68548>>>>>End_Class
68549>>>>>
68549>>>>>
68549>>>>>Class cCJCopyMenuItem is a cCJMenuItem
68550>>>>>    
68550>>>>>    Procedure Construct_Object
68552>>>>>        Forward Send Construct_Object
68554>>>>>        Set psCaption   to C_$CaptionCopy
68555>>>>>        Set psToolTip to C_$ToolTipCopy
68556>>>>>        Set psDescription to C_$DescCopy
68557>>>>>        Set psImage to "actionCopy.ico"
68558>>>>>        Set psShortcut to C_$Key_Ctrl_C
68559>>>>>        Set pbActiveUpdate to True
68560>>>>>        Set psCategory to C_$CategoryEdit
68561>>>>>    End_Procedure
68562>>>>>    
68562>>>>>    
68562>>>>>    Procedure OnExecute Variant vCommandBarControl
68564>>>>>        Send Copy of (focus(Self))
68565>>>>>    End_Procedure
68566>>>>>    
68566>>>>>    Function IsEnabled Returns Boolean
68568>>>>>        Boolean bEnabled
68568>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
68569>>>>>        Function_Return bEnabled
68570>>>>>    End_Function
68571>>>>>    
68571>>>>>End_Class
68572>>>>>
68572>>>>>
68572>>>>>Class cCJPasteMenuItem is a cCJMenuItem
68573>>>>>    
68573>>>>>    Procedure Construct_Object
68575>>>>>        Forward Send Construct_Object
68577>>>>>        Set psCaption   to C_$CaptionPaste
68578>>>>>        Set psToolTip to C_$ToolTipPaste
68579>>>>>        Set psDescription to C_$DescPaste
68580>>>>>        Set psImage to "actionPaste.ico"
68581>>>>>        Set pbActiveUpdate to True
68582>>>>>        Set psShortcut to C_$Key_Ctrl_V
68583>>>>>        Set psCategory to C_$CategoryEdit
68584>>>>>    End_Procedure
68585>>>>>    
68585>>>>>    
68585>>>>>    Procedure OnExecute Variant vCommandBarControl
68587>>>>>        Send Paste of (focus(Self))
68588>>>>>    End_Procedure
68589>>>>>    
68589>>>>>    Function IsEnabled Returns Boolean
68591>>>>>        Boolean bEnabled
68591>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
68592>>>>>        Function_Return bEnabled
68593>>>>>    End_Function
68594>>>>>    
68594>>>>>End_Class
68595>>>>>
68595>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
68596>>>>>    
68596>>>>>    Procedure Construct_Object
68598>>>>>        Forward Send Construct_Object
68600>>>>>        Set psCaption   to C_$CaptionSelectAll
68601>>>>>        Set psToolTip to C_$ToolTipSelectAll
68602>>>>>        Set psDescription to C_$DescSelectAll
68603>>>>>        Set pbActiveUpdate to True
68604>>>>>        Set psShortcut to C_$Key_Ctrl_A
68605>>>>>        Set psCategory to C_$CategoryEdit
68606>>>>>    End_Procedure
68607>>>>>    
68607>>>>>    
68607>>>>>    Procedure OnExecute Variant vCommandBarControl
68609>>>>>        Send Select_All of (focus(Self))
68610>>>>>    End_Procedure
68611>>>>>    
68611>>>>>    Function IsEnabled Returns Boolean
68613>>>>>        Boolean bEnabled
68613>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
68614>>>>>        Function_Return bEnabled
68615>>>>>    End_Function
68616>>>>>    
68616>>>>>End_Class
68617>>>>>
68617>>>>>
68617>>>>>Class cCJExitMenuItem is a cCJMenuItem
68618>>>>>    
68618>>>>>    Procedure Construct_Object
68620>>>>>        Forward Send Construct_Object
68622>>>>>        Set psCaption to C_$CaptionExit
68623>>>>>        Set psToolTip to C_$ToolTipExit
68624>>>>>        Set psDescription to C_$ToolTipExit
68625>>>>>        Set psShortcut to C_$Key_Alt_F4
68626>>>>>        Set psCategory to C_$CategoryFile
68627>>>>>    End_Procedure
68628>>>>>    
68628>>>>>    Procedure OnExecute Variant vCommandBarControl
68630>>>>>        Send Exit_Application of Desktop
68631>>>>>    End_Procedure
68632>>>>>    
68632>>>>>End_Class
68633>>>>>
68633>>>>>Class cCJHelpMenuItem is a cCJMenuItem
68634>>>>>    
68634>>>>>    Procedure Construct_Object
68636>>>>>        Forward Send Construct_Object
68638>>>>>        Set psCaption to C_$CaptionHelp
68639>>>>>        Set psDescription to C_$ToolTipHelp
68640>>>>>        Set psToolTip to C_$DescHelp
68641>>>>>        Set psImage to "ActionHelp.ico"
68642>>>>>        Set psShortcut to "F1"
68643>>>>>        Set psCategory to C_$CategoryHelp
68644>>>>>    End_Procedure
68645>>>>>    
68645>>>>>    Procedure OnExecute Variant vCommandBarControl
68647>>>>>        Send Help of (Focus(Self))
68648>>>>>    End_Procedure
68649>>>>>    
68649>>>>>End_Class
68650>>>>>
68650>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
68651>>>>>    
68651>>>>>    Procedure Construct_Object
68653>>>>>        Forward Send Construct_Object
68655>>>>>        Set psCaption to C_$CaptionAddStatusbar
68656>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
68657>>>>>        Set psDescription to  C_$DescAddStatusbar
68658>>>>>        Set psCategory to C_$CategoryWindow
68659>>>>>    End_Procedure
68660>>>>>    
68660>>>>>    Procedure OnExecute Variant vCommandBarControl
68662>>>>>        Handle hoCommandBars hoClientArea
68662>>>>>        Get CommandBarSystemObject to hoCommandBars
68663>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68664>>>>>        If hoClientArea Begin
68666>>>>>            // the clientarea's parent panel has message
68666>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
68667>>>>>        End
68667>>>>>>
68667>>>>>    End_Procedure
68668>>>>>    
68668>>>>>    Function IsChecked Returns Boolean
68670>>>>>        Boolean bOn
68670>>>>>        Handle hoCommandBars hoClientArea
68670>>>>>        Get CommandBarSystemObject to hoCommandBars
68671>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68672>>>>>        If hoClientArea Begin
68674>>>>>            // the clientarea's parent panel has message
68674>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
68675>>>>>        End
68675>>>>>>
68675>>>>>        Function_Return bOn
68676>>>>>    End_Function
68677>>>>>End_Class
68678>>>>>
68678>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
68679>>>>>    
68679>>>>>    Procedure Construct_Object
68681>>>>>        Forward Send Construct_Object
68683>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
68684>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
68685>>>>>        Set psDescription to C_$DescAutoArrangeIcons
68686>>>>>        Set psCategory to C_$CategoryWindow
68687>>>>>    End_Procedure
68688>>>>>    
68688>>>>>    Procedure OnExecute Variant vCommandBarControl
68690>>>>>        Handle hoCommandBars hoClientArea
68690>>>>>        Get CommandBarSystemObject to hoCommandBars
68691>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68692>>>>>        If hoClientArea Begin
68694>>>>>            // the clientarea's parent panel has message
68694>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
68695>>>>>        End
68695>>>>>>
68695>>>>>    End_Procedure
68696>>>>>    
68696>>>>>    Function IsChecked Returns Boolean
68698>>>>>        Boolean bOn
68698>>>>>        Handle hoCommandBars hoClientArea
68698>>>>>        Get CommandBarSystemObject to hoCommandBars
68699>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68700>>>>>        If hoClientArea Begin
68702>>>>>            // the clientarea's parent panel has message
68702>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
68703>>>>>        End
68703>>>>>>
68703>>>>>        Function_Return bOn
68704>>>>>    End_Function
68705>>>>>End_Class
68706>>>>>
68706>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
68707>>>>>    
68707>>>>>    Procedure Construct_Object
68709>>>>>        Forward Send Construct_Object
68711>>>>>        Set psCaption to C_$CaptionRestoreMenus
68712>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
68713>>>>>        Set psDescription to C_$DescRestoreMenus
68714>>>>>        Set psCategory to C_$CategoryWindow
68715>>>>>    End_Procedure
68716>>>>>    
68716>>>>>    Procedure OnExecute Variant vCommandBarControl
68718>>>>>        Handle hoCommandBars
68718>>>>>        Get CommandBarSystemObject to hoCommandBars
68719>>>>>        Send RestoreLayout of hoCommandBars
68720>>>>>    End_Procedure
68721>>>>>    
68721>>>>>End_Class
68722>>>>>
68722>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
68723>>>>>    
68723>>>>>    Procedure Construct_Object
68725>>>>>        Forward Send Construct_Object
68727>>>>>        Set psCaption to C_$CaptionCascade
68728>>>>>        Set psToolTip to C_$ToolTipCascade
68729>>>>>        Set psDescription to  C_$DescCascade
68730>>>>>        Set psImage to "ActionCascade.ico"
68731>>>>>        Set psCategory to C_$CategoryWindow
68732>>>>>    End_Procedure
68733>>>>>    
68733>>>>>    Procedure OnExecute Variant vCommandBarControl
68735>>>>>        Handle hoCommandBars hoClientArea
68735>>>>>        Get CommandBarSystemObject to hoCommandBars
68736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68737>>>>>        If hoClientArea Begin
68739>>>>>            Send Cascade_Windows of hoClientArea
68740>>>>>        End
68740>>>>>>
68740>>>>>    End_Procedure
68741>>>>>End_Class
68742>>>>>
68742>>>>>Class cCJTileHorizontally is a cCJMenuItem
68743>>>>>    
68743>>>>>    Procedure Construct_Object
68745>>>>>        Forward Send Construct_Object
68747>>>>>        Set psCaption to C_$CaptionTileHorizontally
68748>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
68749>>>>>        Set psDescription to  C_$DescTileHorizontally
68750>>>>>        Set psImage to "ActionTileHorizontally.ico"
68751>>>>>        Set psCategory to C_$CategoryWindow
68752>>>>>    End_Procedure
68753>>>>>    
68753>>>>>    Procedure OnExecute Variant vCommandBarControl
68755>>>>>        Handle hoCommandBars hoClientArea
68755>>>>>        Get CommandBarSystemObject to hoCommandBars
68756>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68757>>>>>        If hoClientArea Begin
68759>>>>>            Send Tile_Windows_Horizontal of hoClientArea
68760>>>>>        End
68760>>>>>>
68760>>>>>    End_Procedure
68761>>>>>End_Class
68762>>>>>
68762>>>>>Class cCJTileVertically is a cCJMenuItem
68763>>>>>    
68763>>>>>    Procedure Construct_Object
68765>>>>>        Forward Send Construct_Object
68767>>>>>        Set psCaption to C_$CaptionTileVertically
68768>>>>>        Set psToolTip to C_$ToolTipTileVertically
68769>>>>>        Set psDescription to  C_$DescTileVertically
68770>>>>>        Set psImage to "ActionTileVertically.ico"
68771>>>>>        Set psCategory to C_$CategoryWindow
68772>>>>>    End_Procedure
68773>>>>>    
68773>>>>>    Procedure OnExecute Variant vCommandBarControl
68775>>>>>        Handle hoCommandBars hoClientArea
68775>>>>>        Get CommandBarSystemObject to hoCommandBars
68776>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68777>>>>>        If hoClientArea Begin
68779>>>>>            Send Tile_Windows_Vertical of hoClientArea
68780>>>>>        End
68780>>>>>>
68780>>>>>    End_Procedure
68781>>>>>End_Class
68782>>>>>
68782>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
68783>>>>>    
68783>>>>>    Procedure Construct_Object
68785>>>>>        Forward Send Construct_Object
68787>>>>>        Set psCaption to C_$CaptionMinimizeWindows
68788>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
68789>>>>>        Set psDescription to  C_$DescMinimizeWindows
68790>>>>>        Set psCategory to C_$CategoryWindow
68791>>>>>    End_Procedure
68792>>>>>    
68792>>>>>    Procedure OnExecute Variant vCommandBarControl
68794>>>>>        Handle hoCommandBars hoClientArea
68794>>>>>        Get CommandBarSystemObject to hoCommandBars
68795>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68796>>>>>        If hoClientArea Begin
68798>>>>>            // the clientarea's parent panel has message
68798>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
68799>>>>>        End
68799>>>>>>
68799>>>>>    End_Procedure
68800>>>>>End_Class
68801>>>>>
68801>>>>>
68801>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
68802>>>>>    
68802>>>>>    Procedure Construct_Object
68804>>>>>        Forward Send Construct_Object
68806>>>>>        Set psCaption to C_$CaptionRestoreWindows
68807>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
68808>>>>>        Set psDescription to  C_$DescRestoreWindows
68809>>>>>        Set psCategory to C_$CategoryWindow
68810>>>>>    End_Procedure
68811>>>>>    
68811>>>>>    Procedure OnExecute Variant vCommandBarControl
68813>>>>>        Handle hoCommandBars hoClientArea
68813>>>>>        Get CommandBarSystemObject to hoCommandBars
68814>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68815>>>>>        If hoClientArea Begin
68817>>>>>            // the clientarea's parent panel has message
68817>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
68818>>>>>        End
68818>>>>>>
68818>>>>>    End_Procedure
68819>>>>>End_Class
68820>>>>>
68820>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
68821>>>>>    
68821>>>>>    Procedure Construct_Object
68823>>>>>        Forward Send Construct_Object
68825>>>>>        Set psCaption to C_$CaptionArrangeIcons
68826>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
68827>>>>>        Set psDescription to  C_$DescArrangeIcons
68828>>>>>        Set psCategory to C_$CategoryWindow
68829>>>>>    End_Procedure
68830>>>>>    
68830>>>>>    Procedure OnExecute Variant vCommandBarControl
68832>>>>>        Handle hoCommandBars hoClientArea
68832>>>>>        Get CommandBarSystemObject to hoCommandBars
68833>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68834>>>>>        If hoClientArea Begin
68836>>>>>            Send Arrange_Icons of hoClientArea
68837>>>>>        End
68837>>>>>>
68837>>>>>    End_Procedure
68838>>>>>    
68838>>>>>End_Class
68839>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJAboutMenuItem.pkg)
68839>>>>>Use cCJCommandBarSystem.pkg
68839>>>>>Use LanguageText.pkg
68839>>>>>
68839>>>>>// It is expected that if you use this class that you provide an about object that is
68839>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
68839>>>>>// because you may wish to create your own custom about package.
68839>>>>>
68839>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
68840>>>>>
68840>>>>>    Procedure Construct_Object
68842>>>>>        Forward Send Construct_Object
68844>>>>>        Set psCaption to C_$CaptionAbout
68845>>>>>        Set psDescription to C_$ToolTipAbout
68846>>>>>        Set psToolTip to C_$DescAbout
68847>>>>>        Set psImage to "ActionAbout.ico"
68848>>>>>        Set psCategory to C_$CategoryHelp
68849>>>>>    End_Procedure
68850>>>>>    
68850>>>>>    Procedure OnExecute Variant vCommandBarControl
68852>>>>>        Handle hoCommandBars hoClientArea
68852>>>>>        Get CommandBarSystemObject to hoCommandBars
68853>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68854>>>>>        If hoClientArea Begin
68856>>>>>            Send Activate_About of hoClientArea
68857>>>>>        End
68857>>>>>>
68857>>>>>    End_Procedure
68858>>>>>
68858>>>>>End_Class
68859>>>>>
68859>>>>>
68859>>>Use cCJDeoMenuItemClasses.pkg
68859>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJMDIWindowsMenuItem.pkg)
68859>>>>>Use cCJCommandBarSystem.pkg
68859>>>>>
68859>>>>>Register_Function Client_ID Returns Integer
68859>>>>>
68859>>>>>// only used by cCJMDIWIndowsMenuItem
68859>>>>>Class cCJMDIWindowItem is a cCJMenuItem
68860>>>>>    
68860>>>>>    Procedure Construct_Object
68862>>>>>        Forward Send Construct_Object
68864>>>>>        Property Handle phWindow 0 // object id of view
68865>>>>>        Set pbControlFlagNoMovable to True
68866>>>>>        Set pbActiveUpdate to True
68867>>>>>    End_Procedure
68868>>>>>    
68868>>>>>    Procedure OnExecute Variant vCommandBarControl
68870>>>>>        Handle hWindow
68870>>>>>        Get phWindow to hWindow
68871>>>>>        Send Activate_View of hWindow
68872>>>>>    End_Procedure
68873>>>>>    
68873>>>>>End_Class
68874>>>>>
68874>>>>>
68874>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
68875>>>>>    
68875>>>>>    Procedure Construct_Object
68877>>>>>        Forward Send Construct_Object
68879>>>>>        Property Handle[] phArrayOfWindows
68880>>>>>        Set peControlType to xtpControlPopup
68881>>>>>        Set psCategory to C_$CategoryWindow
68882>>>>>    End_Procedure
68883>>>>>    
68883>>>>>    // This adds MDI windows to the existing menu items.
68883>>>>>    // This removes any existing windows menus and always adds a new set to the end
68883>>>>>    
68883>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
68885>>>>>        Handle  hClientArea hView
68885>>>>>        String  sLabel
68885>>>>>        Integer i iWindows
68885>>>>>        Handle[] hArrayOfWindows
68886>>>>>        Variant vItem
68886>>>>>        
68886>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
68886>>>>>        // also assume that destroying an action removes all menu instances of that action
68886>>>>>        Get phArrayOfWindows to hArrayOfWindows
68887>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
68888>>>>>        For i from 0 to (iWindows-1)
68894>>>>>>
68894>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
68895>>>>>        Loop
68896>>>>>>
68896>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
68897>>>>>        
68897>>>>>        // Add all views to this menu. Create the action and add the item
68897>>>>>        Move 0 to i
68898>>>>>        Get Client_Id to hClientArea // object id of client area
68899>>>>>        If (hClientArea > 0) Begin
68901>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
68902>>>>>            While (hView <> 0)
68906>>>>>                If (Active_State(hView)) Begin
68908>>>>>                    // create the action
68908>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
68909>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
68910>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
68911>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
68912>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
68914>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
68915>>>>>                    End
68915>>>>>>
68915>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
68916>>>>>                    If (i=0) Begin
68918>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
68919>>>>>                    End
68919>>>>>>
68919>>>>>                    // Create a menu item for this action
68919>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
68920>>>>>                    Increment i
68921>>>>>                End
68921>>>>>>
68921>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
68922>>>>>            Loop
68923>>>>>>
68923>>>>>        End
68923>>>>>>
68923>>>>>        
68923>>>>>        Set phArrayOfWindows to hArrayOfWindows
68924>>>>>        
68924>>>>>    End_Procedure
68925>>>>>    
68925>>>>>End_Class
68926>
68926>Object oHtmlHelp is a cHtmlHelp
68928>End_Object
68929>
68929>Object oApplication is a cApplication
68931>    Set peHelpType to htHtmlHelp
68932>
68932>    Object oConnection is a cConnection
68934>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\LoginEncryption.pkg)
68934>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLoginEncryption.pkg)
68934>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCryptographerEx.pkg)
68934>>>>>>>Use VdfBase.pkg
68934>>>>>>>
68934>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.0\Pkg\CryptographerConstants.pkg)
68934>>>>>>>>>//   Author  : Ulbe Stellema
68934>>>>>>>>>// Algorithm classes
68934>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
68934>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
68934>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
68934>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
68934>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
68934>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
68934>>>>>>>>>
68934>>>>>>>>>// Algorithm types
68934>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
68934>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
68934>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
68934>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
68934>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
68934>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
68934>>>>>>>>>
68934>>>>>>>>>// Generic sub-ids
68934>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
68934>>>>>>>>>
68934>>>>>>>>>// RSA sub-ids
68934>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
68934>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
68934>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
68934>>>>>>>>>
68934>>>>>>>>>// DSS sub-ids
68934>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
68934>>>>>>>>>
68934>>>>>>>>>// DES sub_ids
68934>>>>>>>>>Define ALG_SID_DES                      for 1
68934>>>>>>>>>Define ALG_SID_3DES                     for 3
68934>>>>>>>>>Define ALG_SID_DESX                     for 4
68934>>>>>>>>>Define ALG_SID_IDEA                     for 5
68934>>>>>>>>>Define ALG_SID_CAST                     for 6
68934>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
68934>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
68934>>>>>>>>>Define ALG_SID_3DES_112                 for 9
68934>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
68934>>>>>>>>>Define ALG_SID_RC5                      for 13
68934>>>>>>>>>Define ALG_SID_AES_128                  for 14
68934>>>>>>>>>Define ALG_SID_AES_192                  for 15
68934>>>>>>>>>Define ALG_SID_AES_256                  for 16
68934>>>>>>>>>Define ALG_SID_AES                      for 17
68934>>>>>>>>>
68934>>>>>>>>>// Fortezza sub-ids
68934>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
68934>>>>>>>>>Define ALG_SID_TEK                      for 11
68934>>>>>>>>>
68934>>>>>>>>>// RC2 sub-ids
68934>>>>>>>>>Define ALG_SID_RC2                      for 2
68934>>>>>>>>>
68934>>>>>>>>>// Stream cipher sub-ids
68934>>>>>>>>>Define ALG_SID_RC4                      for 1
68934>>>>>>>>>Define ALG_SID_SEAL                     for 2
68934>>>>>>>>>
68934>>>>>>>>>// Diffie-Hellman sub-ids
68934>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
68934>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
68934>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
68934>>>>>>>>>Define ALG_SID_KEA                      for 4
68934>>>>>>>>>
68934>>>>>>>>>// Hash sub ids
68934>>>>>>>>>Define ALG_SID_MD2                      for 1
68934>>>>>>>>>Define ALG_SID_MD4                      for 2
68934>>>>>>>>>Define ALG_SID_MD5                      for 3
68934>>>>>>>>>Define ALG_SID_SHA                      for 4
68934>>>>>>>>>Define ALG_SID_SHA1                     for 4
68934>>>>>>>>>Define ALG_SID_MAC                      for 5
68934>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
68934>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
68934>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
68934>>>>>>>>>Define ALG_SID_HMAC                     for 9
68934>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
68934>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
68934>>>>>>>>>Define ALG_SID_SHA_256                  for 12
68934>>>>>>>>>Define ALG_SID_SHA_384                  for 13
68934>>>>>>>>>Define ALG_SID_SHA_512                  for 14
68934>>>>>>>>>
68934>>>>>>>>>// secure channel sub ids
68934>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
68934>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
68934>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
68934>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
68934>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
68934>>>>>>>>>
68934>>>>>>>>>// algorithm identifier definitions
68934>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
68934>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
68934>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
68934>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
68934>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
68934>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
68934>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
68934>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
68934>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
68934>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
68934>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
68934>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
68934>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
68934>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
68934>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
68934>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
68934>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
68934>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
68934>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
68934>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
68934>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
68934>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
68934>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
68934>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
68934>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
68934>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
68934>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
68934>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
68934>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
68934>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
68934>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
68934>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
68934>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
68934>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
68934>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
68934>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
68934>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
68934>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
68934>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
68934>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
68934>>>>>>>>>
68934>>>>>>>>>// Providers
68934>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
68934>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
68934>>>>>>>>>
68934>>>>>>>>>// dwFlags definitions for CryptAcquireContext
68934>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
68934>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
68934>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
68934>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
68934>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
68934>>>>>>>>>
68934>>>>>>>>>// dwFlag definitions for CryptGenKey
68934>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
68934>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
68934>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
68934>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
68934>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
68934>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
68934>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
68934>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
68934>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
68934>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
68934>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
68934>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
68934>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
68934>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
68934>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
68934>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
68934>>>>>>>>>
68934>>>>>>>>>// Provider types
68934>>>>>>>>>Define PROV_RSA_FULL                    for 1
68934>>>>>>>>>Define PROV_RSA_SIG                     for 2
68934>>>>>>>>>Define PROV_DSS                         for 3
68934>>>>>>>>>Define PROV_FORTEZZA                    for 4
68934>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
68934>>>>>>>>>Define PROV_SSL                         for 6
68934>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
68934>>>>>>>>>Define PROV_DSS_DH                      for 13
68934>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
68934>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
68934>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
68934>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
68934>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
68934>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
68934>>>>>>>>>Define PROV_RNG                         for 21
68934>>>>>>>>>Define PROV_INTEL_SEC                   for 22
68934>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
68934>>>>>>>>>Define PROV_RSA_AES                     for 24
68934>>>>>>>>>
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
68934>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
68934>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
68934>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
68934>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
68934>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetKeyParam
68934>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
68934>>>>>>>>>Define KP_SALT                          for 2       // Salt value
68934>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
68934>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
68934>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
68934>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
68934>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
68934>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
68934>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
68934>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
68934>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
68934>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
68934>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
68934>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
68934>>>>>>>>>Define KP_Y                             for 15      // Y value
68934>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
68934>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
68934>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
68934>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
68934>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
68934>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
68934>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
68934>>>>>>>>>Define KP_RP                            for 23
68934>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
68934>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
68934>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
68934>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
68934>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
68934>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
68934>>>>>>>>>Define KP_KEYVAL                        for 30
68934>>>>>>>>>Define KP_ADMIN_PIN                     for 31
68934>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
68934>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
68934>>>>>>>>>Define KP_PREHASH                       for 34
68934>>>>>>>>>Define KP_ROUNDS                        for 35
68934>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
68934>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
68934>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
68934>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
68934>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
68934>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
68934>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetHashParam
68934>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
68934>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
68934>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
68934>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
68934>>>>>>>>>
68934>>>>>>>>>// key BLOB types
68934>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
68934>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
68934>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
68934>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
68934>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
68934>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
68934>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
68934>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
68934>>>>>>>>>
68934>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
68934>>>>>>>>>
68934>>>>>>>>>// KP_PADDING
68934>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
68934>>>>>>>>>Define RANDOM_PADDING                   for 2
68934>>>>>>>>>Define ZERO_PADDING                     for 3
68934>>>>>>>>>
68934>>>>>>>>>//  Structure cryptimportkey
68934>>>>>>>>>Struct PUBLICKEYSTRUC
68934>>>>>>>>>    UChar    bType
68934>>>>>>>>>    UChar    bVersion
68934>>>>>>>>>    UShort   reserved
68934>>>>>>>>>    UInteger aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct tPLAINTEXTKEYBLOB
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    UInteger       dwKeySize
68934>>>>>>>>>//    UChar[]        rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
68934>>>>>>>>>Struct HMAC_INFO
68934>>>>>>>>>    UInteger HashAlgid
68934>>>>>>>>>    Pointer pbInnerString
68934>>>>>>>>>    DWord cbInnerString
68934>>>>>>>>>    Pointer pbOuterString
68934>>>>>>>>>    DWord cbOuterString
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct BLOBHEADER
68934>>>>>>>>>    UChar   bType
68934>>>>>>>>>    UChar   bVersion
68934>>>>>>>>>    Short   reserved
68934>>>>>>>>>    Integer aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct CryptoBlob
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    Integer     cbKeySize
68934>>>>>>>>>    UChar[32]   rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
68934>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68935>>>>>>>>>
68935>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
68935>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68937>>>>>>>>>    
68937>>>>>>>>>    Boolean bResult
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>
68937>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
68938>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
68939>>>>>>>>>    
68939>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
68940>>>>>>>>>
68940>>>>>>>>>    Function_Return bResult
68941>>>>>>>>>End_Function
68942>>>>>>>>>
68942>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
68943>>>>>>>>>
68943>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
68944>>>>>>>>>
68944>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
68945>>>>>>>>>
68945>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
68946>>>>>>>>>
68946>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68947>>>>>>>>>
68947>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
68948>>>>>>>>>
68948>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
68949>>>>>>>>>
68949>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68950>>>>>>>>>
68950>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
68951>>>>>>>>>    
68951>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
68952>>>>>>>>>
68952>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
68953>>>>>>>>>
68953>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68954>>>>>>>>>
68954>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
68955>>>>>>>>>    
68955>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
68956>>>>>>>>>    
68956>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68957>>>>>>>>>    
68957>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68958>>>>>>>
68958>>>>>>>Class cCryptographerEx is a cObject
68959>>>>>>>    
68959>>>>>>>    Procedure Construct_Object
68961>>>>>>>        Forward Send Construct_Object
68963>>>>>>>        
68963>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
68964>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
68965>>>>>>>        Property Integer    piCipher    CALG_RC4
68966>>>>>>>        Property Integer    piHash      CALG_MD5
68967>>>>>>>        
68967>>>>>>>        // Private properties
68967>>>>>>>        Property Handle     Private_phProv
68968>>>>>>>        
68968>>>>>>>        // Block cipher properties
68968>>>>>>>        Property UChar[]    paKey
68969>>>>>>>        Property UChar[]    paIV
68970>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
68971>>>>>>>        Property Integer    piKeyType       CALG_AES_256
68972>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
68973>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
68974>>>>>>>        Property Integer    piBlockSize     16
68975>>>>>>>    End_Procedure
68976>>>>>>>    
68976>>>>>>>    
68976>>>>>>>    // Acquire key container handle
68976>>>>>>>    Function AcquireContext Returns Handle
68978>>>>>>>        Integer iProvider
68978>>>>>>>        WString wProvider
68978>>>>>>>        Handle hProv
68978>>>>>>>        Boolean bOk
68978>>>>>>>        Pointer pProv
68978>>>>>>>        
68978>>>>>>>        Move 0 to hProv
68979>>>>>>>        Get piProvider to iProvider
68980>>>>>>>        Get psProvider to wProvider
68981>>>>>>>        
68981>>>>>>>        //  Determine address to be passed as provider
68981>>>>>>>        If (Trim(wProvider) <> "") Begin
68983>>>>>>>            Move (AddressOf(wProvider)) to pProv
68984>>>>>>>        End
68984>>>>>>>>
68984>>>>>>>        Else Begin
68985>>>>>>>            Move 0 to pProv
68986>>>>>>>        End
68986>>>>>>>>
68986>>>>>>>        
68986>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
68986>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
68987>>>>>>>        If (not(bOk) or hProv = 0) Begin
68989>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
68990>>>>>>>        End
68990>>>>>>>>
68990>>>>>>>        
68990>>>>>>>        If (not(bOk) or hProv = 0) Begin
68992>>>>>>>            // Fallback to original
68992>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
68993>>>>>>>            
68993>>>>>>>            If (not(bOk) or hProv = 0) Begin
68995>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
68996>>>>>>>            End
68996>>>>>>>>
68996>>>>>>>        End
68996>>>>>>>>
68996>>>>>>>        Set Private_phProv to hProv
68997>>>>>>>        
68997>>>>>>>        Function_Return hProv
68998>>>>>>>    End_Function
68999>>>>>>>    
68999>>>>>>>    // Releases key container handle
68999>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
69001>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
69002>>>>>>>    End_Function
69003>>>>>>>    
69003>>>>>>>    // Creates hash object
69003>>>>>>>    Function CreateHash Handle hProv Returns Handle
69005>>>>>>>        Integer iAlgorithm
69005>>>>>>>        Handle hHash
69005>>>>>>>        Boolean bOk
69005>>>>>>>        
69005>>>>>>>        Move 0 to hHash
69006>>>>>>>        Get piHash to iAlgorithm
69007>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
69008>>>>>>>        
69008>>>>>>>        Function_Return hHash
69009>>>>>>>    End_Function
69010>>>>>>>    
69010>>>>>>>    // Destroys the hash object
69010>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
69012>>>>>>>        Function_Return (CryptDestroyHash(hHash))
69013>>>>>>>    End_Function
69014>>>>>>>    
69014>>>>>>>    // Adds data to hash object
69014>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
69016>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
69017>>>>>>>    End_Function
69018>>>>>>>    
69018>>>>>>>    // Generates session key
69018>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
69020>>>>>>>        Integer iAlgorithm
69020>>>>>>>        Handle hKey
69020>>>>>>>        Boolean bOk
69020>>>>>>>        
69020>>>>>>>        Move 0 to hKey
69021>>>>>>>        Get piCipher to iAlgorithm
69022>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
69023>>>>>>>        
69023>>>>>>>        Function_Return hKey
69024>>>>>>>    End_Function
69025>>>>>>>    
69025>>>>>>>    // Imports a plain text key
69025>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        Boolean   bSuccess
69027>>>>>>>        Handle    hKey
69027>>>>>>>        Integer   iHeadSize iKeySize
69027>>>>>>>        UChar[]   ucaKeyblob
69028>>>>>>>        Integer iVoid
69028>>>>>>>        
69028>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
69029>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
69030>>>>>>>        
69030>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
69031>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
69032>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
69033>>>>>>>        Move iKeySize           to blobhead.dwKeySize
69034>>>>>>>        
69034>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
69035>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
69036>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
69037>>>>>>>        
69037>>>>>>>        Move 0 to hKey
69038>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
69039>>>>>>>        If (not(bSuccess)) Begin
69041>>>>>>>            Move (ShowLastError()) to iVoid
69042>>>>>>>        End
69042>>>>>>>>
69042>>>>>>>        
69042>>>>>>>        Function_Return hKey
69043>>>>>>>    End_Function
69044>>>>>>>    
69044>>>>>>>    // Destroys the key
69044>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
69046>>>>>>>        Function_Return (CryptDestroyKey(hKey))
69047>>>>>>>    End_Function
69048>>>>>>>    
69048>>>>>>>    // Retrieves key data
69048>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
69050>>>>>>>        Integer iBuffer iLen
69050>>>>>>>        Boolean bOk
69050>>>>>>>        
69050>>>>>>>        Move (SizeOfType(Integer)) to iLen
69051>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
69052>>>>>>>        Function_Return iBuffer
69053>>>>>>>    End_Function
69054>>>>>>>    
69054>>>>>>>    // Retrieves a hash value
69054>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
69056>>>>>>>        UChar[] ucHash
69057>>>>>>>        Integer liResult
69057>>>>>>>        DWord   dwDataLen
69057>>>>>>>        
69057>>>>>>>        Move 0 to dwDataLen
69058>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
69059>>>>>>>        If (liResult = 0) ;            Function_Return ""
69062>>>>>>>        
69062>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
69063>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
69064>>>>>>>        If (liResult = 0) ;            Function_Return ""
69067>>>>>>>        
69067>>>>>>>        Function_Return ucHash
69068>>>>>>>    End_Function
69069>>>>>>>
69069>>>>>>>    // Encrypts data
69069>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69071>>>>>>>        Handle hProv hHash hKey
69071>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
69071>>>>>>>        Boolean bOk
69071>>>>>>>        
69071>>>>>>>        Get AcquireContext to hProv
69072>>>>>>>        If (hProv) Begin
69074>>>>>>>            Get CreateHash hProv to hHash
69075>>>>>>>            If (hHash) Begin
69077>>>>>>>                Get HashData hHash ucPassword to bOk
69078>>>>>>>                If (bOk) Begin
69080>>>>>>>                    Get piCipher to iAlgorithm
69081>>>>>>>                    Get DeriveKey hProv hHash to hKey
69082>>>>>>>                End
69082>>>>>>>>
69082>>>>>>>                Get DestroyHash hHash to bOk
69083>>>>>>>            End
69083>>>>>>>>
69083>>>>>>>            
69083>>>>>>>            If (hKey) Begin
69085>>>>>>>                //  First call to determine resulting data size
69085>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69086>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
69087>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
69088>>>>>>>                
69088>>>>>>>                //  Reserve space in string
69088>>>>>>>                If (iDataLen < iCipherLen) Begin
69090>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
69091>>>>>>>                End
69091>>>>>>>>
69091>>>>>>>                
69091>>>>>>>                //  Call to really decrypt
69091>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
69092>>>>>>>                //If (not(bOk)) Begin
69092>>>>>>>                //Move "" to sData
69092>>>>>>>                //Move (GetLastError()) to iErr
69092>>>>>>>                //End
69092>>>>>>>                
69092>>>>>>>                Get DestroyKey hKey to bOk
69093>>>>>>>            End 
69093>>>>>>>>
69093>>>>>>>            Get ReleaseContext hProv to bOk
69094>>>>>>>        End 
69094>>>>>>>>
69094>>>>>>>        Function_Return ucData
69095>>>>>>>    End_Function
69096>>>>>>>    
69096>>>>>>>    // Decrypts data
69096>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69098>>>>>>>        Handle hProv hHash hKey
69098>>>>>>>        Integer iAlgorithm iDataLen
69098>>>>>>>        Boolean bOk
69098>>>>>>>        
69098>>>>>>>        Get AcquireContext to hProv
69099>>>>>>>        If (hProv) Begin
69101>>>>>>>            Get CreateHash hProv to hHash
69102>>>>>>>            If (hHash) Begin
69104>>>>>>>                Get HashData hHash ucPassword to bOk
69105>>>>>>>                If (bOk) Begin
69107>>>>>>>                    Get piCipher to iAlgorithm
69108>>>>>>>                    Get DeriveKey hProv hHash to hKey
69109>>>>>>>                End
69109>>>>>>>>
69109>>>>>>>                Get DestroyHash hHash to bOk
69110>>>>>>>            End
69110>>>>>>>>
69110>>>>>>>            
69110>>>>>>>            If (hKey) Begin
69112>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69113>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
69114>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
69114>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
69116>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
69117>>>>>>>                End
69117>>>>>>>>
69117>>>>>>>                
69117>>>>>>>                Get DestroyKey hKey to bOk
69118>>>>>>>            End
69118>>>>>>>>
69118>>>>>>>            Get ReleaseContext hProv to bOk
69119>>>>>>>        End
69119>>>>>>>>
69119>>>>>>>        Function_Return ucData
69120>>>>>>>    End_Function
69121>>>>>>>    
69121>>>>>>>    // Creates a key
69121>>>>>>>    Function CreateKey Handle hProv Returns Handle
69123>>>>>>>        Integer iAlg iType iByte iLength iSize
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        Boolean bOk
69123>>>>>>>        Handle hKey
69123>>>>>>>        UChar[] aKey
69124>>>>>>>
69124>>>>>>>        Get paKey to aKey
69125>>>>>>>        Get piKeyAlg to iAlg
69126>>>>>>>        Get piKeyType to iType
69127>>>>>>>        Move iAlg                   to keyBlob.header.bType
69128>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
69129>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
69130>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
69131>>>>>>>        
69131>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
69132>>>>>>>        For iByte from 0 to iLength
69138>>>>>>>>
69138>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
69139>>>>>>>        Loop
69140>>>>>>>>
69140>>>>>>>        
69140>>>>>>>        Move 0 to hKey
69141>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
69142>>>>>>>        Function_Return hKey
69143>>>>>>>    End_Function
69144>>>>>>>    
69144>>>>>>>    // Sets the key parameters
69144>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
69146>>>>>>>        Integer iPadding iMode
69146>>>>>>>        Boolean bOk
69146>>>>>>>        UChar[] aIV
69147>>>>>>>        
69147>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
69147>>>>>>>        //For iByte from 0 to iLength
69147>>>>>>>        //    Move iByte to aIV[iByte]
69147>>>>>>>        //Loop
69147>>>>>>>
69147>>>>>>>        // Set initialization vector
69147>>>>>>>        Get paIV to aIV
69148>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
69149>>>>>>>        If (bOk) Begin
69151>>>>>>>            // Set padding
69151>>>>>>>            Get piKeyPadding to iPadding
69152>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
69153>>>>>>>            If (bOk) Begin
69155>>>>>>>                // Set move
69155>>>>>>>                Get piKeyMode to iMode
69156>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
69157>>>>>>>            End
69157>>>>>>>>
69157>>>>>>>        End
69157>>>>>>>>
69157>>>>>>>        Function_Return bOk        
69158>>>>>>>    End_Function
69159>>>>>>>    
69159>>>>>>>    // Encrypts using block cipher
69159>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
69161>>>>>>>        Handle hProv hKey
69161>>>>>>>        Integer iLen iSize iBlocks
69161>>>>>>>        Boolean bOk
69161>>>>>>>        
69161>>>>>>>        Get AcquireContext to hProv
69162>>>>>>>        If (hProv) Begin
69164>>>>>>>            // Create key
69164>>>>>>>            Get CreateKey hProv to hKey
69165>>>>>>>            If (hKey) Begin
69167>>>>>>>                Get SetKeyParameters hKey to bOk
69168>>>>>>>                If (bOk) Begin
69170>>>>>>>                    // Buffer for block ciphers can be up to block length larger
69170>>>>>>>                    Get piBlockSize to iSize
69171>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69172>>>>>>>                    
69172>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
69173>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
69174>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
69175>>>>>>>                End
69175>>>>>>>>
69175>>>>>>>                Get DestroyKey hKey to bOk
69176>>>>>>>            End
69176>>>>>>>>
69176>>>>>>>            Get ReleaseContext hProv to bOk
69177>>>>>>>        End
69177>>>>>>>>
69177>>>>>>>        Function_Return ucData
69178>>>>>>>    End_Function
69179>>>>>>>    
69179>>>>>>>    // Decrypts using block cipher
69179>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
69181>>>>>>>        Handle hProv hKey
69181>>>>>>>        Integer iLen
69181>>>>>>>        Boolean bOk
69181>>>>>>>        
69181>>>>>>>        Get AcquireContext to hProv
69182>>>>>>>        If (hProv) Begin
69184>>>>>>>            // Create key
69184>>>>>>>            Get CreateKey hProv to hKey
69185>>>>>>>            If (hKey) Begin
69187>>>>>>>                Get SetKeyParameters hKey to bOk
69188>>>>>>>                If (bOk) Begin
69190>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69191>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
69192>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
69193>>>>>>>                End
69193>>>>>>>>
69193>>>>>>>                Get DestroyKey hKey to bOk
69194>>>>>>>            End
69194>>>>>>>>
69194>>>>>>>            Get ReleaseContext hProv to bOk
69195>>>>>>>        End
69195>>>>>>>>
69195>>>>>>>        Function_Return ucData
69196>>>>>>>    End_Function
69197>>>>>>>    
69197>>>>>>>    
69197>>>>>>>    //  Generates random data.
69197>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
69199>>>>>>>        Handle hProv
69199>>>>>>>        UChar[] uaResult
69200>>>>>>>        Boolean bRes
69200>>>>>>>        
69200>>>>>>>        Get AcquireContext to hProv
69201>>>>>>>        
69201>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
69202>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
69203>>>>>>>        
69203>>>>>>>        Get ReleaseContext hProv to bRes
69204>>>>>>>        
69204>>>>>>>        Function_Return uaResult
69205>>>>>>>    End_Function
69206>>>>>>>    
69206>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
69206>>>>>>>    Function GenerateRandomString Integer iLength Returns String
69208>>>>>>>        String sResult
69208>>>>>>>        UChar[] ucData
69209>>>>>>>        Pointer pBase64
69209>>>>>>>        Integer iVoid
69209>>>>>>>        
69209>>>>>>>        Get GenerateRandom iLength to ucData
69210>>>>>>>        
69210>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
69211>>>>>>>        Move (PointerToString(pBase64)) to sResult
69212>>>>>>>        Move (Free(pBase64)) to iVoid
69213>>>>>>>        
69213>>>>>>>        Function_Return (Left(sResult, iLength))
69214>>>>>>>    End_Function
69215>>>>>>>    
69215>>>>>>>End_Class
69216>>>>>
69216>>>>>Class cLoginEncryption is a cObject
69217>>>>>    
69217>>>>>    Procedure Construct_Object
69219>>>>>        Forward Send Construct_Object
69221>>>>>        // this must be set to a multi (40ish) character random key
69221>>>>>        Property String psEncryptPassword ""
69222>>>>>        
69222>>>>>        Object oDataCrypter is a cCryptographerEx
69224>>>>>            Set piHash to CALG_SHA_256
69225>>>>>            Set piCipher to CALG_AES_256
69226>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
69227>>>>>            Set piProvider to PROV_RSA_AES
69228>>>>>        End_Object
69229>>>>>    End_Procedure
69230>>>>>    
69230>>>>>    // This can be augmented to return a password encryption key using any
69230>>>>>    // hidden mechanism desired.
69230>>>>>    Function GetEncryptionPassword Returns String
69232>>>>>        String sPassword
69232>>>>>        Get psEncryptPassword to sPassword
69233>>>>>        Function_Return sPassword
69234>>>>>    End_Function
69235>>>>>    
69235>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
69235>>>>>    //
69235>>>>>    // Params:
69235>>>>>    //   sPlainText     String to encrypt.
69235>>>>>    // Returns:
69235>>>>>    //   Base64 encoded hash.
69235>>>>>    Function EncryptPassword String sPlainText Returns String
69237>>>>>        String sEncryptPassword sBase64
69237>>>>>        UChar[] ucBinary
69238>>>>>        Pointer pBase64
69238>>>>>        Integer iVoid
69238>>>>>        
69238>>>>>        //  Encrypt Key
69238>>>>>        Get GetEncryptionPassword to sEncryptPassword
69239>>>>>        If (sEncryptPassword = "") Begin
69241>>>>>            Error DFERR_PROGRAM "No encryption password set"
69242>>>>>>
69242>>>>>        End
69242>>>>>>
69242>>>>>        
69242>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
69243>>>>>        
69243>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
69245>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
69246>>>>>>
69246>>>>>            Function_Return ""
69247>>>>>        End
69247>>>>>>
69247>>>>>        
69247>>>>>        //  Encode binary hash to Base64
69247>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
69248>>>>>        Move (PointerToString(pBase64)) to sBase64
69249>>>>>        Move (Free(pBase64)) to iVoid
69250>>>>>        
69250>>>>>        Function_Return sBase64
69251>>>>>    End_Function
69252>>>>>    
69252>>>>>    
69252>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
69252>>>>>    //
69252>>>>>    // Params:
69252>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
69252>>>>>    // Returns:
69252>>>>>    //   Readable plain text password
69252>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
69254>>>>>        String sEncryptPassword
69254>>>>>        UChar[] ucBinary ucPlain
69256>>>>>        Boolean bIsHex
69256>>>>>        Integer iLen iVoid
69256>>>>>        Pointer pBinary
69256>>>>>        
69256>>>>>        If (sBase64EncryptedPassword <> "") Begin
69258>>>>>            //  Decode from Base64
69258>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
69259>>>>>            
69259>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
69260>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
69261>>>>>                        
69261>>>>>            Move (Free(pBinary)) to iVoid
69262>>>>>            
69262>>>>>            //  Encrypted binary hash to string
69262>>>>>            Get GetEncryptionPassword to sEncryptPassword
69263>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
69264>>>>>        End
69264>>>>>>
69264>>>>>        
69264>>>>>        Function_Return (UCharArrayToString(ucPlain))
69265>>>>>    End_Function
69266>>>>>End_Class
69267>>>
69267>>>Object oLoginEncryption is a cLoginEncryption
69269>>>
69269>>>    // this must be created in your appsrc directory and must contain an encryption
69269>>>    // key that is set to psEncryptPassword. It will look something like this
69269>>>    //
69269>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
69269>>>    //  
Including file: LoginEncryptionKey.inc    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\LoginEncryptionKey.inc)
69269>>>>// Studio generated login encryption key
69269>>>>Set psEncryptPassword to "3dv{g#~d=DOf~}.pmM:e4lijC*_C`x>$@[,(v<cu"
69270>>>>
69270>>>    
69270>>>    // use this to register this object to your cConnection Object. This object
69270>>>    // must be created after the cConnection object
69270>>>    Move Self to ghoLoginEncryption
69271>>>End_Object
69272>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.0\Pkg\DatabaseLoginDialog.dg)
69272>>>
69272>>>Use Windows.pkg
69272>>>Use cConnection.pkg
69272>>>Use dfLine.pkg
69272>>>
69272>>>Object oDatabaseLoginDialog is a ModalPanel
69274>>>    Set Label to "Database Login"
69275>>>    Set Location to 2 2
69276>>>    Set Size to 110 211
69277>>>    
69277>>>    Property String psId
69279>>>    Property Boolean pbOk False
69281>>>    Property Boolean pbChanged False
69283>>>    Property Boolean pbAllowRemember True
69285>>>    
69285>>>    // this registers this object with the cConnection object.
69285>>>    Move Self to ghoLoginConnectDialog
69286>>>    
69286>>>    Object oUserIDForm is a Form
69288>>>        Set Label to "User Name"
69289>>>        Set Size to 12 85
69290>>>        Set Location to 34 79
69291>>>        Set Label_Col_Offset to 64
69292>>>        Set peAnchors to anTopLeftRight
69293>>>    End_Object
69294>>>    
69294>>>    Object oPwdForm is a Form
69296>>>        Set Size to 12 85
69297>>>        Set Location to 49 79
69298>>>        Set Label_Col_Offset to 64
69299>>>        Set Password_State to True
69300>>>        Set peAnchors to anTopLeftRight
69301>>>        Set Label to "Password"
69302>>>    End_Object
69303>>>    
69303>>>    Object oTrustedConnection is a CheckBox
69305>>>        Set Size to 10 50
69306>>>        Set Location to 65 79
69307>>>        Set Label to "Trusted Connection"
69308>>>    End_Object
69309>>>    
69309>>>    Object oRemember is a CheckBox
69311>>>        Set Size to 10 50
69312>>>        Set Location to 79 14
69313>>>        Set Label to "Remember and don't ask again"
69314>>>        Set Checked_State to True
69315>>>    End_Object
69316>>>    
69316>>>    Object oLogin_btn is a Button
69318>>>        Set Label to "&Login"
69319>>>        Set Location to 92 102
69320>>>        Set peAnchors to anBottomRight
69321>>>        Set Default_State to True
69322>>>        
69322>>>        Procedure OnClick
69325>>>            Boolean bTrust
69325>>>            String sUser sPwd sConn sErr sId
69325>>>            Integer iError
69325>>>            Get psId to sId
69326>>>            Get Value of oUserIDForm to sUser
69327>>>            Get Value of oPwdForm to sPwd
69328>>>            Get Checked_State of oTrustedConnection to bTrust
69329>>>            
69329>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
69330>>>            If (iError=0) Begin
69332>>>                Set pbOk to True
69333>>>                Set pbChanged to True
69334>>>                Send Close_Panel
69335>>>            End
69335>>>>
69335>>>            Else Begin
69336>>>                Get psErrorText of ghoConnection to sErr
69337>>>                Send UserError sErr "Login Error"
69338>>>            End
69338>>>>
69338>>>        End_Procedure
69339>>>    End_Object
69340>>>    
69340>>>    Object oCancel_btn is a Button
69342>>>        Set Label to "&Cancel"
69343>>>        Set Location to 92 157
69344>>>        Set peAnchors to anBottomRight
69345>>>        
69345>>>        Procedure OnClick
69348>>>            Send Close_Panel
69349>>>        End_Procedure
69350>>>    End_Object
69351>>>    
69351>>>    Object oConnectionIdInfo is a TextBox
69353>>>        Set Size to 10 50
69354>>>        Set Location to 4 14
69355>>>        Set Label to 'Connection Id='
69356>>>    End_Object
69357>>>    
69357>>>    Object oConnectionServerInfo is a TextBox
69359>>>        Set Size to 10 50
69360>>>        Set Location to 16 14
69361>>>        Set Label to 'Server'
69362>>>    End_Object
69363>>>    
69363>>>    Object oLineControl1 is a LineControl
69365>>>        Set Size to 2 202
69366>>>        Set Location to 29 5
69367>>>    End_Object
69368>>>    
69368>>>    Function LoginConnectIdDialog String sId Returns Boolean
69371>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
69371>>>        String sUser sPwd sDescription
69371>>>        tConnection Connect
69371>>>        tConnection Connect
69371>>>        
69371>>>        Get pbAllowRemember to bAllowRemember
69372>>>        
69372>>>        
69372>>>        If not bAllowRemember Begin
69374>>>            Set Enabled_State of oRemember to bRemember
69375>>>            Set Visible_State of oRemember to bRemember
69376>>>        End
69376>>>>
69376>>>        
69376>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
69377>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
69378>>>        Set Value of oConnectionServerInfo to Connect.sString
69379>>>        
69379>>>        Set psId to sId
69380>>>        Set pbOk to False
69381>>>        Set pbChanged to False
69382>>>        Set Value of oUserIDForm to Connect.sUID
69383>>>        Set Value of oPwdForm to ""
69384>>>        
69384>>>        Send Popup
69385>>>        
69385>>>        Get pbOk to bOk
69386>>>        Get pbChanged to bChanged
69387>>>        If (bChanged and bOk) Begin
69389>>>            If bAllowRemember Begin
69391>>>                Get Checked_State of oRemember to bRemember
69392>>>                If bRemember Begin
69394>>>                    Get Checked_State of oTrustedConnection to bTrusted
69395>>>                    If not (bTrusted) Begin
69397>>>                        Get Value of oUserIDForm to sUser
69398>>>                        Get Value of oPwdForm to sPwd
69399>>>                    End
69399>>>>
69399>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
69400>>>                End
69400>>>>
69400>>>            End
69400>>>>
69400>>>        End
69400>>>>
69400>>>        Function_Return bOk
69401>>>    End_Function
69402>>>    
69402>>>    
69402>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
69403>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
69404>>>End_Object
69405>>>
69405>    End_Object
69406>
69406>End_Object
69407>
69407>Object oToolTipController is a cToolTipController
69409>    Move Self to ghoToolTipController
69410>End_Object
69411>
69411>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oEditContextMenu.pkg)
69411>>>Use cCJStandardMenuItemClasses.pkg
69411>>>
69411>>>Object oEditContextMenu is a cCJContextMenu
69413>>>    
69413>>>    Move Self to Default_Form_Floating_Menu_ID
69414>>>    
69414>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69416>>>    End_Object
69417>>>    
69417>>>    Object oCutMenuItem is a cCJCutMenuItem
69419>>>        Set pbControlBeginGroup to True
69420>>>    End_Object
69421>>>    
69421>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69423>>>    End_Object
69424>>>
69424>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69426>>>    End_Object
69427>>>
69427>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69429>>>    End_Object
69430>>>
69430>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69432>>>        Set pbControlBeginGroup to True
69433>>>    End_Object
69434>>>
69434>>>End_Object
69435>>>
69435>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oDEOEditContextMenu17.pkg)
69435>>>Use Windows.pkg
69435>>>Use cCJStandardMenuItemClasses.pkg
69435>>>Use cCJDeoMenuItemClasses.pkg
69435>>>
69435>>>
69435>>>Object oDEOEditContextMenu17 is a cCJContextMenu
69437>>>    
69437>>>    Move Self to Default_dbFloating_Menu_ID
69438>>>    
69438>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69440>>>    End_Object
69441>>>    
69441>>>    Object oCutMenuItem is a cCJCutMenuItem
69443>>>        Set pbControlBeginGroup to True
69444>>>    End_Object
69445>>>    
69445>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69447>>>    End_Object
69448>>>
69448>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69450>>>    End_Object
69451>>>
69451>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69453>>>    End_Object
69454>>>
69454>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69456>>>        Set pbControlBeginGroup to True
69457>>>    End_Object
69458>>>
69458>>>    Object oPromptMenuItem is a cCJPromptMenuItem
69460>>>        Set pbControlBeginGroup to True
69461>>>    End_Object
69462>>>
69462>>>    Object oFindNextMenu is a cCJFindNextMenuItem
69464>>>        Set pbControlBeginGroup to True
69465>>>    End_Object
69466>>>
69466>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69468>>>    End_Object
69469>>>
69469>>>    Object oClearMenuItem is a cCJClearMenuItem
69471>>>        Set pbControlBeginGroup to True
69472>>>    End_Object
69473>>>
69473>>>    Object oClearAllMenu is a cCJClearAllMenuItem
69475>>>    End_Object
69476>>>
69476>>>    Object oSaveMenu is a cCJSaveMenuItem
69478>>>    End_Object
69479>>>    
69479>>>    Object oDeleteMenu is a cCJDeleteMenuItem
69481>>>    End_Object
69482>>>
69482>>>    Object oRememberitem is a cCJRememberFieldMenuItem
69484>>>        Set pbControlBeginGroup to True
69485>>>    End_Object
69486>>>
69486>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
69488>>>    End_Object
69489>>>
69489>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
69491>>>    End_Object
69492>>>
69492>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
69494>>>    End_Object
69495>>>
69495>>>End_Object
69496>
69496>Object oMain is a Panel
69498>    Set Label To "My Project"
69499>    Set Location to 0 -1
69500>    Set Size to 300 450
69501>
69501>    Object oCommandBarSystem is a cCJCommandBarSystem
69503>        Set pbTimerUpdate to True
69504>        Set peVisualTheme to xtpThemeOffice2013Outlook
69505>        Set pbAutoResizeIcons to True
69506>
69506>        Procedure OnCreateCommandBars
69509>            Handle hoOptions
69509>            Get OptionsObject to hoOptions
69510>            Forward Send OnCreateCommandBars
69512>        End_Procedure
69513>
69513>        Object oMenuBar is a cCJMenuBar
69515>
69515>            Object oFileMenu is a cCJMenuItem
69517>                Set peControlType to xtpControlPopup          
69518>                Set psCaption   to "&File"
69519>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
69520>                Set psCategory to "Menus"
69521>
69521>                Object oClearMenuItem is a cCJClearMenuItem
69523>                    Set pbAddToDesignerMenu to True
69524>                End_Object
69525>
69525>                Object oClearAllMenu is a cCJClearAllMenuItem
69527>                    Set pbAddToDesignerMenu to True
69528>                End_Object
69529>
69529>                Object oPromptMenuItem is a cCJPromptMenuItem
69531>                    Set pbAddToDesignerMenu to True
69532>                    Set pbControlBeginGroup to True
69533>                End_Object
69534>
69534>                Object oFindMenuItem is a cCJFindMenuItem
69536>                    Set pbAddToDesignerMenu to True
69537>                    Set pbControlBeginGroup to True
69538>                End_Object
69539>
69539>                Object oFindNextMenu is a cCJFindNextMenuItem
69541>                    Set pbAddToDesignerMenu to True
69542>                End_Object
69543>
69543>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69545>                    Set pbAddToDesignerMenu to True
69546>                End_Object
69547>
69547>                Object oFindFirstMenu is a cCJFindFirstMenuItem
69549>                    Set pbAddToDesignerMenu to True
69550>                End_Object
69551>
69551>                Object oFindLastMenu is a cCJFindLastMenuItem
69553>                    Set pbAddToDesignerMenu to True
69554>                End_Object
69555>
69555>                Object oSaveMenuItem is a cCJSaveMenuItem
69557>                    Set pbAddToDesignerMenu to True
69558>                    Set pbControlBeginGroup to True
69559>                End_Object
69560>
69560>                Object oDeleteMenuItem is a cCJDeleteMenuItem
69562>                    Set pbAddToDesignerMenu to True
69563>                End_Object
69564>
69564>                Object oExitMenu is a cCJExitMenuItem
69566>                    Set pbControlBeginGroup to True
69567>                End_Object
69568>
69568>            End_Object
69569>
69569>            Object oViewMenu is a cCJMenuItem
69571>                Set peControlType to xtpControlPopup
69572>                Set psCaption to "&View"
69573>                Set psToolTip to "View"
69574>                Set psDescription to "Available Views"
69575>
69575>                Object oConsultaDiretorioMenuItem is a cCJMenuItem
69577>                    Set psCaption to "ConsultaDiretorio"
69578>                    Set psTooltip to "ConsultaDiretorio"
69579>                
69579>                    Procedure OnExecute Variant vCommandBarControl
69582>                        Handle hoClient
69582>                        Get Client_Id to hoClient
69583>                        Send Activate_oConsultaDiretorio of hoClient
69584>                    End_Procedure
69585>                End_Object
69586>
69586>                Object oConteudoDiretorioMenuItem is a cCJMenuItem
69588>                    Set psCaption to "ConteudoDiretorio"
69589>                    Set psTooltip to "ConteudoDiretorio"
69590>                
69590>                    Procedure OnExecute Variant vCommandBarControl
69593>                        Handle hoClient
69593>                        Get Client_Id to hoClient
69594>                        Send Activate_oConteudoDiretorio of hoClient
69595>                    End_Procedure
69596>                End_Object
69597>
69597>                Object oTestFunctionMenuItem is a cCJMenuItem
69599>                    Set psCaption to "TestFunction"
69600>                    Set psTooltip to "TestFunction"
69601>                
69601>                    Procedure OnExecute Variant vCommandBarControl
69604>                        Handle hoClient
69604>                        Get Client_Id to hoClient
69605>                        Send Activate_oTestFunction of hoClient
69606>                    End_Procedure
69607>                End_Object
69608>
69608>                Object oFunctionDeleteFilesMenuItem is a cCJMenuItem
69610>                    Set psCaption to "FunctionDeleteFiles"
69611>                    Set psTooltip to "FunctionDeleteFiles"
69612>                
69612>                    Procedure OnExecute Variant vCommandBarControl
69615>                        Handle hoClient
69615>                        Get Client_Id to hoClient
69616>                        Send Activate_oFunctionDeleteFiles of hoClient
69617>                    End_Procedure
69618>                End_Object
69619>
69619>            End_Object
69620>            
69620>            Object oReportMenu is a cCJMenuItem
69622>                Set peControlType to xtpControlPopup          
69623>                Set psCaption to "&Report"
69624>                Set psToolTip to "Report"
69625>                Set psDescription to "Available Reports"
69626>            End_Object
69627>
69627>            Object oNavigateMenu is a cCJMenuItem
69629>                Set peControlType to xtpControlPopup      
69630>                Set psCaption to "&Navigate"    
69631>                Set psTooltip to "Navigate"    
69632>                Set psDescription to "Move to different areas of the application"
69633>
69633>                Object oNextAreaMenu is a cCJNextAreaMenu
69635>                End_Object
69636>
69636>                Object oPriorAreaMenu is a cCJPriorAreaMenu
69638>                End_Object
69639>
69639>                Object oNextViewMenu is a cCJNextViewMenu
69641>                End_Object
69642>
69642>                Object oPriorViewMenu is a cCJPriorViewMenu
69644>                End_Object
69645>
69645>                Object oPromptMenu is a cCJPromptMenuItem
69647>                    Set pbControlBeginGroup to True
69648>                End_Object
69649>
69649>                Object oZoomMenu is a cCJZoomMenuItem
69651>                End_Object
69652>
69652>            End_Object
69653>
69653>            Object oWindowMenu is a cCJMDIWindowsMenuItem
69655>                Set peControlType to xtpControlPopup
69656>                Set psCaption to "&Window"
69657>                Set psToolTip to "Window"
69658>                Set psDescription to "Display Current Views and set other display options."    
69659>
69659>                // These are the static windows items. More will be created in onInitPopup 
69659>                Object oDisplayOptionsMenu is a cCJMenuItem
69661>                    Set peControlType to xtpControlPopup          
69662>                    Set psCaption to "&Display Options"
69663>                    Set psToolTip to "Display Options"
69664>                    Set psDescription to "Set display options"
69665>
69665>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
69667>                    End_Object
69668>
69668>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
69670>                    End_Object
69671>
69671>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
69673>                        Set pbControlBeginGroup to True
69674>                    End_Object
69675>
69675>                End_Object
69676>
69676>                Object oCascadeMenu is a cCJCascadeMenuItem
69678>                    Set pbControlBeginGroup to True
69679>                End_Object
69680>
69680>                Object oHorizTile is a cCJTileHorizontally
69682>                End_Object
69683>
69683>                Object oVertTile is a cCJTileVertically
69685>                End_Object
69686>
69686>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
69688>                    Set pbControlBeginGroup to True
69689>                End_Object
69690>
69690>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
69692>                End_Object
69693>
69693>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
69695>                    Set pbControlBeginGroup to True
69696>                End_Object
69697>
69697>            End_Object
69698>
69698>            Object oHelpMenu is a cCJMenuItem
69700>                Set peControlType to xtpControlPopup    
69701>                Set psCaption to "&Help"
69702>                Set psDescription to "Access Information for learning and using this DataFlex application."
69703>                Set psToolTip to "Help"
69704>
69704>                Object oHelpMenuItem is a cCJHelpMenuItem 
69706>                End_Object
69707>
69707>                Object oAboutMenuItem is a cCJAboutMenuItem
69709>                End_Object
69710>
69710>            End_Object
69711>
69711>        End_Object
69712>
69712>        Object oFindToolBar is a cCJToolbar
69714>            Set psTitle to "Finding Toolbar"
69715>
69715>            Object oFindFirstTool is a cCJFindFirstMenuItem
69717>            End_Object
69718>
69718>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
69720>            End_Object
69721>
69721>            Object oFindMenuTool is a cCJFindMenuItem
69723>            End_Object
69724>
69724>            Object oFindNextTool is a cCJFindNextMenuItem
69726>            End_Object
69727>
69727>            Object oFindLastTool is a cCJFindLastMenuItem
69729>            End_Object
69730>
69730>            Object oPromptToolItem is a cCJPromptMenuItem
69732>                Set pbControlBeginGroup to True
69733>            End_Object
69734>
69734>        End_Object
69735>
69735>        Object oFileToolBar is a cCJToolbar
69737>            Set psTitle to "Data Entry Toolbar"
69738>
69738>            Object oClearToolItem is a cCJClearMenuItem
69740>                Set peControlStyle to xtpButtonIconAndCaption
69741>            End_Object
69742>
69742>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
69744>                Set peControlStyle to xtpButtonIconAndCaption
69745>            End_Object
69746>
69746>            Object oSaveToolItem is a cCJSaveMenuItem
69748>                Set peControlStyle to xtpButtonIconAndCaption
69749>                Set pbControlBeginGroup to True
69750>            End_Object
69751>
69751>            Object oDeleteToolItem is a cCJDeleteMenuItem
69753>                Set peControlStyle to xtpButtonIconAndCaption
69754>            End_Object
69755>
69755>        End_Object
69756>
69756>        Object oEditToolBar is a cCJToolbar
69758>            Set psTitle to "Edit Toolbar"
69759>
69759>            Object oCutToolbarItem is a cCJCutMenuItem
69761>            End_Object
69762>
69762>            Object oCopyToolbarItem is a cCJCopyMenuItem
69764>            End_Object
69765>
69765>            Object oPasteToolbarItem is a cCJPasteMenuItem
69767>            End_Object
69768>
69768>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
69770>                Set pbControlBeginGroup to True
69771>            End_Object
69772>
69772>        End_Object
69773>
69773>        Object oRememberToolbar is a cCJToolbar
69775>            Set psTitle to C_$Remember
69776>
69776>            Object oRememberItems is a cCJMenuItem
69778>
69778>                Set peControlType to xtpControlPopup
69779>                Set peControlStyle to xtpButtonCaption
69780>                Set psCaption to C_$Remember
69781>                
69781>                Object oMenuItem is a cCJRememberFieldMenuItem
69783>                    Set peControlStyle to xtpButtonIconAndCaption
69784>                End_Object
69785>                
69785>                Object oMenuItem is a cCJRememberLastFieldMenuItem
69787>                    Set peControlStyle to xtpButtonIconAndCaption
69788>                End_Object
69789>                
69789>                Object oMenuItem is a cCJUnRememberFieldMenuItem
69791>                    Set peControlStyle to xtpButtonIconAndCaption
69792>                End_Object
69793>                
69793>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
69795>                    Set peControlStyle to xtpButtonIconAndCaption
69796>                End_Object
69797>
69797>            End_Object
69798>            
69798>        End_Object
69799>        
69799>        Object oStatusBar is a cCJStatusBar
69801>
69801>            Object oStatusPane1 is a cCJStatusBarPane
69803>                Set piID to sbpIDIdlePane
69804>                Set pbStyleStretch to True
69805>            End_Object
69806>
69806>            Object oStatusPane2 is a cCJStatusBarPane
69808>                Set phoViewPane to Self
69809>                Set pbStyleStretch to True
69810>            End_Object
69811>
69811>        End_Object
69812>
69812>    End_Object
69813>
69813>    Object oClientArea is a ClientArea     
69815>        //VAR GLOBAL 
69815>        String sDirOpenExlorer
69815>        String sReadDir
69815>                
69815>        //VAR GLOBAL TestFuction
69815>        String sGPathFind
69815>        String sGPathDestination
69815>        String sGNameDb
69815>        
69815>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\StdAbout.pkg)
69815>>>// This provides a quick and simple way to create an about package for a program.
69815>>>// You need to create a message inside you client area called Activate_About.
69815>>>// Within this message you should send the message DoAbout passing needed
69815>>>// string information.
69815>>>//
69815>>>//       Procedure Activate_About
69815>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
69815>>>//       End_Procedure
69815>>>//    where: sTitle =     Name of application. If none provided, uses caption
69815>>>//                        bar title
69815>>>//           sVersion   = Version Line. If none provided, will be blank
69815>>>//           sCopyRight = Copyright Line. If none provided, will be blank
69815>>>//           sAuthor    = Author name, blank if none provided
69815>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
69815>>>//                        is used.
69815>>>// It is expected that you will place this in your own object package. For
69815>>>// example an order about package may look like this:
69815>>>//
69815>>>//   // OrderAbout.pkg
69815>>>//   Use StdAbout.pkg
69815>>>//   Procedure Activate_About
69815>>>//      String sTitle sCopyright sVersion sAuthor
69815>>>//      Move "My Order Entry System" to sTitle
69815>>>//      Move "Version 2.1" to sVersion
69815>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
69815>>>//      Move "John Smith"  to sAuthor
69815>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
69815>>>//   end_procedure
69815>>>//   // end of file.
69815>>>
69815>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dfabout.pkg)
69815>>>>>Use LanguageText.pkg
69815>>>>>Use Windows.pkg
69815>>>>>Use DFbitmap.pkg
69815>>>>>Use GlobalFunctionsProcedures.pkg
69815>>>>>Use cTextEdit.pkg
69815>>>>>Use tWinStructs.pkg
69815>>>>>
69815>>>>>Use cli.pkg
69815>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.0\Pkg\DFBTRDRV.PKG)
69815>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
69815>>>>>>>// Notice      : This package contains constants and commands, used to call
69815>>>>>>>//               specific functions in the DFBTRDRV.
69815>>>>>>>Use Ui
69815>>>>>>>//
69815>>>>>>>// Driver Indentification
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>// Driver attributes
69815>>>>>>>//
69815>>>>>>>// Call_Driver functions ID's
69815>>>>>>>//
69815>>>>>>>//
69815>>>>>>>// DFBTRFN_CONVERT_FILE options
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// DFBTRFN_SET_OWNER options
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to create all vars which may be needed
69815>>>>>>>// in other commands.
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to set the owner of a Btrieve file.
69815>>>>>>>// File must have been opened.
69815>>>>>>>// Filenumber needs to be passed.
69815>>>>>>>// To clear set the owner to "".
69815>>>>>>>// Examples:
69815>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
69815>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
69815>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
69815>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
69815>>>>>>>// To clear:
69815>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to parse DFBTR_SET_OWNVER
69815>>>>>>>// options.
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to parse for Callback
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to clear the owner of a Btrieve file.
69815>>>>>>>// File must have been opened.
69815>>>>>>>// Filenumber needs to be passed.
69815>>>>>>>// Examples:
69815>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to add a owner name to the internal list of ownernames
69815>>>>>>>// which will be tries when opening files.
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to remove all owners from the internal list of ownernames
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to set the owner name to be used when opening the DDF files.
69815>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
69815>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
69815>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to change the transaction type.
69815>>>>>>>// Valid types are:
69815>>>>>>>//     DFBTRTT_NONE
69815>>>>>>>//     DFBTRTT_EXCLUSIVE
69815>>>>>>>//     DFBTRTT_CONCURRENT
69815>>>>>>>//
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to get the current transaction type.
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to set explicit_locking
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to get explicit locking
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>//
69815>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
69815>>>>>>>//
69815>>>>>>>
69815>>>>>>>// Purpose: An instance of this class can be used as a broker object to
69815>>>>>>>//          call several Dfbtrdrv releated methods.
69815>>>>>>>
69815>>>>>>>Class cDFBtrDrvHandler is an Array
69816>>>>>>>    
69816>>>>>>>    Procedure Construct_Object Integer iImage
69818>>>>>>>        Forward Send Construct_object iImage
69820>>>>>>>        
69820>>>>>>>        Property String  psDriverID "DFBTRDRV"
69821>>>>>>>    End_Procedure
69822>>>>>>>    
69822>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
69822>>>>>>>    //
69822>>>>>>>    
69822>>>>>>>    Function CKRevision Returns String
69824>>>>>>>        String  sDriverID
69824>>>>>>>        String  sRevision
69824>>>>>>>        String  sVoid
69824>>>>>>>        Integer iRetval
69824>>>>>>>        
69824>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69824>>>>>>>        // This error would otherwise be raised when we have an older
69824>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69824>>>>>>>        Send Ignore_error to Error_object_Id 20491
69825>>>>>>>        Get psDriverID to sDriverID
69826>>>>>>>        Move (Repeat(" ", 255)) to sRevision
69827>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
69832>>>>>>>        Send Trap_Error to Error_object_Id 20491
69833>>>>>>>        If (Trim(sRevision) = "") Begin
69835>>>>>>>            // Unable to get the revision. return all zeroes.
69835>>>>>>>            Move "0.0.0.0" to sRevision
69836>>>>>>>        End
69836>>>>>>>>
69836>>>>>>>        Function_Return sRevision
69837>>>>>>>    End_Function
69838>>>>>>>    
69838>>>>>>>    Function CkUsesUri Returns Integer
69840>>>>>>>        String  sDriverID
69840>>>>>>>        String  sVoid1
69840>>>>>>>        String  sVoid2
69840>>>>>>>        Integer iRetval
69840>>>>>>>        
69840>>>>>>>        Get psDriverID to sDriverID
69841>>>>>>>        
69841>>>>>>>        Move 0 to iRetval
69842>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69842>>>>>>>        // This error would otherwise be raised when we have an older
69842>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
69842>>>>>>>        Send Ignore_error to Error_object_Id 20491
69843>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
69848>>>>>>>        Send Trap_Error to Error_object_Id 20491
69849>>>>>>>        
69849>>>>>>>        Function_Return iRetval
69850>>>>>>>    End_Function
69851>>>>>>>    
69851>>>>>>>    
69851>>>>>>>    
69851>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
69851>>>>>>>    //
69851>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
69851>>>>>>>    //
69851>>>>>>>    
69851>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
69853>>>>>>>        Integer iPartRev
69853>>>>>>>        Integer iCurrentPart
69853>>>>>>>        Integer iSeparatorPos
69853>>>>>>>        
69853>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
69856>>>>>>>        
69856>>>>>>>        Move 0 to iCurrentPart
69857>>>>>>>        Repeat
69857>>>>>>>>
69857>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
69858>>>>>>>            If (iSeparatorPos > 0) Begin
69860>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
69861>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
69862>>>>>>>                Increment iCurrentPart
69863>>>>>>>            End
69863>>>>>>>>
69863>>>>>>>            Else If (sRevision <> "") Begin
69866>>>>>>>                Move sRevision to iPartRev
69867>>>>>>>                Move "" to sRevision
69868>>>>>>>                Increment iCurrentPart
69869>>>>>>>            End
69869>>>>>>>>
69869>>>>>>>            Else ;                Move -1 to iPartRev
69871>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
69873>>>>>>>        
69873>>>>>>>        Function_Return iPartRev
69874>>>>>>>    End_Function
69875>>>>>>>    
69875>>>>>>>    
69875>>>>>>>    
69875>>>>>>>    //
69875>>>>>>>    //  Returns the major revision of the CK
69875>>>>>>>    //
69875>>>>>>>    
69875>>>>>>>    Function CKMajorRevision Returns Integer
69877>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
69878>>>>>>>    End_Function
69879>>>>>>>    
69879>>>>>>>    
69879>>>>>>>    
69879>>>>>>>    //  Returns the minor revision of the CK
69879>>>>>>>    //
69879>>>>>>>    
69879>>>>>>>    Function CKMinorRevision Returns Integer
69881>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
69882>>>>>>>    End_Function
69883>>>>>>>    
69883>>>>>>>    
69883>>>>>>>    //  Returns the release revision of the CK
69883>>>>>>>    //
69883>>>>>>>    
69883>>>>>>>    Function CKReleaseRevision Returns Integer
69885>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
69886>>>>>>>    End_Function
69887>>>>>>>    
69887>>>>>>>    
69887>>>>>>>    //  Returns the major revision of the CK
69887>>>>>>>    //
69887>>>>>>>    
69887>>>>>>>    Function CKBuildRevision Returns Integer
69889>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
69890>>>>>>>    End_Function
69891>>>>>>>    
69891>>>>>>>    
69891>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
69891>>>>>>>    //
69891>>>>>>>    
69891>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
69893>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
69896>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
69899>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
69902>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
69905>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
69908>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
69912>>>>>>>            End
69912>>>>>>>>
69912>>>>>>>        End
69912>>>>>>>>
69912>>>>>>>        
69912>>>>>>>        Function_Return (False)
69913>>>>>>>    End_Function
69914>>>>>>>    
69914>>>>>>>    //   Functions to query the Pervasive.SQL version:
69914>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
69914>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
69914>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
69914>>>>>>>    //
69914>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
69914>>>>>>>    //   in the following format:
69914>>>>>>>    //       <version>.<revision>.<type>
69914>>>>>>>    //   possible values for <type>:
69914>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
69914>>>>>>>    //         server using Workgroup authentication mode
69914>>>>>>>    //       C for client cache engine
69914>>>>>>>    //       D for DOS workstation
69914>>>>>>>    //       N for client Requester
69914>>>>>>>    //       S for NetWare server
69914>>>>>>>    //       T for 32-bit Windows server engine
69914>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
69914>>>>>>>    //
69914>>>>>>>    //   example:
69914>>>>>>>    //       8.50.T
69914>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
69914>>>>>>>    //   32-bits Windows server.
69914>>>>>>>    //
69914>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
69914>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
69914>>>>>>>    //
69914>>>>>>>    //   If the version information is not available or can not be obtained
69914>>>>>>>    //   the functions will return "0.0.0"
69914>>>>>>>    
69914>>>>>>>    //  Returns the version information of the
69914>>>>>>>    //           Pervasive.SQL Client requester.
69914>>>>>>>    
69914>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
69916>>>>>>>        
69916>>>>>>>        String  sDriverID
69916>>>>>>>        String  sVersion
69916>>>>>>>        String  sVoid
69916>>>>>>>        Integer iRetval
69916>>>>>>>        
69916>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69916>>>>>>>        // This error would otherwise be raised when we have an older
69916>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69916>>>>>>>        Send Ignore_error to Error_object_Id 20491
69917>>>>>>>        Get psDriverID to sDriverID
69918>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69919>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69924>>>>>>>        Send Trap_Error to Error_object_Id 20491
69925>>>>>>>        If (Trim(sVersion) = "") Begin
69927>>>>>>>            // Unable to get the revision. return all zeroes.
69927>>>>>>>            Move "0.0.0" to sVersion
69928>>>>>>>        End
69928>>>>>>>>
69928>>>>>>>        Function_Return sVersion
69929>>>>>>>    End_Function
69930>>>>>>>    
69930>>>>>>>    //           Pervasive.SQL Engine
69930>>>>>>>    
69930>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
69932>>>>>>>        
69932>>>>>>>        String  sDriverID
69932>>>>>>>        String  sVersion
69932>>>>>>>        String  sVoid
69932>>>>>>>        Integer iRetval
69932>>>>>>>        
69932>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69932>>>>>>>        // This error would otherwise be raised when we have an older
69932>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69932>>>>>>>        Send Ignore_error to Error_object_Id 20491
69933>>>>>>>        Get psDriverID to sDriverID
69934>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69935>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69940>>>>>>>        Send Trap_Error to Error_object_Id 20491
69941>>>>>>>        If (Trim(sVersion) = "") Begin
69943>>>>>>>            // Unable to get the revision. return all zeroes.
69943>>>>>>>            Move "0.0.0" to sVersion
69944>>>>>>>        End
69944>>>>>>>>
69944>>>>>>>        Function_Return sVersion
69945>>>>>>>    End_Function
69946>>>>>>>    
69946>>>>>>>    //  Returns the version information of the
69946>>>>>>>    //           Pervasive.SQL Server Engine
69946>>>>>>>    
69946>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
69948>>>>>>>        
69948>>>>>>>        String  sDriverID
69948>>>>>>>        String  sVersion
69948>>>>>>>        String  sVoid
69948>>>>>>>        Integer iRetval
69948>>>>>>>        
69948>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69948>>>>>>>        // This error would otherwise be raised when we have an older
69948>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69948>>>>>>>        Send Ignore_error to Error_object_Id 20491
69949>>>>>>>        Get psDriverID to sDriverID
69950>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69951>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69956>>>>>>>        Send Trap_Error to Error_object_Id 20491
69957>>>>>>>        If (Trim(sVersion) = "") Begin
69959>>>>>>>            // Unable to get the revision. return all zeroes.
69959>>>>>>>            Move "0.0.0" to sVersion
69960>>>>>>>        End
69960>>>>>>>>
69960>>>>>>>        Function_Return sVersion
69961>>>>>>>    End_Function
69962>>>>>>>    
69962>>>>>>>End_Class
69963>>>>>>>
69963>>>>>>>
69963>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.0\Pkg\MSSqldrv.pkg)
69963>>>>>>>//     Package that declares MS SQL driver constants and functions.
69963>>>>>>>//     This package can be used by developers who want to add Data Access
69963>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69963>>>>>>>
69963>>>>>>>Use Cli.pkg
69963>>>>>>>Use SQL.pkg
69963>>>>>>>
69963>>>>>>>//   Driver Indentification
69963>>>>>>>
69963>>>>>>>//   Error number constants
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>// SQL Server spcific types.
69963>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69963>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69963>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69963>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69963>>>>>>>
69963>>>>>>>// SQL Server spcific types.
69963>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69963>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69963>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69963>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69963>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69963>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69963>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69963>>>>>>>//
69963>>>>>>>//     Setup a constraint for a file.
69963>>>>>>>
69963>>>>>>>
69963>>>>>>>Class cMSSQLHandler is a cCLIHandler
69964>>>>>>>    
69964>>>>>>>    Procedure Construct_Object
69966>>>>>>>        Forward Send Construct_Object
69968>>>>>>>        
69968>>>>>>>        Set psDriverID to MSSQLDRV_ID
69969>>>>>>>    End_Procedure
69970>>>>>>>    
69970>>>>>>>    
69970>>>>>>>    
69970>>>>>>>    //   Extract the list from the out connect string.
69970>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69972>>>>>>>        String  sItem
69972>>>>>>>        Integer iStart
69972>>>>>>>        Integer iEnd
69972>>>>>>>        
69972>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69975>>>>>>>        
69975>>>>>>>        Send Delete_Data to hoStore
69976>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69977>>>>>>>        While (iStart > 0)
69981>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69982>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69985>>>>>>>            Else Begin
69986>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69987>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69988>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69991>>>>>>>                
69991>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69994>>>>>>>                
69994>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69997>>>>>>>            End
69997>>>>>>>>
69997>>>>>>>        Loop
69998>>>>>>>>
69998>>>>>>>        
69998>>>>>>>        Function_Return (Item_Count(hoStore))
69999>>>>>>>    End_Procedure
70000>>>>>>>    
70000>>>>>>>    
70000>>>>>>>    
70000>>>>>>>    //   Call the driver's browse connect function
70000>>>>>>>    Function BrowseConnect String sInConnStr Returns String
70002>>>>>>>        String  sDriver
70002>>>>>>>        String  sOutConnStr
70002>>>>>>>        Integer iArg
70002>>>>>>>        Integer iRetval
70002>>>>>>>        
70002>>>>>>>        Get psDriverID to sDriver
70003>>>>>>>        If (sDriver <> "") Begin
70005>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70006>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70011>>>>>>>        End
70011>>>>>>>>
70011>>>>>>>        
70011>>>>>>>        Function_Return sOutConnStr
70012>>>>>>>    End_Function// BrowseConnect
70013>>>>>>>    
70013>>>>>>>    
70013>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
70015>>>>>>>        String  sDriver
70015>>>>>>>        String  sOutConnStr
70015>>>>>>>        Integer iArg
70015>>>>>>>        Integer iRetval
70015>>>>>>>        
70015>>>>>>>        Move 1 to iArg // Browses only local
70016>>>>>>>        
70016>>>>>>>        Get psDriverID to sDriver
70017>>>>>>>        If (sDriver <> "") Begin
70019>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70020>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70025>>>>>>>        End
70025>>>>>>>>
70025>>>>>>>        
70025>>>>>>>        Function_Return sOutConnStr
70026>>>>>>>    End_Function// BrowseConnect
70027>>>>>>>    
70027>>>>>>>    
70027>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
70029>>>>>>>        
70029>>>>>>>        String  sServerList
70029>>>>>>>        Integer iNumServers
70029>>>>>>>        Integer iDriver
70029>>>>>>>        Integer iClientVersion
70029>>>>>>>        String  sDriver
70029>>>>>>>        
70029>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
70030>>>>>>>        
70030>>>>>>>        If (iDriver) Begin
70032>>>>>>>            
70032>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
70035>>>>>>>            
70035>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
70036>>>>>>>            
70036>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
70037>>>>>>>            If (iNetworkLocal = 0) Begin
70039>>>>>>>                Get BrowseConnect sDriver to sServerList
70040>>>>>>>            End
70040>>>>>>>>
70040>>>>>>>            Else Begin
70041>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
70042>>>>>>>            End
70042>>>>>>>>
70042>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
70043>>>>>>>        End
70043>>>>>>>>
70043>>>>>>>        
70043>>>>>>>        Function_Return iNumServers
70044>>>>>>>        
70044>>>>>>>    End_Function
70045>>>>>>>    
70045>>>>>>>    //   Enumerate the available SQL Server database servers
70045>>>>>>>    //   This function will return all SQL Server instances on the network.
70045>>>>>>>    //   This may take a long time.
70045>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
70045>>>>>>>    Function EnumerateServers Returns Integer
70047>>>>>>>        
70047>>>>>>>        Integer iNumServers
70047>>>>>>>        Integer iNetworkLocal
70047>>>>>>>        
70047>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
70048>>>>>>>        
70048>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70049>>>>>>>        
70049>>>>>>>        Function_Return iNumServers
70050>>>>>>>        
70050>>>>>>>    End_Function
70051>>>>>>>    
70051>>>>>>>    
70051>>>>>>>    //   Enumerate the available SQL Server database servers
70051>>>>>>>    //   This function will return only return SQL Server instance on the local machine
70051>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
70051>>>>>>>    Function EnumerateServersLocal Returns Integer
70053>>>>>>>        
70053>>>>>>>        Integer iNumServers
70053>>>>>>>        Integer iNetworkLocal
70053>>>>>>>        
70053>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
70054>>>>>>>        
70054>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70055>>>>>>>        
70055>>>>>>>        Function_Return iNumServers
70056>>>>>>>        
70056>>>>>>>    End_Function
70057>>>>>>>    
70057>>>>>>>    
70057>>>>>>>    
70057>>>>>>>    //   Enumerate database in a given server.
70057>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
70059>>>>>>>        Integer hoSQL
70059>>>>>>>        String  sConnect
70059>>>>>>>        String  sDatabase
70059>>>>>>>        Integer hdbc
70059>>>>>>>        Integer hstmt
70059>>>>>>>        Integer iFetchResult
70059>>>>>>>        
70059>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70062>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70065>>>>>>>        
70065>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70068>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70070>>>>>>>        
70070>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70072>>>>>>>            Move Current_Object to hoSQL
70073>>>>>>>        End_Object
70074>>>>>>>        
70074>>>>>>>        If (hoSQL <> 0) Begin
70076>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70077>>>>>>>            If (hdbc <> 0) Begin
70079>>>>>>>                Get SQLOpen of hdbc to hstmt
70080>>>>>>>                If (hstmt <> 0) Begin
70082>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70082>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70082>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70082>>>>>>>                    //   stay the same.
70082>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70083>>>>>>>                    Send SQLCall to hstmt
70084>>>>>>>                    Repeat
70084>>>>>>>>
70084>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70085>>>>>>>                        If (iFetchResult <> 0) Begin
70087>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70088>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70089>>>>>>>                        End
70089>>>>>>>>
70089>>>>>>>                    Until (iFetchResult = 0)
70091>>>>>>>                    
70091>>>>>>>                    Send SQLClose to hstmt
70092>>>>>>>                End
70092>>>>>>>>
70092>>>>>>>                Send SQLDisconnect to hdbc
70093>>>>>>>            End
70093>>>>>>>>
70093>>>>>>>        End
70093>>>>>>>>
70093>>>>>>>        Send Destroy_Object to hoSQL
70094>>>>>>>        
70094>>>>>>>        Function_Return (Item_Count(Current_Object))
70095>>>>>>>    End_Function
70096>>>>>>>    
70096>>>>>>>    
70096>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70098>>>>>>>        
70098>>>>>>>        String  sSqlServerClientVersionName
70098>>>>>>>        
70098>>>>>>>        
70098>>>>>>>        Case Begin
70098>>>>>>>            
70098>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70100>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70101>>>>>>>                Case Break
70102>>>>>>>                
70102>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70105>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70106>>>>>>>                Case Break
70107>>>>>>>            
70107>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70110>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70111>>>>>>>                Case Break
70112>>>>>>>            
70112>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70115>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70116>>>>>>>                Case Break
70117>>>>>>>            
70117>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70120>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70121>>>>>>>                Case Break
70122>>>>>>>            
70122>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70125>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70126>>>>>>>                Case Break
70127>>>>>>>            
70127>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70130>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70131>>>>>>>                Case Break
70132>>>>>>>            
70132>>>>>>>            Case Else
70132>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70133>>>>>>>                
70133>>>>>>>        Case End
70133>>>>>>>        
70133>>>>>>>        
70133>>>>>>>        Function_Return sSqlServerClientVersionName
70134>>>>>>>        
70134>>>>>>>    End_Function
70135>>>>>>>
70135>>>>>>>
70135>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70137>>>>>>>        
70137>>>>>>>        String  sSqlServerClientDriverName
70137>>>>>>>        
70137>>>>>>>        Case Begin
70137>>>>>>>            
70137>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70139>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70140>>>>>>>                Case Break
70141>>>>>>>                
70141>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70144>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70145>>>>>>>                Case Break
70146>>>>>>>            
70146>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70149>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70150>>>>>>>                Case Break
70151>>>>>>>            
70151>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70154>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70155>>>>>>>                Case Break
70156>>>>>>>            
70156>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70159>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70160>>>>>>>                Case Break
70161>>>>>>>            
70161>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70164>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70165>>>>>>>                Case Break
70166>>>>>>>            
70166>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70169>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70170>>>>>>>                Case Break
70171>>>>>>>            
70171>>>>>>>            Case Else
70171>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70172>>>>>>>                
70172>>>>>>>        Case End
70172>>>>>>>        
70172>>>>>>>        
70172>>>>>>>        Function_Return sSqlServerClientDriverName
70173>>>>>>>        
70173>>>>>>>    End_Function
70174>>>>>>>    
70174>>>>>>>    
70174>>>>>>>End_Class
70175>>>>>>>
70175>>>>>>>
70175>>>>>
70175>>>>>Register_Function phoWorkspace Returns Handle
70175>>>>>Register_Function Help_filename Returns String
70175>>>>>Register_Function GetHelpFile Returns String
70175>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
70175>>>>>
70175>>>>>// Do not call directly, use the wrapper function instead
70175>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70176>>>>>
70176>>>>>// Wrapper Function WNetGetUser
70176>>>>>Function WNetGetUser Global ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70178>>>>>    
70178>>>>>    DWord   dwResult     
70178>>>>>    UWide   uwName uwUserName
70178>>>>>    UWide   uwName uwUserName
70178>>>>>        
70178>>>>>    Send StringToWide lpName (&uwName)
70179>>>>>    
70179>>>>>    Send WideSetBuffer lpUser_Name lpLength (&uwUserName)    
70180>>>>>    
70180>>>>>    Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
70181>>>>>    
70181>>>>>    Send WideToString (&uwUserName) lpUser_Name
70182>>>>>    
70182>>>>>    Function_Return dwResult
70183>>>>>End_Function
70184>>>>>
70184>>>>>//    This function reads the current username Of windows and returns that
70184>>>>>//    name or an text unknown user
70184>>>>>Function Network_User_Name for cDesktop Returns String
70186>>>>>    WString wName
70186>>>>>    Integer iRetval iLength
70186>>>>>    
70186>>>>>    Move 0 to iLength
70187>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
70188>>>>>    Move (ZeroString(iLength)) to wName
70189>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
70190>>>>>    
70190>>>>>    If (iRetval = NO_ERROR) Begin
70192>>>>>        Function_Return (CString (wName))
70193>>>>>    End
70193>>>>>>
70193>>>>>    
70193>>>>>    Function_Return "User Unknown"
70194>>>>>End_Function
70195>>>>>
70195>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
70196>>>>>
70196>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
70197>>>>>
70197>>>>>Class SysinfoDisplay is a cTextEdit
70198>>>>>    Procedure Construct_Object
70200>>>>>        Forward Send Construct_Object
70202>>>>>        
70202>>>>>        Set Location to 6 6
70203>>>>>        Set Size to 110 255
70204>>>>>        Set Read_Only_State to True
70205>>>>>        Set pbWrap to False
70206>>>>>    End_Procedure
70207>>>>>    
70207>>>>>    //    This method will show the name Of the current directory in the system
70207>>>>>    //    information box
70207>>>>>    Procedure Show_Current_Directory
70209>>>>>        String sDir
70209>>>>>        
70209>>>>>        Get_Current_Directory to sDir
70210>>>>>        
70210>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
70211>>>>>    End_Procedure
70212>>>>>    
70212>>>>>    Procedure Show_Windows_Directory
70214>>>>>        String sWindir
70214>>>>>        
70214>>>>>        Get_Windows_Directory to sWindir
70215>>>>>        
70215>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
70216>>>>>    End_Procedure
70217>>>>>    
70217>>>>>    Procedure Show_Current_User
70219>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
70220>>>>>    End_Procedure
70221>>>>>    
70221>>>>>    Procedure Show_Number_Format
70223>>>>>        Integer iFormat
70223>>>>>        String sFormatText
70223>>>>>        
70223>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
70226>>>>>        Move (Character (iFormat)) to sFormatText
70227>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
70228>>>>>        
70228>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
70231>>>>>        Move (Character (iFormat)) to sFormatText
70232>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
70233>>>>>    End_Procedure
70234>>>>>    
70234>>>>>    Procedure Show_Filelist_Name
70236>>>>>        String sFilename
70236>>>>>        
70236>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
70239>>>>>        
70239>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
70240>>>>>        Send AppendTextLn ""
70241>>>>>    End_Procedure
70242>>>>>    
70242>>>>>    Procedure Show_Lock_Delay
70244>>>>>        Integer iLockdelay
70244>>>>>        
70244>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
70247>>>>>        
70247>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
70248>>>>>    End_Procedure
70249>>>>>    
70249>>>>>    Procedure Show_Lock_Timeout
70251>>>>>        Integer iLockTimeout
70251>>>>>        
70251>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
70254>>>>>        
70254>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
70255>>>>>    End_Procedure
70256>>>>>    
70256>>>>>    Procedure Show_Screen_Size
70258>>>>>        Integer iYscreensize iXscreensize
70258>>>>>        
70258>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
70259>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
70260>>>>>        
70260>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
70261>>>>>    End_Procedure
70262>>>>>    
70262>>>>>    Procedure Show_Page_Size
70264>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
70265>>>>>    End_Procedure
70266>>>>>    
70266>>>>>    Procedure Show_Date
70268>>>>>        Date dToday
70268>>>>>        
70268>>>>>        Move (CurrentDateTime()) to  dToday
70269>>>>>        
70269>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
70270>>>>>    End_Procedure
70271>>>>>    
70271>>>>>    Procedure Show_Date_Format
70273>>>>>        Integer iDateFormat
70273>>>>>        String sDateFormat
70273>>>>>        
70273>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
70276>>>>>        Case Begin
70276>>>>>            Case (iDateFormat = DF_DATE_USA)
70278>>>>>                Move C_$USA to sDateFormat
70279>>>>>                Case Break
70280>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
70283>>>>>                Move C_$European to sDateFormat
70284>>>>>                Case Break
70285>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
70288>>>>>                Move C_$Military to sDateFormat
70289>>>>>                Case Break
70290>>>>>            Case Else
70290>>>>>                Move C_$UnknownDateType to sDateFormat
70291>>>>>                Case Break
70292>>>>>        Case End
70292>>>>>        
70292>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
70293>>>>>    End_Procedure
70294>>>>>    
70294>>>>>    Procedure Show_Systemresources
70296>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70296>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70296>>>>>        Integer iRetval
70296>>>>>        
70296>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
70297>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
70298>>>>>        If (iRetval = 0) Begin
70300>>>>>            Move (ShowLastError ()) to iRetval
70301>>>>>        End
70301>>>>>>
70301>>>>>        
70301>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
70302>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
70303>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
70304>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
70305>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
70306>>>>>    End_Procedure
70307>>>>>    
70307>>>>>    Procedure Show_Registration
70309>>>>>        String sRegName
70309>>>>>        Integer iSN iMaxUsers
70309>>>>>        
70309>>>>>        Registration sRegName iSN
70310>>>>>>
70310>>>>>        
70310>>>>>        Get_Licensed_Max_Users to iMaxUsers
70311>>>>>        
70311>>>>>        Send AppendTextLn ""
70312>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
70313>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
70314>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
70315>>>>>    End_Procedure
70316>>>>>    
70316>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
70316>>>>>    // To the workspace object passing the an object and message To send back
70316>>>>>    // To this object. It is expected that the workspace object will send this
70316>>>>>    // message for every line Of information it wants displayed (passing the
70316>>>>>    // information To be displayed
70316>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
70316>>>>>    
70316>>>>>    Procedure Show_ServicePack
70318>>>>>        String sKey sVersionDescription sVersion
70318>>>>>        Handle hoRegistry
70318>>>>>        Boolean bExists bOpened
70318>>>>>        
70318>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
70319>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
70320>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
70321>>>>>        
70321>>>>>        Move C_DFVersionRegistryRoot to sKey
70322>>>>>        Get KeyExists of hoRegistry sKey to bExists
70323>>>>>        If (bExists) Begin
70325>>>>>            Get OpenKey of hoRegistry sKey to bOpened
70326>>>>>            If (bOpened) Begin
70328>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
70329>>>>>                If (bExists) Begin
70331>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
70332>>>>>                End
70332>>>>>>
70332>>>>>                
70332>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
70333>>>>>                If (bExists) Begin
70335>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
70336>>>>>                End
70336>>>>>>
70336>>>>>                Send CloseKey of hoRegistry
70337>>>>>            End
70337>>>>>>
70337>>>>>        End
70337>>>>>>
70337>>>>>        Send Destroy of hoRegistry
70338>>>>>        
70338>>>>>        If (sVersionDescription <> "") Begin
70340>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
70341>>>>>            Send AppendTextLn ""
70342>>>>>        End
70342>>>>>>
70342>>>>>    End_Procedure
70343>>>>>    
70343>>>>>    
70343>>>>>    Procedure Show_WorkspaceInformation
70345>>>>>        Integer hoWorkspace
70345>>>>>        
70345>>>>>        If (ghoApplication <> 0) Begin
70347>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70348>>>>>            If (hoWorkspace <> 0) Begin
70350>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
70351>>>>>                Send AppendTextLn ""
70352>>>>>            End
70352>>>>>>
70352>>>>>        End
70352>>>>>>
70352>>>>>    End_Procedure
70353>>>>>    
70353>>>>>    // If connection ids are used, we will send the message EnumerateConnections
70353>>>>>    // to the connection manager object passing the an object and message to send
70353>>>>>    // back to this object. It is expected that the connection manager object will
70353>>>>>    // send this message for every line Of information it wants displayed (passing
70353>>>>>    // the information To be displayed
70353>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
70353>>>>>    
70353>>>>>    Procedure Show_ConnectionIdInformation
70355>>>>>        If (ghoConnection > 0) Begin
70357>>>>>            Send AppendTextLn ""
70358>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
70359>>>>>        End
70359>>>>>>
70359>>>>>    End_Procedure
70360>>>>>    
70360>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
70362>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
70363>>>>>    End_Function
70364>>>>>    
70364>>>>>    Procedure Show_Versions
70366>>>>>        Integer iVersion iRevision iBuild
70366>>>>>        
70366>>>>>        Version_Information iVersion iRevision iBuild
70368>>>>>        
70368>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
70369>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
70370>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
70371>>>>>    End_Procedure
70372>>>>>    
70372>>>>>    Procedure Show_Platform
70374>>>>>        Send AppendTextLn (SFormat (C_$Platform,"32-bit"))
70375>>>>>    End_Procedure
70376>>>>>    
70376>>>>>    Function CKRevisionNumber String sDriverID Returns String
70378>>>>>        Handle hoCLIHandler
70378>>>>>        Handle hoDFBtrDrvHandler
70378>>>>>        String sCKRevision
70378>>>>>        
70378>>>>>        
70378>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
70380>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
70381>>>>>            Set psDriverID of hoCLIHandler to sDriverID
70382>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
70383>>>>>            Send Destroy of hoCLIHandler
70384>>>>>        End
70384>>>>>>
70384>>>>>        Else Begin
70385>>>>>            If (sDriverID = "DFBTRDRV") Begin
70387>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
70388>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
70389>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
70390>>>>>                Send Destroy of hoDFBtrDrvHandler
70391>>>>>            End
70391>>>>>>
70391>>>>>        End
70391>>>>>>
70391>>>>>        
70391>>>>>        Function_Return sCKRevision
70392>>>>>    End_Function
70393>>>>>    
70393>>>>>    
70393>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
70395>>>>>        
70395>>>>>        If (sDriverID = "DATAFLEX") Begin
70397>>>>>            Function_Return False
70398>>>>>        End
70398>>>>>>
70398>>>>>        
70398>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
70399>>>>>    End_Function
70400>>>>>    
70400>>>>>    
70400>>>>>    Procedure Show_Drivers
70402>>>>>        String sCurrentDriver sRevNumber
70402>>>>>        String sLoadedDrivers sClientDriver
70402>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
70402>>>>>        Boolean bOK
70402>>>>>        Handle hoMsqlDrv
70402>>>>>        
70402>>>>>        Move "" to sLoadedDrivers
70403>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
70406>>>>>        For iCount from 1 to iNumberOfDrivers
70412>>>>>>
70412>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
70415>>>>>            If (sLoadedDrivers <> "") Begin
70417>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
70418>>>>>            End
70418>>>>>>
70418>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
70419>>>>>            If (bOK) Begin
70421>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
70423>>>>>                    Move iCount to iMSSQLIndex
70424>>>>>                End
70424>>>>>>
70424>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
70425>>>>>                // if mssqldrv, show the client number
70425>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
70426>>>>>            End
70426>>>>>>
70426>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
70427>>>>>        Loop
70428>>>>>>
70428>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
70429>>>>>        If (iMSSQLIndex>0) Begin
70431>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
70434>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
70435>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
70436>>>>>            Send Destroy of hoMsqlDrv
70437>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
70438>>>>>        End
70438>>>>>>
70438>>>>>    End_Procedure
70439>>>>>    
70439>>>>>    Procedure Show_HelpFile
70441>>>>>        String sHelpFile
70441>>>>>        Integer eHelpType
70441>>>>>        
70441>>>>>        If (ghoApplication <> 0) Begin
70443>>>>>            Get peHelpType of ghoApplication to eHelpType
70444>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
70446>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
70447>>>>>            End
70447>>>>>>
70447>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
70450>>>>>                Get Help_filename of Help_object_id to sHelpFile
70451>>>>>            End
70451>>>>>>
70451>>>>>            Else Begin
70452>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
70453>>>>>            End
70453>>>>>>
70453>>>>>            
70453>>>>>            Send AppendTextLn ""
70454>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
70455>>>>>        End
70455>>>>>>
70455>>>>>    End_Procedure
70456>>>>>    
70456>>>>>    Procedure Show_EnterAsTab
70458>>>>>        Boolean bEnterKeyAsTabKey
70458>>>>>        String sText
70458>>>>>        
70458>>>>>        If (ghoApplication <> 0) Begin
70460>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
70461>>>>>            If (bEnterKeyAsTabKey) Begin
70463>>>>>                Move "True" to sText
70464>>>>>            End
70464>>>>>>
70464>>>>>            Else Begin
70465>>>>>                Move "False" to sText
70466>>>>>            End
70466>>>>>>
70466>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
70467>>>>>        End
70467>>>>>>
70467>>>>>    End_Procedure
70468>>>>>    
70468>>>>>    //    During activation we will remove the old information and add the newly
70468>>>>>    //    found systeminformation
70468>>>>>    Procedure Add_Focus Integer hoRoot
70470>>>>>        Forward Send Add_Focus hoRoot
70472>>>>>        
70472>>>>>        Send Delete_Data
70473>>>>>        
70473>>>>>        Set Changed_State to False
70474>>>>>        Set Read_Only_State to True
70475>>>>>        
70475>>>>>        Send Show_ServicePack
70476>>>>>        Send Show_Versions
70477>>>>>        Send Show_Platform
70478>>>>>        Send Show_Drivers
70479>>>>>        If (ghoConnection <> 0) Begin
70481>>>>>            Send Show_ConnectionIdInformation
70482>>>>>        End
70482>>>>>>
70482>>>>>        Send Show_HelpFile
70483>>>>>        Send Show_Current_Directory
70484>>>>>        Send Show_Filelist_Name
70485>>>>>        If (ghoApplication <> 0) Begin
70487>>>>>            Send Show_WorkSpaceInformation // added To show WS info
70488>>>>>        End
70488>>>>>>
70488>>>>>        Send Show_Current_User
70489>>>>>        Send Show_Windows_Directory
70490>>>>>        Send Show_Screen_Size
70491>>>>>        Send Show_Page_Size
70492>>>>>        Send Show_EnterAsTab
70493>>>>>        Send Show_Number_Format
70494>>>>>        Send Show_Date_Format
70495>>>>>        Send Show_Lock_Delay
70496>>>>>        Send Show_Lock_Timeout
70497>>>>>        Send Show_Date
70498>>>>>        Send Show_Systemresources
70499>>>>>        Send Show_Registration
70500>>>>>        Send Beginning_of_Data
70501>>>>>        
70501>>>>>        Set Icon to 'default.ico'
70502>>>>>    End_Procedure
70503>>>>>End_Class
70504>>>>>
70504>>>>>Class SysInfoDialog is a ModalPanel
70505>>>>>    Procedure Construct_Object
70507>>>>>        Forward Send Construct_Object
70509>>>>>        
70509>>>>>        Set Label to C_$SystemInformation
70510>>>>>        Set Size to 140 267
70511>>>>>        Set piMinSize to 140 267
70512>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70513>>>>>        Set Border_Style to Border_Thick
70514>>>>>        
70514>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
70516>>>>>            Set peAnchors to anAll
70517>>>>>        End_Object
70518>>>>>        
70518>>>>>        Object oCloseButton is a Button
70520>>>>>            Set Label to C_$Close
70521>>>>>            Set Location to 120 210
70522>>>>>            Set Message 0 to (Refproc (Close_Panel))
70523>>>>>            Set Default_State to True
70524>>>>>            Set peAnchors to anBottomRight
70525>>>>>        End_Object
70526>>>>>        
70526>>>>>        On_Key kCancel Send Close_Panel
70527>>>>>    End_Procedure
70528>>>>>End_Class
70529>>>>>
70529>>>>>Class AboutDialog is a ModalPanel
70530>>>>>    Procedure Construct_Object
70532>>>>>        String sVdfRootDir
70532>>>>>        
70532>>>>>        Forward Send Construct_Object
70534>>>>>        
70534>>>>>        Set Label to C_$About
70535>>>>>        Set Size to 89 212
70536>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70537>>>>>        
70537>>>>>        Object oSysInfoDialog is a SysInfoDialog
70539>>>>>        End_Object
70540>>>>>        
70540>>>>>        Object oBox is a Container3d
70542>>>>>            Set Border_Style to Border_StaticEdge
70543>>>>>            Set Size to 63 202
70544>>>>>            Set Location to 4 5
70545>>>>>            
70545>>>>>            Object oAboutGraphic is a BitmapContainer
70547>>>>>                Set Border_Style to Border_None
70548>>>>>                Set Bitmap_Style to Bitmap_Center
70549>>>>>                Set Size to 48 48
70550>>>>>                Set Location to 7 2
70551>>>>>            End_Object
70552>>>>>            
70552>>>>>            Object oProductName is a TextBox
70554>>>>>                Set Label to C_$ProductName
70555>>>>>                Set Size to 10 45
70556>>>>>                Set Location to 8 53
70557>>>>>            End_Object
70558>>>>>            
70558>>>>>            Object oVersion is a TextBox
70560>>>>>                Set Label to C_$Version
70561>>>>>                Set Size to 10 25
70562>>>>>                Set Location to 21 53
70563>>>>>            End_Object
70564>>>>>            
70564>>>>>            Object oCopyright is a TextBox
70566>>>>>                Set Label to C_$Copyright
70567>>>>>                Set Size to 10 31
70568>>>>>                Set Location to 34 53
70569>>>>>            End_Object
70570>>>>>            
70570>>>>>            Object oAuthor is a TextBox
70572>>>>>                Set Label to C_$Author
70573>>>>>                Set Size to 10 22
70574>>>>>                Set Location to 46 53
70575>>>>>            End_Object
70576>>>>>        End_Object
70577>>>>>        
70577>>>>>        Object oOKButton is a Button
70579>>>>>            On_Item C_$OK Send Close_Panel
70580>>>>>            Set Size to 14 50
70581>>>>>            Set Location to 71 157
70582>>>>>        End_Object
70583>>>>>        
70583>>>>>        Object oSysInfoButton is a Button
70585>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
70586>>>>>            Set Size to 14 50
70587>>>>>            Set Location to 71 101
70588>>>>>        End_Object
70589>>>>>        
70589>>>>>        On_Key Kcancel Send KeyAction of oOKButton
70590>>>>>        
70590>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
70591>>>>>    End_Procedure
70592>>>>>    
70592>>>>>    Procedure Set ProductName String sProductName
70594>>>>>        Set Label of oProductName to sProductName
70595>>>>>    End_Procedure
70596>>>>>    
70596>>>>>    Procedure Set Version String sVersion
70598>>>>>        Set Label of oVersion to sVersion
70599>>>>>    End_Procedure
70600>>>>>    
70600>>>>>    Procedure Set Copyright String sCopyright
70602>>>>>        Set Label of oCopyright to sCopyright
70603>>>>>    End_Procedure
70604>>>>>    
70604>>>>>    Procedure Set Author String sAuthor
70606>>>>>        Set Label of oAuthor to sAuthor
70607>>>>>    End_Procedure
70608>>>>>    
70608>>>>>    Procedure Set Logo String sLogo
70610>>>>>        // square bitmaps Of 42x42 work best
70610>>>>>        Set Bitmap of oAboutGraphic to sLogo
70611>>>>>    End_Procedure
70612>>>>>    
70612>>>>>    Procedure Show_Sysinfo
70614>>>>>        Send Popup_Modal of oSysinfoDialog
70615>>>>>    End_Procedure
70616>>>>>    
70616>>>>>    Procedure End_Construct_Object
70618>>>>>        Handle hoVersionInfo
70618>>>>>        Boolean bIncluded
70618>>>>>        Integer iMajor iMinor iRelease iBuild
70618>>>>>        String sLabel
70618>>>>>        
70618>>>>>        Get Label of oVersion to sLabel
70619>>>>>        If (sLabel = C_$VERSION) Begin
70621>>>>>            // set it To the version info Of the program, if available
70621>>>>>            If (ghoApplication <> 0) Begin
70623>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
70624>>>>>                If (hoVersionInfo <> 0) Begin
70626>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
70627>>>>>                    If (bIncluded) Begin
70629>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
70630>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
70631>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
70632>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
70633>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
70634>>>>>                        Set Version to sLabel
70635>>>>>                    End
70635>>>>>>
70635>>>>>                End
70635>>>>>>
70635>>>>>            End
70635>>>>>>
70635>>>>>        End
70635>>>>>>
70635>>>>>        
70635>>>>>        Forward Send End_Construct_Object
70637>>>>>    End_Procedure
70638>>>>>End_Class
70639>>>
70639>>>//  This is the default message. It is expected that you will
70639>>>//  create your own message to override this
70639>>>Procedure Activate_About
70642>>>    Send DoAbout "" "" "" "" ""
70643>>>End_Procedure
70644>>>
70644>>>//  It is expected that you will send this message (most
70644>>>//  likely from Activate_About. This creates an about object, activates it
70644>>>//  and destroys it when done. It is not exepected that you will augment this.
70644>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
70647>>>    Integer hoObj hoMain
70647>>>    
70647>>>    // create object
70647>>>    Object About is an AboutDialog
70649>>>        // if no title passed use the label of the main panel
70649>>>        // (if a main panel exists).
70649>>>        If (sTitle = "") Begin
70651>>>            Get Main_Window of desktop to hoMain
70652>>>            If hoMain ;                Get Label of hoMain to sTitle
70655>>>        End
70655>>>>
70655>>>        Set productname to sTitle
70656>>>        Set version     to sVersion
70657>>>        Set copyright   to sCopyRight
70658>>>        Set author      to sAuthor
70659>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
70662>>>        Move Self to hoObj // object Id
70663>>>    End_Object
70664>>>    Send Popup   of hoObj    // popup the about object
70665>>>    Send Destroy of hoObj // when done, it will be destroyed
70666>>>End_Procedure
70667>>>
70667>        Use ConsultaDiretorio.vw
Including file: ConsultaDiretorio.vw    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\ConsultaDiretorio.vw)
70667>>>Use Windows.pkg
70667>>>Use DFClient.pkg
70667>>>Use DFTabDlg.pkg
70667>>>Use DfAllEnt.pkg
70667>>>Use File_dlg.pkg
70667>>>
70667>>>Activate_View Activate_oConsultaDiretorio for oConsultaDiretorio
70677>>>>
70677>>>Object oConsultaDiretorio is a dbView
70679>>>    Set Label to "Consulta"
70680>>>    Set Size to 73 470
70681>>>    Set Location to -1 4
70682>>>    
70682>>>    Object oOpenExplorer is a Form
70684>>>        Set Size to 14 326
70685>>>        Set Location to 14 68
70686>>>        Set Label to "Caminho arquivo:"
70687>>>
70687>>>        Procedure OnChange
70690>>>            Forward Send OnChange
70692>>>            
70692>>>            Get Value of oOpenExplorer to sDirOpenExlorer
70693>>>        End_Procedure
70694>>>    End_Object
70695>>>        
70695>>>    Object oReadDir is a Form
70697>>>        Set Size to 14 326
70698>>>        Set Location to 44 68
70699>>>        Set Label to "Caminho arquivo:"
70700>>>    
70700>>>        Procedure OnChange           
70703>>>            Forward Send OnChange
70705>>>            
70705>>>            Get Value of oReadDir to sReadDir
70706>>>        End_Procedure
70707>>>    End_Object
70708>>>              
70708>>>    Object oButton1 is a Button
70710>>>        Set Size to 15 56
70711>>>        Set Location to 14 401
70712>>>        Set Label to "Abrir explorer"
70713>>>        
70713>>>        Procedure OnClick
70716>>>            Boolean bFileExists
70716>>>            
70716>>>            File_Exist sDirOpenExlorer bFileExists
70717>>>                                               
70717>>>            If bFileExists Begin
70719>>>                Runprogram Background ('c:\windows\explorer.exe' *  '"' + ((sDirOpenExlorer)) + '"')
70720>>>            End
70720>>>>
70720>>>            Else Begin
70721>>>                
70721>>>            End
70721>>>>
70721>>>        End_Procedure  
70722>>>    End_Object
70723>>>    
70723>>>    Object oButton2 is a Button
70725>>>        Set Size to 14 56
70726>>>        Set Location to 44 401
70727>>>        Set Label to "Ver diretorio"
70728>>>        
70728>>>        Procedure OnClick
70731>>>            Boolean bFileExists
70731>>>            
70731>>>            File_Exist sReadDir bFileExists
70732>>>                                                 
70732>>>            If bFileExists Begin
70734>>>                Send Activate_oConteudoDiretorio 
70735>>>            End
70735>>>>
70735>>>            Else Begin
70736>>>                Send Info_Box "Caminho não encontrado"
70737>>>            End
70737>>>>
70737>>>        End_Procedure   
70738>>>    End_Object
70739>>>End_Object
70740>        Use ConteudoDiretorio.vw
Including file: ConteudoDiretorio.vw    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\ConteudoDiretorio.vw)
70740>>>Use Windows.pkg
70740>>>Use DFClient.pkg
70740>>>Use DFTabDlg.pkg
70740>>>Use DfAllEnt.pkg
70740>>>Use cCJGrid.pkg
70740>>>Use cCJGridColumn.pkg
70740>>>Use cFilesystem.pkg
Including file: cFilesystem.pkg    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\cFileSystem\AppSrc\cFilesystem.pkg)
70740>>>>>//************************************************************************
70740>>>>>//*** FileSystem - Binary file operations For VDF15+.
70740>>>>>//************************************************************************
70740>>>>>//*** Based on original package: akefs.pkg
70740>>>>>//*** Version: 4.0
70740>>>>>//*** (C) NordTeam Gruppen, NOVAX A/S
70740>>>>>//***
70740>>>>>//*** Author......: Allan Kim Eriksen
70740>>>>>//*** Created.....: 23/08 2001
70740>>>>>//***
70740>>>>>//*** Rev History.: 31/08 2018 Nils Svedmyr. Added Functions from Akefs.pkg
70740>>>>>//***               to get/set file date/time and procedure SetFileLastWriteTime.
70740>>>>>//***               Refactored functions FileSize & FileDate to only have one Function_Return,
70740>>>>>//***               and changed a couple of While loops to end with a "loop" word instead of "End".
70740>>>>>//***
70740>>>>>//************************************************************************
70740>>>>>// cFilesystem class with functions and procedures to access binary files.
70740>>>>>// Filenumbers are not limited to 10 but only to system resources.
70740>>>>>// Also windows API calls For file copy, file move ect.
70740>>>>>// This class is For vdf 15 and up.
70740>>>>>// This class is not limited to 2 GB but can handle filesizes up $7FFFFFFFFFFFFFFF (9 exabyte)
70740>>>>>
70740>>>>>//************************************************************************
70740>>>>>// Be aware that argument_size has to be larger
70740>>>>>// than the requested amount of bytes read in the buffer for
70740>>>>>// BytesFromBinaryFile.
70740>>>>>//************************************************************************
70740>>>>>
70740>>>>>//************************************************************************
70740>>>>>// Constants used For the external functions.
70740>>>>>//************************************************************************
70740>>>>>// fsCreatefile.
70740>>>>>    Define GENERIC_READ for            |CI$80000000
70740>>>>>    Define GENERIC_WRITE for           |CI$40000000
70740>>>>>    Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
70740>>>>>    Define CREATE_NEW for              |CI$00000001
70740>>>>>    Define CREATE_ALWAYS for           |CI$00000002
70740>>>>>    Define OPEN_EXISTING for           |CI$00000003
70740>>>>>    Define OPEN_ALWAYS for             |CI$00000004
70740>>>>>    Define TRUNCATE_EXISTING for       |CI$00000005
70740>>>>>
70740>>>>>
70740>>>>>    Define FILE_SHARE_READ for         |CI$1
70740>>>>>    Define FILE_SHARE_WRITE for        |CI$2
70740>>>>>    Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
70740>>>>>
70740>>>>>// Generel.
70740>>>>>Define FNULL For                   |CI$0
70740>>>>>
70740>>>>>// FormatString.
70740>>>>>
70740>>>>>// SetFilePosition.
70740>>>>>Define FILE_BEGIN For     0
70740>>>>>Define FILE_CURRENT For  1
70740>>>>>Define FILE_END For      2
70740>>>>>Define INVALID_SET_FILE_POINTER For |CI$FFFFFFFF
70740>>>>>
70740>>>>>// FindFile.
70740>>>>>
70740>>>>>Define ERROR_NO_MORE_FILES    For |CI18
70740>>>>>Define ERROR_MOD_NOT_FOUND    For |CI126
70740>>>>>
70740>>>>>
70740>>>>>
70740>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileFlags.
70740>>>>>
70740>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileOS.
70740>>>>>Define VOS_DOS          For |CI$10000
70740>>>>>Define VOS_NT           For |CI$40000
70740>>>>>Define VOS_WINDOWS16    For |CI$00001
70740>>>>>Define VOS_WINDOWS32    For |CI$00004
70740>>>>>Define VOS_OS216        For |CI$20000
70740>>>>>Define VOS_OS232        For |CI$30000
70740>>>>>Define VOS_PM16         For |CI$00002
70740>>>>>Define VOS_PM32         For |CI$00003
70740>>>>>Define VOS_UNKNOWN      For |CI$00000
70740>>>>>
70740>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileType.
70740>>>>>Define VFT_APP          For |CI$01
70740>>>>>Define VFT_DLL          For |CI$02
70740>>>>>Define VFT_DRV          For |CI$03
70740>>>>>Define VFT_FONT         For |CI$04
70740>>>>>Define VFT_STATIC_LIB   For |CI$07
70740>>>>>Define VFT_UNKNOWN      For |CI$00
70740>>>>>Define VFT_VXD          For |CI$05
70740>>>>>
70740>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
70740>>>>>Define VFT2_DRV_COMM                For |CI$0A
70740>>>>>Define VFT2_DRV_DISPLAY             For |CI$04
70740>>>>>Define VFT2_DRV_INSTALLABLE         For |CI$08
70740>>>>>Define VFT2_DRV_KEYBOARD            For |CI$02
70740>>>>>Define VFT2_DRV_LANGUAGE            For |CI$03
70740>>>>>Define VFT2_DRV_MOUSE               For |CI$05
70740>>>>>Define VFT2_DRV_NETWORK             For |CI$06
70740>>>>>Define VFT2_DRV_PRINTER             For |CI$01
70740>>>>>Define VFT2_DRV_SOUND               For |CI$09
70740>>>>>Define VFT2_DRV_SYSTEM              For |CI$07
70740>>>>>Define VFT2_DRV_VERSIONED_PRINTER   For |CI$0C
70740>>>>>
70740>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
70740>>>>>Define VFT2_FONT_RASTER             For |CI$01
70740>>>>>Define VFT2_FONT_TRUETYPE           For |CI$03
70740>>>>>Define VFT2_FONT_VECTOR             For |CI$02
70740>>>>>
70740>>>>>Define VFT2_UNKNOWN                 For |CI$00
70740>>>>>
70740>>>>>Define FS_FILEHANDLEMISSING For "The filehandle does not exists For the current filenumber."
70740>>>>>
70740>>>>>// Filesearch
70740>>>>>Enum_List
70740>>>>>    Define DIRMODE_FILES_ONLY For 1
70740>>>>>    Define DIRMODE_DIRECTORIES_ONLY
70740>>>>>    Define DIRMODE_FILES_AND_DIRECTORIES
70740>>>>>End_Enum_List
70740>>>>>
70740>>>>>//************************************************************************
70740>>>>>// Declarations of external functions.
70740>>>>>// Functions that needs variables For output are made global stings or
70740>>>>>// integers, and can be found on top of the declaration.
70740>>>>>//************************************************************************
70740>>>>>External_Function fsCreatefile "CreateFileW" kernel32.dll ;WString wFile ;       //filenameDWord dwDesAccess ;   // access modeDWord dwShare ;       // share modePointer lpSecAtt ;    // SDDWord dwCrDisp ;      // how to createDWord dwFlags ;       // file attributesHandle hTempFile ;    // handle to template filReturns Integer       //Returns handle that can be used to access the object
70741>>>>>
70741>>>>>External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer
70742>>>>>
70742>>>>>External_Function fsFormatMessage "FormatMessageW" kernel32.dll ;DWord dwFlags ;         // source and processing optionsPointer lpSrc ;         // message sourceDWord dwMsgId ;         // message identifierDWord dwLngId ;         // language identifierPointer lpBuf ;         // message bufferDWord nSize ;           // maximum size of message bufferPointer Arg ;           // array of message insertsReturns Integer
70743>>>>>
70743>>>>>External_Function fsLocalFree "LocalFree" kernel32.dll ;Handle hMem ;   // A handle to the local memory object.Returns Integer
70744>>>>>
70744>>>>>External_Function fsCloseHandle "CloseHandle" kernel32.dll ;Handle hObject ;        // handle to objectReturns Integer
70745>>>>>
70745>>>>>External_Function fsReadFile "ReadFile" kernel32.dll ;Handle hFile ;          // handle to filePointer lpBuffer ;      // data bufferDWord nBytesToRead ;    // number of bytes to readPointer lpBytesRead ;   // number of bytes readPointer lpOverlapped ;  // overlapped bufferReturns Integer
70746>>>>>
70746>>>>>External_Function fsWriteFile "WriteFile" kernel32.dll ;Handle hFile ;              // handle to filePointer lpBuf ;             // data bufferDWord nNumBytesWrt ;        // number of bytes to writePointer lpNumBytesWritten ; // number of bytes writtenPointer lpOverlapped ;      // overlapped bufferReturns Integer
70747>>>>>
70747>>>>>External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;Handle hFile ;           // handle to filePointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.Returns Integer
70748>>>>>
70748>>>>>External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;Handle hFile ;              // handle to fileUInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move.DWord dwMoveMethod ;        // The starting point For the file pointer move.Returns UInteger
70749>>>>>
70749>>>>>External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;Handle hFile ;              // handle to the file to have its EOF position moved.Returns Integer             // nonzero if success
70750>>>>>
70750>>>>>External_Function fsDeleteFile "DeleteFileW" Kernel32.Dll ;WString wFileName ;             // Pointer to a null-terminated string that specifies the file to be deleted.Returns Integer
70751>>>>>
70751>>>>>External_Function fsMoveFile "MoveFileW" Kernel32.Dll ;WString sExistingFileName ;     // Pointer to a null-terminated string that names an existing file or directory.WString sNewFileName ;          // Pointer to a null-terminated string that specifies the new name of a file or directory.Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.
70752>>>>>
70752>>>>>External_Function fsCopyFile "CopyFileW" Kernel32.Dll ;WString sExistingFileName ;     // Pointer to a null-terminated string that specifies the name of an existing file.WString sNewFileName ;          // Pointer to a null-terminated string that specifies the name of the new file.Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.
70753>>>>>
70753>>>>>External_Function fsFindFirstFile "FindFirstFileW" Kernel32.Dll ;WString wFileName ;             // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
70754>>>>>
70754>>>>>External_Function fsFindNextFile "FindNextFileW" Kernel32.Dll ;Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
70755>>>>>
70755>>>>>External_Function fsFindClose "FindClose" Kernel32.dll ;Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.Returns Integer
70756>>>>>
70756>>>>>External_Function fsGetFileTime "GetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with read accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
70757>>>>>
70757>>>>>External_Function fsSetFileTime "SetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with write accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
70758>>>>>
70758>>>>>External_function fsGetSystemTimeAsFileTime "GetSystemTimeAsFileTime" Kernel32.dll ;Pointer lpSystemTimeAsFileTime ;   // Pointer to a FILETIME structure containing the current system time in filetimme formatReturns Integer
70759>>>>>
70759>>>>>External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.Returns Integer
70760>>>>>
70760>>>>>External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.Returns Integer
70761>>>>>
70761>>>>>External_Function fsGetTempFileName "GetTempFileNameW" kernel32.dll ;WString sPathname ;WString sPrefixString ;Integer iUnique ;Pointer sTempFileName ;Returns Integer
70762>>>>>
70762>>>>>External_Function fsGetTempPath "GetTempPathW" Kernel32.Dll ;Integer nBufferLength ;Pointer lpBuffer ;Returns Integer
70763>>>>>
70763>>>>>External_Function fsCreateDirectory "CreateDirectoryW" Kernel32.dll ;WString sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be created.Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.Returns Integer
70764>>>>>
70764>>>>>External_Function fsRemoveDirectory "RemoveDirectoryW" Kernel32.dll ;WString sDirName ;             // Pointer to a null-terminated string that specifies the path of the directory to be removed.Returns Integer
70765>>>>>
70765>>>>>External_Function fsExtractAssociatedIcon "ExtractAssociatedIconW" shell32.dll ;Handle hInst ;Pointer lpIconPath ;Integer lpiIcon ;Returns Handle
70766>>>>>
70766>>>>>External_Function fsDestroyIcon "DestroyIcon" User32.dll ;Handle hIcon ;Returns Integer
70767>>>>>
70767>>>>>External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeW" Version.dll ;WString sFilename ;             // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.Returns UInteger
70768>>>>>
70768>>>>>External_Function fsGetFileVersionInfo "GetFileVersionInfoW" Version.dll ;WString sFilename ;             // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.DWord   dwHandle ;              // This parameter is ignored.DWord   dwLen ;                 // The size, in bytes, of the buffer pointed to by the lpData parameter.Pointer lpData ;                // Pointer to a buffer that receives the file-version information.Returns Boolean
70769>>>>>
70769>>>>>External_Function fsVerQueryValue "VerQueryValueW" Version.dll ;Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.WString sSubBlock ;             // The version-information value to be retrieved.Pointer lplpBuffer ;            // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.Returns Boolean
70770>>>>>
70770>>>>>//************************************************************************
70770>>>>>// Structures
70770>>>>>//************************************************************************
70770>>>>>
70770>>>>>// Nils 2018-08-30 Added For the SourceCodeTools project
70770>>>>>// so we don't need to use both Akefs.pkg and this package.
70770>>>>>// A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
70770>>>>>Struct tFileTime
70770>>>>>    DWord dwLowDateTime    // Low-order part of the file time.
70770>>>>>    DWord dwHighDateTime   // High-order part of the file time.
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct structWFD  // Used by FindFirstFile
70770>>>>>    DWord    dwFileAttributes
70770>>>>>    UBigInt  ftCreationDateTime
70770>>>>>    UBigInt  ftLastAccessDateTime
70770>>>>>    UBigInt  ftLastWriteDateTime
70770>>>>>    UInteger nFileSizeHigh
70770>>>>>    UInteger nFileSizeLow
70770>>>>>    DWord    dares
70770>>>>>    DWord    dbres
70770>>>>>    Short[MAX_PATH] cFileName
70770>>>>>    Short[14]       cAlternateFileName
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct structSystemTime
70770>>>>>    UShort wYear
70770>>>>>    UShort wMonth
70770>>>>>    UShort wDayOfWeek
70770>>>>>    UShort wDay
70770>>>>>    UShort wHour
70770>>>>>    UShort wMinute
70770>>>>>    UShort wSecond
70770>>>>>    UShort wMillieseconds
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct structFile
70770>>>>>    Handle hFilehandle
70770>>>>>    String sFilename    // Assigned filename in OEM format.
70770>>>>>    Boolean bEndOfFile  // True then the end of the binary file had been read.
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct structFileBufferPointer
70770>>>>>    Integer iBufferPointer
70770>>>>>    Integer iBufferSize
70770>>>>>    BigInt biFromFilePosition
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct tsSearchResult
70770>>>>>    String sFilename
70770>>>>>    String sAlternateFileName   // 8.3 format
70770>>>>>    DateTime dtCreationDateTime
70770>>>>>    DateTime dtLastAccessDateTime
70770>>>>>    DateTime dtLastWriteDateTime
70770>>>>>    BigInt biFileSize
70770>>>>>    Integer iFileAttributes
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct tsVS_FIXEDFILEINFO
70770>>>>>    DWord dwSignature
70770>>>>>    DWord dwStrucVersion
70770>>>>>    DWord dwFileVersionMS
70770>>>>>    DWord dwFileVersionLS
70770>>>>>    DWord dwProductVersionMS
70770>>>>>    DWord dwProductVersionLS
70770>>>>>    DWord dwFileFlagsMask
70770>>>>>    DWord dwFileFlags
70770>>>>>    DWord dwFileOS
70770>>>>>    DWord dwFileType
70770>>>>>    DWord dwFileSubtype
70770>>>>>    //    DWord dwFileDateMS
70770>>>>>    //    DWord dwFileDateLS
70770>>>>>    UBigInt ubiFileDate
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct tsFileVersionInfo
70770>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
70770>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
70770>>>>>    Short[] siFileVersion
70770>>>>>    Short[] siProductVersion
70770>>>>>    DateTime dtCreationDateTime
70770>>>>>    String sComments
70770>>>>>    String sCompanyName
70770>>>>>    String sFileDescription
70770>>>>>    String sFileVersion
70770>>>>>    String sInternalName
70770>>>>>    String sLegalCopyright
70770>>>>>    String sLegalTrademarks
70770>>>>>    String sOriginalFilename
70770>>>>>    String sProductName
70770>>>>>    String sProductVersion
70770>>>>>    String sPrivateBuild
70770>>>>>    String sSpecialBuild
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Struct tsLandAndCodePage
70770>>>>>    UShort wLanguage
70770>>>>>    UShort wCodePage
70770>>>>>End_Struct
70770>>>>>
70770>>>>>Register_Function FileErrorText Integer iFilenumber Returns String
70770>>>>>
70770>>>>>//************************************************************************
70770>>>>>// The filesystem class
70770>>>>>//************************************************************************
70770>>>>>Class cFilesystem is a cObject
70771>>>>>
70771>>>>>    Procedure Construct_Object
70773>>>>>        Forward Send Construct_Object
70775>>>>>
70775>>>>>        // True then the end of the binary file had been read - not when $1A (EOF) is met.
70775>>>>>        // Legacy property. Use the BinaryFileEndOfFile function instead.
70775>>>>>        Property Boolean pbEOF False
70776>>>>>
70776>>>>>        // True if any error has occured during fileoprerations.
70776>>>>>        Property Boolean pbError False
70777>>>>>
70777>>>>>        // If errormessages should be called with dataflex error command set this to true
70777>>>>>        Property Boolean pbErrorAsVDFError False
70778>>>>>
70778>>>>>        // Keeps assigned handles and filenames For each filenumber.
70778>>>>>        // private
70778>>>>>        Property structFile[] plsFile
70779>>>>>
70779>>>>>        // Keeps read cached buffers For each filenumer. Used For BinaryReadChcheu
70779>>>>>        // private
70779>>>>>        Property String[] psaCachedBuffer
70780>>>>>
70780>>>>>        // Pointers For cached buffers.
70780>>>>>        // private
70780>>>>>        Property structFileBufferPointer[] plsCachedPointer
70781>>>>>    End_Procedure
70782>>>>>
70782>>>>>    // Returns the next available filenumber For a binary file.
70782>>>>>    Function BinaryFileNextFilenumber Returns Integer
70784>>>>>        structFile[] lsFile
70784>>>>>        structFile[] lsFile
70785>>>>>        Integer iMaxFiles iCurrentFile iNextFileNumber
70785>>>>>        Get plsFile to lsFile
70786>>>>>        Move (SizeOfArray(lsFile)) to iMaxFiles
70787>>>>>        Move -1 to iNextFileNumber
70788>>>>>        Move 0 to iCurrentFile
70789>>>>>        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
70793>>>>>            If (lsFile[iCurrentFile].hFilehandle = 0) Begin
70795>>>>>                Move iCurrentFile to iNextFileNumber
70796>>>>>            End
70796>>>>>>
70796>>>>>            Else Begin
70797>>>>>                Increment iCurrentFile
70798>>>>>            End
70798>>>>>>
70798>>>>>        Loop
70799>>>>>>
70799>>>>>        If (iNextFileNumber = -1) Begin
70801>>>>>            Move iMaxFiles to iNextFileNumber
70802>>>>>        End
70802>>>>>>
70802>>>>>        Function_Return iNextFileNumber
70803>>>>>    End_Function
70804>>>>>
70804>>>>>    // Opens a binary file.
70804>>>>>    // If bShared is false or not pharsed the file is opened in exclusive.
70804>>>>>    // If bShared is True the file is opened with both read and write shared mode
70804>>>>>    // If bCreate is True the file is created if it does not exist already.
70804>>>>>    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
70804>>>>>    // Returns true if the file was opened or created without error.
70804>>>>>    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
70806>>>>>        Integer iReturnValue iErrornumber
70806>>>>>        DWord dwSharedMode dwCreateMode dwAccessMode
70806>>>>>        structFile[] lsFile
70806>>>>>        structFile[] lsFile
70807>>>>>        String sFilenameANSI
70807>>>>>        Boolean bOk bFilehandleOK
70807>>>>>        Get plsFile to lsFile
70808>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70810>>>>>            If (lsFile[iFilenumber].hFilehandle = 0) Begin
70812>>>>>                Move True to bFilehandleOK
70813>>>>>            End
70813>>>>>>
70813>>>>>        End
70813>>>>>>
70813>>>>>        Else Begin
70814>>>>>            Move True to bFilehandleOK
70815>>>>>        End
70815>>>>>>
70815>>>>>        If bFilehandleOK Begin
70817>>>>>            Move sFilename to lsFile[iFilenumber].sFilename
70818>>>>>            Move sFilename to sFilenameANSI
70819>>>>>            Set pbError to False
70820>>>>>            Move False to bOk
70821>>>>>            Move GENERIC_RANDOM to dwAccessMode
70822>>>>>            Move FNULL to dwSharedMode
70823>>>>>            If (num_arguments > 2) Begin
70825>>>>>                If (bShared = True) Begin
70827>>>>>                    Move FILE_SHARE_RANDOM to dwSharedMode
70828>>>>>                End
70828>>>>>>
70828>>>>>            End
70828>>>>>>
70828>>>>>            Move OPEN_EXISTING to dwCreateMode
70829>>>>>            If (num_arguments > 3) Begin
70831>>>>>                If (bCreate = True) Begin
70833>>>>>                    Move OPEN_ALWAYS to dwCreateMode
70834>>>>>                End
70834>>>>>>
70834>>>>>            End
70834>>>>>>
70834>>>>>            If (num_arguments > 4) Begin
70836>>>>>                If (bReadOnly = True) Begin
70838>>>>>                    Move GENERIC_READ to dwAccessMode
70839>>>>>                    If (bShared = True) Begin
70841>>>>>                        Move FILE_SHARE_READ to dwSharedMode
70842>>>>>                    End
70842>>>>>>
70842>>>>>                End
70842>>>>>>
70842>>>>>            End
70842>>>>>>
70842>>>>>            Append sFilenameANSI (Character(0)) (Character(0))
70844>>>>>            Move (fsCreatefile(sFilenameANSI, dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
70845>>>>>            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
70847>>>>>                Move (fsGetLastError()) to iErrornumber
70848>>>>>                If iErrornumber Begin
70850>>>>>                    Send DoShowError iErrornumber ("File: "+ sFilename)
70851>>>>>                End
70851>>>>>>
70851>>>>>            End
70851>>>>>>
70851>>>>>            Else Begin
70852>>>>>                Move iReturnValue to lsFile[iFilenumber].hFilehandle
70853>>>>>                Move False to lsFile[iFilenumber].bEndOfFile
70854>>>>>                Set plsFile to lsFile
70855>>>>>                Set pbEOF to False
70856>>>>>                Move True to bOk
70857>>>>>            End
70857>>>>>>
70857>>>>>        End
70857>>>>>>
70857>>>>>        Else Begin
70858>>>>>            Send warning_box "The filenumber is already used."
70859>>>>>        End
70859>>>>>>
70859>>>>>        Function_Return bOk
70860>>>>>    End_Function
70861>>>>>
70861>>>>>    // Closing a binary file
70861>>>>>    // Returns true if the file could be closed.
70861>>>>>    Function BinaryFileClose Integer iFilenumber Returns Boolean
70863>>>>>        Integer iRetVal iErrorNumber
70863>>>>>        Handle hHandle
70863>>>>>        structFile[] lsFile
70863>>>>>        structFile[] lsFile
70864>>>>>        structFileBufferPointer[] lsFileBufferPointer
70864>>>>>        structFileBufferPointer[] lsFileBufferPointer
70865>>>>>        String[] saCachedBuffer
70866>>>>>        Boolean bOk
70866>>>>>        Get BinaryFileHandle iFilenumber to hHandle
70867>>>>>        Set pbError to False
70868>>>>>        Move False to bOk
70869>>>>>        If hHandle Begin
70871>>>>>            Move (fsCloseHandle(hHandle)) to iRetVal
70872>>>>>            If (iRetVal = 0) Begin           // Could not close
70874>>>>>                Move (fsGetLastError()) to iErrorNumber
70875>>>>>                If iErrorNumber Begin
70877>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70878>>>>>                End
70878>>>>>>
70878>>>>>            End
70878>>>>>>
70878>>>>>            Else Begin
70879>>>>>                Get plsFile to lsFile
70880>>>>>                Get plsCachedPointer to lsFileBufferPointer
70881>>>>>                Get psaCachedBuffer to saCachedBuffer
70882>>>>>                Move 0 to lsFile[iFilenumber].hFilehandle
70883>>>>>                Move "" to saCachedBuffer[iFilenumber]
70884>>>>>                Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70885>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].iBufferSize
70886>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].biFromFilePosition
70887>>>>>                Set plsFile to lsFile
70888>>>>>                Set plsCachedPointer to lsFileBufferPointer
70889>>>>>                Set psaCachedBuffer to saCachedBuffer
70890>>>>>                Move True to bOk
70891>>>>>            End
70891>>>>>>
70891>>>>>        End
70891>>>>>>
70891>>>>>        Function_Return bOk
70892>>>>>    End_Function
70893>>>>>
70893>>>>>    // Reading from a binary file.
70893>>>>>    // The data read from the file is placed in sReadBuffer and the function returns the number of bytes read.
70893>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70893>>>>>    // No errors occures if you try to read past end of file.
70893>>>>>    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = 2000) instead of
70893>>>>>    // reading one byte at a time. No errors occures if you try to read past end
70893>>>>>    // of file. Note that iNumberOfBytes must not exceed the argument size.
70893>>>>>    Function BinaryFileRead Integer iFilenumber Integer iNumberOfBytes String ByRef sReadBuffer Returns Integer
70895>>>>>        Handle hFileHandle
70895>>>>>        Integer iBytesRead iMaxBuffer iErrorNumber
70895>>>>>        Boolean bOk
70895>>>>>        structFile[] lsFile
70895>>>>>        structFile[] lsFile
70896>>>>>        Set pbError to False
70897>>>>>        Move 0 to iBytesRead
70898>>>>>        Get_Argument_Size to iMaxBuffer
70899>>>>>        If (iNumberOfBytes > iMaxBuffer) Begin
70901>>>>>            Send warning_box "Blocksize to read exceeds argument size!"
70902>>>>>            Function_Return iBytesRead
70903>>>>>        End
70903>>>>>>
70903>>>>>        If (iNumberOfBytes < 1) Begin
70905>>>>>            Send warning_box "Number of bytes to read can not be less than one."
70906>>>>>            Function_Return iBytesRead
70907>>>>>        End
70907>>>>>>
70907>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70908>>>>>        If hFileHandle Begin
70910>>>>>            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
70911>>>>>            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
70912>>>>>            If (bOk = False) Begin
70914>>>>>                Move (fsGetLastError()) to iErrorNumber
70915>>>>>                If iErrorNumber Begin
70917>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70918>>>>>                End
70918>>>>>>
70918>>>>>            End
70918>>>>>>
70918>>>>>            Else Begin
70919>>>>>                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
70921>>>>>                    Get plsFile to lsFile
70922>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
70923>>>>>                    Set plsFile to lsFile
70924>>>>>                    Set pbEOF to True
70925>>>>>                    Move (Left(sReadBuffer, iBytesRead)) to sReadBuffer
70926>>>>>                End
70926>>>>>>
70926>>>>>            End
70926>>>>>>
70926>>>>>        End
70926>>>>>>
70926>>>>>        Else Begin
70927>>>>>            Send warning_box FS_FILEHANDLEMISSING
70928>>>>>        End
70928>>>>>>
70928>>>>>        Function_Return iBytesRead
70929>>>>>    End_Function
70930>>>>>
70930>>>>>    // Reading from a binary file until a string of bytes are matched.
70930>>>>>    // The data read from the file is placed in the sReturnBuffer and the function returns the number of bytes read until the match is read including the match.
70930>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70930>>>>>    // The return string buffer would also be empty.
70930>>>>>    // No errors occures if you try to read past end of file.
70930>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
70930>>>>>    Function BinaryFileReadCachedUntilMatch Integer iFilenumber String sMatchString String ByRef sReturnBuffer Boolean ByRef bEndOfFile Returns Integer
70932>>>>>        Handle hFileHandle
70932>>>>>        Integer iBuffersize iMatchPos iLengthMatch
70932>>>>>        String sByte
70932>>>>>        structFile[] lsFile
70932>>>>>        structFile[] lsFile
70933>>>>>        structFileBufferPointer[] lsFileBufferPointer
70933>>>>>        structFileBufferPointer[] lsFileBufferPointer
70934>>>>>        String[] saCachedBuffer
70935>>>>>        Get plsFile to lsFile
70936>>>>>        Move "" to sReturnBuffer
70937>>>>>        Move 1 to iMatchPos
70938>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70940>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
70941>>>>>            If (hFileHandle <> 0) Begin
70943>>>>>                Move (Length(sMatchString)) to iLengthMatch
70944>>>>>                Get plsCachedPointer to lsFileBufferPointer
70945>>>>>                Get psaCachedBuffer to saCachedBuffer
70946>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
70948>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70949>>>>>                    Move "" to saCachedBuffer[iFilenumber]
70950>>>>>                End
70950>>>>>>
70950>>>>>                Repeat
70950>>>>>>
70950>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer > lsFileBufferPointer[iFilenumber].iBufferSize) Begin
70952>>>>>                        Get_Argument_Size to iBuffersize
70953>>>>>                        Get BinaryFilePosition iFilenumber to lsFileBufferPointer[iFilenumber].biFromFilePosition
70954>>>>>                        Get BinaryFileRead iFilenumber iBuffersize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer[iFilenumber].iBufferSize
70955>>>>>                        Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70956>>>>>                        Set psaCachedBuffer to saCachedBuffer
70957>>>>>                    End
70957>>>>>>
70957>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer =< lsFileBufferPointer[iFilenumber].iBufferSize) Begin
70959>>>>>                        Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer[iFilenumber].iBufferPointer)) to sByte
70960>>>>>                        Increment lsFileBufferPointer[iFilenumber].iBufferPointer
70961>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
70962>>>>>                        If (sByte = Mid(sMatchString, 1, iMatchPos)) Begin
70964>>>>>                            Increment iMatchPos
70965>>>>>                        End
70965>>>>>>
70965>>>>>                        Else Begin
70966>>>>>                            Move 1 to iMatchPos
70967>>>>>                        End
70967>>>>>>
70967>>>>>                    End
70967>>>>>>
70967>>>>>                Until (iMatchPos > iLengthMatch or lsFileBufferPointer[iFilenumber].iBufferSize = 0)
70969>>>>>                Set plsCachedPointer to lsFileBufferPointer
70970>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
70972>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
70973>>>>>                End
70973>>>>>>
70973>>>>>            End
70973>>>>>>
70973>>>>>            Else Begin
70974>>>>>                Send warning_box FS_FILEHANDLEMISSING
70975>>>>>            End
70975>>>>>>
70975>>>>>        End
70975>>>>>>
70975>>>>>        Function_Return (Length(sReturnBuffer))
70976>>>>>    End_Function
70977>>>>>
70977>>>>>    // Reading from a binary file as CSV file For next text field.
70977>>>>>    // The data read from the file is placed in the sReturnBuffer excluding the separator and the function returns true.
70977>>>>>    // Then the function returns false the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70977>>>>>    // When the end of row data has been read the bEndOfRow is set true.
70977>>>>>    // The end of row is indicated with sCharEOL. If that is not applied the charactersequence character(13) + character(10) is used.
70977>>>>>    // The return string buffer would also be empty.
70977>>>>>    // No errors occures if you try to read past end of file.
70977>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
70977>>>>>    Function BinaryFileReadCachedCSV Integer iFilenumber String sFieldseparator String sTextQualification String ByRef sReturnBuffer Boolean ByRef bEndOfRow Boolean ByRef bEndOfFile String sCharEOL Returns Integer
70979>>>>>        Handle hFileHandle
70979>>>>>        Integer iLengthSeparator iLengthTextQualification iEOLLength iTestLength
70979>>>>>        String sByte sEOL sTestBuffer
70979>>>>>        structFile[] lsFile
70979>>>>>        structFile[] lsFile
70980>>>>>        structFileBufferPointer[] lsFileBufferPointer
70980>>>>>        structFileBufferPointer[] lsFileBufferPointer
70981>>>>>        String[] saCachedBuffer
70982>>>>>        Boolean bInTextFieldMode bTextFieldReady bFieldSeparator bTextQualificator bEscapeTextQualificatorTest bByteOk
70982>>>>>        BigInt biAfterTextQualificator
70982>>>>>        Get plsFile to lsFile
70983>>>>>        If (num_arguments > 6) Begin
70985>>>>>            Move sCharEOL to sEOL
70986>>>>>        End
70986>>>>>>
70986>>>>>        Else Begin
70987>>>>>            Move ((Character(13))+(Character(10))) to sEOL
70988>>>>>        End
70988>>>>>>
70988>>>>>        Move (Length(sEOL)) to iEOLLength
70989>>>>>        Move "" to sReturnBuffer
70990>>>>>        Move "" to sByte
70991>>>>>        Move False to bInTextFieldMode
70992>>>>>        Move False to bTextFieldReady
70993>>>>>        Move False to bEndOfRow
70994>>>>>        Move False to bTextQualificator
70995>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70997>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
70998>>>>>            If (hFileHandle <> 0) Begin
71000>>>>>                Move (Length(sFieldseparator)) to iLengthSeparator
71001>>>>>                Move (Length(sTextQualification)) to iLengthTextQualification
71002>>>>>                Get plsCachedPointer to lsFileBufferPointer
71003>>>>>                Get psaCachedBuffer to saCachedBuffer
71004>>>>>
71004>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
71006>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
71007>>>>>                    Move "" to saCachedBuffer[iFilenumber]
71008>>>>>                End
71008>>>>>>
71008>>>>>                Repeat
71008>>>>>>
71008>>>>>                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
71009>>>>>                    If bByteOk Begin
71011>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
71012>>>>>                        Move (Right(sReturnBuffer, iLengthSeparator) = sFieldseparator) to bFieldSeparator
71013>>>>>                        If bFieldSeparator Begin
71015>>>>>                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthSeparator))) to sReturnBuffer
71016>>>>>                            Move True to bTextFieldReady
71017>>>>>                            Move False to bEscapeTextQualificatorTest
71018>>>>>                        End
71018>>>>>>
71018>>>>>                        If (not(bTextFieldReady)) Begin
71020>>>>>                            Move (Right(sReturnBuffer, iEOLLength) = sEOL) to bEndOfRow
71021>>>>>                            If bEndOfRow Begin
71023>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iEOLLength))) to sReturnBuffer
71024>>>>>                                Move True to bTextFieldReady
71025>>>>>                            End
71025>>>>>>
71025>>>>>                        End
71025>>>>>>
71025>>>>>                        If (not(bTextFieldReady)) Begin
71027>>>>>                            Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
71028>>>>>                            If bTextQualificator Begin
71030>>>>>                            // Read until end of text field. Place filepointer after text field.
71030>>>>>                                Move True to bInTextFieldMode
71031>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
71032>>>>>                                Repeat
71032>>>>>>
71032>>>>>                                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
71033>>>>>                                    If bByteOk Begin
71035>>>>>                                        Move (sReturnBuffer + sByte) to sReturnBuffer
71036>>>>>                                        Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
71037>>>>>                                        If bTextQualificator Begin
71039>>>>>                                        // Either it is the end of the text field or the escape text qualificator has been read.
71039>>>>>                                        // Read ahead to a new buffer to see if the next bytes are the text qualificator.
71039>>>>>                                        // If it is, add the new buffer to the return buffer.
71039>>>>>                                        // If not, restore the filebuffer to this position and mark the text field ended.
71039>>>>>                                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
71040>>>>>                                            Set plsCachedPointer to lsFileBufferPointer
71041>>>>>                                            Get BinaryFileCachedPosition iFilenumber to biAfterTextQualificator
71042>>>>>                                            Move "" to sTestBuffer
71043>>>>>                                            Move 0 to iTestLength
71044>>>>>                                            Move True to bEscapeTextQualificatorTest
71045>>>>>                                            Repeat
71045>>>>>>
71045>>>>>                                                Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
71046>>>>>                                                If bByteOk Begin
71048>>>>>                                                    Move (sTestBuffer + sByte) to sTestBuffer
71049>>>>>                                                    Increment iTestLength
71050>>>>>                                                    If (Left(sTextQualification, iTestLength) = sTestBuffer) Begin
71052>>>>>                                                        If (iTestLength = iLengthTextQualification) Begin
71054>>>>>                                                            Move (sReturnBuffer + sTestBuffer) to sReturnBuffer
71055>>>>>                                                            Move False to bEscapeTextQualificatorTest
71056>>>>>                                                        End
71056>>>>>>
71056>>>>>                                                    End
71056>>>>>>
71056>>>>>                                                    Else Begin
71057>>>>>                                                        Set BinaryFileChachedPosition iFilenumber to biAfterTextQualificator
71058>>>>>                                                        Get plsCachedPointer to lsFileBufferPointer
71059>>>>>                                                        Move False to bEscapeTextQualificatorTest
71060>>>>>                                                        Move False to bInTextFieldMode
71061>>>>>                                                    End
71061>>>>>>
71061>>>>>                                                End
71061>>>>>>
71061>>>>>                                            Until (bEscapeTextQualificatorTest = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
71063>>>>>                                        End
71063>>>>>>
71063>>>>>                                    End
71063>>>>>>
71063>>>>>                                Until (bInTextFieldMode = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
71065>>>>>                            End
71065>>>>>>
71065>>>>>                        End
71065>>>>>>
71065>>>>>                    End
71065>>>>>>
71065>>>>>                Until (bTextFieldReady = True or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
71067>>>>>                Set plsCachedPointer to lsFileBufferPointer
71068>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
71070>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
71071>>>>>                    If (bEndOfFile = True) Begin
71073>>>>>                        Move True to bTextFieldReady
71074>>>>>                        Move True to bEndOfRow
71075>>>>>                    End
71075>>>>>>
71075>>>>>                End
71075>>>>>>
71075>>>>>            End
71075>>>>>>
71075>>>>>            Else Begin
71076>>>>>                Send warning_box FS_FILEHANDLEMISSING
71077>>>>>            End
71077>>>>>>
71077>>>>>        End
71077>>>>>>
71077>>>>>        Function_Return bTextFieldReady
71078>>>>>    End_Function
71079>>>>>
71079>>>>>    Function NextByteCSV Integer ByRef iFilenumber structFileBufferPointer ByRef lsFileBufferPointer String[] ByRef saCachedBuffer String ByRef sByte Returns String
71081>>>>>        Integer iBufferSize
71081>>>>>        Boolean bOk
71081>>>>>        If (lsFileBufferPointer.iBufferPointer > lsFileBufferPointer.iBufferSize) Begin
71083>>>>>            Get_Argument_Size to iBufferSize
71084>>>>>            Get BinaryFilePosition iFilenumber to lsFileBufferPointer.biFromFilePosition
71085>>>>>            Get BinaryFileRead iFilenumber iBufferSize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer.iBufferSize
71086>>>>>            Move 1 to lsFileBufferPointer.iBufferPointer
71087>>>>>            Set psaCachedBuffer to saCachedBuffer
71088>>>>>        End
71088>>>>>>
71088>>>>>        If (lsFileBufferPointer.iBufferPointer <= lsFileBufferPointer.iBufferSize) Begin
71090>>>>>            Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer.iBufferPointer)) to sByte
71091>>>>>            Increment lsFileBufferPointer.iBufferPointer
71092>>>>>            Move True to bOk
71093>>>>>        End
71093>>>>>>
71093>>>>>        Function_Return bOk
71094>>>>>    End_Function
71095>>>>>
71095>>>>>    // Shortcut to read a binary file as lines from a textfile.
71095>>>>>    // Reads from cached file until sCharEOL are recieved.
71095>>>>>    // Data is returned without the ending sCharEOL
71095>>>>>    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
71095>>>>>    // Returns True when the line has been read.
71095>>>>>    Function BinaryFileReadCachedLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
71097>>>>>        Boolean bEndOfRow
71097>>>>>        Integer iBytesRead iEOLLength
71097>>>>>        String sEOL
71097>>>>>        If (num_arguments > 3) Begin
71099>>>>>            Move sCharEOL to sEOL
71100>>>>>        End
71100>>>>>>
71100>>>>>        Else Begin
71101>>>>>            Move ((Character(13))+(Character(10))) to sEOL
71102>>>>>        End
71102>>>>>>
71102>>>>>        Move (Length(sEOL)) to iEOLLength
71103>>>>>        Get BinaryFileReadCachedUntilMatch iFilenumber sEOL (&sLine) (&bEndOfFile) to iBytesRead
71104>>>>>        If (iBytesRead > 0) Begin
71106>>>>>            If (Right(sLine, iEOLLength) = sEOL) Begin
71108>>>>>                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
71109>>>>>                Move True to bEndOfRow
71110>>>>>            End
71110>>>>>>
71110>>>>>        End
71110>>>>>>
71110>>>>>        Function_Return bEndOfRow
71111>>>>>    End_Function
71112>>>>>
71112>>>>>    // Writing to a binary file.
71112>>>>>    // Returns true if the data was written to the file without error.
71112>>>>>    Function BinaryFileWrite Integer iFilenumber String ByRef sWriteData Returns Boolean
71114>>>>>        Integer iBytesWritten iBytesToWrite iErrorNumber
71114>>>>>        Handle hFileHandle
71114>>>>>        Boolean bOk
71114>>>>>        Set pbError to False
71115>>>>>        Move False to bOk
71116>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71117>>>>>        If hFileHandle Begin
71119>>>>>            Move 0 to iBytesWritten
71120>>>>>            Move (Length(sWriteData)) to iBytesToWrite
71121>>>>>            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
71122>>>>>            If (bOk = False) Begin
71124>>>>>                Move (fsGetLastError()) to iErrorNumber
71125>>>>>                If iErrorNumber Begin
71127>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
71128>>>>>                End
71128>>>>>>
71128>>>>>            End
71128>>>>>>
71128>>>>>            If (iBytesToWrite <> iBytesWritten) Begin
71130>>>>>                Send Warning_box "Not all data could be written!"
71131>>>>>                Move False to bOk
71132>>>>>            End
71132>>>>>>
71132>>>>>        End
71132>>>>>>
71132>>>>>        Else Begin
71133>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
71134>>>>>        End
71134>>>>>>
71134>>>>>        Function_Return bOk
71135>>>>>    End_Function
71136>>>>>
71136>>>>>    // Write HEX values to a binary file as bytes.
71136>>>>>    // HEX values in sWriteHEX are first coverted to bytes and then written
71136>>>>>    // to the binary file.
71136>>>>>    // Returns true if the HEX data was written to the file without error.
71136>>>>>    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
71138>>>>>        String sData
71138>>>>>        Integer iLength iCount iByte
71138>>>>>        Boolean bOk
71138>>>>>        Move (Length(sWritehex)) to iLength
71139>>>>>        Move 1 to iCount
71140>>>>>        While (iCount < iLength)
71144>>>>>            Move ("$"+Mid(sWriteHex, 2, iCount)) to iByte
71145>>>>>            Move (iCount + 2) to iCount
71146>>>>>            Move (sData + Character(iByte)) to sData
71147>>>>>        Loop
71148>>>>>>
71148>>>>>        Get BinaryFileWrite iFilenumer (&sData) to bOk
71149>>>>>        Function_Return bOk
71150>>>>>    End_Function
71151>>>>>
71151>>>>>    // Retrives the file size from a binary file.
71151>>>>>    Function BinaryFileSize Integer iFilenumber Returns BigInt
71153>>>>>        BigInt biFilesize
71153>>>>>        Handle hFileHandle
71153>>>>>        Boolean bOk
71153>>>>>        Integer iErrorNumber
71153>>>>>        Set pbError to False
71154>>>>>        Move -1 to biFilesize
71155>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71156>>>>>        If hFileHandle Begin
71158>>>>>        // The LARGE_INTEGER structure has the same structure as a BigInt.
71158>>>>>            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
71159>>>>>            If (bOk = -False) Begin
71161>>>>>                Move (fsGetLastError()) to iErrorNumber
71162>>>>>                If iErrorNumber Begin
71164>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
71165>>>>>                End
71165>>>>>>
71165>>>>>            End
71165>>>>>>
71165>>>>>        End
71165>>>>>>
71165>>>>>        Else Begin
71166>>>>>            Send warning_box FS_FILEHANDLEMISSING
71167>>>>>        End
71167>>>>>>
71167>>>>>        Function_Return biFilesize
71168>>>>>    End_Function
71169>>>>>
71169>>>>>    // Retrives the file position from a binary file.
71169>>>>>    // Returns -1 if an error occured.
71169>>>>>    Function BinaryFilePosition Integer iFilenumber Returns BigInt
71171>>>>>        BigInt biFilePosition biBigHi
71171>>>>>        Handle hFileHandle
71171>>>>>        Boolean bOk
71171>>>>>        Integer iErrorNumber iLo iHi
71171>>>>>        UInteger iNewPos
71171>>>>>
71171>>>>>        Set pbError to False
71172>>>>>        Move -1 to biFilePosition
71173>>>>>        Move 0 to iHi
71174>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71175>>>>>        If hFileHandle Begin
71177>>>>>            Move (2^32) to biBigHi
71178>>>>>            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
71179>>>>>            If (iNewPos = (biBigHi - 1)) Begin
71181>>>>>                Move (fsGetLastError()) to iErrorNumber
71182>>>>>                If iErrorNumber Begin
71184>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
71185>>>>>                End
71185>>>>>>
71185>>>>>                Else Begin
71186>>>>>                    Move True to bOk
71187>>>>>                End
71187>>>>>>
71187>>>>>            End
71187>>>>>>
71187>>>>>            Else Begin
71188>>>>>                Move True to bOk
71189>>>>>            End
71189>>>>>>
71189>>>>>            If bOk Begin
71191>>>>>                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
71192>>>>>            End
71192>>>>>>
71192>>>>>        End
71192>>>>>>
71192>>>>>        Else Begin
71193>>>>>            Send warning_box FS_FILEHANDLEMISSING
71194>>>>>        End
71194>>>>>>
71194>>>>>        Function_Return biFilePosition
71195>>>>>    End_Function
71196>>>>>
71196>>>>>    // Sets the file position from a binary file to a new position.
71196>>>>>    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
71198>>>>>        Handle hFileHandle
71198>>>>>        Integer iHi iErrorNumber
71198>>>>>        UInteger iLo iNewPos
71198>>>>>        Boolean bOk
71198>>>>>        BigInt biFileSize biBigHi
71198>>>>>        structFile[] lsFile
71198>>>>>        structFile[] lsFile
71199>>>>>
71199>>>>>        Set pbError to False
71200>>>>>        Move False to bOk
71201>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71202>>>>>        If hFileHandle Begin
71204>>>>>            Move (2^32) to biBigHi
71205>>>>>            Move (biPosition / biBigHi) to iHi
71206>>>>>            Move (biPosition - (iHi * biBigHi)) to iLo
71207>>>>>            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
71208>>>>>            If (iNewPos = (biBigHi - 1)) Begin
71210>>>>>                Move (fsGetLastError()) to iErrorNumber
71211>>>>>                If iErrorNumber Begin
71213>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
71214>>>>>                End
71214>>>>>>
71214>>>>>                Else Begin
71215>>>>>                    Move True to bOk
71216>>>>>                End
71216>>>>>>
71216>>>>>            End
71216>>>>>>
71216>>>>>            Else Begin
71217>>>>>                Move True to bOk
71218>>>>>            End
71218>>>>>>
71218>>>>>            If bOk Begin
71220>>>>>                Get BinaryFileSize iFilenumber to biFileSize
71221>>>>>                Get plsFile to lsFile
71222>>>>>                If (biFileSize > biPosition) Begin
71224>>>>>                    Move False to lsFile[iFilenumber].bEndOfFile
71225>>>>>                    Set pbEOF to False
71226>>>>>                End
71226>>>>>>
71226>>>>>                Else Begin
71227>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
71228>>>>>                    Set pbEOF to True
71229>>>>>                End
71229>>>>>>
71229>>>>>                Set plsFile to lsFile
71230>>>>>            End
71230>>>>>>
71230>>>>>        End
71230>>>>>>
71230>>>>>        Else Begin
71231>>>>>            Send warning_box FS_FILEHANDLEMISSING
71232>>>>>        End
71232>>>>>>
71232>>>>>        Set pbError to (not(bOk))
71233>>>>>    End_Procedure
71234>>>>>
71234>>>>>    // Returns -1 if an error occured.
71234>>>>>    Function BinaryFileCachedPosition Integer iFileNumber Returns BigInt
71236>>>>>        BigInt biPosition
71236>>>>>        structFileBufferPointer[] lsFileBufferPointer
71236>>>>>        structFileBufferPointer[] lsFileBufferPointer
71237>>>>>        Handle hFileHandle
71237>>>>>        Move -1 to biPosition
71238>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71239>>>>>        If hFileHandle Begin
71241>>>>>            Get plsCachedPointer to lsFileBufferPointer
71242>>>>>            If (iFilenumber < SizeOfArray(lsFileBufferPointer)) Begin
71244>>>>>                If (lsFileBufferPointer[iFileNumber].iBufferSize > 0) Begin
71246>>>>>                    Move (lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferPointer - 1) to biPosition
71247>>>>>                End
71247>>>>>>
71247>>>>>                Else Begin
71248>>>>>                    Get BinaryFilePosition iFileNumber to biPosition
71249>>>>>                End
71249>>>>>>
71249>>>>>            End
71249>>>>>>
71249>>>>>            Else Begin
71250>>>>>                Get BinaryFilePosition iFileNumber to biPosition
71251>>>>>            End
71251>>>>>>
71251>>>>>        End
71251>>>>>>
71251>>>>>        Else Begin
71252>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
71253>>>>>        End
71253>>>>>>
71253>>>>>        Function_Return biPosition
71254>>>>>    End_Function
71255>>>>>
71255>>>>>    // Sets the pointer For the current file cache.
71255>>>>>    Procedure Set BinaryFileChachedPosition Integer iFileNumber BigInt biNewPosition
71257>>>>>        Handle hFileHandle
71257>>>>>        structFileBufferPointer[] lsFileBufferPointer
71257>>>>>        structFileBufferPointer[] lsFileBufferPointer
71258>>>>>        String[] saCachedBuffer
71259>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71260>>>>>        If hFileHandle Begin
71262>>>>>            Get plsCachedPointer to lsFileBufferPointer
71263>>>>>            If (lsFileBufferPointer[iFileNumber].biFromFilePosition > biNewPosition) Begin
71265>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
71266>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
71267>>>>>                Set plsCachedPointer to lsFileBufferPointer
71268>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
71269>>>>>                Get psaCachedBuffer to saCachedBuffer
71270>>>>>                Move "" to saCachedBuffer[iFileNumber]
71271>>>>>                Set psaCachedBuffer to saCachedBuffer
71272>>>>>            End
71272>>>>>>
71272>>>>>            Else If ((lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferSize) < biNewPosition) Begin
71275>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
71276>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
71277>>>>>                Set plsCachedPointer to lsFileBufferPointer
71278>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
71279>>>>>                Get psaCachedBuffer to saCachedBuffer
71280>>>>>                Move "" to saCachedBuffer[iFileNumber]
71281>>>>>                Set psaCachedBuffer to saCachedBuffer
71282>>>>>            End
71282>>>>>>
71282>>>>>            Else Begin
71283>>>>>                Move (biNewPosition - lsFileBufferPointer[iFileNumber].biFromFilePosition + 1) to lsFileBufferPointer[iFileNumber].iBufferPointer
71284>>>>>                Set plsCachedPointer to lsFileBufferPointer
71285>>>>>            End
71285>>>>>>
71285>>>>>        End
71285>>>>>>
71285>>>>>        Else Begin
71286>>>>>            Send warning_box FS_FILEHANDLEMISSING
71287>>>>>        End
71287>>>>>>
71287>>>>>    End_Procedure
71288>>>>>
71288>>>>>    // Truncate or extend a binary file to the specified file position
71288>>>>>    // by setting the binary file End Of File position.
71288>>>>>    // If biPosition is -1 the current file position is used as EOF position.
71288>>>>>    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
71290>>>>>        Handle hFileHandle
71290>>>>>        Boolean bError bOk
71290>>>>>        Integer iErrorNumber
71290>>>>>        structFile[] lsFile
71290>>>>>        structFile[] lsFile
71291>>>>>        Set pbError to False
71292>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71293>>>>>        If hFileHandle Begin
71295>>>>>            If (biPosition > -1) Begin
71297>>>>>                Set BinaryFilePosition iFilenumber to biPosition
71298>>>>>            End
71298>>>>>>
71298>>>>>            Get pbError to bError
71299>>>>>            If (bError = False) Begin
71301>>>>>                Move (fsSetEndOfFile(hFileHandle)) to bOk
71302>>>>>                If (bOk = False) Begin
71304>>>>>                    Move (fsGetLastError()) to iErrorNumber
71305>>>>>                    If iErrorNumber Begin
71307>>>>>                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
71308>>>>>                    End
71308>>>>>>
71308>>>>>                End
71308>>>>>>
71308>>>>>                Else Begin
71309>>>>>                    Get plsFile to lsFile
71310>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
71311>>>>>                    Set plsFile to lsFile
71312>>>>>                    Set pbEOF to True
71313>>>>>                End
71313>>>>>>
71313>>>>>            End
71313>>>>>>
71313>>>>>        End
71313>>>>>>
71313>>>>>        Else Begin
71314>>>>>            Send warning_box FS_FILEHANDLEMISSING
71315>>>>>        End
71315>>>>>>
71315>>>>>        Set pbError to (not(bOk))
71316>>>>>    End_Procedure
71317>>>>>
71317>>>>>    // Returns true if the last read from the binary file had reached the end.
71317>>>>>    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
71319>>>>>        structFile[] lsFile
71319>>>>>        structFile[] lsFile
71320>>>>>        Handle hFileHandle
71320>>>>>        Boolean bEndOfFile
71320>>>>>        Move True to bEndOfFile
71321>>>>>        Set pbError to False
71322>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
71323>>>>>        If hFileHandle Begin
71325>>>>>            Get plsFile to lsFile
71326>>>>>            Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
71327>>>>>        End
71327>>>>>>
71327>>>>>        Else Begin
71328>>>>>            Send warning_box FS_FILEHANDLEMISSING
71329>>>>>        End
71329>>>>>>
71329>>>>>        Function_Return bEndOfFile
71330>>>>>    End_Function
71331>>>>>
71331>>>>>    // Returns the filehandle from the filenumber.
71331>>>>>    // Returns 0 if the filenumber is not used.
71331>>>>>    Function BinaryFileHandle Integer iFilenumber Returns Handle
71333>>>>>        Handle hFileHandle
71333>>>>>        structFile[] lsFile
71333>>>>>        structFile[] lsFile
71334>>>>>        Get plsFile to lsFile
71335>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
71337>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
71338>>>>>        End
71338>>>>>>
71338>>>>>        Function_Return hFileHandle
71339>>>>>    End_Function
71340>>>>>
71340>>>>>    // Searches For a file
71340>>>>>    // iMode = DIRMODE_FILES_ONLY (default)
71340>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
71340>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES
71340>>>>>    // Returns True if found
71340>>>>>    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
71342>>>>>        Integer iMode
71342>>>>>        Boolean bFound
71342>>>>>        tsSearchResult[] lsResult
71342>>>>>        tsSearchResult[] lsResult
71343>>>>>        Move False to bFound
71344>>>>>        Set pbError to False
71345>>>>>        If (num_arguments < 2) Begin
71347>>>>>            Move DIRMODE_FILES_ONLY to iMode
71348>>>>>        End
71348>>>>>>
71348>>>>>        Else Begin
71349>>>>>            Move iFileDirMode to iMode
71350>>>>>        End
71350>>>>>>
71350>>>>>        Get FileSearch sFilePathMask iMode True to lsResult
71351>>>>>        If (SizeOfArray(lsResult) > 0) Begin
71353>>>>>            Move True to bFound
71354>>>>>        End
71354>>>>>>
71354>>>>>        Function_Return bFound
71355>>>>>    End_Function
71356>>>>>
71356>>>>>    // Deletes a file.
71356>>>>>    // Returns True if succeeds.
71356>>>>>    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
71358>>>>>        Boolean bFound bDeleted
71358>>>>>        Integer iErrorNumber iRetryLeft
71358>>>>>
71358>>>>>        Set pbError to False
71359>>>>>        If (num_arguments > 1) Begin
71361>>>>>            Move iRetryAttempts to iRetryLeft
71362>>>>>        End
71362>>>>>>
71362>>>>>        Else Begin
71363>>>>>            Move 0 to iRetryLeft
71364>>>>>        End
71364>>>>>>
71364>>>>>        Get FileExists sFilename to bFound
71365>>>>>        If bFound Begin
71367>>>>>            Repeat
71367>>>>>>
71367>>>>>                Move (sFilename+(Character(0))) to sFilename
71368>>>>>                Move (fsDeleteFile(sFilename)) to bDeleted
71369>>>>>                If (bDeleted = False) Begin
71371>>>>>                    Decrement iRetryLeft
71372>>>>>                    If (iRetryLeft <= 0) Begin
71374>>>>>                        Move (fsGetLastError()) to iErrorNumber
71375>>>>>                        If iErrorNumber Begin
71377>>>>>                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
71378>>>>>                        End
71378>>>>>>
71378>>>>>                    End
71378>>>>>>
71378>>>>>                    Else Begin
71379>>>>>                        Sleep 1
71380>>>>>                    End
71380>>>>>>
71380>>>>>                End
71380>>>>>>
71380>>>>>            Until (bDeleted = True or iRetryLeft <= 0)
71382>>>>>        End
71382>>>>>>
71382>>>>>        Function_Return bDeleted
71383>>>>>    End_Function
71384>>>>>
71384>>>>>    // Moves a file or directory.
71384>>>>>    // Returns True if succeeds.
71384>>>>>    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
71386>>>>>        Boolean bMoved
71386>>>>>        Integer iErrorNumber iRetryLeft
71386>>>>>
71386>>>>>        Set pbError to False
71387>>>>>        If (num_arguments > 2) Begin
71389>>>>>            Move iRetryAttempts to iRetryLeft
71390>>>>>        End
71390>>>>>>
71390>>>>>        Else Begin
71391>>>>>            Move 0 to iRetryLeft
71392>>>>>        End
71392>>>>>>
71392>>>>>        Move (sExistingFilename+(Character(0))) to sExistingFilename
71393>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
71394>>>>>        Repeat
71394>>>>>>
71394>>>>>            Move (fsMoveFile(sExistingFilename, sNewFileName)) to bMoved
71395>>>>>            If (bMoved = False) Begin
71397>>>>>                Decrement iRetryLeft
71398>>>>>                If (iRetryLeft <= 0) Begin
71400>>>>>                    Move (fsGetLastError()) to iErrorNumber
71401>>>>>                    If iErrorNumber Begin
71403>>>>>                        Send DoShowError iErrorNumber ("Tried to move/rename file: "+sExistingFileName+" to "+sNewFileName)
71404>>>>>                    End
71404>>>>>>
71404>>>>>                End
71404>>>>>>
71404>>>>>                Else Begin
71405>>>>>                    Sleep 1
71406>>>>>                End
71406>>>>>>
71406>>>>>            End
71406>>>>>>
71406>>>>>        Until (bMoved = True or iRetryLeft <= 0)
71408>>>>>        Function_Return bMoved
71409>>>>>    End_Function
71410>>>>>
71410>>>>>    // Copies a file. Overwriting an existing file by default.
71410>>>>>    // Returns True if succeeds.
71410>>>>>    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
71412>>>>>        Boolean bCopied
71412>>>>>        Boolean bDoNotOverwrite
71412>>>>>        Integer iErrorNumber iRetryLeft
71412>>>>>        Set pbError to False
71413>>>>>        Move (sExistingFileName+(Character(0))) to sExistingFileName
71414>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
71415>>>>>        If (Num_Arguments > 2) Begin
71417>>>>>            Move bFailIfExists to bDoNotOverwrite
71418>>>>>        End
71418>>>>>>
71418>>>>>        Else Begin
71419>>>>>            Move False to bDoNotOverwrite
71420>>>>>        End
71420>>>>>>
71420>>>>>        If (num_arguments > 3) Begin
71422>>>>>            Move iRetryAttempts to iRetryLeft
71423>>>>>        End
71423>>>>>>
71423>>>>>        Else Begin
71424>>>>>            Move 0 to iRetryLeft
71425>>>>>        End
71425>>>>>>
71425>>>>>        Repeat
71425>>>>>>
71425>>>>>            Move (fsCopyFile(sExistingFileName, sNewFileName, bDoNotOverwrite)) to bCopied
71426>>>>>            If (bCopied = False) Begin
71428>>>>>                Decrement iRetryLeft
71429>>>>>                If (iRetryLeft <= 0) Begin
71431>>>>>                    Move (fsGetLastError()) to iErrorNumber
71432>>>>>                    If iErrorNumber Begin
71434>>>>>                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
71435>>>>>                    End
71435>>>>>>
71435>>>>>                End
71435>>>>>>
71435>>>>>                Else Begin
71436>>>>>                    Sleep 1
71437>>>>>                End
71437>>>>>>
71437>>>>>            End
71437>>>>>>
71437>>>>>        Until (bCopied = True or iRetryLeft <= 0)
71439>>>>>        Function_Return bCopied
71440>>>>>    End_Function
71441>>>>>
71441>>>>>    // Renames a file or directory.
71441>>>>>    // Returns True if succeeds.
71441>>>>>    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
71443>>>>>        Boolean bRenamed
71443>>>>>        If (num_arguments > 2) Begin
71445>>>>>            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
71446>>>>>        End
71446>>>>>>
71446>>>>>        Else Begin
71447>>>>>            Get FileMove sExistingFileName sNewFileName to bRenamed
71448>>>>>        End
71448>>>>>>
71448>>>>>        Function_Return bRenamed
71449>>>>>    End_Function
71450>>>>>
71450>>>>>    // Returns the file size of a file.
71450>>>>>    // Returns -1 if an error occured.
71450>>>>>    // Use *this* instead of FileSize as it works for both 32 bit as well as 64 bit and can
71450>>>>>    // always return filesizes over 2GB.
71450>>>>>    Function FileSizeEx String sFilename Returns Bigint
71452>>>>>        tsSearchResult[] lsSearchResult
71452>>>>>        tsSearchResult[] lsSearchResult
71453>>>>>        BigInt iRetval
71453>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
71454>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71456>>>>>            Move lsSearchResult[0].biFileSize to iRetval
71457>>>>>        End
71457>>>>>>
71457>>>>>        Else Begin
71458>>>>>            Move -1 to iRetval
71459>>>>>        End
71459>>>>>>
71459>>>>>        Function_Return iRetval
71460>>>>>    End_Function
71461>>>>>
71461>>>>>//
71461>>>>>// Check your source code to see if it uses the filesize function and if it does, change it to FileSizeEx
71461>>>>>// Once you verified that you are no longer using filesize, then add the following line to your code.
71461>>>>>//
71461>>>>>// // Source is not using obsolete filesize function
71461>>>>>// Define no_cFileSystem_filesize_here
71461>>>>>//
71461>>>>>// and the warning is resolved.
71461>>>>>    // Returns the file size of a file.
71461>>>>>    // Returns -1 if an error occured.
71461>>>>>    // ** Don't USE THIS, but FileSizeEx above as this only works correctly for 64 bit.
71461>>>>>    Function FileSize String sFilename Returns Longptr
71463>>>>>      BigInt biSize
71463>>>>>//      #Warning 12234 "FileSize is now obsolete, check your code and set no_cFileSystem_filesize_here compiler directive to remove"
71463>>>>>      Get FileSizeEx sFilename to biSize
71464>>>>>      Function_Return biSize
71465>>>>>    End_Function
71466>>>>>
71466>>>>>    // Returns the last write date of a file.
71466>>>>>    // Returns 0 if an error occured.
71466>>>>>    Function FileDate String sFilename Returns Date
71468>>>>>        tsSearchResult[] lsSearchResult
71468>>>>>        tsSearchResult[] lsSearchResult
71469>>>>>        Date dDate
71469>>>>>        Move 0 to dDate
71470>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
71471>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71473>>>>>            Move lsSearchResult[0].dtLastWriteDateTime to dDate
71474>>>>>        End
71474>>>>>>
71474>>>>>        Function_Return dDate
71475>>>>>    End_Function
71476>>>>>
71476>>>>>    // Returns the fileversion info.
71476>>>>>    // Returns false if an error occured.
71476>>>>>    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
71478>>>>>        Boolean bOk
71478>>>>>        Integer iErrorNumber iStatus
71478>>>>>        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
71479>>>>>        If (iStatus = -1) Begin
71481>>>>>            Move (fsGetLastError()) to iErrorNumber
71482>>>>>            If iErrorNumber Begin
71484>>>>>                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
71485>>>>>            End
71485>>>>>>
71485>>>>>        End
71485>>>>>>
71485>>>>>        Move (iStatus = 0) to bOk
71486>>>>>        Function_Return bOk
71487>>>>>    End_Function
71488>>>>>
71488>>>>>    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
71490>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
71490>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
71490>>>>>        UInteger iBytesNeeded
71490>>>>>        Address aBuffer
71490>>>>>        Boolean bOk
71490>>>>>        String sSubBlock
71490>>>>>        DWord dwBufferLen dwBufferPointer
71490>>>>>        tsLandAndCodePage lsLandAndCodePage
71490>>>>>        tsLandAndCodePage lsLandAndCodePage
71490>>>>>        Move (sFilename + (Character(0))) to sFilename
71491>>>>>        Move 0 to iBytesNeeded
71492>>>>>        Move 0 to aBuffer
71493>>>>>        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
71494>>>>>        Move 0 to lsLandAndCodePage.wCodePage
71495>>>>>        Move (fsGetFileVersionInfoSize(sFilename, 0)) to iBytesNeeded
71496>>>>>        If (iBytesNeeded = 0) Begin
71498>>>>>            Function_Return False
71499>>>>>        End
71499>>>>>>
71499>>>>>        Move False to bOk
71500>>>>>        Move (Alloc(iBytesNeeded)) to aBuffer
71501>>>>>        Move (MemSet(aBuffer, 0, iBytesNeeded)) to bOk
71502>>>>>        Move (fsGetFileVersionInfo(sFilename, 0, iBytesNeeded, aBuffer)) to bOk
71503>>>>>        If (not(bOk)) Begin
71505>>>>>            Move (Free(aBuffer)) to bOk
71506>>>>>            Function_Return -1
71507>>>>>        End
71507>>>>>>
71507>>>>>        Move "\" to sSubBlock
71508>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71509>>>>>        Move 0 to dwBufferLen
71510>>>>>        Move 0 to dwBufferPointer
71511>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71512>>>>>        If (not(bOk)) Begin
71514>>>>>            Move (Free(aBuffer)) to bOk
71515>>>>>            Function_Return -1
71516>>>>>        End
71516>>>>>>
71516>>>>>        If (dwBufferLen <> 52) Begin
71518>>>>>            Send warning_box (SFormat("Length of bufferdata For VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
71519>>>>>            Move (Free(aBuffer)) to bOk
71520>>>>>            Function_Return -2
71521>>>>>        End
71521>>>>>>
71521>>>>>        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
71522>>>>>        If (not(bOk)) Begin
71524>>>>>            Move (Free(aBuffer)) to bOk
71525>>>>>            Function_Return -1
71526>>>>>        End
71526>>>>>>
71526>>>>>        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
71527>>>>>        Get ConvertFileTimeToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
71528>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
71529>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
71530>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
71531>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
71532>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
71533>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
71534>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
71535>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
71536>>>>>        Move "\VarFileInfo\Translation" to sSubBlock
71537>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71538>>>>>        Move 0 to dwBufferLen
71539>>>>>        Move 0 to dwBufferPointer
71540>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71541>>>>>        If (not(bOk)) Begin
71543>>>>>            Move (Free(aBuffer)) to bOk
71544>>>>>            Function_Return -1
71545>>>>>        End
71545>>>>>>
71545>>>>>        If (dwBufferLen <> 4) Begin
71547>>>>>            Send warning_box (SFormat("Length of bufferdata For land and codepage numbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
71548>>>>>            Move (Free(aBuffer)) to bOk
71549>>>>>            Function_Return -2
71550>>>>>        End
71550>>>>>>
71550>>>>>        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
71551>>>>>        Get VerQueryValueStringFileInfo aBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
71552>>>>>        Get VerQueryValueStringFileInfo aBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
71553>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
71554>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
71555>>>>>        Get VerQueryValueStringFileInfo aBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
71556>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
71557>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
71558>>>>>        Get VerQueryValueStringFileInfo aBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
71559>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
71560>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
71561>>>>>        Get VerQueryValueStringFileInfo aBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
71562>>>>>        Get VerQueryValueStringFileInfo aBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
71563>>>>>        Move (Free(aBuffer)) to bOk
71564>>>>>        Function_Return 0
71565>>>>>    End_Function
71566>>>>>
71566>>>>>    // Convert an short integer to a 4-character hex string.
71566>>>>>    Function ShortToHex Short siValue Returns String
71568>>>>>        String sHex
71568>>>>>        Move "" to sHex
71569>>>>>        Repeat
71569>>>>>>
71569>>>>>            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
71570>>>>>            Move (siValue / |CI$10) to siValue
71571>>>>>        Until (siValue = 0)
71573>>>>>        Move (Right("0000" + sHex, 4)) to sHex
71574>>>>>        Function_Return sHex
71575>>>>>    End_Function
71576>>>>>
71576>>>>>    Function VerQueryValueStringFileInfo Address aBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
71578>>>>>        String sSubBlock
71578>>>>>        String sValue
71578>>>>>        DWord dwBufferLen dwBufferPointer
71578>>>>>        Boolean bOk
71578>>>>>        WString wValue
71578>>>>>        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
71579>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71580>>>>>        Move 0 to dwBufferLen
71581>>>>>        Move 0 to dwBufferPointer
71582>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71583>>>>>        If (not(bOk)) Begin
71585>>>>>            Function_Return ""
71586>>>>>        End
71586>>>>>>
71586>>>>>        Move (ZeroString(dwBufferLen)) to wValue  // size is in bytes, so we are reserving too much space
71587>>>>>        Move (MemCopy(AddressOf(wValue), dwBufferPointer, dwBufferLen)) to bOk  // memcopy copies the correct amount though
71588>>>>>        Move (CString(wValue)) To sValue
71589>>>>>        Function_Return sValue
71590>>>>>    End_Function
71591>>>>>
71591>>>>>    // Returns the file extention without the leading "."
71591>>>>>    // Example sFile = "x:\text.txt". The function returns "txt".
71591>>>>>    Function FileExtention String sFilename Returns String
71593>>>>>        String sExtention
71593>>>>>        Integer iPos
71593>>>>>        Move (RightPos(".", sFilename)) to iPos
71594>>>>>        If (iPos > 0) Begin
71596>>>>>            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
71597>>>>>            If (sExtention contains "\" or sExtention contains " ") Begin
71599>>>>>                Move "" to sExtention
71600>>>>>            End
71600>>>>>>
71600>>>>>        End
71600>>>>>>
71600>>>>>        Function_Return sExtention
71601>>>>>    End_Function
71602>>>>>
71602>>>>>    // Gets a handle to an icon stored as a resource in a file or an icon
71602>>>>>    // stored in a file's associated executable file.
71602>>>>>    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
71602>>>>>    Function FileIcon String sFilename Returns Handle
71604>>>>>        Handle hIcon
71604>>>>>        Integer iIcon
71604>>>>>        Address aFilename
71604>>>>>        WString wFileName
71604>>>>>        Move (Pad(sFilename, MAX_PATH)) to wFilename
71605>>>>>        Move (AddressOf(wFileName)) To aFileName
71606>>>>>        Move 0 to iIcon
71607>>>>>        Move (fsExtractAssociatedIcon(0, aFilename, AddressOf(iIcon))) to hIcon
71608>>>>>        Function_Return hIcon
71609>>>>>    End_Function
71610>>>>>
71610>>>>>    // Destroy hIcon, created from FileIcon.
71610>>>>>    Procedure DestroyFileIcon Handle hIcon
71612>>>>>        Integer iResult
71612>>>>>        If (hIcon <> 0) Begin
71614>>>>>            Move (fsDestroyIcon(hIcon)) to iResult
71615>>>>>        End
71615>>>>>>
71615>>>>>    End_Procedure
71616>>>>>
71616>>>>>    // Search a directory For the files with normal windows mask-signs
71616>>>>>    // Returns an array of matching files and directories
71616>>>>>    // iMode = DIRMODE_FILES_ONLY
71616>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
71616>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
71616>>>>>    // If bReturnOnlyOne is true only one search result item is returned.
71616>>>>>    // If bReturnOnlyOne is true and no items where found no error is shown.
71616>>>>>    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
71618>>>>>        tsSearchResult[] lsSearchResult
71618>>>>>        tsSearchResult[] lsSearchResult
71619>>>>>        Integer iSearchResultCount iMode iErrorNumber
71619>>>>>        structWFD lsFindData
71619>>>>>        structWFD lsFindData
71619>>>>>        Handle hFindFile
71619>>>>>        Boolean bError bStop bFound bOk bOnlyOne
71619>>>>>        BigInt biBigHi
71619>>>>>        Address aFileName
71619>>>>>
71619>>>>>        If (num_arguments < 2) Begin
71621>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
71622>>>>>        End
71622>>>>>>
71622>>>>>        Else Begin
71623>>>>>            Move iFileDirMode to iMode
71624>>>>>        End
71624>>>>>>
71624>>>>>        If (num_arguments < 3) Begin
71626>>>>>            Move False to bOnlyOne
71627>>>>>        End
71627>>>>>>
71627>>>>>        Else Begin
71628>>>>>            Move bReturnOnlyOne to bOnlyOne
71629>>>>>        End
71629>>>>>>
71629>>>>>        Move (sFilePathMask+Character(0)) To sFilePathMask
71630>>>>>        Move 0 To lsFindData.dwFileAttributes   // Initialize lsFindData
71631>>>>>        Move (fsFindFirstFile(sFilePathMask, AddressOf(lsFindData))) to hFindFile
71632>>>>>        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
71634>>>>>            Move False to bError
71635>>>>>            Move False to bStop
71636>>>>>            Move (2^32) to biBigHi
71637>>>>>            Set pbError to bError
71638>>>>>            While (bError = False and bStop = False)
71642>>>>>                Move False to bFound
71643>>>>>                Case Begin
71643>>>>>                    Case (iMode = DIRMODE_FILES_ONLY)
71645>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
71647>>>>>                            Move True to bFound
71648>>>>>                        End
71648>>>>>>
71648>>>>>                        Case Break
71649>>>>>                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
71652>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
71654>>>>>                            Move True to bFound
71655>>>>>                        End
71655>>>>>>
71655>>>>>                        Case Break
71656>>>>>                    Case Else
71656>>>>>                        Move True to bFound
71657>>>>>                        Case Break
71658>>>>>                Case End
71658>>>>>                If bFound Begin
71660>>>>>                    Move (AddressOf(lsFindData.cFileName)) to aFilename
71661>>>>>                    Move (PointerToWString(aFilename)) to lsSearchResult[iSearchResultCount].sFilename
71662>>>>>                    Move (AddressOf(lsFindData.cAlternateFileName)) to aFilename
71663>>>>>                    Move (PointerToWString(aFilename)) to lsSearchResult[iSearchResultCount].sAlternateFileName
71664>>>>>                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
71665>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
71666>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
71667>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
71668>>>>>                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
71669>>>>>                    Increment iSearchResultCount
71670>>>>>                    If bOnlyOne Begin
71672>>>>>                        Move True to bStop
71673>>>>>                    End
71673>>>>>>
71673>>>>>                End
71673>>>>>>
71673>>>>>                If (bStop = False) Begin
71675>>>>>                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
71676>>>>>                End
71676>>>>>>
71676>>>>>                If (bOk = False) Begin
71678>>>>>                    Move True to bStop
71679>>>>>                    If (bOnlyOne = False) Begin
71681>>>>>                        Move (fsGetLastError()) to iErrorNumber
71682>>>>>                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
71684>>>>>                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
71685>>>>>                        End
71685>>>>>>
71685>>>>>                    End
71685>>>>>>
71685>>>>>                End
71685>>>>>>
71685>>>>>                Get pbError to bError
71686>>>>>            Loop
71687>>>>>>
71687>>>>>            Move (fsFindClose(hFindFile)) to bOk
71688>>>>>        End
71688>>>>>>
71688>>>>>        Function_Return lsSearchResult
71689>>>>>    End_Function
71690>>>>>
71690>>>>>    // Search a directory and all subdirectories For the files with normal windows mask-signs.
71690>>>>>    // lsResult[?].sFileName contains full path and filename.
71690>>>>>    // iMode = DIRMODE_FILES_ONLY
71690>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
71690>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
71690>>>>>    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
71692>>>>>        Integer iMode
71692>>>>>        Boolean bOnlyOne
71692>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
71692>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
71694>>>>>        If (num_arguments < 2) Begin
71696>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
71697>>>>>        End
71697>>>>>>
71697>>>>>        Else Begin
71698>>>>>            Move iFileDirMode to iMode
71699>>>>>        End
71699>>>>>>
71699>>>>>        If (num_arguments < 3) Begin
71701>>>>>            Move False to bOnlyOne
71702>>>>>        End
71702>>>>>>
71702>>>>>        Else Begin
71703>>>>>            Move bReturnOnlyOne to bOnlyOne
71704>>>>>        End
71704>>>>>>
71704>>>>>        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
71705>>>>>        Function_Return lsFinalResult
71706>>>>>    End_Function
71707>>>>>
71707>>>>>    // Private
71707>>>>>    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
71709>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
71709>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
71711>>>>>        Integer iMax iCnt iLast iFinalMax
71711>>>>>        String sSearchInDir sFileMask
71711>>>>>        Boolean bStop
71711>>>>>        
71711>>>>>        Move False to bStop
71712>>>>>        Move (RightPos("\", sFilePathMask)) to iLast
71713>>>>>        If (iLast > 0) Begin
71715>>>>>            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
71716>>>>>            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
71717>>>>>        End
71717>>>>>>
71717>>>>>        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
71718>>>>>        Move (SizeOfArray(lsSearchResultDir)) to iMax
71719>>>>>        Move 0 to iCnt
71720>>>>>        While (iCnt < iMax and bStop = False)
71724>>>>>            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
71726>>>>>                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
71727>>>>>            End
71727>>>>>>
71727>>>>>            Increment iCnt
71728>>>>>            If (bReturnOnlyOne = True) Begin
71730>>>>>                If (SizeOfArray(lsFinalResult) > 0) Begin
71732>>>>>                    Move True to bStop
71733>>>>>                End
71733>>>>>>
71733>>>>>            End
71733>>>>>>
71733>>>>>        Loop
71734>>>>>>
71734>>>>>        If (bStop = False) Begin
71736>>>>>            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
71737>>>>>            Move (SizeOfArray(lsSearchResult)) to iMax
71738>>>>>            Move (SizeOfArray(lsFinalResult)) to iFinalMax
71739>>>>>            Move 0 to iCnt
71740>>>>>            While (iCnt < iMax and bStop = False)
71744>>>>>                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
71745>>>>>                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
71746>>>>>                Increment iFinalMax
71747>>>>>                Increment iCnt
71748>>>>>                If (bReturnOnlyOne = True) Begin
71750>>>>>                    If (SizeOfArray(lsFinalResult) > 0) Begin
71752>>>>>                        Move True to bStop
71753>>>>>                    End
71753>>>>>>
71753>>>>>                End
71753>>>>>>
71753>>>>>            Loop
71754>>>>>>
71754>>>>>        End
71754>>>>>>
71754>>>>>        Function_Return lsSearchResult
71755>>>>>    End_Function
71756>>>>>
71756>>>>>    // Finds a list of files.
71756>>>>>    // sSearchFiles is a list of files to search For separated by semicolon (;).
71756>>>>>    // sSearchFiles may not contain paths but may contain wildcards.
71756>>>>>    // sSearchPaths may only contain paths.
71756>>>>>    // Returns a string array with the files
71756>>>>>    // Returns only files with full path.
71756>>>>>    // Use:
71756>>>>>    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
71756>>>>>    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
71756>>>>>    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
71758>>>>>        String[] saFileList
71759>>>>>        Integer iFilelistCount iSearchFilesCount iCurSearchFile
71759>>>>>        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
71759>>>>>        String sCurSearchFile sCurSearchPath
71759>>>>>        tsSearchResult[] lsSearchResult
71759>>>>>        tsSearchResult[] lsSearchResult
71760>>>>>        Get CountOfFields sSearchPaths to iSearchPathsCount
71761>>>>>        Get CountOfFields sSearchFiles to iSearchFilesCount
71762>>>>>        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin
71764>>>>>            For iCurSearchFile from 1 to iSearchFilesCount
71770>>>>>>
71770>>>>>                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
71771>>>>>                Move (Trim(sCurSearchFile)) to sCurSearchFile
71772>>>>>                If (sCurSearchFile <> "") Begin
71774>>>>>                    For iCurSearchPath from 1 to iSearchPathsCount
71780>>>>>>
71780>>>>>                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
71781>>>>>                        If (Right(sCurSearchPath, 1) <> "\") Begin
71783>>>>>                            Move (sCurSearchPath + "\") to sCurSearchPath
71784>>>>>                        End
71784>>>>>>
71784>>>>>                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
71785>>>>>                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
71786>>>>>                        Decrement iFilesFound
71787>>>>>                        For iCurFileFound from 0 to iFilesFound
71793>>>>>>
71793>>>>>                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
71794>>>>>                            Increment iFilelistCount
71795>>>>>                        Loop
71796>>>>>>
71796>>>>>                    Loop
71797>>>>>>
71797>>>>>                End
71797>>>>>>
71797>>>>>            Loop
71798>>>>>>
71798>>>>>        End
71798>>>>>>
71798>>>>>        Function_Return saFileList
71799>>>>>    End_Function
71800>>>>>
71800>>>>>    // Get Windows Temp path
71800>>>>>    Function FileTempPath Returns String
71802>>>>>        Integer iRetVal
71802>>>>>        String  sTempPath
71802>>>>>        WString wTempPath
71802>>>>>        Move (ZeroString(MAX_PATH)) to wTempPath
71803>>>>>        Move (fsGetTempPath(MAX_PATH, AddressOf(wTempPath))) to iRetVal
71804>>>>>        If (iRetVal > MAX_PATH) Begin
71806>>>>>            Move (ZeroString(iRetval)) to wTempPath
71807>>>>>            Move (fsGetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
71808>>>>>        End
71808>>>>>>
71808>>>>>        Move wTempPath To sTempPath
71809>>>>>        Move (CString(sTempPath)) to sTempPath
71810>>>>>        Function_Return sTempPath
71811>>>>>    End_Function
71812>>>>>
71812>>>>>    // Generates a temporary file.
71812>>>>>    // Returns full path and filename or blank if no file could be created.
71812>>>>>    // sPathName is the place where the temporary file is generated. If it is
71812>>>>>    // not argumented the TEMP enviroment variable is used. If that is also not
71812>>>>>    // available the current directory is used.
71812>>>>>    // You can prefix the first 3 letters of the filename with sPrefix.
71812>>>>>    Function FileTempFileName String sPathName String sPrefix Returns String
71814>>>>>        Address aTempFileName
71814>>>>>        String sPathNameTmp sPrefixTmp sTempFileName
71814>>>>>        Boolean bOk
71814>>>>>        WString wTempFileName
71814>>>>>        Set pbError to False
71815>>>>>        If (num_arguments > 0) Begin
71817>>>>>            Move sPathName to sPathNameTmp
71818>>>>>        End
71818>>>>>>
71818>>>>>        Else Begin
71819>>>>>            Move "" to sPathNameTmp
71820>>>>>        End
71820>>>>>>
71820>>>>>        If (num_arguments > 1) Begin
71822>>>>>            Move sPrefix to sPrefixTmp
71823>>>>>        End
71823>>>>>>
71823>>>>>        Else Begin
71824>>>>>            Move "" to sPrefixTmp
71825>>>>>        End
71825>>>>>>
71825>>>>>        Move (Trim(sPathNameTmp)) to sPathNameTmp
71826>>>>>        If (sPathNameTmp = "") Begin
71828>>>>>            Get FileTempPath to sPathNameTmp
71829>>>>>            If (sPathNameTmp = "") Begin
71831>>>>>                Move "." to sPathNameTmp
71832>>>>>            End
71832>>>>>>
71832>>>>>        End
71832>>>>>>
71832>>>>>        Move (ZeroString(MAX_PATH))     To wTempFilename
71833>>>>>        Move (AddressOf(wTempFileName)) To aTempFileName
71834>>>>>        Move (fsGetTempFileName(sPathNameTmp, sPrefixTmp, 0, aTempFileName)) to bOk
71835>>>>>        If bOk Begin
71837>>>>>            Move wTempFileName          To sTempFileName
71838>>>>>            Move (CString(sTempFileName)) to sTempFileName
71839>>>>>        End
71839>>>>>>
71839>>>>>        Function_Return sTempFileName
71840>>>>>    End_Function
71841>>>>>
71841>>>>>    // Creates a new directory.
71841>>>>>    // Returns True if succeeds.
71841>>>>>    Function DirectoryCreate String sDirectoryName Returns Boolean
71843>>>>>        Boolean bFound bOk
71843>>>>>        Integer iErrorNumber
71843>>>>>        Move False to bOk
71844>>>>>        Set pbError to False
71845>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
71846>>>>>        If (not(bFound)) Begin
71848>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
71849>>>>>            Move (fsCreateDirectory(sDirectoryname, FNULL)) to bOk
71850>>>>>            If (bOk = False) Begin           // Could not create
71852>>>>>                Move (fsGetLastError()) to iErrorNumber
71853>>>>>                If iErrorNumber Begin
71855>>>>>                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
71856>>>>>                End
71856>>>>>>
71856>>>>>            End
71856>>>>>>
71856>>>>>        End
71856>>>>>>
71856>>>>>        Function_Return bOk
71857>>>>>    End_Function
71858>>>>>
71858>>>>>    // Removes an existing empty directory.
71858>>>>>    // Returns True if succeeds.
71858>>>>>    Function DirectoryRemove String sDirectoryName Returns Boolean
71860>>>>>        Boolean bFound bOk
71860>>>>>        Integer iErrorNumber
71860>>>>>        Move False to bOk
71861>>>>>        Set pbError to False
71862>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
71863>>>>>        If bFound Begin
71865>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
71866>>>>>            Move (fsRemoveDirectory(sDirectoryname)) to bOk
71867>>>>>            If (bOk = False) Begin           // Could not delete
71869>>>>>                Move (fsGetLastError()) to iErrorNumber
71870>>>>>                If iErrorNumber Begin
71872>>>>>                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
71873>>>>>                End
71873>>>>>>
71873>>>>>            End
71873>>>>>>
71873>>>>>        End
71873>>>>>>
71873>>>>>        Function_Return bOk
71874>>>>>    End_Function
71875>>>>>
71875>>>>>    // Removes a directory and all its contents.
71875>>>>>    // Returns true on succes.
71875>>>>>    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
71877>>>>>        tsSearchResult[] alsSearchResults
71877>>>>>        tsSearchResult[] alsSearchResults
71878>>>>>        Integer iIndex
71878>>>>>        Boolean bOk
71878>>>>>
71878>>>>>        If (Right(sDirectoryName, 1) = "\") Begin
71880>>>>>            Move (Left(sDirectoryName, Length(sDirectoryName) - 1)) to sDirectoryName
71881>>>>>        End
71881>>>>>>
71881>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_DIRECTORIES_ONLY to alsSearchResults
71882>>>>>        For iIndex from 2 to (SizeOfArray(alsSearchResults) - 1)
71888>>>>>>
71888>>>>>            Get DirectoryRemoveRecursive (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
71889>>>>>            If (not(bOk)) Begin
71891>>>>>                Function_Return False
71892>>>>>            End
71892>>>>>>
71892>>>>>        Loop
71893>>>>>>
71893>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_FILES_ONLY to alsSearchResults
71894>>>>>        For iIndex from 0 to (SizeOfArray(alsSearchResults) - 1)
71900>>>>>>
71900>>>>>            Get FileDelete (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
71901>>>>>            If (not(bOk)) Begin
71903>>>>>                Function_Return False
71904>>>>>            End
71904>>>>>>
71904>>>>>        Loop
71905>>>>>>
71905>>>>>        Get DirectoryRemove sDirectoryName to bOk
71906>>>>>        Function_Return bOk
71907>>>>>    End_Function
71908>>>>>
71908>>>>>    // Converts the filetime in UTC and returns a datetime in local time.
71908>>>>>    // private
71908>>>>>    Function ConvertFileTimeToLocalDateTime UBigInt ubiFileTime Returns DateTime
71910>>>>>        Boolean bOk
71910>>>>>        UBigInt ubiZero
71910>>>>>        structSystemTime lsSystemTime lsLocalTime
71910>>>>>        structSystemTime lsSystemTime lsLocalTime
71910>>>>>        DateTime dtLocalTime
71910>>>>>        Move 0 to lsSystemTime.wDay
71911>>>>>        Move 0 to lsLocalTime.wDay
71912>>>>>        Move 0 to ubiZero
71913>>>>>        If (ubiFileTime <> ubiZero) Begin
71915>>>>>            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
71916>>>>>            If bOk Begin
71918>>>>>                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
71919>>>>>                If bOk Begin
71921>>>>>                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
71922>>>>>                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
71923>>>>>                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
71924>>>>>                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
71925>>>>>                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
71926>>>>>                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
71927>>>>>                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
71928>>>>>                End
71928>>>>>>
71928>>>>>            End
71928>>>>>>
71928>>>>>        End
71928>>>>>>
71928>>>>>        Function_Return dtLocalTime
71929>>>>>    End_Function
71930>>>>>
71930>>>>>    // Returns the filename with full path where the casing is preserved from windows.
71930>>>>>    Function FilePreservedFilename String sFilename Returns String
71932>>>>>        Integer iNumOfDirectories iCurrentDirectory
71932>>>>>        String sPreservedFilename sCurDir sSearchName
71932>>>>>        tsSearchResult[] lsSearchResult
71932>>>>>        tsSearchResult[] lsSearchResult
71933>>>>>
71933>>>>>        Get CountOfFields sFilename "\" to iNumOfDirectories
71934>>>>>        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
71940>>>>>>
71940>>>>>            Get FieldAtIndex sFilename iCurrentDirectory "\" to sCurDir
71941>>>>>            If (sCurDir <> "") Begin
71943>>>>>                If (Right(sCurDir, 1) <> ":") Begin
71945>>>>>                    Move (sPreservedFilename + sCurDir) to sSearchName
71946>>>>>                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsSearchResult
71947>>>>>                    If (SizeOfArray(lsSearchResult) > 0) Begin
71949>>>>>                        Move (sPreservedFilename + lsSearchResult[0].sFilename + "\") to sPreservedFilename
71950>>>>>                    End
71950>>>>>>
71950>>>>>                    Else Begin
71951>>>>>                        Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
71952>>>>>                    End
71952>>>>>>
71952>>>>>                End
71952>>>>>>
71952>>>>>                Else Begin
71953>>>>>                    Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
71954>>>>>                End
71954>>>>>>
71954>>>>>            End
71954>>>>>>
71954>>>>>            Else Begin
71955>>>>>                Move (sPreservedFilename + "\") to sPreservedFilename
71956>>>>>            End
71956>>>>>>
71956>>>>>        Loop
71957>>>>>>
71957>>>>>        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsSearchResult
71958>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71960>>>>>            Move (sPreservedFilename + lsSearchResult[0].sFilename) to sPreservedFilename
71961>>>>>        End
71961>>>>>>
71961>>>>>        Else Begin
71962>>>>>            Function_Return ""
71963>>>>>        End
71963>>>>>>
71963>>>>>        Function_Return sPreservedFilename
71964>>>>>    End_Function
71965>>>>>
71965>>>>>    // Returns the number of fields present in a string of fields seperated by a delimiter.
71965>>>>>    // If sDelimiter is not applied the ";" will be used.
71965>>>>>    Function CountOfFields String sFields String sDelimiter Returns Integer
71967>>>>>        Integer iChar icChar iField
71967>>>>>        String sDlm
71967>>>>>        If (sFields ="") Begin
71969>>>>>            Function_Return 0
71970>>>>>        End
71970>>>>>>
71970>>>>>        If (num_arguments > 1) Begin
71972>>>>>            Move sDelimiter to sDlm
71973>>>>>        End
71973>>>>>>
71973>>>>>        Else Begin
71974>>>>>            Move ";" to sDlm
71975>>>>>        End
71975>>>>>>
71975>>>>>        Move (Length(sFields) -1) to icChar
71976>>>>>        For iChar from 1 to icChar
71982>>>>>>
71982>>>>>            If (Mid(sFields, 1, iChar) = sDlm) Begin
71984>>>>>                Increment iField
71985>>>>>            End
71985>>>>>>
71985>>>>>        Loop
71986>>>>>>
71986>>>>>        Function_Return (iField +1)
71987>>>>>    End_Function
71988>>>>>
71988>>>>>    // Returns a field from a string containing multiple delimited fields.
71988>>>>>    // Index is 1-based.
71988>>>>>    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
71990>>>>>        Integer iField iPos
71990>>>>>        String sField sDlm
71990>>>>>        If (num_arguments > 2) Begin
71992>>>>>            Move sDelimiter to sDlm
71993>>>>>        End
71993>>>>>>
71993>>>>>        Else Begin
71994>>>>>            Move ";" to sDlm
71995>>>>>        End
71995>>>>>>
71995>>>>>        Move (sFields + sDlm) to sFields
71996>>>>>        For iField from 1 to iIndex
72002>>>>>>
72002>>>>>            Move (Pos(sDlm, sFields)) to iPos
72003>>>>>            If iPos Begin
72005>>>>>                Move (Left(sFields, iPos -1)) to sField
72006>>>>>                Move (Right(sFields, Length(sFields) -iPos)) to sFields
72007>>>>>            End
72007>>>>>>
72007>>>>>            Else Begin
72008>>>>>                Function_Return ""
72009>>>>>            End
72009>>>>>>
72009>>>>>        Loop
72010>>>>>>
72010>>>>>        Function_Return sField
72011>>>>>    End_Function
72012>>>>>
72012>>>>>    // Removes the file extention from the sFile string and returns the extention including "."
72012>>>>>    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
72012>>>>>    Function RemoveExtention String ByRef sFilename Returns String
72014>>>>>        String sExtention
72014>>>>>        Integer iLengthExtention
72014>>>>>        Get FileExtention sFilename to sExtention
72015>>>>>        Move (Length(sExtention)) to iLengthExtention
72016>>>>>        If (iLengthExtention > 0) Begin
72018>>>>>            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
72019>>>>>        End
72019>>>>>>
72019>>>>>        Function_Return sExtention
72020>>>>>    End_Function
72021>>>>>
72021>>>>>    // Add a directory separator if it is not present.
72021>>>>>    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
72021>>>>>    Function AddFolderSeperator String sFolderName Returns String
72023>>>>>        String sDirSep
72023>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
72024>>>>>        Move (Trim(sFolderName)) to sFolderName
72025>>>>>        If (Right(sFolderName, 1) <> sDirSep) Begin
72027>>>>>            Move (sFolderName + sDirSep) to sFolderName
72028>>>>>        End
72028>>>>>>
72028>>>>>        Function_Return sFolderName
72029>>>>>    End_Function
72030>>>>>
72030>>>>>    // Removes a directory separator if it is present.
72030>>>>>    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
72030>>>>>    Function RemoveFolderSeperator String sFolderName Returns String
72032>>>>>        String sDirSep
72032>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
72033>>>>>        Move (Trim(sFolderName)) to sFolderName
72034>>>>>        If (Right(sFolderName, 1) = sDirSep) Begin
72036>>>>>            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
72037>>>>>        End
72037>>>>>>
72037>>>>>        Function_Return sFolderName
72038>>>>>    End_Function
72039>>>>>
72039>>>>>    Function FileLastWriteTime String sFileName Returns tFileTime
72041>>>>>        DWord dwAccess
72041>>>>>        DWord dwShared
72041>>>>>        DWord dwCreate
72041>>>>>        Handle hFile
72041>>>>>        Integer iRetval iErrorNumber
72041>>>>>        tFileTime ftLastWrite
72041>>>>>        tFileTime ftLastWrite
72041>>>>>        //
72041>>>>>        Append sFilename (Character(0)) (Character(0))
72043>>>>>        Move (GENERIC_READ iOr GENERIC_WRITE) To dwAccess
72044>>>>>        Move FILE_SHARE_RANDOM   To dwShared
72045>>>>>        Move OPEN_EXISTING       To dwCreate
72046>>>>>
72046>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) To hFile
72047>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
72049>>>>>            Move (fsGetLastError()) To iErrorNumber
72050>>>>>            If iErrorNumber Begin
72052>>>>>                Send DoShowError iErrorNumber sFileName
72053>>>>>            End
72053>>>>>>
72053>>>>>            Procedure_Return
72054>>>>>        End
72054>>>>>>
72054>>>>>        Else Begin
72055>>>>>            Move 0 To ftLastWrite.dwLowDateTime
72056>>>>>            Move (fsGetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) To iRetval
72057>>>>>            If (iRetVal = 0) Begin           //Could not close
72059>>>>>                Move (fsGetLastError()) To iErrorNumber
72060>>>>>                If iErrorNumber Begin
72062>>>>>                    Send DoShowError iErrorNumber sFileName
72063>>>>>                End
72063>>>>>>
72063>>>>>            End
72063>>>>>>
72063>>>>>            Move (fsCloseHandle(hFile)) To iRetVal
72064>>>>>            If (iRetVal = 0) Begin           //Could not close
72066>>>>>                Move (fsGetLastError()) To iErrorNumber
72067>>>>>                If iErrorNumber Begin
72069>>>>>                    Send DoShowError iErrorNumber sFileName
72070>>>>>                End
72070>>>>>>
72070>>>>>            End
72070>>>>>>
72070>>>>>        End
72070>>>>>>
72070>>>>>        Function_Return ftLastWrite
72071>>>>>    End_Function
72072>>>>>
72072>>>>>    Function CurrentSystemTimeAsFileTime Returns tFileTime
72074>>>>>        Integer iRetVal
72074>>>>>        Integer iErrorNumber
72074>>>>>        String  sFileName
72074>>>>>        tFileTime ftCurrentTime
72074>>>>>        tFileTime ftCurrentTime
72074>>>>>
72074>>>>>        Move 0 to ftCurrentTime.dwLowDateTime
72075>>>>>        Move (fsGetSystemTimeAsFileTime(AddressOf(ftCurrentTime))) to iRetVal
72076>>>>>        If (iRetVal = 0) Begin
72078>>>>>            Move (fsGetLastError()) to iErrorNumber
72079>>>>>            If iErrorNumber Begin
72081>>>>>                Send DoShowError iErrorNumber sFileName
72082>>>>>            End
72082>>>>>>
72082>>>>>        End
72082>>>>>>
72082>>>>>        Function_Return ftCurrentTime
72083>>>>>    End_Function
72084>>>>>
72084>>>>>    // Nils 2018-08-30 Added this message from Akefs.pkg as we need it For the
72084>>>>>    // SourceCodeTools project
72084>>>>>    Procedure Set FileLastWriteTime String sFileName tFileTime ftLastWrite
72086>>>>>        DWord dwAccess dwShared dwCreate
72086>>>>>        Handle hFile
72086>>>>>        Integer iRetval iErrorNumber
72086>>>>>
72086>>>>>        Append sFilename (Character(0)) (Character(0))
72088>>>>>        Move (GENERIC_READ ior GENERIC_WRITE) to dwAccess
72089>>>>>        Move FILE_SHARE_RANDOM   to dwShared
72090>>>>>        Move OPEN_EXISTING       to dwCreate
72091>>>>>
72091>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) to hFile
72092>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
72094>>>>>            Move (fsGetLastError()) to iErrorNumber
72095>>>>>            If (iErrorNumber <> 0) Begin
72097>>>>>                Send DoShowError iErrorNumber sFileName
72098>>>>>            End
72098>>>>>>
72098>>>>>            Procedure_Return
72099>>>>>        End
72099>>>>>>
72099>>>>>        Else Begin
72100>>>>>            Move (fsSetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) to iRetval
72101>>>>>            If (iRetVal = 0) Begin           //Could not close
72103>>>>>                Move (fsGetLastError()) to iErrorNumber
72104>>>>>                If (iErrorNumber <> 0) Begin
72106>>>>>                    Send DoShowError iErrorNumber sFileName
72107>>>>>                End
72107>>>>>>
72107>>>>>            End
72107>>>>>>
72107>>>>>            Move (fsCloseHandle(hFile)) to iRetVal
72108>>>>>            If (iRetVal = 0) Begin           //Could not close
72110>>>>>                Move (fsGetLastError()) to iErrorNumber
72111>>>>>                If (iErrorNumber <> 0) Begin
72113>>>>>                    Send DoShowError iErrorNumber sFileName
72114>>>>>                End
72114>>>>>>
72114>>>>>            End
72114>>>>>>
72114>>>>>        End
72114>>>>>>
72114>>>>>    End_Procedure
72115>>>>>
72115>>>>>    // Fetch the error message from the system message table using the default language.
72115>>>>>    // If not in unicode then the variable sAppendErrorText is in ANSI
72115>>>>>    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
72117>>>>>        Pointer lpOut
72117>>>>>        Integer iRetChars iRetVal
72117>>>>>        String sMsg
72117>>>>>        Boolean bOk
72117>>>>>        WString wMsg
72117>>>>>
72117>>>>>        Move 0 to lpOut
72118>>>>>        Move (fsFormatMessage((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
72119>>>>>        If (iRetChars > 0) Begin
72121>>>>>            Move (ZeroString(iRetChars*2)) to wMsg
72122>>>>>            Move (MemCopy(AddressOf(wMsg), lpOut, iRetChars*2)) to bOk
72123>>>>>            Move (fsLocalFree(lpOut)) to iRetVal
72124>>>>>            Move wMsg To sMsg
72125>>>>>            If (num_arguments > 0) Begin
72127>>>>>                Move (Trim(sAppendErrorText)) to sAppendErrorText
72128>>>>>                If (sAppendErrorText <> "") Begin
72130>>>>>                    Append sMsg "\n" sAppendErrorText
72132>>>>>                End
72132>>>>>>
72132>>>>>            End
72132>>>>>>
72132>>>>>            Send warning_box sMsg
72133>>>>>        End
72133>>>>>>
72133>>>>>    End_Procedure
72134>>>>>
72134>>>>>    // Shows a warning message to user with OK button and a exclamation icon.
72134>>>>>    // private
72134>>>>>    Procedure Warning_Box String sWngMsg
72136>>>>>        Integer iVoid
72136>>>>>        Boolean bSendVdfError
72136>>>>>        Set pbError to True
72137>>>>>        Get pbErrorAsVDFError to bSendVdfError
72138>>>>>        If (bSendVdfError = False) Begin
72140>>>>>            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
72141>>>>>        End
72141>>>>>>
72141>>>>>        Else Begin
72142>>>>>            Error DFERR_PROGRAM sWngMsg
72143>>>>>>
72143>>>>>        End
72143>>>>>>
72143>>>>>    End_Procedure
72144>>>>>
72144>>>>>    // Fetch the filename from the list of filenames associated with a filenumber.
72144>>>>>    // This function is used For reporting filenames during an error.
72144>>>>>    // private
72144>>>>>    Function FileErrorText Integer iFilenumber Returns String
72146>>>>>        String sErrorText
72146>>>>>        structFile[] lsFile
72146>>>>>        structFile[] lsFile
72147>>>>>        Get plsFile to lsFile
72148>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
72150>>>>>            Move ("File: "+lsFile[iFilenumber].sFilename) to sErrorText
72151>>>>>        End
72151>>>>>>
72151>>>>>        Function_Return sErrorText
72152>>>>>    End_Function
72153>>>>>
72153>>>>>End_Class
72154>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJGridColumnRowIndicator.pkg)
72154>>>>>Use cCJGridColumn.pkg
72154>>>>>
72154>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
72155>>>>>    
72155>>>>>    Procedure Construct_Object
72157>>>>>        Forward Send Construct_Object
72159>>>>>        
72159>>>>>        Property Integer piImage 0
72160>>>>>        
72160>>>>>        Set psCaption to ""
72161>>>>>        Set piWidth to 20
72162>>>>>        Set pbResizable to False
72163>>>>>        Set pbEditable to False
72164>>>>>        Set pbFocusable to False
72165>>>>>        Set pbAllowDrag to False
72166>>>>>        Set psToolTip to "Row Indicator"
72167>>>>>    End_Procedure
72168>>>>>    
72168>>>>>    Procedure OnCreateColumn
72170>>>>>        Integer iImage
72170>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
72172>>>>>        Set piImage to iImage
72173>>>>>    End_Procedure
72174>>>>>    
72174>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
72176>>>>>        Integer iImage iFocusedRow
72176>>>>>        Handle hoDataSource
72176>>>>>        
72176>>>>>        Get phoDataSource to hoDataSource
72177>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
72178>>>>>        Move -1 to iImage
72179>>>>>        If (iRow = iFocusedRow) Begin
72181>>>>>            Get piImage to iImage
72182>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
72183>>>>>        End
72183>>>>>>
72183>>>>>    End_Procedure
72184>>>>>    
72184>>>>>End_Class
72185>>>
72185>>>Activate_View Activate_oConteudoDiretorio for oConteudoDiretorio
72195>>>>
72195>>>Object oConteudoDiretorio is a dbView
72197>>>    Set Location to 2 4
72198>>>    Set Border_Style to Border_Thick
72199>>>    Set Size to 241 567
72200>>>    Set piMinSize to 228 525                                     
72201>>>       
72201>>>    Object oPathFile is a Form
72203>>>        Set Location to 22 81
72204>>>        Set Size to 13 469
72205>>>        Set Label to "Caminho arquivo:"
72206>>>        Set Enabled_State to False
72207>>>    End_Object
72208>>>       
72208>>>    Object oCJGrid1 is a cCJGrid
72210>>>        Set Size to 165 533
72211>>>        Set Location to 54 17
72212>>>        Set peAnchors to anAll
72213>>>        Set pbReadOnly to True
72214>>>        Set pbSelectionEnable to True 
72215>>>
72215>>>        Object oCJGridColumnRowIndicator1 is a cCJGridColumnRowIndicator
72217>>>            Set piWidth to 18
72218>>>        End_Object
72219>>>
72219>>>        Object oCustomer_Name is a cCJGridColumn
72221>>>            Set piWidth to 889
72222>>>            Set psCaption to "Arquivos encontrados:"
72223>>>        End_Object
72224>>>        
72224>>>        Procedure CheckPath
72227>>>            Boolean bExist
72227>>>            
72227>>>            File_Exist sReadDir bExist
72228>>>            If (bExist) Begin
72230>>>                Set Value of oPathFile to sReadDir
72231>>>                Send LoadData
72232>>>            End
72232>>>>
72232>>>            Else Begin
72233>>>                Send Info_Box "Caminho não encontrado, grid não foi criada"
72234>>>                Break
72235>>>            End 
72235>>>>
72235>>>        End_Procedure
72236>>>               
72236>>>        Procedure OnRowDoubleClick Integer iRow Integer iCol                      
72239>>>            Forward Send OnRowDoubleClick iRow iCol 
72241>>>            String sFile
72241>>>            Boolean bExist
72241>>>                        
72241>>>            //  Setinha
72241>>>            If (iCol = (piColumnId(oCJGridColumnRowIndicator1))) Begin
72243>>>                If (YesNo_Box("Deseja mesmo excluir o arquivo?","Informação",MBR_Yes) = MBR_Yes) Begin                   
72245>>>                      
72245>>>                    Get RowValue of oCustomer_Name iRow to sFile
72246>>>                    Move (sReadDir + "\" + sFile) to sFile
72247>>>                   
72247>>>                    EraseFile sFile        
72248>>>>
72248>>>                    File_Exist sFile bExist
72249>>>                        
72249>>>                    If (not(bExist)) Begin
72251>>>                        Send Info_Box (sFile + "was deleted successfully")
72252>>>                    End
72252>>>>
72252>>>                    Else Begin
72253>>>                        Send Stop_Box (sFile + "was NOT deleted successfully")
72254>>>                    End    
72254>>>>
72254>>>                End
72254>>>>
72254>>>            End
72254>>>>
72254>>>            //  Nome do arquivo
72254>>>            If (iCol = (piColumnId(oCustomer_Name))) Begin     
72256>>>                Get RowValue of oCustomer_Name iRow to sFile
72257>>>                Move (sReadDir + "\" + sFile) to sFile
72258>>>                
72258>>>                Send Info_Box ("Function download " + sFile)
72259>>>                // Dowload
72259>>>            End
72259>>>>
72259>>>
72259>>>          Send LoadData
72260>>>        End_Procedure
72261>>>        
72261>>>        Procedure LoadData 
72264>>>            tDataSourceRow[] TheData
72264>>>            tDataSourceRow[] TheData
72265>>>            String [] aFiles
72266>>>            Boolean bFound
72266>>>            Integer iRows iName iIndex iIndicador   
72266>>>            String sBuffer sDiretorio
72266>>>    
72266>>>            Move ("dir: " + sReadDir) to sDiretorio
72267>>>            Direct_Input sDiretorio
72268>>>            Move 0 to iIndex                          
72269>>>            While (not (SeqEof))
72273>>>                Readln sBuffer
72274>>>                Move (Trim(sBuffer)) to aFiles[iIndex]
72275>>>                Increment iIndex
72276>>>            Loop
72277>>>>
72277>>>            Close_Input 
72278>>>        
72278>>>            // Get the datasource indexes of the various columns
72278>>>            Get piColumnId of oCJGridColumnRowIndicator1 to iIndicador
72279>>>            Get piColumnId of oCustomer_Name to iName
72280>>>    
72280>>>            Move 0 to iIndex 
72281>>>            For iIndex from 0 to (SizeOfArray(aFiles) - 1)   
72287>>>>
72287>>>                If not (aFiles[iIndex] = "[.]" or aFiles[iIndex] = "[..]" or aFiles[iIndex] = "") Begin
72289>>>                    Move aFiles[iIndex] to TheData[iRows].sValue[iName] 
72290>>>                    Increment iRows
72291>>>                End
72291>>>>
72291>>>            Loop
72292>>>>
72292>>>            
72292>>>            // Initialize Grid with new data
72292>>>            Send InitializeData TheData
72293>>>            Send MovetoFirstRow
72294>>>        End_Procedure
72295>>>        
72295>>>        Procedure Activating    
72298>>>          Forward Send Activating
72300>>>          Send CheckPath
72301>>>        End_Procedure  
72302>>>
72302>>>        Procedure Deactivating                  
72305>>>            Forward Send Deactivating
72307>>>            
72307>>>            Send LoadData 
72308>>>        End_Procedure
72309>>>    End_Object  
72310>>>End_Object
72311>        Use TestFunction.vw
Including file: TestFunction.vw    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\TestFunction.vw)
72311>>>Use Windows.pkg
72311>>>Use DFClient.pkg
72311>>>Use DFTabDlg.pkg
72311>>>Use DfAllEnt.pkg
72311>>>Use File_dlg.pkg
72311>>>Use cFilesystem.pkg
72311>>>
72311>>>Deferred_View Activate_oTestFunction for ;Object oTestFunction is a dbView
72336>>>
72336>>>    Set Border_Style to Border_Thick
72337>>>    Set Size to 126 470
72338>>>    Set Location to -1 4
72339>>>
72339>>>    Procedure FindDbFiles String sPathFind String sPathDestiny String sNameDb String[] ByRef sArquivosOrigem String[] ByRef sArquivosDestino  
72342>>>        Boolean bExist
72342>>>        String [] aFiles aExtension
72344>>>        String sBuffer sFilePlusExtension sExtension sFile
72344>>>        Integer iIndexFiles iIndexExtension
72344>>>        
72344>>>        Move "DAT" to aExtension[0]
72345>>>        Move "K1" to aExtension[1]
72346>>>        Move "K2" to aExtension[2]
72347>>>        Move "K3" to aExtension[3]
72348>>>        Move "K4" to aExtension[4]
72349>>>        Move "K5" to aExtension[5]
72350>>>        Move "K6" to aExtension[6]
72351>>>        Move "K7" to aExtension[7]
72352>>>        Move "K8" to aExtension[8]
72353>>>        Move "K9" to aExtension[9]
72354>>>        Move "K10" to aExtension[10]
72355>>>        Move "K11" to aExtension[11]
72356>>>        Move "K12" to aExtension[12]
72357>>>        Move "K13" to aExtension[13]
72358>>>        Move "K14" to aExtension[14]
72359>>>        Move "K15" to aExtension[15]
72360>>>        Move "VLD" to aExtension[16]
72361>>>        Move "TAG" to aExtension[17]
72362>>>        Move "HDR" to aExtension[18]
72363>>>                   
72363>>>        File_Exist sPathFind bExist
72364>>>        If (bExist) Begin   
72366>>>            
72366>>>            Direct_Input ("dir: " + sPathFind)      
72367>>>            While (not (SeqEof))  
72371>>>                Readln sBuffer
72372>>>                If not (sBuffer = "[.]" or sBuffer = "[..]" or sBuffer = "") Begin 
72374>>>                    Move (Uppercase(sBuffer)) to sFile
72375>>>                    Move (Uppercase(sNameDb)) to sNameDb  
72376>>>                    
72376>>>                    For iIndexExtension from 0 to (SizeOfArray(aExtension) - 1)
72382>>>>
72382>>>                        Move aExtension[iIndexExtension] to sExtension
72383>>>                        Move (sNameDb + "." + sExtension) to sFilePlusExtension
72384>>>                         
72384>>>                        If (sFile = sFilePlusExtension) Begin       
72386>>>                            Move (sPathFind + "\" + sBuffer) to sArquivosOrigem[iIndexFiles] 
72387>>>                            Move (sPathDestiny + "\" + sBuffer) to sArquivosDestino[iIndexFiles]                          
72388>>>                            Increment iIndexFiles
72389>>>                            Move (SizeOfArray(aExtension) - 1) to iIndexExtension
72390>>>                        End                    
72390>>>>
72390>>>                    Loop             
72391>>>>
72391>>>                End
72391>>>>
72391>>>            Loop
72392>>>>
72392>>>            Close_Input            
72393>>>        End
72393>>>>
72393>>>        Else Begin
72394>>>            Send Info_Box "Caminho não encontrado"
72395>>>        End 
72395>>>>
72395>>>    End_Procedure
72396>>>    
72396>>>    Function CopyDbFiles String sPathSender String sPathDestination String sFiles Returns Boolean
72399>>>        Integer iIndex
72399>>>        String[] sArquivosOrigem 
72400>>>        String[] sArquivosDestino
72401>>>        Boolean bReturn
72401>>>              
72401>>>        Handle hoFileSystem
72401>>>        Get Create (RefClass(cFilesystem)) to hoFileSystem
72402>>>   
72402>>>        Send FindDbFiles sGPathFind sGPathDestination sGNameDb (&sArquivosOrigem) (&sArquivosDestino)
72403>>>    
72403>>>        For iIndex from 0 to (SizeOfArray(sArquivosOrigem) - 1) 
72409>>>>
72409>>>            Get FileCopy of hoFileSystem sArquivosOrigem[iIndex] sArquivosDestino[iIndex] 0 0 to bReturn
72410>>>        Loop
72411>>>>
72411>>>        
72411>>>        Send Destroy of hoFileSystem
72412>>>        
72412>>>        Function_Return bReturn
72413>>>    End_Function
72414>>>      
72414>>>    Object oPathFind is a Form
72416>>>        Set Size to 15 263
72417>>>        Set Location to 4 64
72418>>>        Set Label to "oPathFind:"
72419>>>
72419>>>        Procedure OnChange
72422>>>            Forward Send OnChange
72424>>>            
72424>>>            Get Value of oPathFind to sGPathFind
72425>>>        End_Procedure
72426>>>    End_Object
72427>>>
72427>>>    Object oPathDestinatio is a Form
72429>>>        Set Size to 17 381
72430>>>        Set Location to 45 64
72431>>>        Set Label to "oPathDestinatio:"
72432>>>    
72432>>>        Procedure OnChange           
72435>>>            Forward Send OnChange
72437>>>            
72437>>>            Get Value of oPathDestinatio to sGPathDestination
72438>>>        End_Procedure
72439>>>    End_Object
72440>>>    
72440>>>    Object oNameDb is a Form
72442>>>        Set Size to 17 70
72443>>>        Set Location to 4 389
72444>>>        Set Label to "oNameDb:"
72445>>>    
72445>>>        Procedure OnChange           
72448>>>            Forward Send OnChange
72450>>>            
72450>>>            Get Value of oNameDb to sGNameDb
72451>>>        End_Procedure
72452>>>    End_Object  
72453>>>                                   
72453>>>    Object oFunctionCopyDbFiles is a Button
72455>>>        Set Size to 38 212
72456>>>        Set Location to 78 132
72457>>>        Set Label to 'Testar função'
72458>>>    
72458>>>        // fires when the button is clicked
72458>>>        Procedure OnClick
72461>>>            Boolean bRetornoFunction
72461>>>            
72461>>>            Get CopyDbFiles sGPathFind sGPathDestination sGNameDb to bRetornoFunction
72462>>>        End_Procedure
72463>>>    End_Object
72464>>>Cd_End_Object
72466>>>>
72466>        Use FunctionDeleteFiles.vw
Including file: FunctionDeleteFiles.vw    (C:\xampp\htdocs\dataflex_learning\DataFlexStudio v20.0\Policom\AppSrc\FunctionDeleteFiles.vw)
72466>>>Use Windows.pkg
72466>>>Use DFClient.pkg
72466>>>
72466>>>Deferred_View Activate_oFunctionDeleteFiles for ;Object oFunctionDeleteFiles is a dbView
72491>>>
72491>>>    Set Border_Style to Border_Thick
72492>>>    Set Size to 186 397
72493>>>    Set Location to 1 1
72494>>>    Set Label to "FunctionDeleteFiles"
72495>>>    
72495>>>    Procedure FindDbFiles String sPathFind String sNameDb String[] ByRef sArquivos
72498>>>        Boolean bExist
72498>>>        String sBuffer sFile sExtention
72498>>>        Integer iIndexFiles iPos
72498>>>                   
72498>>>        Move (sNameDb + ".") to sNameDb
72499>>>        Move (Uppercase(sNameDb)) to sNameDb
72500>>>        
72500>>>        
72500>>>        File_Exist sPathFind bExist
72501>>>        If (bExist) Begin                
72503>>>            Handle hoFileSystem
72503>>>            
72503>>>            Direct_Input ("dir: " + sPathFind)      
72504>>>            While (not (SeqEof))  
72508>>>                Readln sBuffer
72509>>>                If not (sBuffer = "[.]" or sBuffer = "[..]" or sBuffer = "") Begin
72511>>>                     
72511>>>                    Get Create (RefClass(cFilesystem)) to hoFileSystem 
72512>>>                    Get RemoveExtention of hoFileSystem sBuffer to sExtention
72513>>>                    
72513>>>                    Move (Replace(sExtention, sBuffer, "")) to sFile
72514>>>                    Move (Uppercase(sFile)) to sFile
72515>>>                                       
72515>>>                    If (sFile = sNameDb) Begin
72517>>>                        Move (sPathFind + "\" + sBuffer) to sArquivos[iIndexFiles]
72518>>>                        Increment iIndexFiles
72519>>>                    End                  
72519>>>>
72519>>>                End
72519>>>>
72519>>>            Loop
72520>>>>
72520>>>            Close_Input 
72521>>>                       
72521>>>            Send Destroy of hoFileSystem   
72522>>>        End
72522>>>>
72522>>>        Else Begin
72523>>>            Send Info_Box "Caminho não encontrado"
72524>>>        End 
72524>>>>
72524>>>    End_Procedure
72525>>>    
72525>>>    Function DeleteDbFiles String sPathSender String sPathDestination String sFiles Returns Boolean
72528>>>        Integer iIndex
72528>>>        String[] sArquivos
72529>>>        Boolean bReturn
72529>>>              
72529>>>        Handle hoFileSystem
72529>>>        Get Create (RefClass(cFilesystem)) to hoFileSystem
72530>>>   
72530>>>        Send FindDbFiles sGPathFind sGNameDb (&sArquivos)
72531>>>        
72531>>>        For iIndex from 0 to (SizeOfArray(&sArquivos) - 1) 
72537>>>>
72537>>>            Get FileDelete of hoFileSystem (&sArquivos[iIndex]) to bReturn
72538>>>        Loop
72539>>>>
72539>>>      
72539>>>        Send Destroy of hoFileSystem
72540>>>             
72540>>>        Function_Return bReturn
72541>>>    End_Function
72542>>>    
72542>>>    Object oPathFind is a Form
72544>>>        Set Size to 15 324
72545>>>        Set Location to 13 66
72546>>>        Set Label to "oPathFind:"
72547>>>
72547>>>        Procedure OnChange
72550>>>            Forward Send OnChange
72552>>>            
72552>>>            Get Value of oPathFind to sGPathFind
72553>>>        End_Procedure
72554>>>    End_Object
72555>>>    
72555>>>    Object oNameDb is a Form
72557>>>        Set Size to 17 191
72558>>>        Set Location to 45 103
72559>>>        Set Label to "oNameDb:"
72560>>>    
72560>>>        Procedure OnChange           
72563>>>            Forward Send OnChange
72565>>>            
72565>>>            Get Value of oNameDb to sGNameDb
72566>>>        End_Procedure
72567>>>    End_Object  
72568>>>                                   
72568>>>    Object oFunctionDeleteFiles is a Button
72570>>>        Set Size to 38 212
72571>>>        Set Location to 102 92
72572>>>        Set Label to 'Testar oFunctionDeleteFiles'
72573>>>    
72573>>>        // fires when the button is clicked
72573>>>        Procedure OnClick
72576>>>            Boolean bRetornoFunction
72576>>>                       
72576>>>            Get DeleteDbFiles sGPathFind sGNameDb to bRetornoFunction
72577>>>        End_Procedure
72578>>>    End_Object
72579>>>Cd_End_Object
72581>>>>
72581>        
72581>        Procedure Activate_About
72584>            Send DoAbout "" "" "" "" ""
72585>        End_Procedure
72586>
72586>    End_Object
72587>
72587>End_Object
72588>
72588>Start_UI
72589>
Summary
Memory Available: 643891200
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 42429
Total Resources: 0
Total Commands : 72588
Total Windows  : 0
Total Pages    : 0
Static Data    : 449149
Message area   : 507404
Total Blocks   : 26397
